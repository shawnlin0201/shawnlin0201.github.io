---
title: JavaScript 深入理解 Garbage Collection 垃圾回收機制
date: 2000-01-01 00:00:00
tags:
- [JavaScript]
- [Memory]
categories: 
- [JavaScript]
- [JavaScript, 深入理解]
- [Memory]
---

<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

# JavaScript 與記憶體
記憶體漏失是程式設計中一項常見錯誤，特別是使用沒有內置自動垃圾回收的程式語言，如C及C++。
提供自動記憶體管理的程式語言如Java、C#、VB.NET以及LISP，都不能避免記憶體漏失。例如，程式會把項目加入至列表，但在完成時沒有移除，如同人把物件丟到一堆物品中或放到抽屜內，但後來忘記取走這件物品一樣。記憶體管理器不能判斷項目是否將再被存取，除非程式作出一些指示表明不會再被存取。

如果一個程式存在記憶體流失並且它的記憶體使用量穩定增長，通常不會有很快的症狀。每個物理系統都有一個較大的記憶體量，如果記憶體流失沒有被中止（比如重新啟動造成漏失的程式）的話，它遲早會造成問題。

`array = []` `array.length = 0`

重點：JavaScript 的 deallocation 不是你決定的，是 browser 決定的

當然你可以自己把 reference 移除，可是你無法直接 deallocate 它，而他什麼時候、在什麼條件下會被 GC 回收基本上也不是由你決定的。

# 記憶體生命週期

配置你程式需要的記憶體空間
使用配置到的記憶體空間(讀，寫)
當不再使用時釋放已被配置的記憶體空間

在所有語言中，第二點的(運作方式)是確定的。第一點以及最後一點在低階語言中是確定的，但是在高階語言如Javascript 則通常是不明確的。

# 記憶體配置
值的初始化
為了不讓開發者對配置感到困擾，Javascript 會在宣告值的同時完成記憶體配置

# 記憶體的使用
基本上使用值表示對已被配置的記憶體做讀寫。可藉由讀取或寫入變數的值或一個物件特性或甚至傳一個參數到函數中來完成此事。

# 記憶體流失

`array = []` 重新賦值 `array = []` （此時指向的記憶體已經有所不同）

```js
let a = []
let b = a // 參考指向 a 的記憶體

console.log(a === b) // true，因為參考的記憶體指向同一處

a = [] // 重新賦值一個新的陣列給 a 變數，此時 a 指向新的記憶體

console.log(a === b) // false，此時兩個變數所指向的記憶體已經不同了
```

```js
let a = []
a = [] // Memory Leak！
```
前一行宣告 `a` 時所指向的記憶體參考已消失，找不到參考到原先陣列的方法了，因此造成記憶體洩漏（memory leak）。

# 記憶體回收機制

談論到記憶體管理，問題通常出現在這個階段。最困難的工作是尋找「已不再被使用的記憶體配置空間」。通常程式要求開發者來決定程式裡面的這塊記憶體空間不再使用且釋放該空間回給系統。

高階的語言都有一個叫作垃圾回收器(garbage collector) 的軟體，他的工作是追蹤記憶體分配的使用情況，以便自動釋放一個不再使用的記憶體空間，還給系統。 但這個垃圾回收器只是「儘量」做到自動釋放記憶體空間，因為判斷記憶體空間是否要繼續使用，這件事是不可判定的（不能用演算法來解決）。

回收機制的演算法主要概念是參考(reference)概念。在記憶體管理的上下文中(context)，如果一個物件可以訪問到另一個物件(無論是隱式或顯式)，即稱為該物件參考另一個物件。例如：JavaScript 的物件都有參考該物件的原型(prototype) (隱式參考) 以及該物件的屬性值 (顯式參考)。

在原型鏈的情況下，物件的概念擴展到比普通的 JavasScript 物件更廣，這個概念還包含函數作用域 (function scopes)（或全局詞法作用域 (global lexical scope) ）


# 記憶體回收演算法：Reference counting

這是一個最務實的垃圾回收演算法。 這個演算法將原本「這個物件再也不會被使用」的廣泛定義縮減到「沒有其他任何物件參考它」。如果一個物件不在被任何物件參考，它將被視為可回收記憶體的垃圾。

限制：循環
當涉及到循環時有一個限制。在下面的例子中，創造兩個物件並相互參考，從而製作一個循環。當呼叫函式時，他們應該超出作用範圍，因此他們實際上是無用且可釋放。但垃圾回收參考計數演算法會認為，兩個物件都至少被參考一次，因此兩個都是不能被回收的。

```js
function f() {
  var o = {};
  var o2 = {};
  o.a = o2; // o 參考 o2
  o2.a = o; // o2 參考 o

  return 'azerty';
}

f();
```

# JavaScript 所採用的演算法：Mark-and Sweep

重點：大部分 GC 使用的是 Mark-and-Sweep 演算法

這個演算法將「這個物件再也不會被使用」的定義縮減到「這個物件不可到達」。

這個演算法假設一組物件，其名為「根 (roots)」（在 JavaScript 中，根(roots)是全局物件）。垃圾回收器定期從這些根開始，尋訪所有被根參考的物件與那些物件參考的物件。垃圾回收器會回收那些沒有被尋訪的到物件。

這個演算法比前一個演算法更好，因為一個不被任何物件參考的物件，一定無法從根被尋訪到。然而，一個無法從根被尋訪到的物件，不一定不被任何物件參考，可以在循環的例子中發現這件事。

截至2012年，所有現代瀏覽器都使用標記和清理的垃圾回收器。 在過去的幾年裡，JavaScript 垃圾回收領域的所有改進都是對這個演算法的實作與改進，但並未改進垃圾回收演算法本身，也沒有縮減垃圾的定義 「這個物件再也不會被使用」。

循環不再是一個問題
在上面的第一個範例中，函式呼叫返回後，那兩個物件不再被全局物件可以尋訪到的物件參考。 因此，它們將被垃圾回收器發現，視為不可達到的。

第二個範例也是一樣的。 一旦 div 和它的處理程序從根本上無法尋訪，它們都會被垃圾回收掉，儘管他們自身相互參考。

限制：物件必須明顯的不可達到
雖然有這個限制存在，但在實務卻很少發生。這也是幾乎沒有人關心這件事的原因。

# 參考文章
- [Memory Management MDN](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Memory_Management)
- [Garbage Collection wiki](https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8))
-[基本算法 mark-and-sweep](https://liujiacai.net/blog/2018/06/15/garbage-collection-intro/#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-mark-and-sweep)
- [](https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec)
