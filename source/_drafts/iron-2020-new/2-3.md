---
title: 【事前準備】2-3 資料型別（data types）
tags: 《透過認知模型認識 JavaScript》
---

# 資料種類（data type）

![](https://i.imgur.com/zNJueBL.png)
![](https://i.imgur.com/fEx2YXe.jpg)

---

在變數（variable）的章節，我們已經學習怎麼宣告變數並且存取變數裡面的值，眼尖的你或許會發現裡面的數值有數字、文字……等等不同的類型，而這些不同的類型我們稱呼他為資料型別（data types）

## 原始型別、非原始型別

在 JavaScript 當中，資料型別主要可以分為 **原始類別** 以及 **非原始類別**：

原始型別（primitive types）
- 字串（String）：使用單引號 `''` 、雙引號 `""` 所包起的文字內容。
- 數字（Number）：`0`、`-1`、`100`、`10000` ……等等。
- 布林值（Boolean）：`true` 以及 `false`。
- `undefined`
- `null`

物件型別（object types）：又可稱為非原始型別（Non-primitive types）
- 物件（Object）
- 陣列（Array)
- 函式（Function）
- 不是原始型別的都是物件

## 原始型別與非原始型別的差異

上面提及的原始型別與非原始型別最大的差異在於透過變數賦值時的參考機制不太相同。

### 透過變數賦值時若該變數為原始型別時
當我們今天透過變數賦值給另一個變數，若該變數的資料型態為 **原始型別** 時：

```js
var boxA = 1
var boxB = 2
boxA = boxB // 透過變數賦值，而該變數所儲存的是原始型別
console.log(boxA) // ???
```

一開始在執行期的創造階段時會分配一個記憶體地址：

> var boxA
> var boxB

![](https://i.imgur.com/or4hDij.png)

接著執行期的執行階段，開始一行一行讀取程式，接著將值存於該記憶體位置中：
> boxA = 1

![](https://i.imgur.com/ociVzzY.png)

> boxB = 2

![](https://i.imgur.com/GahpRZc.png)


接下來在第三行 `boxA = boxB` 中，我們依據變數章節時提過的 **找址（LHS）** 與 **找值（RHS）** 概念解釋：`boxA = boxB` 是在告訴解析器說：請它先找到 `boxB` 的值（`2`）接著再將這個值賦值給 `boxA`。

此時由於 `2` 為 **原始型別**，因此解析器會選擇另開一個記憶體位置給 `boxA`，並且把 `2` 同時賦值進去。

![](https://i.imgur.com/C5qtjPy.png)

因此最後 `console.log(boxA)` 會找到位於 `0x02` 中的 `2`。

### 透過變數賦值時若該變數為物件型別時

當我們今天透過變數賦值給另一個變數，若該變數的資料型態為 **物件型別** 時：

```js
var boxA = 1
var boxB = {}
boxA = boxB // 透過變數賦值，而該變數所儲存的是物件型別
console.log(boxA) // ???
```

同樣的，一開始在執行期的創造階段時會分配一個記憶體地址：

> var boxA
> var boxB

![](https://i.imgur.com/or4hDij.png)

在執行階段中的第一行、第二行時也是一模一樣，只是賦的值稍微不同而已：
> boxA = 1

![](https://i.imgur.com/ociVzzY.png)

> boxB = {}

![](https://i.imgur.com/fl2sB7L.png)

接下來看到第三行 `boxA = boxB`，這次與上方不同的地方在於 `boxB` 的值是一個 **物件型別** 因此這次解析器是選擇將 `boxA` 的記憶體位置指向了 `boxB` 的記憶體位置，也就是 `0x01`。

![](https://i.imgur.com/VAoTaFv.png)

現在 `boxA` 與 `boxB` 都指向了 `0x01`，所以當程式執行到最後一行 `console.log(boxA)` 時，所找到的值自然為 `0x01` 中的 `{}`。

### 比較賦值的不同情況
現在，我們將前面變數章節提過的內容與這章節的三種情形比較一下：

> 第一種情形：若將值直接賦值與變數時，不論資料型別為何，都會指向到新的記憶體。
```js
var box; // 0x00
box = 1; // 0x01
box = {}; // 0x02
console.log(box); // 0x02 => {}
```

> 第二種情形：若透過變數賦值，如果來源資料為原始型別，則指向新的記憶體。
```js
var boxA = 1; // 0x00
var boxB = 2; // 0x01
boxA = boxB; // 0x02
console.log(boxA) // 0x02 => 2
console.log(boxB) // 0x01 => 2
```

> 第三種情形：若透過變數賦值，如果來源資料為物件型別，則會將變數的參考地址改為賦值變數的記憶體地址。
```js
var boxA = 1; // 0x00
var boxB = {}; // 0x01
boxA = boxB; // 0x01
console.log(boxA); // 0x01 => {}
console.log(boxB); // 0x01 => {}
```

## 建立模型時間
目標：
- 瞭解資料型別
- 釐清資料類型

### 整理重點：

- 賦值的目標是原始型別還是物件型別決定了賦值時是傳地址還是值

### 認知模型樹狀圖參考：
