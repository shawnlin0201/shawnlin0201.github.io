---
title: 【事前準備】2-4 決策與評估：運算式（Expression）
tags: 《透過認知模型認識 JavaScript》
---

# 決策與評估

![](https://i.imgur.com/CkS5qNf.jpg)


在日常生活中，人們總是無時無刻的在進行決策（Decision-making），從挑選早餐要吃什麼、上課或上班前思考一下今天要做什麼，處處都會需要判斷，而我們對於這些決策的根基點，往往便是來自於「計算」。

---

## 運算式（Expression）

在 JavaScript 當中，我們可以如說故事般地撰寫程式，其中的脈絡、流程同樣也少不了「計算」，而在 JavaScript 程式碼中有許許多多的內容被解析器「翻譯」時，會被看作是要估算出（evaluate）一個數值，而種類大概可以歸類成以下幾種：

- 原始型別運算式（Primitive Expressions）
- 算數運算式（Arithmetic Expressions）
- 字串運算式（String Expressions）
- 邏輯運算式（Logical Expressions）
- 賦值運算式（Assignment Expressions）

```js
1; // 1

1 + 2; // 3

'Hello, ' + 'JavaScript!'; // 'Hello, JavaScript!'

5 > 1; // true

box = 360; // 360
```

還可以配合變數章節中的 LHS、RHS 概念結合使用，讓變數能儲存計算完的值，也能在需要的時候透過變數來呼叫之前計算過的值：

```js
var one = 1;
var two = 2;
var five = 5;
var text = 'Hello, ' + 'JavaScript!';
var box;

one; // 1
one + two; // 3
text; // 'Hello, JavaScript!'
five > one; // true
box = (one + five) * two; // 12

console.log(box); // 12
```
而這些運算完的值除了將來可以顯示於網頁上之外，另外還能提供下一章會提到的敘述句（statement）來使用：

```js
var ownMoney = 200
var stockPrice = 300
var isEnough = ownMoney > stockPrice // false

if (isEnough) {
    console.log('You have enough money to pay this!')
} else {
    console.log('Sorry! You need more money for this.')
}
```

> ### 延伸閱讀：有副作用（Side Effects）的運算式
> 上面提到的運算式當中，還可分為有副作用的（Side Effects）與無副作用的運算式。
> 而無副作用的運算式意思是它只是 **單純用來取值**：
> ```js
> 1 + 2; // 3
> ```
> 有副作用的運算式則表示它除了 **計算出值之外它還會做一些其他事情**：
> ```js
> var a = 1; // 1
> a = 2; // 2
> ```

## 運算子

現在我們瞭解在 JavaScript 當中有些程式碼的部分是屬於計算的部分，而這些特定的表示符號，我們稱其為運算子（operators）或稱為運算元，以下列出幾個較為常見的運算子：

- 算數運算子（Arithmetic Operators）
- 比較運算子（Comparison Operators）
- 邏輯運算子（Logical Operators）
- 三元運算子（Conditional Operators）
- 逗號運算子（Comma Operators）

而接下來將會介紹這幾個運算子在實戰中比較常使用的技巧與要注意的地方！

> 詳細的運算子可參考 MDN 上 [運算式與運算子](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators) 章節，這裡就不贅述所有的運算子了。

### 算數運算子（Arithmetic Operators）

算數運算子除了基本的加減乘除之外，有兩種值得一提的是遞增（`++`，increment）與遞減。（`--`，decrement）。

以遞增為例，它的用法是將一個特定的運算元（變數、陣列元素或物件）轉為數字後再加上 `1`，並且可分為前遞增（pre-increment）與後遞增（post-increment）的差別。

前遞增：對於該運算元加 `1`，並顯示加完後的值。
```js
var box = 0;

++box; // 1

console.log(box); // 1
```

後遞增：先顯示原先的值，再對於該運算元加 `1`。
```js
var box = 0;

box++; // 0

console.log(box); // 1
```

從這個範例中可以很清楚的看見兩者的差異，若怕搞混的話，最簡單的記憶方式是看符號是前置還是後置，若在前面就是先加（減）再顯示，若在後的話就是先顯示後加（減）。

在實戰當中這個運算元最常被用來處理迴圈相關的處理：

```js
var mixedCatsColor = ['black', 'white', 'orange', 'tuxedo', 'tortoiseshell', 'tabby'];

for(var i = 0; i < mixedCatsColor.length; i++) {
    console.log('There is a(n) ' + mixedCatsColor[i] + ' cat!')
}
```

### 比較運算子（Comparison Operators）

由於比較運算子皆會返回一個 **布林值**，從人類的邏輯上來說也就是它將告訴你這個運算結果 `符合` 或 `不符合` 字面上的意義，因此實戰中可以用來比對它 **是否符合某種狀態**。

比如要計算在速食店能不能買套餐時，宣告的部分我會拆成 **資料來源等等基本數值** 與 **比較** 的區域。

```js
// 資料來源、從 API 取得等等數值。
var wallet = 100;
var frenchFriesPrice = 60;
var hamburgarPrice = 50;
// 比較邏輯類
var setMeal = frenchFriesPrice + hamburgarPrice;
var isWalletEnoughToBuySet = wallet >= setMeal
```

> 若想加強語意可考慮在常數上多下工夫，如宣告採用 `const`，命名上採用全大寫等等技巧。

接著比較的時候就能夠輕易的透過識別字語意來表達程式中的邏輯：

```js
var wallet = 100;
var frenchFriesPrice = 60;
var hamburgarPrice = 50;
var setMeal = frenchFriesPrice + hamburgarPrice;
var isWalletEnoughToBuySet = wallet >= setMeal

if (isWalletEnoughToBuySet) {
    buySetMeal()
};
```

#### 自動轉型（coercion）

另一個值得注意的點是，除了全等於（`===`）與全不等（`!==`）之外，在進行比較運算的過程當中，都會透過 `valueOf()` 或 `toString()` 來將值轉成原始型別（primitive types），接著才會在進行比較，更常見的說法叫做自動轉型（Coercion）。

```js
'100' == 100; // true => (100).toString() => '100'
```

而物件型別的值與其他物件型別皆會不相等，即便是「看」起來一模一樣：

```js
[] == [] // false
```

除非今天比較的物件是位於 **同個記憶體位置** 時，就會顯示 `true`：

```js
var a = []; // 0x00 => undefined, 0x02 => []
var b = []; // 0x01 => undefined, 0x04 => []
var c = a;  // 0x02 => []

a === c // true，因為都指向 0x02 中的 []
a === b // false，指向不同的記憶體位置
c === b // false，指向不同的記憶體位置
```
#### 其他注意事項

而在實戰中，即使我們知道自動轉型的這個議題，但較多開發者習慣是傾向使用全等來比較，增強團體協作上的穩定性。

此外，從網頁中的 Input 表單取值時的資料型態也要特別注意：

```js
var stockPrice = document.querySelector('#age').value; // 從表單上取值，假設使用者填入了 100

stockPrice += 100 // 試著加上 100...

if (stockPrice > 500) {
    console.log('Guess what!'); // 猜猜發生了什麼事情。
}
```

### 邏輯運算子（Logical Operators）

與比較運算子概念類似，同樣可以用來處理是否符合某個狀態，但是卻由於 **短路邏輯** 的特性，使其具有四種含意。

當我們使用 `&&` 時，所代表的是可以是 ``



### 三元運算子（Conditional Operators）
### 逗號運算子（Comma Operators）


## 運算子優先權

## 建立模型時間
目標：理解 JavaScript 表達式與運算式之間的差異。

### 整理重點：

### 認知模型樹狀圖參考：
