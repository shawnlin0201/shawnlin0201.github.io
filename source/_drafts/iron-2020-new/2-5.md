---
title: 【建立模型】2-5 流程與計算：敘述句（statement）與思考（thinking）
tags: 《透過認知模型認識 JavaScript》
---

# 流程與思考

![](https://i.imgur.com/iiR1jdN.jpg)
> cover picture sponsor: [gleammming.art](https://www.instagram.com/gleammming.art/?hl=zh-tw)

在 Maier（1931）的兩繩問題研究當中，受試者被要求在一密閉房間中同時抓住兩條由天花板上垂下的繩子，而房間內只有一把鐵鎚、其他的小工具以及，且兩條繩子垂下的距離很長，使你無法抓著其中一條繩子同時摸到另外一條繩子。

---

> 思考一下要是你是受試者，你會怎麼解決兩繩問題？

## 開放與封閉

Wakefield（1992）藉由 **開放** 與 **封閉** 定義了關於問題與回答的分類。

其中的開放意思即為結構不定的，沒有明確的指示，想做什麼都可以，而封閉意思即為結構清晰且有明確的指示，受限一定的條件以內的事件。藉由這個分類，我們可以將其分為四個象限來表示：

![](https://i.imgur.com/q1uQikx.png)

而基於這在四個象限，其他研究中也陸續發現有關於問題所對應的解決策略也是不大相同的：

- 開放性問題 與 開放性解答：透過各種不同的策略來解決問題。
- 開放性問題 與 封閉性解答：透過 **頓悟（insight）** 來得到解決問題。
- 封閉性問題 與 開放性解答：透過發散性的思考來解決問題。
- 封閉性問題 與 封閉性解答：透過瞭解問題解出唯一一種解答。

比如上方中的兩繩問題便是屬於開放性問題與封閉性解答，該實驗原先定義是要讓受試者 **頓悟（insight）** 到可以將鐵鎚綁在繩子上，並透過 **鐘擺的原理** 來解決問題。

而這四個象限當中，開放性問題與封閉性問題擁有明顯的差距，其最大的差異點在於封閉性可藉由類似 **步驟（step）** 的概念慢慢解開問題，比如在圈叉遊戲中，由於步驟是有限的，因此我們可以透過回推步驟，歸類出後手必輸的幾種下法；開放性問題則需要透過重新建構問題的本質，轉化問題表徵才能夠藉由已知的部分推論下去，例如我們在 1-3 章中的食物問題中，我們除了要知道有沒有餓肚子之外，也要先查看零錢是否足夠，才不會在結帳時才發現沒錢結帳，並且最重要的是 **你還可以自己決定順序**。

對於軟體開發而言， JavaScript 程式碼的實作過程其實也近乎是屬於開放性的問答題，而有些人可能因為不擅長沒有步驟的解決方式，因此時常在開發當中遇到困難點，但我們實際要如何解決或是透過訓練好讓我們能較為順利地開發完成呢？

這是不得不提到人類在解決問題上的幾種心理路徑，而這些方法我們稱其為 **捷思法（heutistics）**！

## 捷思法（heutistics）

捷思法主要是在講述人類會透過某些心歷路程來解決問題，而常見的捷思法有下列四種方式：

- 目標分析策略
- 前向運作策略
- 反向運作策略
- 列舉測試策略

### 目標分析策略

目標分析策略主要是透過洞察到問題的根本來分析解決的焦點，藉此縮短「最初要解決的部分與最後要達成的目標」的距離。

就如同我們 **具象化流程圖** 的行為，其實就是再縮短我們邏輯與程式之間實作的問題。我們可以藉由繪製完的流程，輕易地指出哪裡有邏輯上的問題，並依照最後調整好的邏輯流程轉化為實際的程式碼，使「開發」這件事情從一無所有到至少有個流程的概念，接著便剩下 **如何轉化為程式碼** 等問題。

若要採用此策略的人，需要擅長使用轉化、同構問題等技巧，將問題解析成另一種相對來說好解決的問題。實際案例是一名參與第 29 屆國際數學奧林匹克競賽的選手 Emanouil Atanassov，他透過了韋達定理（Vieta's theorem）以及無窮遞降法（method of infinite descent）的概念，簡潔的證明了號稱競賽以來最困難的「[傳奇第六題](https://www.thenewslens.com/article/131455)」。

### 前向分析策略

前向分析策略是則是試圖從「問題的源頭」開始解決，接著發散各種思考與方法來試圖達到欲解決的目標。

以我自身的經歷舉例，在當時我的目標是想成為一名網頁開發工程師，就像是一開始我在自學程式之前，我不清楚「自學程式」的概念，因此我是先學習如何「自學程式」，接著經由許多前人分享的經驗，才開始得知「發問的藝術」、「問題搜尋的技術」及「社群」等等方法與途徑，近而幫助我對於成為一名「網頁開發工程師」更多的體會與大模樣的方向。

而若要採取此策略的人，需要相較擅長於「自學」與「自行解決」模式的人，另外這種模式你會相較需要一個導師（Mentor）的角色來協助你定義你所進行的方向，避免你的方向偏離了你的目標。而這位導師並不一定是個「人」，它可能會是書籍，也有可能是網站上的文章等等如 1-6 章中我所分享的部分。

> 若你有看過天能（TENET）這部電影的話，就好比裡頭的「某個」戰術一樣，是個採取夾擊的策略。（避免暴雷就不多說了）

### 後向分析策略

後向分析策略顧名思義是試圖從「問題的目標」開始反推解決，也就是說先定義出你問題的目標部分，依序回推各個部分要怎麼達成。

例如兩繩問題當中若採後向分析策略則是先想像同時抓著兩隻繩子的模樣，接著前一步必定為鬆開繩子因此繩子會開始擺盪，然而擺盪的幅度越來越小，最後回到初始靜止的狀態；接著你就會意識到繩子的擺盪幅度要越來越大，最後大到你可以同時抓著兩隻繩子，進而分析出你需要透過綁物品在繩子上來增加擺盪幅度，來達成同時抓住兩個繩子的目標。

這套策略某種程度上可將原先較為開放性問答縮減成相對封閉性的問題。我也曾輔導過一名自學者，比起在實作開發中採用前向分析策略來思考實作問題，他採用後向分析的策略能夠更快速地分析出解決步驟，原因是過程其實相對來說要具體的多。

### 列舉測試策略

列舉測試策略簡單來說就是想各種方法來解決問題。


接下來，在定義出明確的目標與流程之後，我們就要學習如何透過 JavaScript 中的敘述句來表達我們的流程。

## 敘述句

在 JavaScript 中，除了計算數值用的運算式（expression）之外，最主要常見的便是敘述句（statement，又可稱為述句、陳述句等）。

其中，「宣告」、「命令」與「流程」等等的語法皆為此類，而它們的用意最主要在於可以幫助我們控制有關邏輯上的流程，以下列出幾個較為常見的敘述句語法：

宣告類語法：
- `var`
- `function`

流程類語法：
- `if/else`
- `switch`
- `try/catch`

跳躍類語法：
- `break`
- `continue`

迭代類語法：
- `for`、`for/in`、`for/of`
- `while`
- `do/while`

### block

在所有敘述句當中，有一個特別的敘述句語法，我們稱其為 **區塊（block，`{}`）** 語法，它最主要是用來組合敘述句成為一個 **區塊**：

```js
{
    var text = 'block syntax!'
}
```

而這個區塊大多數會用來與敘述句結合使用，例如接下來將介紹到的 `if` 敘述句：

```js
if (運算式) {
    // 運算式為真值時就執行這個區塊的程式
}
```

對於 `var` 來說，這個區塊語法並不影響到他的作用域（scope），也就是說使用 `var` 所宣告的變數如同在該區塊外面宣告變數一樣：

```js
var text = 'global value'

{
    var text = 'block value'
    console.log('text', text) // 'block value'
}

console.log('text', text) // 'block value'
```

> #### 延伸閱讀：`let`、`const` 與區塊語法
> 對於 `let` 以及 `const` 來說，它們如同 `var` 一樣是宣告敘述句，但差別在於他們限定於當下 **區塊敘述句以內** 的範圍：
> 
> ```js
> let text = 'global value'
> 
> {
>     let text = 'block value'
>     console.log('text', text) // 'block value'
> }
> 
> console.log('text', text) // 'global value'
> ```

其他關於作用域更詳細的內容我將會在第四章中提及！

這裡最主要的用意是讓你知道區塊對於部分的敘述句來說是有其意義的！

至於其他的敘述句大約會用在那些地方呢？接下來我們以之前在 1-3 章中提過的流程圖為例：

![https://ithelp.ithome.com.tw/upload/images/20200918/20119062wHpDMOplce.png](https://ithelp.ithome.com.tw/upload/images/20200918/20119062wHpDMOplce.png)


### if 敘述句
在這張流程圖中的「身上有錢嗎」的環節當中我們會運用到「是、否」判斷，而在 JavaScript 中我們可以利用 `if` 述句來表達流程：

```js
var cashOnMe = 200;
var foodPrice = 100;

if (cashOnMe >= foodPrice){
 // 買食物...
}
```

其中 `()` 內所放的是前面我們提到的運算式，而當運算式其結果值為 `truthy` 類型時就會執行後面的區塊敘述句內的所有程式碼。

若你需要更多流程你也可以使用 `if/else` 述句：

```js
var cashOnMe = 200;
var foodPrice = 100;

if (cashOnMe >= foodPrice){
 // 買食物...
} else {
 // 回家
}
```

甚至你也可以使用 `if/else if/else` 來定義流程：


```js
var cashOnMe = 200;
var foodPrice = 100;
var haveMoneyInBank = true;

if (cashOnMe >= foodPrice){
    // 有足夠的錢買食物...
} else if ( haveMoneyInBank ) {
    // 沒有錢，但帳戶中有錢，領個錢就可以買東西
} else {
    // 沒有錢，且帳戶中也沒有錢，乾脆回家
}
```


### switch 敘述句

透過上方 `if/else if/else` 中的範例我們可以察覺，若判斷有多種情境時，雖然我們可以在 `if` 與 `else` 敘述句之間插入 `else if` 來增加判斷內容，但如果情境太多我們將會很難追蹤實際上執行到哪個區塊內。而 `switch` 敘述句允許我們透過一個運算結果，來定義不同結果時我們應該要做什麼事情：

```js
var week = new Date().getDay();

switch(week) {
    case 1:
        console.log('隨便吃吃！')
        break;
    case 2:
        console.log('隨便吃吃！')
        break;
    case 3:
        console.log('隨便吃吃！')
        break;
    case 4:
        console.log('隨便吃吃！')
        break;
    case 5:
        console.log('隨便吃吃！')
        break;
    case 6:
        console.log('吃大餐囉！')
        break;
    case 0:
        console.log('吃大餐囉！')
        break;
    default:
        console.log('想一下要吃什麼。')
        break;
}
```

也可以藉由 `switch` 特性，將不同 `case` 情境合併在一起提升閱讀性跟維護性：

```js
var week = new Date().getDay();

switch(week) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        console.log('隨便吃吃！')
        break;
    case 6:
    case 0:
        console.log('吃大餐囉！')
        break;
    default:
        console.log('想一下要吃什麼。')
        break;
}
```

另外若你的情境需要的是一段範圍時，也有很 `tricky` 的作法：

```js
var cashOnMe = 200;

switch(true) {
    case (cashOnMe >= 150):
        console.log('買便當套餐（含飲料、小菜、濃湯）')
        break;
    case (cashOnMe >= 130):
        console.log('買便當、飲料與小菜')
        break;
    case (cashOnMe >= 100):
        console.log('買便當與飲料')
        break;
    case (cashOnMe >= 80):
        console.log('買便當')
        break;
    default:
        console.log('回家')
        break;
}

```

但我個人不建議這麼做，可以的話還是回歸到 `if/else` 寫法。

> 相關討論可參考 stackoverflow 上的這兩篇討論文：
> - [討論文一](https://stackoverflow.com/questions/17145723/how-can-i-use-ranges-in-a-switch-case-statement-using-javascript?noredirect=1&lq=1)
> - [討論文二](https://stackoverflow.com/questions/5619832/switch-on-ranges-of-integers-in-javascript)

### for 敘述句

`for` 迴圈基本上是用在「需要 **重複** 執行某件事情直到……為止」的情境當中，例如流程圖中的「肚子餓嗎？」一直到「吃下食物」後的循環。

而 `for` 迴圈的基本用法是：

```js
for(初始敘述句;條件式;完成敘述句) {
    // 區塊內敘述句
}
```
1. 執行初始敘述句。
2. 條件式若為真值則執行下方區塊內的敘述句，若否則執行完成敘述句後就離開整個 `for` 敘述句。
3. 每完成一次區塊內敘述句就執行小括弧最後的完成敘述句，接著在回到第二部中檢查是否為真值。

套用流程圖情境的概念碼：

```js
var cashOnMe = 200
var foodPrice = 50
var foodProvideSatietyPercentage = 10 // 假設食物給予的飽足感百分比

for(var satiety = 0; satiety =< 100; satiety += foodProvideSatiety){
    if (/* 檢查一下身上的錢是否足夠 */){

        if(/* 判斷是否有想吃的食物 */){
            // 排隊結帳結帳
        } else {
            // 回家    
        }

    } else {
        // 回家
    }    
}
```

> 如 1-3 中我們提到的，檢查到這邊你應該開始發現流程圖中有些流程仍需要改進，所以初步的流程規劃、規格定案相當的重要，後面我們會陸續提到要怎麼調整這些內容。

### function 述句

接下要介紹的函式（function）可說是 JavaScript 中的最難以搞懂的語法之一，許多剛開始接觸程式語言的新手，甚至是連從別的程式語言轉來學習 JavaScript 的開發者都會陷入在它的特性當中，但在這個章節中我暫時不會談到這些細節，我們要專注在它對於我們邏輯流程上的幫助！

還記得我們前面提過的區塊敘述句（block）嗎？函式的作用就像是替那個區塊敘述句取上一個名稱，而你往後便可以透過那個函式名稱來執行內部的程式碼。

比如說我今天寫完了一個檢查我有沒有錢的幾個敘述句：

```js
var cashOnMe = 200;
var foodPrice = 100;
var haveMoneyInBank = true;

if (cashOnMe >= foodPrice){
    // 有足夠的錢買食物...
} else if ( haveMoneyInBank ) {
    // 沒有錢，但帳戶中有錢，領個錢就可以買東西
} else {
    // 沒有錢，且帳戶中也沒有錢，乾脆回家
}
```

我們便可以透過 `function` 來宣告函式，透過區塊敘述句定義這些內容：

```js
var cashOnMe = 200;
var foodPrice = 100;
var haveMoneyInBank = true;

function checkMoneyIfCanBuySomething() {
    
    if (cashOnMe >= foodPrice){
        // 有足夠的錢買食物...
    } else if ( haveMoneyInBank ) {
        // 沒有錢，但帳戶中有錢，領個錢就可以買東西
    } else {
        // 沒有錢，且帳戶中也沒有錢，乾脆回家
    }
}
```

這麼做的好處是，每當我需要做上述那些區塊敘述句內的事情時，我就只要呼叫對應的名稱即可執行，不必每次都打一樣的敘述句與運算式來完成我想做的事情：

```js
checkMoneyIfCanBuySomething();

checkMoneyIfCanBuySomething(); // 再算一次
```

另外好處是可以讓函式名稱為該區塊程式碼所做的事情取上一個「代名詞」，使得你不必看完內部整段敘述句才知道它在做什麼。

以人類口語的「吃飯」為例：

```js
function 吃飯() {
    找到食物()
    吃掉食物()
}

吃飯() // 我可以幾乎不用看函式區塊敘述句內部的程式碼，便可以大約知道在做什麼事情。
```

而函式中的參數，就好比我們定義好固定的行為意義，只是做的「對象」、「事物」不同而已：

```js
function 吃(食物名稱) {
    找到(食物名稱)
    吃掉(食物名稱)
}

function 喝(食物名稱) {
    找到(食物名稱)
    喝下(食物名稱)
}

吃('蛋餅')
喝('奶茶')
```

並且在開發上你可以定義一個大範圍的事件，而大範圍的概念裡面在拆出小範圍的多個事件，最後細分到程式碼是要如何實作的部分：

```js
function 找到(物品名稱) {
    // 透過程式碼實作出找到物品的完整流程
}

function 吃掉(){
    // 透過程式碼實作出吃掉東西的完整流程
}

function 喝下(){
    // 透過程式碼實作出喝下東西的完整流程
}

function 吃(食物名稱) {
    找到(食物名稱)
    吃掉(食物名稱)
}

function 喝(食物名稱) {
    找到(食物名稱)
    喝下(食物名稱)
}

吃('蛋餅')
喝('奶茶')
```
<!-- todo -->
- 回歸到流程圖中的概念
- 思考前面捷思法的前向、後向 要怎麼套用在上方飯例中的開發法則。

## 建立模型時間
目標：理解 JavaScript 表達式與運算式之間的差異。

### 整理重點：

### 認知模型樹狀圖參考：
