---
title: 【強化模型】3-3 瀏覽器中的事件處理（下集）
tags: 《透過認知模型認識 JavaScript》
---

<!-- ## 事件捕獲（capturing）與事件冒泡（bubbling) -->
## 瀏覽器事件發生的過程

在上一篇中，我們提到了三種註冊方式以及好幾種不同的事件類型，而正當你以為事件瀏覽器事件只是單純的註冊與執行的話，就會落入到它的陷阱當中。

當然，我們並不需要真的瞭解到太過底層的內容，例如透過細胞自動機（Cellular automaton）中的 Wireworld 來模擬物理層面上的 [電子運作情形](https://xieranmaya.github.io/blog/demo/wireworld-computer.html)。
![](https://i.imgur.com/F8DJYDf.png)

但我們至少要知道的是，瀏覽器事件並非只單靠瀏覽器中的程式碼在處理，而是使用者藉由操作設備發射訊號給電腦 CPU，接著經過一連串的處理後，最後由瀏覽器負責處理事件後續的相關資訊。

接下來，我們要以一個簡單的點擊事件為例，來深入瞭解事件發生時的整個過程：
```html
<html>
    <head>
        <title>ithelp ironman</title>
    </head>
    <body>
        <h1>inon 2020</h1>
        <p id="target">join us</p>
    </body>
</html>
```

```js
var handleClick = function(e){
    console.log(e)
}

window.addEventListener('click', handleClick)
target.addEventListener('click', handleClick)
```

根據上方的程式碼，當我們今天點擊網頁中的 `<p>` 元素的區域時，事件會如下圖中的方式傳遞：

![](https://i.imgur.com/A7vComq.png)


當操作經由一連串處理後，第一個進入到瀏覽器的事件守門員便是我們之前在 **瀏覽器物件模型（BOM）** 中所提到的 `Window` 物件。

接著事件流程會一直追尋我們透過滑鼠點擊的目標 `<p>`，而在抵達之前的這個階段我們稱為 **捕獲階段（capture phase）**。




首先要注意到的事情是，事件流程基本上是以 HTML DOM API 的規範為基準在傳遞的，並且經由的對象是以 **元素為單位**，文字節點是沒辦法單獨納為一個路徑的。

接著在事件處理的流程中，達到目標前的階段我們稱為 **捕獲階段（capture phase）**，達到目標元素後則稱為 **目標階段（target phase）**，而後續返回 `Window` 的階段則為 **冒泡階段（bubbling phase）**。

這個事件階段之所以需要重視，是因為我們安裝事件監聽器時所選擇的是 **監聽目標**、**事件類型** 以及 **事件階段**。

因為事件發生時不一定是由 **監聽目標** 本身所引起的，比如我雖然是點網頁中的 `<p>`，但註冊在 `window` 上的監聽器也因為符合 **事件類型** 以及 **事件流向有經過該元素** 所以跟著被觸發：

```js
window.addEventListener('click', handleClick) // 符合事件類型（點擊）、有經過事件流向（冒泡）=> 觸發
target.addEventListener('click', handleClick) // 符合事件類型（點擊）、有經過事件流向（冒泡）=> 觸發
```

除此之外，當我們在使用標準事件模型（DOM LeveL 2 model）註冊事件時，我們也可以透過第三個參數將決定這個監聽器是被安裝在 **捕獲階段（capture phase）** 還是 **冒泡階段（bubbling phase）**：

```js
window.addEventListener('click', handleClick) // 預設是採用冒泡階段
window.addEventListener('click', handleClick, false) // 採用冒泡階段
window.addEventListener('click', handleClick, true) // 採用捕獲階段
```

而若一個事件同時觸發了多個監聽器時，處理的順序則是依賴 **事件流向** 以及 **程式碼中的位置**。

```js
window.addEventListener('click', handleClick, true) // 捕獲階段
target.addEventListener('click', handleClick, true) // 捕獲階段
target.addEventListener('click', handleClick) // 冒泡階段
window.addEventListener('click', handleClick) // 冒泡階段
```

以上方程式碼點擊 `target` 為例，整個流程觸發順序為：

1. 捕獲階段 - window 物件
2. 捕獲階段 - #target 元素
3. 冒泡階段 - #target 元素
4. 冒泡階段 - window 物件

若是將目標元素的監聽器換一下位置

```js
window.addEventListener('click', handleClick, true) // 捕獲階段
target.addEventListener('click', handleClick) // 冒泡階段
target.addEventListener('click', handleClick, true) // 捕獲階段
window.addEventListener('click', handleClick) // 冒泡階段
```

上方程式碼會因為在 **目標階段（Target Phase）** 並沒有先後上的問題，因此變成哪個監聽器先被註冊就先執行哪個的觸發情況出現：

1. 捕獲階段 - window 物件
2. 冒泡階段 - #target 元素
3. 捕獲階段 - #target 元素
4. 冒泡階段 - window 物件


## 取消傳遞

## 取消原生行為

## 事件代理（event delegate）