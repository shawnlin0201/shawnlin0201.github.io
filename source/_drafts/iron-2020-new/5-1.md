---
title: 【淬鍊模型】5-1 版本控制（Version Controll）
tags: 《透過認知模型認識 JavaScript》
---

在完賽的時後我們曾經提到對於解決需求問題來說，程式碼只是其中一種實作的形式，而接下來淬鍊模型章節中要補充的內容，便是那些有助於我們解決問題的一些工具與其他解決需求問題的思維。

# 版本控制

在開發專案的過程當中，由於我們不太可能在一天內完成所有的部分，因此我們時常需要去回顧以往所撰寫的程式碼，藉此來維護與新增我們所需要的內容，但是問題就出在這裡，你可以試著想像一下從閱讀這篇系列文開始到現在你所撰寫過的任何程式碼嗎？

若你感到困難的話其實是理所當然的事情，因為人類的短期記憶並沒有辦法記得太多東西，且這些內容也不見得適合轉變為長期記憶，因此清晰地記住所有你曾經撰寫過的程式碼顯然不是一件明智的事情。

除此之外，對於提供服務的產品與網站來說，這些系統只在乎你給他的那份檔案是否是可運作的，因此這些程式碼往往會由一個人以上的團隊共同維護，最後產生一份共同的檔案。

> 但這樣子不就會有版本不一致的問題嗎？其他人要怎麼知道我改了什麼？

好在工程師們最拿手的專業便是有邏輯的解決各種問題，因此對於這種事情我們有好多好多策略：

- 透過筆記本紀錄更改的內容
- 透過日期命名檔案名稱
- 透過共用資料夾管理團隊檔案
- ……還有好多好多策略

以上方法你可能曾經想過或甚至現在的公司正在使用，然而，透過這些策略來解決版本這件事情時，你可能會發生不少問題：

- 紀錄更改的筆記本沒人寫上最新內容，甚至弄丟了筆記本。
- 不知道 `2020-10-21` 這個資料夾的到底更新了什麼東西。
- 共用資料夾中的 `aaa.js` 這個突然多出來的檔案是什麼？

這些情況當負責維護專案的始作俑者們還在公司中的時候，是一件值得慶幸的事情，因為你可以很快地找到人來問問題，但就連作者本人都不在團隊中時，連問都沒辦法問的時候，你的血壓這時可能隨著專案時程的逼近而逐漸上升。

好在工程師們最拿手的另一件事就是會不斷的調整解決問題的策略……？

因此集中式的版本控制管理思維就出現了！

## 集中式版本控制

在集中式版本控制的思維中，檔案都必須得要放在中央伺服器的 **檔案庫（Repository）上**，而任何人都必須要從這個唯一的地方取得 **檔案更新（Update）與提交（Commit）** 你變更的檔案，即便突然出現了重大 BUG，我們也可以藉由降回前一版本先快速止血，在慢慢找出發生問題的原因。

而實施這種方式中較有名的工具為 SVN（Subvision），這一類集中式版本控管工具，除了依靠著中央集權統治（？）的管理之下，通常也會附帶一些日期、版本敘述等等功能來幫助你控管各個版本之間的差異。

然而正當你以為事情就這樣落幕時，另外一個問題又出現了。

在這種版本控制模式底下並不是每次提交的時候都會如你所願，因為有可能你與同事一開始在取出（check-out）檔案時都是拿到版本代號為一的版本，結果在中午吃飯前另一個同事已經先行提交新的內容變更進去，因此現在中央檔案庫的版本已經變為二。

結果最後當你在下午前想要提交檔案時，系統就會提示你你的檔案變更與伺服器上的檔案有所差異，你必須手動處理這個衝突（conflict）。

![](https://i.imgur.com/LtiEhoA.png)

而正當你解決完衝突心想終於可以下班時，此時

