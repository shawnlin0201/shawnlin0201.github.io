<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript 深入淺出 陣列處理迴圈的方法（forEach、map、filter、reduce）</title>
    <url>/JavaScript/JavaScript-Array-methods/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>今天要來介紹四個陣列中處理迴圈的常見方法，還在用 <code>for</code> 迴圈打天下嗎？來看看這些 cool 東西吧 (?)</p>
<a id="more"></a>

<p>下面要介紹的方法目的都在於可以使程式碼更加的簡潔易懂：</p>
<h1 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h1><p><code>forEach</code> 方法簡單說就是將陣列整個遍歷一次，並且不回傳值。</p>
<p>例如原本 <code>for</code> 迴圈中我們要把 <code>arr</code> 陣列中的每個值加到 <code>acc</code> 當中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> acc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  acc += arr[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(acc) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>用 <code>forEach</code> 的寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> acc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  acc += val</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(acc) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>如果你想額外拿到遍歷時陣列的索引值或原先的陣列可以透過第二、第三參數拿到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> acc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val)  <span class="comment">// 分三次印出 1, 5, 9</span></span><br><span class="line">  <span class="built_in">console</span>.log(idx)  <span class="comment">// 分三次印出 0, 1, 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(array) <span class="comment">// 分三次印出 [1, 5, 9], [1, 5, 9], [1, 5, 9]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h1><p><code>map</code> 方法與 <code>forEach</code> 類似，但他可以回傳一個運算完的陣列：</p>
<p>例如原先我們要取得另一個運算完的陣列可能會這麼做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> newNumber = arr[i] * <span class="number">2</span></span><br><span class="line">  newArr.push(newNumber)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<p>但用了 <code>map</code> 後：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">val, idx, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val * <span class="number">2</span> <span class="comment">//  建立一個新的陣列，並將 1, 2, 3 分別乘 2 後依序傳入到陣列當中</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<h1 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h1><p><code>filter</code> 作用最主要是用來篩檢內容，例如原先我們會這麼處理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]) <span class="comment">// 1, 2, 3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (arr[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    newArr.push(arr[i]) <span class="comment">// 只有 2, 3 符合</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<p>用了 <code>filter</code> 後：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val &gt; <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<h1 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h1><p>最後一個則是累加器 <code>reduce</code>，他最主要的作用就是依序取出與整理。</p>
<p>原先我們需要整理陣列可能會這樣寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> sumArrAddTwo = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  sumArrAddTwo += (arr[i] + <span class="number">2</span>) <span class="comment">// 依序取出 1, 5, 9 並加上 2，也就是將 3, 7, 11 累加給 sumArrAddTwo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumArrAddTwo) <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>

<p>用了 <code>reduce</code> 後：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> sumArrAddTwo = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total, val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> total + val + <span class="number">10</span></span><br><span class="line">&#125;, <span class="number">0</span>) <span class="comment">// 這裡的 0 代表累加器初始值為 0，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分解開來就像是</span></span><br><span class="line"><span class="comment">第一次：0 + 1 + 10 = 11</span></span><br><span class="line"><span class="comment">第二次：11 + 5 + 10 = 26</span></span><br><span class="line"><span class="comment">第三次：26 + 9 + 10 = 45</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumArrAddTwo) <span class="comment">// 45</span></span><br></pre></td></tr></table></figure>

<p>但要注意的是，若你沒有給予 <code>reduce</code> 第二個參數的話，他預設會將第一個陣列值當作初始值，因此會變成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> sumArrAddTwo = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total, val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> total + val + <span class="number">10</span></span><br><span class="line">&#125;) <span class="comment">// 這裡沒有給予初始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分解開來就像是</span></span><br><span class="line"><span class="comment">第一次：1 + 5 + 10 = 16      // 陣列中的第一個值被當作初始值來看待</span></span><br><span class="line"><span class="comment">第二次：11 + 9 + 10 = 26</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumArrAddTwo) <span class="comment">// 36</span></span><br></pre></td></tr></table></figure>

<p>但這種累加我自己是偏好使用 forEach 另外存一個變數會相對直覺一點。</p>
<p>不過若是要用來整理資料結構跟扁平化的時候 <code>reduce</code> 的優勢會比較明顯：</p>
<h2 id="reduce-整理資料結構"><a href="#reduce-整理資料結構" class="headerlink" title="reduce 整理資料結構"></a>reduce 整理資料結構</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    firstname: <span class="string">'Audy'</span>,</span><br><span class="line">    lastname: <span class="string">'Lin'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    firstname: <span class="string">'Berry'</span>,</span><br><span class="line">    lastname: <span class="string">'Chen'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">3</span>,</span><br><span class="line">    firstname: <span class="string">'Cath'</span>,</span><br><span class="line">    lastname: <span class="string">'Chang'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> member = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total, val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> total.concat(&#123;</span><br><span class="line">    memberID: val.id,</span><br><span class="line">    fullname: val.firstname + <span class="string">' '</span> + val.lastname</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(member)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    "memberID": 1,</span></span><br><span class="line"><span class="comment">    "fullname": "Audy Lin"</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    "memberID": 2,</span></span><br><span class="line"><span class="comment">    "fullname": "Berry Chen"</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    "memberID": 3,</span></span><br><span class="line"><span class="comment">    "fullname": "Cath Chang"</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><del>雖然如果是 API 打下來的資料通常我都會叫後端直接整理好</del></p>
<p>但自己有需要的時候還是可以用這種方式快速整理好資料喔！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">MDN - Array.prototype.reduce</a></li>
<li><a href="https://www.ucamc.com/e-learning/javascript/261-javascript-reduce%E3%80%81foreach%E3%80%81filter%E3%80%81map" target="_blank" rel="noopener">Javascript迴圈函式Reduce、ForEach、Filter、Map 應用範例</a></li>
<li><a href="https://fred-zone.blogspot.com/2017/01/javascript-mapreduce.html" target="_blank" rel="noopener">上手使用 JavaScript 的 Map、Reduce 吧！</a></li>
<li><a href="https://wcc723.github.io/javascript/2017/06/29/es6-native-array/" target="_blank" rel="noopener">JavaScript 陣列處理方法 [filter(), find(), forEach(), map(), every(), some(), reduce()]</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Arrow Function 箭頭函式</title>
    <url>/JavaScript/JavaScript-Arrow-function/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>箭頭函式算是 ECMAScript 中常見的用法之一，但他與一般的函式差別在哪？就讓我們一起來瞭解箭頭函式到底是什麼吧。</p>
<a id="more"></a>

<h1 id="基礎用法"><a href="#基礎用法" class="headerlink" title="基礎用法"></a>基礎用法</h1><p>一般我們在使用函式我們可能會這麼做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般函式宣告（function declaration）的用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或定義在變數當中的函式運算式（function expression）</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而箭頭函式最主要是將函式運算式或函式陳述式轉化成這種撰寫方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="進階用法"><a href="#進階用法" class="headerlink" title="進階用法"></a>進階用法</h1><h2 id="省略"><a href="#省略" class="headerlink" title="省略"></a>省略</h2><p>當函式語句內部只有運算式的時候還可以省略大括號與宣告返回值的部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br></pre></td></tr></table></figure>

<p>如果只有一個參數還可以省略中間小括號的部分（如果沒有或有兩個以上的參數就需要小括號）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greaterThanOne = <span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br></pre></td></tr></table></figure>

<h2 id="預設參數（Default-parameters）與剩餘函數（Rest-parameter）"><a href="#預設參數（Default-parameters）與剩餘函數（Rest-parameter）" class="headerlink" title="預設參數（Default parameters）與剩餘函數（Rest parameter）"></a>預設參數（Default parameters）與剩餘函數（Rest parameter）</h2><p>在箭頭函式中一樣可以使用預設函數與剩餘函數：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x = <span class="number">0</span>, ...y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (y.length === <span class="number">0</span> ) &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line">  <span class="keyword">let</span> sumOtherNum = y.reduce(<span class="function">(<span class="params">total, value</span>) =&gt;</span> total + value)</span><br><span class="line">  <span class="keyword">return</span> x + sumOtherNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum()          <span class="comment">// 0</span></span><br><span class="line">sum(<span class="number">1</span>)         <span class="comment">// 1</span></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><p>我們都知道 JavaScript 是採用靜態作用域，而箭頭函式沒有 this 屬性，因此在箭頭函式中的 this 會指向的是父層定義箭頭函式當下的 this：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ShawnL = &#123;</span><br><span class="line">  name: <span class="string">'ShawnL'</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hi, My name is '</span> + <span class="keyword">this</span>.name +<span class="string">'.'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShawnL.sayHi() <span class="comment">// Hi, My name is ShawnL .</span></span><br></pre></td></tr></table></figure>

<p>若使用箭頭函式的情況：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'anonymous'</span></span><br><span class="line"><span class="keyword">const</span> ShawnL = &#123;</span><br><span class="line">  name: <span class="string">'ShawnL'</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Hi, My name is '</span> + <span class="keyword">this</span>.name +<span class="string">'.'</span> <span class="comment">// this 指向定義 ShawnL 的 this （也就是 window）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShawnL.sayHi() <span class="comment">// "Hi, My name is anonymous."  .</span></span><br></pre></td></tr></table></figure>

<p>箭頭函式對於 this 的影響不小，像是在 Vue.js 框架中的 computed 若使用箭頭函式就會因為 this 指向問題而產生錯誤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      number: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    addNumber: <span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">this</span>.number + x <span class="comment">// this 指向 window 了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而 React.js 則是利用了這個特性，在撰寫 class component 簡化寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CardWrapper</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      cardTitle: <span class="string">'Title'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="comment">// 用原先函式宣告寫法會受到呼叫者的指向而有所不同，現在箭頭函式統一指向了這個元件</span></span><br><span class="line">      cardTitle: event.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;<span class="keyword">this</span>.state.cardTitle&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="text" onChange=&#123;this.handleChange&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是箭頭函式的用法，我自己是還蠻常用到的，使用時要注意的就是瀏覽器支援度與 this 指向問題，確認沒問題後箭頭函式將會大幅提升程式碼可閱讀性與開發速度。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://wiki.developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">MDN - Arrow functions</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Automatic Semicolon Insertion 自動插入分號機制</title>
    <url>/JavaScript/JavaScript-Automatic-Semicolon-Insertion/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>在 JavaScript 當中 <code>;</code> 被用來作為分隔表達式語句（statement）符號；然而，你知道在 2000 年時的 ECMAScript（ES3）中，有自動插入分號機制（Automatic Semicolon Insertion）會幫你自動插入分號嗎？</p>
<a id="more"></a>

<h1 id="結尾是否一定得分號？"><a href="#結尾是否一定得分號？" class="headerlink" title="結尾是否一定得分號？"></a>結尾是否一定得分號？</h1><p>如序文所述，在 JavaScript 當中主要是用來分隔表達式語句（statement）符號，而在 ES3 中新增的自動插入分號機制（Automatic Semicolon Insertion）則是基於當你一段程式碼後按下 <code>Enter</code> （也就是實際上寫入一個換行符號（<code>\n</code>））時，JavaScript parser 就有一定規則的幫你補分號進去程式。</p>
<p>瀏覽器基於 ECMAS-262 spec Automatic Semicolon Insertion 規則而實作的結果就是，有些地方就算你不寫他也會幫你補、有些則是你不寫他也不會幫你補；但另一群例外則是你一定得補分號跟不能補分號的情況。</p>
<p>所以情境大致上可分為：</p>
<ul>
<li>不會 ASI 的情境</li>
<li>會 ASI 的情境</li>
<li>一定要補分號的情境</li>
<li>一定不能補分號的情境</li>
<li>不需要補分號的情境</li>
</ul>
<h1 id="不會-ASI-的情境"><a href="#不會-ASI-的情境" class="headerlink" title="不會 ASI 的情境"></a>不會 ASI 的情境</h1><ul>
<li>該行沒有結束程式碼區塊時</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> frult = [</span><br><span class="line">  <span class="string">'apple'</span>,</span><br><span class="line">  <span class="string">'banana'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lyrics = <span class="string">`    </span></span><br><span class="line"><span class="string">  你看這碗又大又圓</span></span><br><span class="line"><span class="string">  你看這麵又長又寬</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<ul>
<li>下一行開頭是運算子的時候</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">+<span class="number">1</span></span><br><span class="line">++</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>條件陳述句沒有用花括號 <code>{}</code> 包起來時。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(a)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'false'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用空白分隔程式碼時</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'false'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="一定要補分號的情境"><a href="#一定要補分號的情境" class="headerlink" title="一定要補分號的情境"></a>一定要補分號的情境</h1><ul>
<li>表達式與表達式之間</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="keyword">var</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a); <span class="keyword">if</span> (b)</span><br></pre></td></tr></table></figure>

<ul>
<li>下行開頭為 <code>[</code> 、 <code>(</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'log'</span>) <span class="comment">// SyntaxError: console.log(...) is not a function</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'IIFE'</span>)</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>

<p>防禦手段可以透過前置分號來幫忙：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'IIFE'</span>)</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">;[<span class="string">'array'</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="一定不能多補分號的情境"><a href="#一定不能多補分號的情境" class="headerlink" title="一定不能多補分號的情境"></a>一定不能多補分號的情境</h1><ul>
<li><p>for 迴圈小括號中的兩個分號是固定值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;)&#123; &#125; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++;) &#123;&#125; <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>條件、迴圈等陳述式中小括號的後方</p>
</li>
</ul>
<h1 id="不需要補分號的情境"><a href="#不需要補分號的情境" class="headerlink" title="不需要補分號的情境"></a>不需要補分號的情境</h1><ul>
<li>陳述式花括號的後方</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> () &#123;&#125; <span class="comment">// 不需要補</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (); &#123;&#125; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="keyword">for</span> (;;); &#123;&#125; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>


<h1 id="懂了-ASI-之後"><a href="#懂了-ASI-之後" class="headerlink" title="懂了 ASI 之後"></a>懂了 ASI 之後</h1><p>在知道 Automatic Semicolon Insertion 後應該要瞭解到結尾分號是一種<strong>選項</strong>，因此團隊風格可以決定要不要採用；另外一定要的情況是採用了不支援沒分號的壓縮工具，但現在大部分的工具應該都有支援沒分號的寫法。更重要的是絕對不會是為了減少程式碼的大小而不寫，因為最後壓縮工具都會幫你補上去。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Async &amp; Await</title>
    <url>/JavaScript/JavaScript-Async-Await/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>上次看完 Promise 如何快速解決 callback hell 之後這次要來介紹 ES7 的兄弟檔 <code>Async</code> &amp; <code>Await</code>。</p>
<a id="more"></a>

<h1 id="Async-amp-Await"><a href="#Async-amp-Await" class="headerlink" title="Async &amp; Await"></a><code>Async</code> &amp; <code>Await</code></h1><p>在 ES 7 橫空出世的 <code>Async</code> 與 <code>Await</code>，最主要的功能就是協助 Promise 的操作，還記得之前基本的 Promise 用法嗎？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> res(<span class="string">'funcA done!'</span>), (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> res(<span class="string">'funcB done!'</span>), (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcC</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> res(<span class="string">'funcC done!'</span>), (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA()</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">return</span> funcB()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">return</span> funcC()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>而 <code>async</code> 功用就是包裹一個函式，使其最後會返回 Promise 物件，而 <code>await</code> 就是用來等待每個非同步的完成，才往下執行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> res(<span class="string">'funcA done!'</span>), (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> res(<span class="string">'funcB done!'</span>), (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcC</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> res(<span class="string">'funcC done!'</span>), (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> funcA()</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">await</span> funcB()</span><br><span class="line">  <span class="keyword">let</span> c = <span class="keyword">await</span> funcC()</span><br><span class="line">  <span class="built_in">console</span>.log( a + b + c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result() <span class="comment">// 'funcA done!funcB done!funcC done!'</span></span><br></pre></td></tr></table></figure>

<p>每當執行到 <code>await</code>，它都會等待 <code>Promise</code> 回應，因此若要寫出非同步合併的效果就會更加方便了！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Execution Context Stack（Call Stack）呼叫堆疊</title>
    <url>/JavaScript/JavaScript-Call-Stack/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>
延續上篇執行環境（Execution Context）的內容，接下來要介紹整個 JavaScript 在執行期間（runtime）的運作，也就是 JavaScript 在瀏覽器中是怎麼被執行的。

<a id="more"></a>

<p>在瀏覽器當中執行 JavaScript 最主要關鍵在於瞭解上次提到的執行環境，以及接下來提到<strong>執行環境的堆疊（Execution Context Stack 或稱 Call Stack）</strong>與<strong>任務循環（Event Loop）機制</strong>。</p>
<h1 id="Execution-Context-Stack"><a href="#Execution-Context-Stack" class="headerlink" title="Execution Context Stack"></a>Execution Context Stack</h1><p>每呼叫一次函式就會創立一個執行環境（Execution Context），並且在執行完畢前又有新的執行環境時就會堆疊起來，而這種執行環境中的堆疊又稱呼叫堆疊（Call Stack）顧名思義，其資料結構是一個堆疊（Stack），而這種資料結構處理方式就是後入先出（LIFO，Last in First out）：</p>
<p>例如當我們執行下面程式碼時：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  func2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'func1'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'func2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'func start'</span>)</span><br><span class="line">func1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'func end'</span>)</span><br></pre></td></tr></table></figure>

<p>在呼叫堆疊中看起來就像這樣：</p>
<p><img src="/images/JavaScript/Execution-Context-Stack.png" alt="Execution-Context-Stack.png"></p>
<p>一進入 JavaScript 前會執行一個主程式函式來包裹。</p>
<p>接著執行 <code>func1()</code> 函式，進入 <code>func1()</code> 函式後執行 <code>func2()</code> 函式。</p>
<p>在執行 <code>console.log(&#39;func2&#39;)</code> 完後，<code>func2()</code> 函式會從 stack 中移除。</p>
<p>執行 <code>console.log(&#39;func1&#39;)</code>，<code>func1()</code> 函式會從 stack 中移除。</p>
<p>最後整段程式碼都執行完畢時，便把 <code>main</code> 也拋出 stack。</p>
<p>這就是 Execution Context Stack（Call Stack）呼叫堆疊的運作方式，也就是為何大家會說 JavaScript 是 <strong>單執行緒（single thread）</strong> 的原因。</p>
<p>但以上的例子都只有同步（synchronous）的情況，如果遇到像是 setTimeout() 等 Web APIs 與需要藉由 Ajax 取得資料的非同步（Asynchronous）情況時，這時候就輪到 Event Loop 與 Job Queue 上場了。</p>
<h1 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h1><ul>
<li><a href="https://darjun.github.io/2018/11/23/javascript-callstack-eventloop/" target="_blank" rel="noopener">深入理解Javascript之CallStack&amp;EventLoop</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Call Stack</tag>
        <tag>Synchronous</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Closure 閉包</title>
    <url>/JavaScript/JavaScript-Closure/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>常常聽到閉包卻不知道是指什麼？看看文章又覺得是在講作用域（Scope）？就算知道他是什麼也不知道用他能做什麼？</p>
<p>如果你有以上的問題，那就讓我們一起來看看閉包吧！</p>
<a id="more"></a>

<h1 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h1><p>閉包（Closure）其實算是 JavaScript 的種種特性所集合起來的概念，裡面牽扯到了作用域鏈（Scope Chain）、高階函式（Higher-order function）與自由變數（free variable）等等概念。</p>
<blockquote>
<p>推薦先閱讀 Scope 與 Higher-order function 一文</p>
</blockquote>
<h1 id="Free-Variable"><a href="#Free-Variable" class="headerlink" title="Free Variable"></a>Free Variable</h1><p>自由變數（free variable）的意思則是指使用不在自己的作用域中的變數：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 這裡的 x 就是自由變數</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA()</span><br></pre></td></tr></table></figure>

<p>而要瞭解自由變數的原因在於通常談論閉包的特性時，通常會指有用到自由變數的情況：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">num = <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">    result = result + num</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = acc()</span><br><span class="line"></span><br><span class="line">counter.add(<span class="number">3</span>) <span class="comment">// 3</span></span><br><span class="line">counter.add(<span class="number">5</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>在上面程式碼中，使用 <code>counter</code> 覆值 <code>acc</code> 會是一個重點，因為函式的執行環境（Execution Context）在函式執行完畢時，就會被移出呼叫堆疊（Call Stack），也因此照理來說裡面的變數物件（Variable Object）及作用域鏈（Scope Chain）會消失。</p>
<p>但因為使用了 <code>counter</code> 覆值 <code>acc</code>，因此執行完畢時，會將此參照記錄到 <code>counter</code> 當中。</p>
<p>最後我們就能藉由操作 <code>counter</code> 來達到看似控制 <code>acc</code> 內部的變數的效果。</p>
<h1 id="why-we-need-closure"><a href="#why-we-need-closure" class="headerlink" title="why we need closure?"></a>why we need closure?</h1><p>聰明的讀者一定想到了一點，既然執行函式時都會創立一個執行環境，那麼用不同變數去承接這些環境，不就能達到類似獨立的效果嗎？</p>
<p>沒錯！我們再來看一次剛剛的程式碼，只是我們用不同的變數去接取：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">num = <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">    result = result + num</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter1 = acc()</span><br><span class="line"><span class="keyword">let</span> counter2 = acc()</span><br><span class="line"></span><br><span class="line">counter1.add(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">counter1.add(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">counter2.add(<span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line">counter2.add(<span class="number">20</span>) <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">counter1.add(<span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">counter2.add(<span class="number">30</span>) <span class="comment">// 60</span></span><br></pre></td></tr></table></figure>

<p>我們可以看到 <code>counter1</code>、<code>counter2</code> 各自擁有其執行環境，</p>
<p>除此之外在函式執行完畢時，原先執行環境移除後，該環境中的變數物件應該會消失，但由於作用域鏈的綁定，使其被重新<br>變相延長了他的生命週期，也就是說只要 <code>counter1</code>、<code>counter2</code> 再沒有被重新賦值（reassign）的情況下，<code>acc</code> 中的 <code>result</code> 就會一直存在裡面。</p>
<p>現在我們大致上已經瞭解閉包是什麼以及可以如何善用它了，最後我們再回頭來較準確地重新看一次閉包的解釋：</p>
<p>根據參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">MDN</a> 對於閉包的解釋：</p>
<blockquote>
<p>閉包（Closure）是函式以及該函式被宣告時所在的作用域環境（lexical environment）的組合。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Event Loop、Job Queue</title>
    <url>/JavaScript/JavaScript-Event-Loop-and-Job-Queue/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>要知道 JavaScript 執行期（runtime）究竟在做什麼事情？絕對不能不知呼叫堆疊（Call Stack）、事件循環（Event Loop）及任務隊列（Job Queue）。</p>
<p>前陣子介紹了 JavaScript 執行期間如果只有同步（Synchronous）的程式碼時是非常容易理解的，因為我們只需要理解呼叫堆疊（Call stack）中的執行環境（Execution Context），就能夠透過變數物件（Variable）、執行物件（Activation Object）、作用域鍊（Scope Chain）來理解作用域（Scope）與以及閉包（Closure）等等概念。</p>
<p>那麼非同步要以什麼方式來理解呢？那就是靠任務循環（Event Loop）以及任務序列（Job Queue）的機制啦！</p>
<a id="more"></a>

<h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><p>任務循環（Event Loop）嚴格說起來並不是 JavaScript 本身的機制，而是 JavaScript 運行環境（runtime）裡的機制（也就是瀏覽器）。</p>
<p>在瀏覽器當中的主執行緒（Main Thread）會透過 JavaScript 引擎去即時編譯 JavaScript 程式碼，而辨識到<strong>非同步的程式碼區塊</strong>時，就會指派給各個監視器（watcher）。</p>
<p>接著主執行緒會在不斷的輪詢（polling）各個監視器（watcher）來確認是否產生事件，例如 <code>setTimeout</code> 會經由瀏覽器的 <code>Timer</code> 檢查是否到特定的時間，如果達到特定的時間就會將其事件移到任務隊列（Job Queue）上。</p>
<p>而在輪詢的過程中，也會去查看 JavaScript 中的呼叫堆疊（Call Stack）是否為空的，如果是的話就將任務隊列（task queue）裡的任務放入呼叫堆疊當中。</p>
<p>也因此我們可以說任務循環算是實作 JavaScript 非同步機制的一種作法，如果沒有任務循環那麼 JavaScript 就無法做到非同步這件事情。</p>
<p>那麼，我們現在瞭解任務循環了，但什麼是任務隊列？</p>
<h1 id="Job-Queue"><a href="#Job-Queue" class="headerlink" title="Job Queue"></a>Job Queue</h1><p>任務隊列（Job Queue）又稱 Event Queue 或 Callback Queue，簡單來說就是各種非同步事件用來排隊的地方；也就意味著，在非同步的概念當中並不是誰比較早寫誰先被執行，而是透過上述所說的各個監視器產生事件後才排入任務隊列的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'first'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'second'</span>)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'third'</span>)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<p>像上面的順序就是依序將第一個、第二個與第三個 <code>setTimeout</code> 分別交由 <code>Timer</code> 去確認時間，而 <code>Timer</code> 首先確認到第二個與第三個時間到，這時候分別把第二個與第三個排入任務隊列，最後才是第一個。</p>
<p>因此結果會顯示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'second'</span> <span class="comment">// 與 'third' 幾乎同時顯示</span></span><br><span class="line"><span class="string">'third'</span>  <span class="comment">// 與 'second' 幾乎同時顯示，但稍微晚一點（如果不清楚為什麼的話推薦閱讀執行環境 Execution Context 一文</span></span><br><span class="line"></span><br><span class="line"><span class="string">'first'</span> <span class="comment">// 與前兩者相較晚一些才顯示</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>而延伸其概念我們可以說 <code>setTimeout</code> 只能做到確認至少幾秒後才會被執行，我們並沒有辦法精確的定義他們什麼時候被執行。</p>
</blockquote>
<p>那麼有什麼事件是會被放入任務隊列的：</p>
<ul>
<li><code>XMLHttpRequest</code>：預設採用非同步方式取得資料，它另外也提供同步的方式給需要的開發者。</li>
<li><code>fetch</code>：使用非同步的做法取得資料。</li>
<li><code>setTimeout</code>、<code>setInterval</code>：由於 JavaScript 本身沒有計時器，因此執行後會交由瀏覽器的計時器倒數，時間到了才回傳至任務序列（Task Queue）等待任務循環（Event Loop）機制將其傳入主線程。<br>以上等等</li>
</ul>
<p>然而非同步程式區塊如果是 <code>promise</code> 的話則又有另一種隊列，我們稱其為 <code>Mircotask</code>…</p>
<p>詳見 <code>Mircotask</code> 一文</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Execution Content 執行環境</title>
    <url>/JavaScript/JavaScript-Execution-Context/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>常聽見有人說作用域（Scope）但是不知道它是什麼，又或者查了作用域瞭解了之後卻不知道它是怎麼形成的？</p>
<p>那麼你可能需要知道一下什麼叫做執行環境（Execution Context）</p>
<a id="more"></a>

<h1 id="Execution-Context"><a href="#Execution-Context" class="headerlink" title="Execution Context"></a>Execution Context</h1><p>執行環境（execution context）是指 JavaScript 引擎模組化直譯程式碼時的區塊環境。簡單來說，就像是在整個 JavaScript 執行時，引擎將程式碼拆解成許多區塊，將這些區塊一塊一塊疊起來，運算完結果就移除當前的區塊，然後繼續運算下一部分的區塊。</p>
<p>這些區塊內存放著變數物件（Variable Object）、範圍鍊（Scope Chain）等等內容，使 JavaScript 引擎（V8）可以更方便的管理。</p>
<p>不過我們寫 JavaScript 程式碼時，從來就沒有主動宣告過執行環境這件事情阿。那麼到底什麼時會創建執行環境呢？</p>
<p>答案就是呼叫一個函式的時候。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  funcB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA()</span><br></pre></td></tr></table></figure>

<p>當我們執行了上面的程式時，整個執行環境的堆疊 stack 看起來就像是這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[main, funcA, funcB]</span><br></pre></td></tr></table></figure>

<p>接著計算完 <code>funcB</code> 後拋出 <code>Hello</code> 後就變成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[main, funcA]</span><br></pre></td></tr></table></figure>

<p>然後 <code>funcA</code> 執行完後就剩下主程式本身：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[main]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果想更加深入的瞭解上面整個運作請見執行環境堆疊一文。</p>
</blockquote>
<h1 id="Execution-Context-Types"><a href="#Execution-Context-Types" class="headerlink" title="Execution Context Types"></a>Execution Context Types</h1><p>現在我們大略知道執行環境是由一個堆疊負責運作管理的，而執行環境總共可分為：</p>
<ul>
<li>全域執行環境（Global Execution Context）</li>
<li>函式執行環境（Function Execution Context）</li>
</ul>
<h2 id="Global-Execution-Context"><a href="#Global-Execution-Context" class="headerlink" title="Global Execution Context"></a>Global Execution Context</h2><p>全域執行環境指的是一開始執行 JavaScript 程式時所創立的執行環境，裡面包含了：</p>
<ul>
<li>階段（Phase）</li>
<li>全域物件（Global Object）</li>
<li>this</li>
<li>變數物件（Variable Object）</li>
<li>範圍鏈（Scope Chain）</li>
</ul>
<p>在瀏覽器中，<code>this</code> 所指向的便是瀏覽器物件 <code>window</code>，<br>在 Node.js 中，<code>this</code> 則是指向 <code>global</code>。</p>
<p>以程式碼為例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>整段程式碼運行完畢時，在全域執行環境可以看作是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalExecutionContext = &#123;</span><br><span class="line">  Phase: <span class="string">'Execution'</span>,    <span class="comment">// 運行階段</span></span><br><span class="line">  <span class="built_in">window</span>: GlobalObject,  <span class="comment">// 在瀏覽器中全域物件便是指 Web API</span></span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>,          <span class="comment">// 指向 window</span></span><br><span class="line">  variableObject: &#123;      <span class="comment">// 變數物件（Variable）</span></span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  scopeChain: variableObject       <span class="comment">// 因為已經是最外層</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中變數物件（Variable）就是在形容 a 與 b 。</p>
<h2 id="Function-Execution-Context"><a href="#Function-Execution-Context" class="headerlink" title="Function Execution Context"></a>Function Execution Context</h2><p>函式執行環境指的是執行函式時所創立執行環境，裡面包含了：</p>
<ul>
<li>階段（Phase）</li>
<li>this</li>
<li>執行物件（Activation Object，其實也就只是多了一些東西的變數物件）</li>
<li>範圍鏈（Scope Chain） </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>整段程式碼運行完畢時，在函式執行環境可以看作是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addExecutionContext = &#123;</span><br><span class="line">  Phase: <span class="string">'Execution'</span>,    <span class="comment">// 運行階段</span></span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>,          <span class="comment">// 指向呼叫的地方 =&gt; window</span></span><br><span class="line">  activationObject: &#123;    <span class="comment">// 執行物件</span></span><br><span class="line">    <span class="built_in">arguments</span>: &#123; <span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: (activation object + [[Scope]])     <span class="comment">// 簡單來說該值就是視覺上宣告程式時的外層範圍加上自己的執行物件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中執行物件（Variable）就是形容 <code>arguments</code> 、 <code>a</code> 與 <code>b</code>， 所以在函式執行環境中變數物件與執行物件的概念其實是差不多的，但由於全域執行環境沒有 <code>arguments</code>，所以才又多了個執行物件的概念。</p>
<blockquote>
<p>其中個別的議題涉及廣泛，我將依底下分類各開一篇文章再深度解釋：</p>
<ul>
<li>Variable Object &amp; Activation Object</li>
<li>this</li>
<li>Scope Chain</li>
</ul>
</blockquote>
<p>而在瞭解執行環境的種類後，接著要來瞭解執行環境是怎麼運作的：</p>
<h1 id="Execution-Context-Phase"><a href="#Execution-Context-Phase" class="headerlink" title="Execution Context Phase"></a>Execution Context Phase</h1><p>在執行環境中總共可分為兩個階段：</p>
<ul>
<li>創造階段（creation phase）</li>
<li>執行階段（execution phase）</li>
</ul>
<h2 id="Creation-Phase"><a href="#Creation-Phase" class="headerlink" title="Creation Phase"></a>Creation Phase</h2><p>在全域執行環境的創造階段中會：</p>
<ul>
<li>建立全域物件（Global Object）</li>
<li>建立變數物件（Variable Object）</li>
<li>建立 <code>this</code>，並將它指向全域物件（在瀏覽器中是 <code>window</code>，在 Node.js 則是 <code>global</code>）</li>
<li>建立範圍鏈，並設為 null。（因為他自己就是最頂層）</li>
</ul>
<p>在函式執行環境的創造階段中會：</p>
<ul>
<li>建立執行物件（Activation Object）</li>
<li>建立 <code>this</code>，並把它指向呼叫此函式的 caller。</li>
<li>建立範圍鏈（Scope chain），並把它指向此函式的外層（程式編寫時視覺上的）。</li>
</ul>
<h2 id="Excuting-Phase"><a href="#Excuting-Phase" class="headerlink" title="Excuting Phase"></a>Excuting Phase</h2><p>當創造階段結束時，執行環境就會將裡面的階段（Phase）從 <code>Creation</code> 更改為 <code>Execution</code> 來表示進入到執行階段。</p>
<p>而執行階段最主要就是一行一行（line by line）的執行該執行環境的程式碼，如果有遇到宣告就對宣告進行處理等等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在所有程式碼執行前，首先執行環境會先進入創造階段，此時會將所有變數初始化一個 <code>undefined</code> 的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  <span class="built_in">window</span>: globleObject,</span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>,</span><br><span class="line">  variableObject : &#123;</span><br><span class="line">    a: <span class="literal">undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以等到運行階段時，第一個 <code>console.log</code> 輸出的值會是 <code>undefined</code>。</p>
<p>接著一行一行的看到第二行程式碼，我們這時才將 <code>1</code> 賦值給變數 <code>a</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Execution'</span>,</span><br><span class="line">  <span class="built_in">window</span>: globleObject,</span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>,</span><br><span class="line">  variableObject : &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這時候第三行 <code>console.log</code> 在當下的執行環境找到變數 <code>a</code> 現在的值為 <code>1</code>，這時才真正的將 <code>1</code> 呈現出來。</p>
<p>而所謂的提升（Hoisting）、<code>let</code> 的 TDZ 等等概念也是因為這樣而來的。</p>
<p>以上大概是執行環境（Execution Context）的介紹，其中還有許多概念我將另闢新文來做更深入的介紹。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts" target="_blank" rel="noopener">ECMA 262 8.3Execution Contexts</a></li>
<li><a href="http://notepad.yehyeh.net/Content/WebDesign/Javascript/ECMA/Core/JavaScriptCore.php#section8" target="_blank" rel="noopener">ECMA-262 Javascript核心 譯文</a></li>
<li><a href="https://blog.techbridge.cc/2018/12/08/javascript-closure/#scope" target="_blank" rel="noopener">所有的函式都是閉包：談 JS 中的作用域與 Closure</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10203387" target="_blank" rel="noopener">你不可不知的 JavaScript 二三事#Day5：湯姆克魯斯與唐家霸王槍——變數的作用域(Scope) (1)</a></li>
<li><a href="https://dev.to/gemhar/execution-context-the-secret-life-of-functions-1bl1" target="_blank" rel="noopener">Execution Context &amp; the Secret Life of Functions</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Error &amp; Exception-Handling 錯誤與例外處理</title>
    <url>/JavaScript/JavaScript-Exception-Handling/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>在程式開發中不免會遇到一些錯誤以及例外的狀況，而在 JavaScript 中又是要如何處理錯誤與例外呢？</p>
<a id="more"></a>

<h1 id="錯誤與例外處理"><a href="#錯誤與例外處理" class="headerlink" title="錯誤與例外處理"></a>錯誤與例外處理</h1><p>不少的文章其實都指出錯誤（Error）處理與例外（Exception）處理其實雖然都是 <code>Exception Handling</code>，但它們的本意上其實不大相同。</p>
<p>第一類的錯誤主要發生的是在程式碼方面的錯誤，比如拼寫錯誤（typo）、語法錯誤（Syntax Error）等等，這一類的錯誤應該是在開發階段中我們可以透過程式編輯器的檢查，甚至是使用 <code>console.log</code>、<code>debugger</code> 之類的語法，透過瀏覽器提供的開發者工具列（如 Chrome 的 Chrome DevTools）來尋找錯誤並解決。</p>
<p>第二類的錯誤主要則是系統上的錯誤，好比前端的例外處理要關心的是使用者在操作瀏覽器過程中的行為異常，例如網路突然斷掉了，使用者無法正常向伺服器端取得資料時，這時處在客戶端的 JavaScript 程式應該要如何應對？</p>
<p>所以在 JavaScript 中撇除掉錯誤中的型別議題，大部分說明例外處理的時候通常會聚焦偏向後者的討論。</p>
<p>而接下來我們將從第一類的錯誤開始延伸至第二類的錯誤：</p>
<h1 id="錯誤-Error"><a href="#錯誤-Error" class="headerlink" title="錯誤 Error"></a>錯誤 Error</h1><p>在 JavaScript 中有一個 <code>Error</code> 物件專門產生錯誤訊息的實體，我們可以透過傳入字串來顯示出錯誤訊息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Hello, Error?'</span>)</span><br><span class="line">error <span class="comment">// Error: Hello, Error?</span></span><br></pre></td></tr></table></figure>

<h2 id="錯誤類型"><a href="#錯誤類型" class="headerlink" title="錯誤類型"></a>錯誤類型</h2><p>而除了 <code>Error</code> 物件之外，在 JavaScript 中還有另外七種錯誤子類型，它們會透過 <code>Error</code> 物件所創建與拋出：</p>
<ul>
<li>EvalError（被遺棄）</li>
<li>InternetError（未標準化）</li>
<li>RangeRrror</li>
<li>ReferenceError</li>
<li>SyntaxError</li>
<li>TypeError</li>
<li>URIError</li>
</ul>
<h3 id="EvalError"><a href="#EvalError" class="headerlink" title="EvalError"></a>EvalError</h3><p><code>EvalError</code> 主要發生在全域函數發生錯誤時會產生，就 MDN 文件看來目前好像已經遺棄這種錯誤訊息。</p>
<h3 id="InternetError"><a href="#InternetError" class="headerlink" title="InternetError"></a>InternetError</h3><p><code>InternetError</code> 主要發生在 JavaScript Engine 在 Runtime 有異常時會警告，而這個錯誤也尚未標準化，畢竟每家的引擎還是會有自己想定義的內容（簡單來講就是你的錯不一定是我的錯，我的錯也不一定你的錯。）</p>
<h3 id="RangeRrror"><a href="#RangeRrror" class="headerlink" title="RangeRrror"></a>RangeRrror</h3><p>範圍錯誤（<code>RangeRrror</code>）主要發生在傳入方法參數超出有效範圍就會發生錯誤，最常出現在 <code>Number</code> 中的 <code>toFixed</code>、<code>toExponential</code> 等等方法中，當然我們也可以在函式中自訂錯誤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPositive</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x === <span class="number">0</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">"Zero is not Positive &amp; Nagative number."</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &gt; <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isPositive(<span class="number">1</span>)  <span class="comment">// true</span></span><br><span class="line">isPositive(<span class="number">-1</span>) <span class="comment">// false</span></span><br><span class="line">isPositive(<span class="number">0</span>)  <span class="comment">// RangeError: Zero is not Positive &amp; Nagative number.</span></span><br></pre></td></tr></table></figure>

<h3 id="ReferenceError"><a href="#ReferenceError" class="headerlink" title="ReferenceError"></a>ReferenceError</h3><p>引用錯誤（<code>ReferenceError</code>）主要發生在試圖存取一個尚未宣告過的變數，最常出現在打錯字、大小寫錯誤而找不到變數的情況：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415926</span></span><br><span class="line"><span class="built_in">console</span>.log(pi) <span class="comment">// ReferenceError: pi is not defined</span></span><br></pre></td></tr></table></figure>

<p>這種錯誤通常在開發階段時，程式編輯器就會透過高亮、深淺來提示是否有輸入錯誤造成無法解析以及宣告變數未使用，此時你就可以檢查是否有引用錯誤的情況。</p>
<h3 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h3><p>語法錯誤（<code>SyntaxError</code>）主要發生在 JavaScript 語法錯誤的情況，同樣的這種錯誤得在開發階段就得排除，否則會造成程式無法執行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI <span class="number">3.1415926</span> <span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello'</span>) <span class="comment">// 被上方錯誤中斷了</span></span><br></pre></td></tr></table></figure>

<h3 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h3><p>型別錯誤（<code>TypeError</code> ）主要發生在資料型別（Data Type）的操作上與 JavaScript Engine 預期不同時就會產生，通常會發生在函式傳參數時，內部行為與引用參數型別有誤所造成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">murmur</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> text.split(<span class="string">''</span>).join(<span class="string">'murmur'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">murmur(<span class="string">'Hello, JavaScript.'</span>) <span class="comment">// "Hmurmuremurmurlmurmurlmurmuromurmur,murmur murmurJmurmuramurmurvmurmuramurmurSmurmurcmurmurrmurmurimurmurpmurmurtmurmur."</span></span><br><span class="line">murmur([ <span class="comment">// TypeError: text.split is not a function</span></span><br><span class="line">  <span class="string">'Hello, HTML.'</span>,</span><br><span class="line">  <span class="string">'Hello, CSS.'</span>,</span><br><span class="line">  <span class="string">'Hello, JavaScript.'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>這是 JavaScript 中最容易出現的錯誤，由於 JavaScript 宣告時並不需要定義型別，並且 JavaScript 還擁有自動強制轉型（Coercion）的議題在，因此這個問題除了工程師要自律的使用函式之外，若真的有需要也可以藉由使用 TypeScript 來強化檢查型別這件事情。</p>
<h3 id="URIError"><a href="#URIError" class="headerlink" title="URIError"></a>URIError</h3><p><code>URIError</code> 主要發生在使用 <code>encodeURI()</code> 或 <code>decodeURI()</code> 傳入不正常的參數所導致：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">decodeURIComponent</span>(<span class="string">'%'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err <span class="keyword">instanceof</span> <span class="built_in">URIError</span>)  <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(err.message)              <span class="comment">// malformed URI sequence</span></span><br><span class="line">  <span class="built_in">console</span>.log(err.name)                 <span class="comment">// URIError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例外處理"><a href="#例外處理" class="headerlink" title="例外處理"></a>例外處理</h1><p>以上那些錯誤盡量都應該是在撰寫程式時就應該要解決的，然而還有一些使用者在操作時才遇到情況我們通常可以使用 <code>try</code>、<code>catch</code>、<code>throw</code>以及 <code>finally</code> 來解決。</p>
<ul>
<li>try：放入主要的程式碼</li>
<li>throw：拋出錯誤訊息</li>
<li>catch：如果有錯誤，則錯誤訊息會被傳到這個區塊，並且執行這個區塊的行為</li>
<li>finally：不論有無錯誤最後這個區塊都會被執行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">guessNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()* <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (random) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Number is Positive!'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'Number is Zero.'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Do something!'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Stopping guess number.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guessNumber()</span><br><span class="line"><span class="comment">/* 情況 1：random 為 1</span></span><br><span class="line"><span class="comment">* Number is Positive!</span></span><br><span class="line"><span class="comment">* Do something!</span></span><br><span class="line"><span class="comment">* Stopping guess number.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情況 2：random 為 0</span></span><br><span class="line"><span class="comment">* Number is Zero.</span></span><br><span class="line"><span class="comment">* Stopping guess number.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>從上面範例中可以看到若當 JavaScript Runtime 執行到 <code>throw</code> 並拋出錯誤時， <code>try</code> 區塊原本執行的內容就會中止，並且接著執行 <code>catch</code> 區塊內的內容；若沒有的話則是繼續執行 <code>try</code> 原先區塊的行為，但無論如何最後 <code>finally</code> 區塊都是會被執行的地方。</p>
<h1 id="客製化錯誤"><a href="#客製化錯誤" class="headerlink" title="客製化錯誤"></a>客製化錯誤</h1><p>如果要客製化錯誤的話我們可以藉由繼承 <code>Error</code> 物件本身的 <code>name</code> 以及 <code>message</code> 來定義錯誤名稱與內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Status:'</span>,</span><br><span class="line">  <span class="keyword">this</span>.message = message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>() <span class="comment">// 繼承 Error 類別</span></span><br><span class="line">CustomError.prototype.constructor = CustomError <span class="comment">// 將建構子從 Error 轉回 CustomEror</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> CustomError(<span class="string">'[A1] Permission is denied.'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.name, err.message) <span class="comment">// Status: [A1] Permission is denied.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AJAX-中的錯誤"><a href="#AJAX-中的錯誤" class="headerlink" title="AJAX 中的錯誤"></a>AJAX 中的錯誤</h1><p>既然最主要是使用者在汲取資料時容易會遇到斷線等等問題而導致操作失敗，所以採用了 Promise 所設計的 AJAX API 本身都有支援 <code>catch</code> 的選項來協助除錯，即便沒有也通常會提供相對應的例外處理 API 來協助開發：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fetch</span></span><br><span class="line">fetch(<span class="string">'url'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(res) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// axios</span></span><br><span class="line">axios.get(<span class="string">'url'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res.data))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery ajax</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  type: <span class="string">"GET"</span>,</span><br><span class="line">  url: <span class="string">"url"</span>,</span><br><span class="line">  success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function">(<span class="params">XMLHttpRequest, textStatus, errorThrown</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.error(textStatus)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="錯誤事件處理器"><a href="#錯誤事件處理器" class="headerlink" title="錯誤事件處理器"></a>錯誤事件處理器</h1><p>瀏覽器有提供一個綁定在全域下的錯誤事件處理器，只要觸發下列條件就會啟動 <code>window.onerror</code>：</p>
<ul>
<li>JavaScript Runtime 的各種 Error。</li>
<li>透過元素屬性的 <code>src</code> 引入資源時發生異常。</li>
</ul>
<p>而針對上面兩種不同的情況 callback function 的傳送參數也有不同：</p>
<p>針對 Runtime Error：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">windon.onerorr = <span class="function"><span class="keyword">function</span> (<span class="params">message, filename, lineNumber, columnNumber, errorObject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>針對 Element source Error：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如載入圖片如果發生異常時我們便可以透過這個 <code>onerror</code> 來執行替換預設圖片的程式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">onerror</span>=<span class="string">"replaceToDefaultImage(this)"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceToDefaultImage</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> defaultImage = <span class="string">'xxx.png'</span></span><br><span class="line">  target.src = defaultImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上便是幾種常見的錯誤類型、例外處理與錯誤事件處理器。</p>
<p>最後，錯誤處理就開發上算是一種行為的脈絡，也並非所有情境都會需要這種脈絡，前端應就整體行為流程去斟酌。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://pjchender.blogspot.com/2017/12/js-error-handling.html" target="_blank" rel="noopener">PJChen - [JS] 談談 JavaScript 中的錯誤處理 Error Handling</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noopener">MDN - Error</a></li>
<li><a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part3/error.html" target="_blank" rel="noopener">Eddy Chang - 錯誤與例外處理</a></li>
<li><a href="https://www.ithome.com.tw/voice/131812" target="_blank" rel="noopener">林信良 - JavaScript錯誤處理</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Garbage Collection 垃圾回收機制</title>
    <url>/JavaScript/JavaScript-Garbage-Collection/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>垃圾回收機制（Garbage Collection）主要是在協助執行於電腦上的應用程式，保留、清除一些儲存於記憶體中一些用不到的資料。</p>
<p>那麼在 JavaScript 中的垃圾回收機制又是如何處理呢？</p>
<a id="more"></a>

<h1 id="瀏覽器中的記憶體存取"><a href="#瀏覽器中的記憶體存取" class="headerlink" title="瀏覽器中的記憶體存取"></a>瀏覽器中的記憶體存取</h1><p>要知道垃圾回收機制前，要先稍微瞭解一下記憶體存取的概念，對於瀏覽器來說，由於各家廠商對於記憶體管理（Memory Management）的實作不同，存取的抽象概念可能也會有所差距，但大致上來說都會擁有 <code>stack</code> 與 <code>heap</code> 的儲存機制：</p>
<p>其中 stack 存放著一些較為簡單的資料，如一些原始數值（如：Number、String 等等），另外還有儲存一些指向 <code>heap</code> 的地址（address）。</p>
<p>而相對的 <code>heap</code> 就是用來儲存一些比較複雜的物件類型（或說非原始類型、複雜類型）。</p>
<p>所以每次操作資料時都會去 <code>stack</code> 設定相關的資料，如果是處理物件類型的資料，那就得在 <code>stack</code> 設定一個找到 <code>heap</code> 的地址，再儲存值到 <code>heap</code> 裡面；如果只是原始數值，就指向到 <code>stack</code> 就完成了。</p>
<blockquote>
<p>想知道瀏覽器實作時遵循的文件可參考 <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-memory-model" target="_blank" rel="noopener">ECMA 262 - 10.0</a></p>
</blockquote>
<h1 id="Memory-leak-記憶體遺失"><a href="#Memory-leak-記憶體遺失" class="headerlink" title="Memory leak 記憶體遺失"></a>Memory leak 記憶體遺失</h1><p>上面介紹到簡略的存取概念後，我們可以知道：</p>
<ul>
<li>每次操作時都會申請分配（allocate） <code>stack</code> 的記憶體。</li>
<li>物件類型不僅會分配到 <code>stack</code>，還會再深入到 <code>heap</code> 當中。</li>
</ul>
<p>所以當我們對於變數重新賦值（reassign）一個物件類型時，意味著我們需要重新分配一個 <code>stack</code> 地址後，再連結到新的一個 <code>heap</code> 當中。</p>
<p>而一個較為經典的記憶體遺失案例就發生在這個過程中當中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">'大家掰掰，這是我們最後一次見面了。'</span>]</span><br><span class="line">a = [<span class="string">'大家好，我其實是另一個陣列'</span>] <span class="comment">// Memory leak</span></span><br></pre></td></tr></table></figure>

<p>僅僅兩行，就能造成一個簡單的記憶體遺失案例，這中間發生什麼事情了？</p>
<p>首先，第一行我們對於 <code>a</code> 賦值，由於是物件類型，我們必須分配到 <code>stack</code> 記憶體後，儲存一個指向 <code>heap</code> 的地址，並在 <code>heap</code> 中存下 <code>[&#39;大家掰掰，這是我們最後一次見面了。&#39;]</code>。</p>
<p>接著第二行，我們對於 <code>a</code> 重新賦值，由於是物件類型，我們必須再次重新分配到 <code>stack</code> 記憶體後，儲存另一個指向 <code>heap</code> 的地址，原本在 <code>heap</code> 中存下 <code>[&#39;大家掰掰，這是我們最後一次見面了。&#39;]</code> 資料，它仍然還在那邊，不過我們再也無法去取得它了。</p>
<blockquote>
<p>想看更多的垃圾（？）可以參考這篇<a href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec" target="_blank" rel="noopener">文章</a></p>
</blockquote>
<h1 id="垃圾回收機制"><a href="#垃圾回收機制" class="headerlink" title="垃圾回收機制"></a>垃圾回收機制</h1><p>身為人類，我們都知道哪些東西要拿去丟垃圾車，但瀏覽器其實並沒有提供你手動丟記憶體垃圾的權利，因為瀏覽器會幫我們丟掉這些垃圾。</p>
<p>簡單的來說，記憶體垃圾要怎麼丟、丟什麼完全不是我們網頁工程師所能控制的，我們唯一能做的就是減少垃圾的產生<del>或繼續製造垃圾。</del></p>
<p>那麼瀏覽器要怎麼辨識哪些是記憶體垃圾呢？一般在辨識記憶體垃圾上有比較常見的兩種方法：</p>
<ul>
<li>計算參考（Reference counting）演算法</li>
<li>標記掃除（Mark-and-Sweep）演算法</li>
</ul>
<h2 id="記憶體回收演算法：Reference-counting"><a href="#記憶體回收演算法：Reference-counting" class="headerlink" title="記憶體回收演算法：Reference counting"></a>記憶體回收演算法：Reference counting</h2><p>簡單來說就是該記憶體有沒有被參考到，而這理論上確實很合理，因為沒有被參考到的就是垃圾。</p>
<p>但有一種明明有被參考到但卻還是垃圾的情況：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line">  obj.a = obj2;   <span class="comment">// obj 參考 obj2</span></span><br><span class="line">  obj2.a = obj;    <span class="comment">// obj2 參考 obj</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<p>這種例子就叫做循環參考。</p>
<h2 id="標記掃除演算法：Mark-and-Sweep"><a href="#標記掃除演算法：Mark-and-Sweep" class="headerlink" title="標記掃除演算法：Mark-and-Sweep"></a>標記掃除演算法：Mark-and-Sweep</h2><p>標記掃除演算法是大部分垃圾回收機制的處理方式。</p>
<p>原因在於這種演算法則是將記憶體垃圾定義為「從根（roots）開始，不可到達的物件」。</p>
<p>對於 JavaScript 來說，根即為全局物件（詳見變數物件 Variable Object），因此這種算法會遍歷所有被全局物件所參考的物件與所參考的物件底下所有被參考的物件，還有其被參考的物件所參考的物件（好饒舌），一直到最後為止，沒有被這個颱風尾掃到的，就是垃圾。</p>
<p>這個演算法好處解決了上面循環的問題：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line">  obj.a = obj2;   <span class="comment">// obj 參考 obj2</span></span><br><span class="line">  obj2.a = obj;    <span class="comment">// obj2 參考 obj</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>垃圾回收機制最終控制權是在瀏覽器身上而非網頁開發工程師本身，儘管完美的垃圾回收應該要使記憶體垃圾不會對使用者造成負擔，但我們仍可以試著理解垃圾回收機制儘量避免這些會成為記憶體垃圾的寫法。</p>
<h1 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)" target="_blank" rel="noopener">Garbage Collection wiki</a></li>
<li><a href="https://zh.wikipedia.org/zh-tw/%E9%9B%BB%E8%85%A6%E8%A8%98%E6%86%B6%E9%AB%94" target="_blank" rel="noopener">Memory wiki</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Memory_Management" target="_blank" rel="noopener">Memory Management MDN</a></li>
<li><a href="https://liujiacai.net/blog/2018/06/15/garbage-collection-intro/#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-mark-and-sweep" target="_blank" rel="noopener">基本算法 mark-and-sweep</a></li>
<li><a href="https://zh.javascript.info/garbage-collection" target="_blank" rel="noopener">garbage-collection</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">JavaScript 内存泄漏教程</a></li>
<li><a href="https://juejin.im/post/5b10ba336fb9a01e66164346" target="_blank" rel="noopener">JavaScript 内存机制</a></li>
<li><a href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec" target="_blank" rel="noopener">How JavaScript works: memory management + how to handle 4 common memory leaks</a></li>
<li><a href="https://medium.com/@ethannam/javascripts-memory-model-7c972cd2c239" target="_blank" rel="noopener">JavaScript’s Memory Model</a></li>
<li><a href="https://codeburst.io/js-demystified-04-execution-context-97dea52c8ac6" target="_blank" rel="noopener">JS Demystified 04 — Execution Context</a></li>
<li><a href="https://www.coderbridge.com/@aszx87410/a5279d9298ab4e75bf75c75a4f391e78" target="_blank" rel="noopener">Day00：V8 bytecode 系列文介紹</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Promise</title>
    <url>/JavaScript/JavaScript-Promise/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>繼回呼地獄（Callback Hell）之後，ES 6 推了一個令人振奮的功能，那就是 <code>Promise</code>！</p>
<p>Promise 解決了使用回呼時會產生的回呼地獄，讓整個程式平坦化之外，更多了一些 <code>Promise.all</code> 、 <code>Promise.race</code> 使許多非同步處理能更加的簡潔，</p>
<p>今天就讓我們一起來看看 <code>Promise</code> 要怎麼使用吧！</p>
<a id="more"></a>

<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>沒有經歷過糟糕的怎麼會懂另一邊的好，所以第一節當然要先看看相對醜醜的寫法。</p>
<p>而在之前 <code>Promise</code> 還未出現時，如果我們需要讓不同非同步方法能夠等待可以這麼做：</p>
<p>情境一，有序地等待，直接回呼下一個函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcA done!'</span>)</span><br><span class="line">    callback()</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcB done!'</span>)</span><br><span class="line">    callback()</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcC</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcC done!'</span>)</span><br><span class="line">    callback()</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  funcB(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    funcC(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'All Done'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但這樣會造成回呼地獄。</p>
<p>情境二，互相等待，做一個控管函式，由控管函式確認最後合併結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcA done!'</span>)</span><br><span class="line">    callback(<span class="string">'A'</span>)</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcB done!'</span>)</span><br><span class="line">    callback(<span class="string">'B'</span>)</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combineResult</span>(<span class="params">func1, func2, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> box = []</span><br><span class="line">  funcA(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    box.push(val)   <span class="comment">// A</span></span><br><span class="line">    <span class="keyword">if</span>(box.length === <span class="number">2</span>) &#123;</span><br><span class="line">      callback(<span class="string">'All done!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  funcB(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    box.push(val)   <span class="comment">// B</span></span><br><span class="line">    <span class="keyword">if</span>(box.length === <span class="number">2</span>) &#123;</span><br><span class="line">      callback(<span class="string">'All done!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">combineResult(funcA, funcB, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// All done!</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>情境三，互相競爭，做一個控管函式，由控管函式來阻止另一個函式回呼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcA done!'</span>)</span><br><span class="line">    callback(<span class="string">'A'</span>)</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcB done!'</span>)</span><br><span class="line">    callback(<span class="string">'B'</span>)</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">raceResult</span>(<span class="params">func1, func2, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> box = []</span><br><span class="line">  funcA(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    box.push(val)   <span class="comment">// A</span></span><br><span class="line">    <span class="keyword">if</span>(box.length === <span class="number">1</span>) &#123;</span><br><span class="line">      callback(val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  funcB(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    box.push(val)   <span class="comment">// B</span></span><br><span class="line">    <span class="keyword">if</span>(box.length === <span class="number">1</span>) &#123;</span><br><span class="line">      callback(val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raceResult(funcA, funcB, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result + <span class="string">' is first!'</span>) <span class="comment">// ? is first!</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面兩種做法雖然已經可以解決一些基礎的等待與競爭情境，但顯然看起來還是不夠乾淨，於似乎我們在 ES6 終於盼到了這一刻，</p>
<p>那就是 <code>Promise</code>！</p>
<h1 id="Promise-基本使用"><a href="#Promise-基本使用" class="headerlink" title="Promise 基本使用"></a>Promise 基本使用</h1><p>Promise 顧名思義它主要是用來承諾一些非同步上的行為要如何處理。</p>
<p>而一個基本的 Promise 會有三種狀態：</p>
<ul>
<li>pending：等待執行回應。</li>
<li>resolve（fulfilled）：執行完畢，並且回應完成。</li>
<li>reject：執行完畢，並且回應失敗。</li>
</ul>
<p>最基本的用法就是在函式中初始化一個 Promise 物件，並把相關處理放在裡面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcA done!'</span>)        <span class="comment">// 回應表示執行完畢，結果成功，並送出成功結果。</span></span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;                  <span class="comment">// 捕捉到錯誤時</span></span><br><span class="line">      reject(err)                   <span class="comment">// 回應表示執行完畢，結果失敗，並送出失敗結果。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著當 Promise 執行成功時，我們可以藉由 <code>then</code> 去取得 <code>resolve</code> 所回應的成功結果，執行失敗則可以藉由 <code>catch</code> 去取得 <code>reject</code> 所回應的失敗結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">funcA()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 在這裡執行成功的後續處理</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">rej</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(rej) <span class="comment">// 在這裡執行失敗的後續處理</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>而其中由 <code>then</code> 所返回的值也是 <code>Promise</code> 物件，因此你還可以接著做其他後續處理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">funcA()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> res <span class="comment">// 第一波處理後將值回傳，使得接下來能可以繼續使用 Promise 中的 then 方法處理</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 第二波處理</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>釐清怎麼使用後，接著我們回到第一個情境改寫一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcA done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcB done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcC done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    funcB()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    funcC()</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>有沒有看到改寫後整個平坦化了許多！</p>
<p>現在來看看合併與競爭下的 Promise 要怎麼使用：</p>
<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h1><p>在 Promise 之中我們只要將會返回 Promise 物件的函式包裹在一起即可透過 <code>Promise.all</code> 等待所有結果後，再發出最後結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcA done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcB done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([funcA(), funcB()])</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// ["funcA done!", "funcB done!"]</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>如此一來它就會等待所有函式都返回結果時，於下一個 <code>then</code> 中回傳一個陣列，裡面分別為所有 Promise <code>resolve</code> 的結果。</p>
<h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h1><p>若是要競爭非同步行為的話，則透過 <code>Promise.race</code> 就可以取得第一個執行完畢的結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcA done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcB done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([funcA(), funcB()])</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// 'func? done'</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>如此一來它就會等待第一個回應的結果，並只回傳第一個結果。</p>
<h1 id="Promise-其餘狀況"><a href="#Promise-其餘狀況" class="headerlink" title="Promise 其餘狀況"></a>Promise 其餘狀況</h1><p>除了基本的合併與競爭之外，Promise 還有下列情境可以使用：</p>
<ul>
<li>first()：只要第一個 Promise 回應了就執行。</li>
<li>last()：最後一個 Promise 回應了才執行。</li>
<li>none()：如果所有 Promise 都失敗了才執行。</li>
<li>any()：任何一個 Promise 成功了就執行。</li>
</ul>
<p>以上就是 Promise 基本用法，其餘之外還有一些雷點跟狀況就等待大家來挖掘吧（？</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://blog.huli.tw/2015/08/26/javascript-promise-generator-async-es6/" target="_blank" rel="noopener">[Javascript] Promise, generator, async與ES6</a></li>
<li><a href="https://wcc723.github.io/development/2020/02/16/all-new-promise/" target="_blank" rel="noopener">JavaScript Promise 全介紹</a></li>
<li><a href="https://pjchender.github.io/2017/09/26/js-promise-%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">[JS] Promise 的使用</a></li>
<li><a href="https://cythilya.github.io/2018/10/31/promise/" target="_blank" rel="noopener">你懂 JavaScript 嗎？#24 Promise</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10194569?sc=iThelpR" target="_blank" rel="noopener">重新認識 JavaScript: Day 26 同步與非同步</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Scope</title>
    <url>/JavaScript/JavaScript-Scope/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>為什麼 <code>console.log</code> 出來的結果跟你想的不一樣？</p>
<p>瞭解 <code>Scope</code> 後，你將會大幅提升閱 code 能力！</p>
<a id="more"></a>

<blockquote>
<p>要瞭解作用域（Scope）前，建議要先有執行環境（Execution Context）的概念就可以很快理解本篇內容！</p>
</blockquote>
<h1 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h1><p>作用域（Scope）簡單的來說就像是變數的生存環境，最主要牽扯的是有關於執行環境（Execution Context）的概念，而簡單來說，只要執行函式就會創造一個新的執行環境。</p>
<blockquote>
<p>想深入請詳見執行環境一文。</p>
</blockquote>
<h2 id="全域執行環境"><a href="#全域執行環境" class="headerlink" title="全域執行環境"></a>全域執行環境</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上列程式在執行前（Creation Phase），會先初始化變數物件（Variable Object）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GlobalExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  variableObject: &#123;</span><br><span class="line">    a: <span class="literal">undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這也是為什麼 <strong>執行時</strong> 一行一行直譯時第一行秀出該行 <code>console.log(a)</code> 為 <code>undefined</code> ，而第三行則是秀出 <code>1</code> 的原因（也是 <code>提升 Hoisting</code> 概念的由來）。</p>
<h2 id="函式執行環境"><a href="#函式執行環境" class="headerlink" title="函式執行環境"></a>函式執行環境</h2><p>接著或許你會說，那麼我如果執行了一個函式，裡面不是也會形成新的執行環境，那他如果找不到裡面的變數怎麼辦？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>我們一樣來看看在初始化時函式執行環境做了什麼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FunctionExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  activationObject: &#123;</span><br><span class="line">    argument: []</span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: activationObject + [[scope]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>執行物件（Actication Object）與變數物件（Variable Object）其實只差在多了個 <code>argument</code> 參數。</p>
</blockquote>
<p>我們可以從執行物件（Actication Object）中看到他並沒有 <code>a</code> 這個變數，那麼它要去哪裡找呢？</p>
<h1 id="Scope-Chain"><a href="#Scope-Chain" class="headerlink" title="Scope Chain"></a>Scope Chain</h1><p>範圍鏈、或稱作用鏈（Scope Chain），主要的目的在於當我們在該執行環境中的物件找不到變數時，就會透過作用鏈的機制來尋找。</p>
<p>而一般作用鏈初始化的內容會是自己本身的變數物件加上 <code>[[scope]]</code>，所以我們可以理解成一開始理所當然的會先去找當前的變數環境，找不到再來看有沒有在 <code>[[scope]]</code> 當中。</p>
<p>那麼 <code>[[scope]]</code> 又是什麼東西？</p>
<p>根據 ECMA 262 三版中的解釋是，當一開始建立此函式時，<code>[[scope]]</code> 所設定的值會是當下環境中的 <code>scope chain</code>，回到剛剛的程式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) </span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>所以<code>[[scope]]</code> 其實就是宣告 <code>function</code> 的環境，更白話一點的方式就是，<br><strong>找不到變數就往宣告函式的外層找就行！</strong></p>
<p>接著來驗證此想法：</p>
<h2 id="Scope-Chain，範例一"><a href="#Scope-Chain，範例一" class="headerlink" title="Scope Chain，範例一"></a>Scope Chain，範例一</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  y()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br><span class="line">x();</span><br></pre></td></tr></table></figure>

<p>在上面程式碼中，函式 <code>y</code> 是在全域執行環境下被初始化的，因此函式 <code>y</code> 的 scope chain 除了自己本身之外，另一個就是找到全域執行環境當中，因此輸出 <code>1</code>。</p>
<h2 id="Scope-Chain，範例二"><a href="#Scope-Chain，範例二" class="headerlink" title="Scope Chain，範例二"></a>Scope Chain，範例二</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)  <span class="comment">// ?</span></span><br><span class="line">  &#125;</span><br><span class="line">  y()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x();</span><br></pre></td></tr></table></figure>

<p>在上面程式碼中，函式 <code>y</code> 是在函式執行環境 <code>x</code> 下被初始化的，因此函式 <code>y</code> 的 scope chain 除了自己本身之外，另一個就是找到函式執行環境 <code>x</code> 當中，而在 <code>x</code> 環境當中有宣告 <code>a</code> 變數，因此輸出 <code>2</code>。</p>
<h2 id="Scope-Chain，範例三"><a href="#Scope-Chain，範例三" class="headerlink" title="Scope Chain，範例三"></a>Scope Chain，範例三</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  y()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)  <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x();</span><br></pre></td></tr></table></figure>

<p>在上面程式碼中，函式 <code>y</code> 是在全域執行環境下被初始化的，因此函式 <code>y</code> 的 scope chain 除了自己本身之外，另一個就是找到全域執行環境當中的 <code>x</code>，但與範例一不同的地方在於，執行 <code>x()</code> 時，內部的 <code>a</code> 去更動了全域環境的 <code>a</code> 值，因此輸出 <code>2</code>。</p>
<h1 id="Scope-type-作用域類型"><a href="#Scope-type-作用域類型" class="headerlink" title="Scope type 作用域類型"></a>Scope type 作用域類型</h1><p>作用域的類型其實分有兩種：</p>
<ul>
<li>動態作用域（dynamic scope）</li>
<li>靜態作用域（static scope），又稱為詞法作用域（lexical scope）。</li>
</ul>
<p>動態作用域的意思是以<strong>呼叫</strong>函式的地方當作作用域鏈。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  y()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 若是動態的話這邊會以呼叫的地方，也就是 x 的環境當作作用域，最後輸出 2。</span></span><br><span class="line">&#125;</span><br><span class="line">x();</span><br></pre></td></tr></table></figure>

<p>靜態作用域的意思則是以<strong>宣告</strong>函式的地方當作作用域鏈。</p>
<p>JavaScript 所採用的是便是靜態作用域的方法，而大部分會搞錯都是認為 JavaScript 是以動態作用域的做法下去看的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  y()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 但 JavaScript 是採用靜態作用域，因此其實哪邊呼叫它並沒有關係，因為他看到是最初宣告它的作用域。</span></span><br><span class="line">&#125;</span><br><span class="line">x();</span><br></pre></td></tr></table></figure>

<p>若能搞懂動態與靜態的差別，並知道 JavaScript 是以靜態作用域的思維下去思考，作用域其實沒你想像中的難！</p>
<h1 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h1><ul>
<li><a href="https://pjchender.blogspot.com/2015/12/javascriptscope-chainouter-environment.html" target="_blank" rel="noopener">[筆記] JavaScript中Scope Chain和outer environment的概念</a></li>
<li><a href="http://notepad.yehyeh.net/Content/WebDesign/Javascript/ECMA/Core/JavaScriptCore.php#section8" target="_blank" rel="noopener">ECMA-262 Javascript核心 譯文</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10203387" target="_blank" rel="noopener">你不可不知的 JavaScript 二三事#Day5：湯姆克魯斯與唐家霸王槍——變數的作用域(Scope) (1)</a></li>
<li><a href="https://blog.techbridge.cc/2018/12/08/javascript-closure/#scope" target="_blank" rel="noopener">所有的函式都是閉包：談 JS 中的作用域與 Closure</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Pure Function &amp; Side Effect 純函數與副作用</title>
    <url>/JavaScript/JavaScript-Pure-Function/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>來點純一點的貨吧！</p>
<p>為什麼函式還有分純不純的呢？有副作用的函式又是怎麼一回事？</p>
<p>讓我們一起來瞭解純函數與副作用到底是什麼吧！</p>
<a id="more"></a>

<h1 id="Pure-Function"><a href="#Pure-Function" class="headerlink" title="Pure Function"></a>Pure Function</h1><p>純函式（pure function）主要的概念是不會改變函式外面與函式傳進來的數值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">// 4</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>而我們會需要純函式的原因：</p>
<ul>
<li>具可快取性（cachable），可建立快取方法加速運算。</li>
<li>具有移植性（portable），由於純函式具有一致性，因此函式可輕鬆移到別的程式中。</li>
<li>引用具有透明性（referntial transparency），引用資料從何而來一清二楚，</li>
<li>函式本身即為文件（self-documenting），不必再另外撰寫一份說明文件，相對容易理解好維護。</li>
<li>具可測試性（testable），</li>
<li>好理解，因為沒有競爭狀態（race condition）。（雖然在 JavaScript Runtime 中本身是屬於單執行緒，本來就沒競爭狀態的問題）。</li>
</ul>
<h2 id="可快取性"><a href="#可快取性" class="headerlink" title="可快取性"></a>可快取性</h2><p>我們可以透過閉包的機制封裝結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cacheFunc = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = &#123;&#125; <span class="comment">// 參數與回傳值將會被快取在這裡</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arg = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>)</span><br><span class="line">    cache[arg] = cache[arg] || func.apply(func, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> cache[arg]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著就可以透過這個 <code>cacheFunc</code> 來快取運算值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = cacheFunc(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">5</span>) <span class="comment">// 6</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">5</span>) <span class="comment">// 從快取得到 6</span></span><br></pre></td></tr></table></figure>

<h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><p>可移植性簡單來說就是因為純函式到哪裡運算邏輯都不受影響，因此別的程式需要時可以直接引用，甚至是複製到其他專案中。</p>
<h2 id="引用透明性"><a href="#引用透明性" class="headerlink" title="引用透明性"></a>引用透明性</h2><p>引用透明性是指撰寫時視覺上我們可以很清楚的知道函式的輸入輸出總是能輸出相同的值。</p>
<h2 id="本身為文件"><a href="#本身為文件" class="headerlink" title="本身為文件"></a>本身為文件</h2><p>純函數本身可以被看作是一種文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderH1 = <span class="function"><span class="keyword">function</span>(<span class="params">content</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;'</span> + content + <span class="string">'&lt;/h1&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.title'</span>).innerHTML = renderH1(<span class="string">'標題'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="可測試性"><a href="#可測試性" class="headerlink" title="可測試性"></a>可測試性</h2><p>純函數由於在內部不直接引用外部值，而須透過參數給定，因此在測試上只需要針對傳送參數即可，並且必定會回傳相同值也讓測試案例（test case）更好撰寫。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'add func test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  test(<span class="string">'add 1 &amp; 2 should equal 3'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>) <span class="comment">// 不論使用多少次 add(1, 2) 最後都一定會返回 3。</span></span><br><span class="line">  &#125;)</span><br><span class="line">  test(<span class="string">'add 2 &amp; 4 should equal 6'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    expect(add(<span class="number">2</span>, <span class="number">4</span>)).toBe(<span class="number">6</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="可並行性"><a href="#可並行性" class="headerlink" title="可並行性"></a>可並行性</h2><p>在別的程式語言中要考量存取記憶體的先後順序定義的問題，然而 JavaScript 在 Runtime 時本身就是單執行緒，所以 JavaScript 不會進入競爭狀態（race condition）。但如果是在別的程式語言中使用純函數，就可以透過純函數不依靠記憶體而得到避免進入競爭狀態的窘境。</p>
<p>以上便是使用純函數的好處與理由。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10185780" target="_blank" rel="noopener">Day 12: ES6篇: Side Effects(副作用)與Pure Functions(純粹函式)</a></li>
<li><a href="https://medium.com/frochu/%E7%B4%94%E7%B2%B9%E7%9A%84%E5%A5%BD-pure-function-%E7%9F%A5%E9%81%93-574d5c0d7819" target="_blank" rel="noopener">純粹的好，Pure Function 知道</a></li>
<li><a href="https://jigsawye.gitbooks.io/mostly-adequate-guide/ch3.html" target="_blank" rel="noopener">第 3 章：Pure Function－單純的幸福</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Statement &amp; Expression 陳述式與表達式</title>
    <url>/JavaScript/JavaScript-Statement-Expression/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>你有想過為什麼變數可以儲存 <code>3</code> 卻沒有辦法儲存 <code>if/else</code> 語句，可是卻又能儲存整個 <code>function</code> 嗎？</p>
<p>一起來看看陳述式與表達式的概念就能馬上瞭解！</p>
<a id="more"></a>

<p>在談談兩者之前要先請你看下方程式，請問最後會秀出甚麼呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span>(a = <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a = <span class="number">4</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>

<p>如果無法一眼看出是 <code>4</code>、<code>4</code> 或不知道為什麼會這樣的話歡迎繼續看下去！</p>
<h1 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h1><p>在 JavaScript 中，語句主要可分為陳述式（statement）與表達式（expression）。</p>
<p>而陳述式簡單的來說就像是指令一樣，它的目的主要是去執行一些事情，並且不會返回運算結果，例如 <code>if/else</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> () &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>陳述式最主要是用來描述它將做什麼事，並且它也不會回傳一個運算結果給你。</p>
<h1 id="Expression"><a href="#Expression" class="headerlink" title="Expression"></a>Expression</h1><p>除了陳述式之外，JavaScript 另一種語句我們稱為表達式（Expression），</p>
<p>而表達式又稱為運算式，顧名思義就是在計算一些東西，因此在 JavaScript 執行期他會回傳一個運算結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span> + <span class="number">1</span>) <span class="comment">// 回傳 2</span></span><br></pre></td></tr></table></figure>

<p>而我們可以藉由將表達式所運算的結果藉由變數指派記憶體的路徑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="number">1</span> + <span class="number">1</span>) <span class="comment">// a 存下回傳的 2</span></span><br><span class="line"></span><br><span class="line">a <span class="comment">// 現在 a 儲存的路徑指向 2</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span> * <span class="number">2</span> <span class="comment">// a 存下回傳的 10</span></span><br><span class="line"></span><br><span class="line">a <span class="comment">// 現在 a 儲存的路徑指向 10</span></span><br></pre></td></tr></table></figure>

<p>一些其他的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">2</span> <span class="comment">// 回傳 false</span></span><br><span class="line">(<span class="number">2</span> &gt; <span class="number">1</span> ? <span class="string">'yes'</span> : <span class="string">'no'</span>) <span class="comment">// 回傳 yes</span></span><br><span class="line">a = <span class="number">3</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>有注意到嗎？賦值運算子 <code>=</code> 其實也是表達式，而 <code>=</code> 所回傳的結果是右方運算完的內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">var</span> y;</span><br><span class="line"><span class="keyword">var</span> z = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">x = y = z + <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">// ?</span></span><br><span class="line"><span class="built_in">console</span>.log(y) <span class="comment">// ?</span></span><br><span class="line"><span class="built_in">console</span>.log(z) <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>在執行的過程中， <code>x = y = z + 5</code> 這句會先被拆解成 <code>y = z + 5</code>，接著再把 <code>y = z + 5</code> 所返回的值 <code>5</code> 賦值給 <code>x</code>，所以最後結果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(y) <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(z) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>現在再回頭看最上面的那道題目，你應該可以解釋為什麼最後印出的結果會是 <code>4</code>、<code>4</code> 了！</p>
<h1 id="常見誤區"><a href="#常見誤區" class="headerlink" title="常見誤區"></a>常見誤區</h1><p>至於為什麼要區辨表達式跟陳述式的原因很多，其中一個例子是當你原本 <code>if</code> 中是要透過全等運算 <code>===</code> 但錯打成 <code>=</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if(a === 3) &#123;&#125; 原本要做全等比較</span></span><br><span class="line"><span class="keyword">if</span> (a = <span class="number">3</span>) &#123;&#125; <span class="comment">// 不小心打成這樣，但由於裡面返回的運算值是 3 ，為真值，所以最後仍然能通過 if 執行內部的東西。</span></span><br></pre></td></tr></table></figure>

<p>而這種錯誤在 typo 當中也算是一種比較麻煩的類型，原因是因為它是合法且能執行的，所以要特別小心。</p>
<h1 id="函式"><a href="#函式" class="headerlink" title="函式"></a>函式</h1><p>函式（function）在 JavaScript 算是物件的一種，所以自然而然可以把它當作值來操作，比方說把函式透過變數來儲存，或是單純呼叫函式，因此自然而然它也擁有表達式與陳述式兩種形式。</p>
<h2 id="函式陳述式-Function-Statement"><a href="#函式陳述式-Function-Statement" class="headerlink" title="函式陳述式 Function Statement"></a>函式陳述式 Function Statement</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">something</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(something)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say <span class="comment">// function say(something)&#123; console.log(something) &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="函式表達式-Function-Expression"><a href="#函式表達式-Function-Expression" class="headerlink" title="函式表達式 Function Expression"></a>函式表達式 Function Expression</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(something)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say <span class="comment">// function (something) &#123; console.log(something) &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="比較-函式陳述式-amp-函式表達式"><a href="#比較-函式陳述式-amp-函式表達式" class="headerlink" title="比較 函式陳述式 &amp; 函式表達式"></a>比較 函式陳述式 &amp; 函式表達式</h2><p>這兩個最大的差異點在於 JavaScript 執行時（Runtime）當下的執行環境（Execution Context）中。</p>
<p>所以若是以下這段程式碼為例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">statementFunction()</span><br><span class="line">expressionFunction()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">statementFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expressionFunction = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">statementFunction()</span><br><span class="line">expressionFunction()</span><br></pre></td></tr></table></figure>

<p>在全域環境執行時期的創造階段中，會有一個叫做 <code>Variable Object</code> 紀錄所有的值（若不清楚的請詳見 <code>Varaible Object</code> 與 <code>Activation Object</code> 一章），函式陳述式在這裡會被視為需要被初始化的目標，而透過變數宣告的則是會先預設一個<br> <code>undefined</code> 的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GlobalExecutionContext = &#123; <span class="comment">// 全域執行環境</span></span><br><span class="line">  phase: <span class="string">'Creation'</span>, <span class="comment">// 創造階段</span></span><br><span class="line">  variableObject: &#123; <span class="comment">// 紀錄當下環境的值</span></span><br><span class="line">    statementFunction: <span class="function"><span class="keyword">function</span> <span class="title">statementFunction</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'Hi'</span>) &#125;,</span><br><span class="line">    expressionFunction: <span class="literal">undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等創造模式結束所有的行為後，進入執行階段才會開始一行一行的檢查有沒有要運算的內容，因此第一行我們可以很輕易的在 <code>variable object</code> 中找到 <code>statementFunction</code> 這個辨識字（identity）所儲存的是一個函式，因此要它執行函式很合理。</p>
<p>但就在第二行時，我們知道 <code>variable object</code> 中 <code>expressionFunction</code> 這個識別字所表示的值還是初始化的 <code>undefined</code>，因此要去執行一個 <code>undefined</code> 時引擎就會拋出一個錯誤提醒你。</p>
<p>所以他們之間的差異最主要還是在於 <code>scope</code> 這件事情上，如果已經瞭解 <code>Execution Context</code> 的創造階段與執行階段到底做了什麼事情的話，其實你也大概知道這兩者背後的運作原理了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Microtasks &amp; Marcotask</title>
    <url>/JavaScript/JavaScript-Microtasks-Marcotask/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>
前陣子我們介紹到事件循環（Event Loop）以及任務隊列（Job Queue），使我們更加瞭解 JavaScript 中非同步（Asynchronous）的運作知識，然而並非所有的非同步事件都是排在同一個隊伍裡……

<a id="more"></a>

<h1 id="Microtasks-amp-Marcotask"><a href="#Microtasks-amp-Marcotask" class="headerlink" title="Microtasks &amp; Marcotask"></a>Microtasks &amp; Marcotask</h1><p>之前我們理解到非同步事件會經由 Web API 依照各自的做法（如： <code>setTimeoue</code> 需靠 <code>Timer</code> 檢查），之後才排入任務隊列（Job Queue）中，然而任務隊列實際上還可以分為 <code>Marcotask</code> 與 <code>Mircotask</code> 兩個隊伍。</p>
<p>而各自會排入的事件大概可以分為：</p>
<ul>
<li>Marcotasks：<code>setTimeout</code>、<code>setInterval</code>、I/O、UI 渲染</li>
<li>Mircotasks：<code>Promises</code>、<code>MutationObserver</code></li>
</ul>
<p>在執行順序上 <code>Mircotasks</code> 是優於 <code>Marcotasks</code> 且會等到 <code>Mircotasks</code> 都執行完了才會回來檢查 <code>Marcotasks</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>

<p>執行完畢會顯示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'end'</span></span><br><span class="line"><span class="string">'Promise1'</span></span><br><span class="line"><span class="string">'Promise2'</span></span><br><span class="line"><span class="string">'setTimeout1'</span></span><br><span class="line"><span class="string">'setTimeout2'</span></span><br></pre></td></tr></table></figure>

<p>一步一步來看的話，程式應當會先執行同步的程式碼，因此依序直譯到最後一行時，會依序將 <code>start</code> 以及 <code>end</code> 拋出。</p>
<p>接著其他非同步的程式則會分派到不同的 <code>watcher</code> 待任務循環的輪詢。</p>
<p>其中 <code>Promise1</code>、<code>Promise2</code> 分到 <code>Mircotasks</code>， <code>setTimeout1</code>、<code>setTimeout2</code> 分到 <code>Marcotasks</code>。</p>
<p>等到主線程（main thread）執行完畢時，任務循環首先會去查看 <code>Mircotasks</code> 還有沒有事件，如果有就將之移入呼叫堆疊（Call Stack）中執行，直到 <code>Mircotasks</code> 沒有事件才去檢查 <code>Marcotasks</code>。</p>
<p>由此可知如果想要非同步事件盡早被解決的話可以使用會被分派於 <code>Mircotasks</code> 的寫法，如果想要避免非同步事件受到 <code>Mircotasks</code> 隊伍影響到其餘非同步事件則應盡量都使用 <code>Marcotasks</code> 方法。</p>
<h1 id="強迫寫成-Mircotasks-事件或-Marcotasks-事件的方法"><a href="#強迫寫成-Mircotasks-事件或-Marcotasks-事件的方法" class="headerlink" title="強迫寫成 Mircotasks 事件或 Marcotasks 事件的方法"></a>強迫寫成 Mircotasks 事件或 Marcotasks 事件的方法</h1><p>強迫寫成 Marcotasks 技巧其實很多人可能都有使用過了，那就是 <code>setTimeout(fn, 0)</code>。</p>
<p>透過 <code>setTimeout</code> 的特性讓內部的程式區塊可以拖延至主線程都執行完畢時再來執行內部的程式碼，例如需要龐大的計算時就可以以此來包裹。</p>
<p>而強迫寫成 Mircotask 這個可能就比較少人知道了，我們可以透過 <code>queueMicrotask(callback)</code> 來執行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">queueMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'這個回呼回被拋到 Mircotasks 隊列中'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'這個回呼回被拋到 Marcotasks 隊列中'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>以上就是 Microtasks &amp; Marcotask 在瀏覽器上的概念，基本上事件循環（Event Loop）整體的概念到這裡已經算是一個尾端了，每個部份當然可以更加的深究，不過與產出的結果可以說是以達到相近不遠的程度了，若有興趣的可以再深究下去，一起來討論！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Variable Object &amp; Activation Object</title>
    <url>/JavaScript/JavaScript-Variable-Object-and-Activation-Object/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>理解變數物件（Variable Object，簡稱 VO）與執行物件（Activation Object）的概念對於理解作用域（Scope）、提升（Hoisting）、垃圾回收機制（Garbage collection）、閉包（Closure）與執行環境（Execution context）等等至關重要。</p>
<p>究竟變數物件到底指的是什麼？為何理解它會可以快速打通任督二脈？就讓我們一來看看它吧！</p>
<a id="more"></a>

<p>根據 ECMA <a href="https://www.ecma-international.org/archive/ecmascript/1999/TC39WG/990220-es2_func.pdf" target="_blank" rel="noopener">10.1.3 Variable Instantiation</a> 對於 Variable Object 的解釋：</p>
<blockquote>
<p>Every execution context has associated with it a variable object.<br>Variables and functions declared in the source text are added as properties of the variable object.<br>For function, anonymous, and implementation-supplied code, parameters are added as properties of the variable object.</p>
</blockquote>
<p>也就是說每個執行環境都會包含著一個變數物件（Variable Object），而執行函式等所創造出來的執行環境中，則會把參數（parameters）也加進去變數物件中，也就是活化（Acativation Object）</p>
<p>用物件來表示的話，全域變數物件大概就像這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GlobalExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  variableObject: &#123;</span><br><span class="line">    a: <span class="literal">undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而執行物件僅僅就是多了參數的變數物件版本：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FunctionExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  activationObject: &#123;</span><br><span class="line">    argument: []</span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: activationObject + [[scope]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中變數物件大致上會包含了三樣描述：</p>
<ul>
<li>phase：用來描述變數物件所處的階段。</li>
<li>variableObject、activationObject：初始化變數的值會存放在這，而函式的執行物件則多了 <code>argument</code>。</li>
<li>scopeChain：作用域鏈，用來理解作用域的關鍵（詳見 Scope 一文）</li>
</ul>
<h1 id="Phase"><a href="#Phase" class="headerlink" title="Phase"></a>Phase</h1><p>當每個執行環境（Execution Context）剛執行時，這裡的階段會被標為初始化，當下該環境中需要初始化的變數會被初始化為 <code>undefined</code>，若有函式則會將其移入為值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(x,y)</span><br></pre></td></tr></table></figure>

<p>對於全域的執行環境來說，一開始初始化階段會長得像這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GlobalExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  variableObject: &#123;</span><br><span class="line">    x: <span class="literal">undefined</span>,</span><br><span class="line">    y: <span class="literal">undefined</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123; <span class="keyword">return</span> a + b&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行到第一行 <code>let x = 1</code> 時，將 <code>x</code> 覆值 <code>1</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GlobalExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  variableObject: &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="literal">undefined</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123; <span class="keyword">return</span> a + b&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>後面依此類推。</p>
<p>我們可以發現初始化時最大的差別在於函式一開始就會被存入，因此宣告函式時我們可以在宣告前也能使用，而 <code>x</code>、<code>y</code> 變數則是要等到執行階段，執行到該行才會被覆值。</p>
<p>而在執行 <code>add</code> 函式所創建的執行環境中，一開始初始化階段會長得像這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  activationObject: &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">3</span>,</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="number">1</span>: <span class="number">3</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: activationObject + [[scope]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看見執行物件中會隱性的（implicit）將參數（paramemter）建立值，並且對於原先 <code>add(x,y)</code> 中的引數（arguments）建立了一個獨立的物件，這裡也是為什麼我們能透過函式的 <code>arguments</code> 取得引進來的數值。</p>
<p>以上是變數物件與執行物件的概念介紹，熟悉了這個之後再去看作用域就可以更快速理解作用域鏈（Scope Chain）所帶來的影響。（詳見 Scope 一文）</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://www.ecma-international.org/archive/ecmascript/1999/TC39WG/990220-es2_func.pdf" target="_blank" rel="noopener">10.1.3 Variable Instantiation</a></li>
<li><a href="https://github.com/SDLyu/JavaScript/blob/master/Core/Variable%20Object.md" target="_blank" rel="noopener">變數物件(Variable Object)</a></li>
<li><a href="https://wiki.jikexueyuan.com/project/javascript-depth-understanding/variable-object.html" target="_blank" rel="noopener">變數物件(Variable Object)</a></li>
<li><a href="http://notepad.yehyeh.net/Content/WebDesign/Javascript/ECMA/Core/JavaScriptCore.php#section7" target="_blank" rel="noopener">ECMA-262 Javascript核心</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 call by value（call by address）</title>
    <url>/JavaScript/JavaScript-call-by-value/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>


<p>最近經過一年的淬鍊再回頭看看有關於傳值這篇文<br><a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/" target="_blank" rel="noopener">https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/</a></p>
<p>我覺得 call by value(address) 的解釋法應該是最接近且一致的心理模型了，來分享一下我對 JavaScript 中賦值、存取與修改的看法。</p>
<a id="more"></a>

<p>我預設的心理模型：</p>
<ol>
<li>識別字（identity）存取資料時是靠記憶體地址，並不是值本身。</li>
<li>重新賦值時（reassign），無論資料型別，一率另開一個記憶體地址放入該值，並儲存該記憶體地址。</li>
<li>修改物件內容時，修改的目標是該記憶體地址內的值。</li>
<li>賦值一個識別字時，會透過儲存的記憶體地址找到值：<ul>
<li>若該值為原始數值（primitive value），則另開一個記憶體地址放入該值，並儲存該記憶體地址。</li>
<li>若該值為非原始數值（Non-primitive value），則直接複製原先目標的記憶體地址。</li>
</ul>
</li>
</ol>
<p>接著以這個心理模型解釋以下幾種常見的狀況：</p>
<h1 id="若複製目標為原始數值並重新賦值："><a href="#若複製目標為原始數值並重新賦值：" class="headerlink" title="若複製目標為原始數值並重新賦值："></a>若複製目標為原始數值並重新賦值：</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> primitiveValue = <span class="number">1</span> <span class="comment">// 賦值一個記憶體地址（0x00）裡面放入 1</span></span><br><span class="line"><span class="keyword">var</span> copyPrimitiveValue = primitiveValue <span class="comment">// 從 primitiveValue 找到該記憶體地址（0x00）的值為 1，重新分配一個新的地址（0x01），並放入一個原始數值 1 進去（0x01）</span></span><br><span class="line"></span><br><span class="line">copyPrimitiveValue = <span class="number">2</span> <span class="comment">// 重新分配一個 0x02 的記憶體地址，而原先的 0x01 到時候會被瀏覽器記憶體清除機制標記掃除法（Mark-and-Sweep）清除。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(primitiveValue) <span class="comment">// 讀取 0x00 的值 =&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(copyPrimitiveValue) <span class="comment">// 讀取 0x02 的值 =&gt; 2</span></span><br></pre></td></tr></table></figure>

<h1 id="若複製目標為非原始數值並重新賦值："><a href="#若複製目標為非原始數值並重新賦值：" class="headerlink" title="若複製目標為非原始數值並重新賦值："></a>若複製目標為非原始數值並重新賦值：</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nonPrimitiveValue = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;  <span class="comment">// 賦值一個記憶體地址（0x00）裡面放入 &#123;a: 1&#125;</span></span><br><span class="line"><span class="keyword">var</span> copyNonPrimitiveValue = nonPrimitiveValue <span class="comment">// 從 nonPrimitiveValue 找到該記憶體地址（0x00）的值為 &#123;a: 1&#125;，發現為非原始數值，直接複製原先的地址（0x00）</span></span><br><span class="line"></span><br><span class="line">copyNonPrimitiveValue = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125; <span class="comment">// 重新分配一個 0x01 的記憶體地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nonPrimitiveValue) <span class="comment">// 讀取 0x00 的值 =&gt; &#123;a: 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(copyNonPrimitiveValue) <span class="comment">// 讀取 0x01 的值 =&gt; &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="若複製目標為非原始數值並修改："><a href="#若複製目標為非原始數值並修改：" class="headerlink" title="若複製目標為非原始數值並修改："></a>若複製目標為非原始數值並修改：</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nonPrimitiveValue = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;  <span class="comment">// 賦值一個記憶體地址（0x00）裡面放入 &#123;a: 1&#125;</span></span><br><span class="line"><span class="keyword">var</span> copyNonPrimitiveValue = nonPrimitiveValue <span class="comment">// 從 nonPrimitiveValue 找到該記憶體地址（0x00）的值為 &#123;a: 1&#125;，發現為非原始數值，直接複製原先的地址（0x00）</span></span><br><span class="line"></span><br><span class="line">copyNonPrimitiveValue.a = <span class="number">2</span> <span class="comment">// 這裡的 copyNonPrimitiveValue.a 屬於一種叫做 MemberExpression 的語法，因此它做的事情是先找到記憶體地址（0x00）中的 &#123;a: 1&#125;，在修改其中的 a 對應的 value 為 2。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nonPrimitiveValue) <span class="comment">// 讀取 0x00 的值 =&gt; &#123;a: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(copyNonPrimitiveValue) <span class="comment">// 讀取 0x00 的值 =&gt; &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="傳入函式中並重新賦值"><a href="#傳入函式中並重新賦值" class="headerlink" title="傳入函式中並重新賦值"></a>傳入函式中並重新賦值</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nonPrimitiveValue = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; <span class="comment">// (1.) 分配至 0x00，value 為 &#123;a: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reassign</span>(<span class="params">obj</span>) </span>&#123; <span class="comment">// (3.) 接收到 0x00</span></span><br><span class="line">  <span class="comment">// (4.) 在 JavaScript 創造期會隱性 assign obj 至 0x00 </span></span><br><span class="line">  obj = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125; <span class="comment">// (5.) 重新分配至 0x01</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reassign(nonPrimitiveValue) <span class="comment">// (2.) 傳入 0x00</span></span><br><span class="line"><span class="built_in">console</span>.log(nonPrimitiveValue) <span class="comment">// (6.) 讀取 0x00 =&gt; &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="傳入函式中並修改"><a href="#傳入函式中並修改" class="headerlink" title="傳入函式中並修改"></a>傳入函式中並修改</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nonPrimitiveValue = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; <span class="comment">// (1.) 分配至 0x00，value 為 &#123;a: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reassign</span>(<span class="params">obj</span>) </span>&#123; <span class="comment">// (3.) 接收到 0x00</span></span><br><span class="line">  <span class="comment">// (4.) 在 JavaScript 創造期會隱性 assign obj 至 0x00 </span></span><br><span class="line">  obj.a = <span class="number">2</span> <span class="comment">// (5.) 讀取 0x00 中的 &#123;a: 1&#125; 並將其中的 a 值修改為 2 =&gt; 0x00: &#123;a: 2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reassign(nonPrimitiveValue) <span class="comment">// (2.) 傳入 0x00</span></span><br><span class="line"><span class="built_in">console</span>.log(nonPrimitiveValue) <span class="comment">// (6.) 讀取 0x00 =&gt; &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>以上通通是用同個心理模型來解釋，所以我目前斷言 JavaScript 最主要是 call by value 而這個 value 指的是記憶體位置的部分。</p>
<p>而對於「賦值」為什麼會有情況原因在於「重新賦值」與「修改」的差別</p>
<ul>
<li>重新賦值（reassign）：給識別字（Identifer）一個新的記憶體地址</li>
<li>修改：從原先的記憶體地址中找到值再做修改，也就是物件成員表達式（MemberExpression）中的值。</li>
</ul>
<p>目前驗證的方法可以透過這個簡易的視覺化工具執行編譯分析，去觀察直接讀取識別字跟識別字成員的差別。</p>
<ul>
<li><a href="https://ui.dev/javascript-visualizer" target="_blank" rel="noopener">視覺化工具</a></li>
</ul>
<p>以上是我對於賦值、存取與修改的看法，也歡迎不同的意見來交流與驗證！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Callback Function 回呼函式</title>
    <url>/JavaScript/JavaScript-callback-function/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>回呼？回調？<br>Callback Function 到底 Call 了什麼東西回去？<br>就讓我們來瞭解回呼函式到底在做什麼吧！</p>
<a id="more"></a>

<h1 id="callback-function"><a href="#callback-function" class="headerlink" title="callback function"></a>callback function</h1><p>回呼函式（Callback Function）其實就是函式，只是一般都會定義<strong>某個函式為另一個函式的參數，當透過另一個函式呼叫該函式時</strong>，此時我們就可以說它是回呼函式。</p>
<p>比如我們從 <code>isbndb.com</code> 找到了一隻可以查閱書籍相關內容的 API，我們可以將其寫成下列函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBookInfo</span>(<span class="params">ISBN</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'https://api2.isbndb.com/book/'</span> + ISBN )</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// 這裡會回應一個 json 格式的書籍資料</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果我們想要取得書籍資料後做一些處理的話，直接寫在函式裡面就會難以重複利用，並且會副作用在裡面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBookInfo</span>(<span class="params">ISBN</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'https://api2.isbndb.com/book/'</span> + ISBN )</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在裡面對 responese 回來的資料做一些處理</span></span><br><span class="line">      <span class="comment">// 另外做了只有針對 ISBN 9862764414 的額外處理</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getBookInfo(<span class="string">'9862764414'</span>) <span class="comment">// 第一次沒問題</span></span><br><span class="line"></span><br><span class="line">getBookInfo(<span class="string">'986476246X'</span>) <span class="comment">// 糟了，是副作用，裡面的額外處理是我不想要的</span></span><br></pre></td></tr></table></figure>

<p>這時候我們可以將要處理的函式作為參數傳進去，使得取得資料的時候去呼叫這隻函式，接著就可以在使用函式的同時，同時定義好取到資料後要做什麼事情：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBookInfo</span>(<span class="params">ISBN, cb</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'https://api2.isbndb.com/book/'</span> + ISBN )</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> cb(res)) <span class="comment">// 執行 cb 參數，也就是我們使用函式時所定義的回呼函式。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getBookInfo(<span class="string">'9862764414'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 這裡可以寫取到 ISBN 9862764414 的資料後要做什麼事情</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">getBookInfo(<span class="string">'986476246X'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 現在可以各自做處理了！</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>從上面範例中可以看見，回呼函式輕鬆的將耦合降低了，我們將來要使用不同的 ISBN 取得書目資料時，我們不必再去更改 <code>getBookInfo</code> 函式裡的內容，而是在使用函式時可以自由的定義取到資料後要進行的處理！</p>
<h1 id="error-first"><a href="#error-first" class="headerlink" title="error first"></a>error first</h1><p>在上方的例子中我們可以看見我們只有定義了取得資料後的狀態，並沒有定義取得資料失敗的狀態，因此我們要在把錯誤狀態加進我們的回呼函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先不管 getBookInfo 內部的實作</span></span><br><span class="line"></span><br><span class="line">getBookInfo(<span class="string">'9862764414'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// x, y 應該要是什麼</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>從上面例子可以看到當我們在執行 <code>getBookInfo</code> 函式的回呼函式時，我們並無法知道 <code>x</code>、<code>y</code> 傳進來的參數代表什麼意思，此時如果要你選一個參數當判斷取得資料成功與否你會選擇哪個？</p>
<p>較好的做法其實是使用第一個參數來做判斷：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBookInfo</span>(<span class="params">ISBN, cb</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'https://api2.isbndb.com/book/'</span> + ISBN )</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> cb(<span class="literal">true</span>, err)) <span class="comment">// 如果取得失敗會執行這個函式</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> cb(<span class="literal">false</span>, res)) <span class="comment">// 如果取得成功會執行這個函式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getBookInfo(<span class="string">'9862764414'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 定義取得失敗後的做法，此時 res 可以回應錯誤的內容</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 定義取得成功後的做法，此時 res 可以回應成功的內容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>為什麼會是第一個參數呢？原因在於我們對於成功取得資料的與否這件事情是一定會遇到的，所以我們可以藉由放在第一個參數來減低不必要的參數使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getBookInfo(<span class="string">'9862764414'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, err</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 定義取得失敗後的做法，此時 res 可以回應錯誤的內容</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 定義取得成功後的做法，此時 res 可以回應成功的內容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面例子則是假如 callback function 第五個才是 err 處理，可以看見儘管我們只有要使用 <code>a</code> 參數與 <code>err</code> 處理，我們仍然要把其他參數列好列滿。</p>
<h1 id="callback-hell"><a href="#callback-hell" class="headerlink" title="callback hell"></a>callback hell</h1><p>當我們以為終於完成 Callback function 時，上忍告訴你事情沒有這麼簡單就結束，假如今天有一個狀況是有一連串的函式需要按順序執行時，你第一個可能會想到這麼做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  funcB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  funcC()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA()</span><br></pre></td></tr></table></figure>

<p>但你現在已經會回呼函式了，因此改寫成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  cb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  cb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA(        <span class="comment">// 執行完函式 A 時 callback 函式 B</span></span><br><span class="line">  funcB(      <span class="comment">// 執行完函式 B 時 callback 函式 C</span></span><br><span class="line">    funcC()</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>你不禁讚嘆自己如同 JavaScript 忍者一樣寫出低耦合的程式，如同一位上忍般解決了一個艱困的難題</p>
<p>直到當我們有多個順序需要執行時：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">funcA(</span><br><span class="line">  funcB(</span><br><span class="line">    funcC(</span><br><span class="line">      funcD(</span><br><span class="line">        funcE(</span><br><span class="line">          funcF(</span><br><span class="line">            funcG(</span><br><span class="line">              funcH(</span><br><span class="line">                funcI()</span><br><span class="line">              )</span><br><span class="line">            )</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>「此時你就可以看到著名的回呼地獄（Callback Hell），而且這還不含錯誤處理呢。」上忍如是說，「至於要怎麼解決，只能詳閱 Promise 一文」。</p>
<h1 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h1><ul>
<li><a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/callback.html" target="_blank" rel="noopener">Callback(回調)</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 This</title>
    <url>/JavaScript/JavaScript-this/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p><code>this</code> 可以在 JavaScript 當中可以說是比 <code>prototype</code> 還要更難懂的概念，但今天要來嘗試以簡潔的方式來說明 <code>this</code> 到底是誰。</p>
<a id="more"></a>

<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>簡單來講，<code>this</code> 依據的是 <strong>函式被呼叫的方式</strong>，而呼叫方式可分為：</p>
<ul>
<li>預設綁定：全域呼叫、呼叫當下參考沒有自物件的函式。</li>
<li>隱含綁定：呼叫當下參考自物件的函式。</li>
<li>被綁定的呼叫：使用 bind、call、apply。</li>
<li>箭頭函式的呼叫。</li>
<li>函式建構式的呼叫。</li>
</ul>
<h1 id="預設綁定、隱含綁定"><a href="#預設綁定、隱含綁定" class="headerlink" title="預設綁定、隱含綁定"></a>預設綁定、隱含綁定</h1><p>隱含綁定主要是依據 <strong>執行當下該行程式碼時有沒有參考物件</strong>，如果沒有參考物件預設則會自動綁定全域物件（在瀏覽器是 <code>window</code>，在 Node.js 是 <code>global</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  getX: getX <span class="comment">// 這裡單純指向上方的 getX 函式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getX() <span class="comment">// 10</span></span><br><span class="line">obj.getX() <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p><code>getX()</code> 該行並沒有參考物件才去呼叫，所以 <code>this</code> 自動綁定全域物件 window，最後找到的是 window.x 的 10</p>
<p>此外如果是嚴格模式（strict mode），如果採用預設綁定， <code>this</code> 將不會自動綁定全域物件，而是給予 <code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  getThis: getThis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getThis() <span class="comment">// undefined</span></span><br><span class="line">obj.getThis() <span class="comment">// obj 本身</span></span><br></pre></td></tr></table></figure>

<p>現在來嘗試看看複雜例子並且想一下答案是什麼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  getX: getX</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj.getX</span><br><span class="line"></span><br><span class="line">getX()      <span class="comment">// ?</span></span><br><span class="line">obj.getX()  <span class="comment">// ?</span></span><br><span class="line">obj2()      <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>getX()</code>：10，因為參考時純粹拿到了該函式並且執行。</p>
</blockquote>
<blockquote>
<p><code>obj.getX()</code> ：20，透過 obj 物件去尋找該方法並呼叫，所以是指向 obj，因此是 obj.x 的值。</p>
</blockquote>
<blockquote>
<p><code>obj2()</code>：10，這裡有個陷阱，實際上該行並沒有參考物件，而是透過一個已經指向 <code>getX</code> 函式的參考去呼叫的</p>
</blockquote>
<p>所以簡單的來說，最主要是專注在執行的該行即可，執行該行所產生的執行環境，<code>this</code> 就綁在它上面！</p>
<p>再來一題：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  getX: getX</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  x: <span class="number">30</span>,</span><br><span class="line">  getX: obj.getX</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = obj2.getX</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj4 = &#123;</span><br><span class="line">  x: <span class="number">40</span>,</span><br><span class="line">  getX: obj3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getX()      <span class="comment">// ?</span></span><br><span class="line">obj.getX()  <span class="comment">// ?</span></span><br><span class="line">obj2.getX() <span class="comment">// ?</span></span><br><span class="line">obj3()      <span class="comment">// ?</span></span><br><span class="line">obj4.getX() <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>getX()</code>：10，剛行沒參考自物件，所以 <code>this</code> 預設綁定在全域上。<br><code>obj.getX()</code> ：20，剛行參考自物件 <code>obj</code>，所以 <code>this</code> 預設綁定在 <code>obj</code> 上。<br><code>obj2.getX()</code>：30，剛行參考自物件 <code>obj2</code>，所以 <code>this</code> 預設綁定在 <code>obj2</code> 上。<br><code>obj3()</code>：10，剛行沒參考自物件，所以 <code>this</code> 預設綁定在全域上。<br><code>obj4.getX()</code>：40，剛行參考自物件 <code>obj4</code>，所以 <code>this</code> 預設綁定在 <code>obj4</code> 上。</p>
</blockquote>
<p>最後一題：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">30</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">    &#125;</span><br><span class="line">    inner()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getX()  <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>obj.getX()</code>：答案為 10。</p>
</blockquote>
<p>剛才說到了執行該行所產生的執行環境，<code>this</code> 就綁在它上面，所以最後 <code>console.log</code> 前所執行的函式是哪句？</p>
<p>如果你看成 <code>obj.getX()</code> ，理所當然的你就會不小心答出 <code>20</code>。</p>
<p>而其實最後執行 <code>console.log</code> 的函式是 <code>inner()</code>，而 <code>inner()</code> 該行並沒有參考其他物件，所以是預設綁定在全域中，也就是 <code>window</code>，因此答案是 <code>10</code>。</p>
<h2 id="預設綁定、隱含綁定實戰中的問題"><a href="#預設綁定、隱含綁定實戰中的問題" class="headerlink" title="預設綁定、隱含綁定實戰中的問題"></a>預設綁定、隱含綁定實戰中的問題</h2><p>有時候我們呼叫函式時不想使用當下的 <code>this</code> 而是想要外層的 <code>this</code> 怎麼辦？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">second</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">  &#125;,second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x:<span class="number">10</span>,</span><br><span class="line">  wait: wait</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.wait(<span class="number">1000</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>在上面這段程式中我們雖然最底下執行當下有參考到 <code>obj</code> 了，但 <code>wait</code> 函式中真正在執行 <code>console.log()</code> 前呼叫的是 <code>window.setTimeout</code> 這個函式，所以其實是參考了 <code>window</code> 這個全域物件並把 <code>this</code> 綁定給他，最後拋出 <code>window.x</code> 的值，也就是 <code>undefined</code>。</p>
<p>所以用 <code>console.log(this)</code> 檢查其實會像這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">second</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)       <span class="comment">// 這個會指向執行當下該行呼叫函式的物件，在這範例中會指向 obj</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)     <span class="comment">// 這個會指向 window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">  &#125;,second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x:<span class="number">10</span>,</span><br><span class="line">  wait: wait</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.wait(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>確認 <code>this</code> 的範疇後，我們就可以利用作用域的特性（找不到變數值會向外層找）來實現抓取外面的 <code>this</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">second</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span> <span class="comment">// obj</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x) <span class="comment">// window.x</span></span><br><span class="line">    <span class="built_in">console</span>.log(that.x) <span class="comment">// obj.x</span></span><br><span class="line">  &#125;,second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x:<span class="number">10</span>,</span><br><span class="line">  wait: wait</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.wait(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>至於那個 <code>that</code> 主要是用來儲存 <code>this</code> 指向用的，另外也有人會取名為 <code>self</code> 等等名稱。</p>
<p>如果這個方法還不喜歡的話，可以繼續往下看看其他綁定方法。</p>
<h1 id="強制綁定-bind、call、apply"><a href="#強制綁定-bind、call、apply" class="headerlink" title="強制綁定 bind、call、apply"></a>強制綁定 bind、call、apply</h1><p>除了上面這種預設綁定與隱含（implicit）綁定之外，接下來要介紹強制綁定的三種方法。</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><code>bind</code> 的用法主要是在呼叫時加上綁定 <code>this</code> 的物件對象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  x: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getX()              <span class="comment">// 10</span></span><br><span class="line">getX.bind(obj)()    <span class="comment">// 20</span></span><br><span class="line">getX.bind(obj2)()   <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>原本 <code>getX()</code> 執行到該行時會由於該行當下沒有去其他物件中尋找函式，所以會採預設綁定在 <code>window</code> 當中，但透過 <code>bind</code> 的綁定，我們可以在呼叫時將 <code>this</code> 指定給另一個物件，因而可以參考到不同的物件當中。</p>
<p>上面所提到的實戰的部分也可以用 <code>bind</code> 解決</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">second</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x) <span class="comment">// 10</span></span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>),second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x:<span class="number">10</span>,</span><br><span class="line">  wait: wait</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.wait(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>上面的程式範例中，我們透過 <code>bind</code> 綁定了 <code>setTimeout</code> 裡面的 <code>this</code>，因此每次呼叫 <code>wait</code> 時，裡面 <code>setTimeout</code> 中回呼函式內的 <code>this</code> 都會與外面相同了，而不會被 <code>window.setTimeout</code> 的 <code>window</code> 物件所影響到。</p>
<h2 id="call、apply"><a href="#call、apply" class="headerlink" title="call、apply"></a>call、apply</h2><p><code>call</code>、<code>apply</code> 的用法比較接近，差別在使用時會立即呼叫該函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params">num = <span class="number">0</span>, anotherNum = <span class="number">0</span></span>)</span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x + num + anotherNum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  getX: getX</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addX(<span class="number">1</span>, <span class="number">2</span>)              <span class="comment">// 13</span></span><br><span class="line">addX.call(obj, <span class="number">1</span>, <span class="number">2</span>)    <span class="comment">// 23</span></span><br><span class="line">addX.apply(obj, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>call()，第一個參數是要綁定 <code>this</code> 的物件，後續帶入參數是用逗號來區隔。</p>
</blockquote>
<blockquote>
<p>apply()，第一個參數也是綁定 <code>this</code> 的物件，但後續帶入參數是放在一個陣列當中。</p>
</blockquote>
<h1 id="箭頭函式的呼叫"><a href="#箭頭函式的呼叫" class="headerlink" title="箭頭函式的呼叫"></a>箭頭函式的呼叫</h1><p>箭頭函式（arrow function）本身並沒有 <code>this</code>，並且會遵循一般變數查找的邏輯來運作，因此在箭頭函式中的 <code>this</code> 如同綁定在<strong>函式宣告之處</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x) <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x) <span class="comment">// 10</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x) <span class="comment">// 20</span></span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  getX: getX</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getX()</span><br></pre></td></tr></table></figure>
<p>第一個 <code>setTimeout</code> 我們在上集已經討論過它是綁定到全域當中，所以最後會撈到 <code>window.x</code>。</p>
<p>然而第二個 <code>setTimeout</code> 中的回呼函式用了箭頭函式的寫法，因此在即時直譯的過程中在箭頭函式內是找不到 <code>this</code> 的，接著他會如同我們在找變數值所參考作用域的情況一樣，向外層作用域去尋找 <code>this</code>，最後在 <code>getX</code> 作用域找到了當下執行環境中的 <code>this</code>，也就是由 <code>obj.getX()</code> 所創造出來的 <code>this</code>。（如第一個 <code>console.log</code> 當下的作用域一樣）</p>
<p>現在我們便知道為何用在箭頭函式中的 <code>this</code> 如同綁定在<strong>函式宣告之處</strong>的這個由來了。</p>
<h2 id="箭頭函式的呼叫-in-嚴格模式"><a href="#箭頭函式的呼叫-in-嚴格模式" class="headerlink" title="箭頭函式的呼叫 in 嚴格模式"></a>箭頭函式的呼叫 in 嚴格模式</h2><p>箭頭函式中的 <code>this</code> 另一個值得一提的就是在嚴格模式下，以往嚴格模式是禁止預設綁定到全域當中，並且會給予 <code>undefined</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getX()    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>但如果是使用箭頭函式的話就沒有這個限制：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">var</span> getX = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getX()    <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<p>以上就是箭頭函式對於 <code>this</code> 的影響，最後再來談談個 <code>new</code>。</p>
<h1 id="new-的綁定"><a href="#new-的綁定" class="headerlink" title="new 的綁定"></a>new 的綁定</h1><p><code>new</code> 關鍵字主要是用來初始化函式建構式，而使用 <code>new</code> 的當下，<code>this</code> 就會綁定在對應的物件上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'apple'</span>)    <span class="comment">// &#123;name: "apple"&#125;</span></span><br><span class="line"><span class="keyword">var</span> banana = <span class="keyword">new</span> Fruit(<span class="string">'Banana'</span>)  <span class="comment">// &#123;name: "Banana"&#125;</span></span><br><span class="line"></span><br><span class="line">Fruit(<span class="string">'nothing'</span>) <span class="comment">// window.name =&gt; nothing</span></span><br></pre></td></tr></table></figure>

<p>雖然不是很完整，到這邊為止 <code>this</code> 的觀念已經可以解決大部分一般的 <code>this</code> 問題了。</p>
<blockquote>
<p>如果還想繼續深究 <code>this</code> 的話我只能推這篇<a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">文章</a>了</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 prototype</title>
    <url>/JavaScript/JavaScript-prototype/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p><code>prototype</code> 一直是個 JavaScript 核心裡面最難以解釋的概念，因為光是提到 <code>prototype</code>，就不得不提相關的概念：<code>constructor</code>、<code>__proto__</code>、<code>Function.prototype</code>、<code>Object.prototype</code> ……等等，所以等了一段時間我覺得是時候來講講他了。</p>
<a id="more"></a>


<p>要說為什麼會有 <code>prototype</code> 的出現其實需要考究到當時開發 <code>JavaScript</code> 的創造者 <strong>Brendan Eich</strong> 說起。</p>
<p>在 20 年代初期的瀏覽器當中，一開始使用者並沒有與客戶端（client side）互動的能力，頂多就是用來瀏覽與點擊各種連結的工具，假設有表單要使用者去輸入，發送時也僅能在伺服器端（server side）去做欄位檢查。</p>
<p>而當時對於使用撥接數據機上網的，也就是開起來會「嘰－－嘟嘟嘟嚕－－唰唰唰唰」的年代來說，這樣的體驗並不是很好，因為當時可是連開個頁面都要跑個一兩分鐘以上，當你填好表單結果等了一段時間伺服器才跟你說哪個欄位缺少資訊或錯誤，這種使用者體驗並不是很好。</p>
<blockquote>
<p>那要怎麼辦呢？</p>
</blockquote>
<p>在當時網景公司（Netscape）便想要改善這種很鳥的體驗，他們需要一種可以立刻跟使用者有互動的語言，所以便派了工程師去開發一套語言來做這件事情，沒錯，那個人就是 <strong>Brendan Eich</strong>。</p>
<p>當然 <code>JavaScript</code> 的命名與 <code>Java</code> 之間的關係並不在這篇的討論範圍內，因為我們要來討論 <code>JavaScript</code> 為何會有 <code>prototype</code> 的這件事：</p>
<p>首先 <code>JavaScript</code> 一開始設計理念就是 <strong>不要太複雜</strong>，而在當年程式語言正流行著物件導向設計（oriented），所以在 <strong>JavaScript</strong> 所有的東西都是物件。</p>
<p>如今，我們可以透過 <code>new</code> 關鍵字來透過函式建構式（constructor）建立一個實體物件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I love '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"><span class="keyword">var</span> banana = <span class="keyword">new</span> Fruit(<span class="string">'Banana'</span>)</span><br><span class="line">apple.log() <span class="comment">// I love Apple.</span></span><br><span class="line">banana.log() <span class="comment">// I love Banana.</span></span><br></pre></td></tr></table></figure>
<p>我們可以由上方例子看到 <code>apple</code> 與 <code>banana</code> 雖然都是使用 <code>Fruit</code> 這個建構式所創造出來的物件，但裡面的 <code>log</code> 方法其實是一樣的用法，我們並不需要每次初始化時都建立一個這個函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(apple) <span class="comment">// &#123; name: 'Apple', log: function()&#123; console.log('I love ' + this.name + '.') &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(banana) <span class="comment">// &#123; name: 'banana', log: function()&#123; console.log('I love ' + this.name + '.') &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>假如我要更改其中一個實體中的 <code>log</code> 函式，因為物件指向不同的地方，所以我得一個一個做更改，這時候我們就可以藉由 <code>prototype</code> 來解決這個問題。</p>
<h1 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h1><p><code>prototype</code> 的功用很簡單，其實就是幫助我們將要繼承的方法從建構式中抽離出來：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fruit.prototype.log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I love '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"><span class="keyword">var</span> banana = <span class="keyword">new</span> Fruit(<span class="string">'Banana'</span>)</span><br><span class="line">apple.log() <span class="comment">// I love Apple.</span></span><br><span class="line">banana.log() <span class="comment">// I love Banana.</span></span><br></pre></td></tr></table></figure>

<p>我們可以看見 <code>apple</code> 與 <code>banana</code> 依然能使用 <code>log</code> 方法，但我們來檢查一下他們本身：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(apple) <span class="comment">// &#123; name: 'Apple' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(banana) <span class="comment">// &#123; name: 'banana' &#125;</span></span><br></pre></td></tr></table></figure>

<p>不…不…不見了？</p>
<p>對於物件存取很熟悉的我們都知道用了點標示法存取物件內的東西應該要在物件內阿，可是怎麼在物件中找不到 <code>log</code> 的存在？</p>
<p>而這一切原來就是 <code>__proto__</code> 搞的鬼。</p>
<h1 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h1><p><code>__proto__</code> 這個東西主要就是用來指向繼承的物件是誰，而效果簡單來說就是當你在當下物件中尋找不到某個方法（methods）時，就會循著這 <code>__proto__</code> 去尋找，直到找到 <code>Object.prototype</code> 中的 <code>__proto__</code> 為止（因為該值為 <code>null</code>，意思即是沒有繼承的物件了）。</p>
<p>所以回過頭來看剛才範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fruit.prototype.log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I love '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"></span><br><span class="line">apple.log() <span class="comment">// I love Apple.</span></span><br><span class="line"><span class="built_in">console</span>.log(apple) <span class="comment">// &#123; name: 'Apple' &#125;</span></span><br></pre></td></tr></table></figure>

<p>對於 <code>apple</code> 來說 <code>apple.__proto__</code> 會尋找到 <code>Fruit.prototype</code> 當中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">apple.__proto__ === Fruit.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因此我們透過 <code>apple.__proto__</code> 在 <code>Fruit</code> 物件裡面找到這個方法並且呼叫他。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Fruit) </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  log: function() &#123; console.log('I love ' + this.name + '.') &#125;,</span></span><br><span class="line"><span class="comment">  constructor: function Fruit(name) &#123; this.name = name &#125;</span></span><br><span class="line"><span class="comment">  __proto__: Function.prototype</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>假如我們要使用連在 <code>Fruit</code> 物件中都沒有的方法，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"></span><br><span class="line">apple.toString()</span><br></pre></td></tr></table></figure>

<p>現在我們知道透過 <code>apple.__proto__</code> 找到 <code>Fruit.prototype</code>，但裡面也沒有，所以又沿著 <code>Fruit.prototype.__proto__</code>，找到了 <code>Function.prototype</code> 裡的方法 <code>toString()</code>。</p>
<p>用 JavaScript 來表示的話，其實我們是呼叫到了 <code>apple.__proto__.__proto__.toString()</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">apple.toString() === apple.__proto__.__proto__.toString() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>而 <code>__proto__</code> 之間的連結也就是所謂的原型鍊（prototype chain）。</p>
<p>值得一提的是：</p>
<ul>
<li>所有物件 <code>__proto__</code> 最後會找到的是 <code>Object.prototype.__proto__</code> 中的 <code>null</code>，表示再也找不到所繼承的物件。</li>
<li>如果方法名稱相同，比如剛才的 <code>Fruit</code> 物件中也有個 <code>toString</code> 方法，則在找到 <code>Object.prototype.toString</code> 之前就會先找到 <code>Fruit.prototype.toString</code>。</li>
</ul>
<h1 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h1><p>但這樣我們要怎麼確認該方法是該物件實體本來的方法，還是透過原型鍊所找到的方法呢？<br>除了我們剛剛用 <code>console.log</code> 直接將 <code>apple</code> 整個叫出來看之外，我們其實可以透過 <code>hasOwnProperty</code> 來確認：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fruit.prototype.log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I love '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(apple) <span class="comment">// &#123; name: 'Apple' &#125;</span></span><br><span class="line">apple.hasOwnProperty(<span class="string">'log'</span>) <span class="comment">// false，log 方法並沒有存在實體中</span></span><br><span class="line">apple.__proto__.hasOwnProperty(<span class="string">'log'</span>) <span class="comment">// true，log 方法是存在 prototype 當中</span></span><br></pre></td></tr></table></figure>


<h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>在 <code>prototype</code> 中我們可以看到除了有物件的方法與 <code>__proto__</code> 之外，裡面還有一個 <code>constructor</code>，而這個 <code>constructor</code> 其實也就是代表建構函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.constructor) <span class="comment">// function Fruit(name) &#123; this.name = name &#125;</span></span><br></pre></td></tr></table></figure>

<p>現在有整體原型鍊的概念了，我們現在看看 <code>new</code> 做了什麼</p>
<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p><code>new</code> 關鍵字在初始化物件時，做的動作其實就是：</p>
<ul>
<li>建立一個物件</li>
<li>將該物件的 <code>__proto__</code> 指向該函式建構式（constructor）的 <code>prototype</code></li>
<li>呼叫物件中的建構函式（constructor）</li>
<li>把物件回傳（所以我們才能用變數接這個物件）。</li>
</ul>
<p>最後我們要來比較一下初始化物件之間的關係。</p>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p><code>instnaceof</code> 簡單來說就是比較該實體與被比較的關聯式不是在同個原型鍊上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"><span class="keyword">var</span> shawn = <span class="keyword">new</span> Person(<span class="string">'Shawn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple <span class="keyword">instanceof</span> Fruit)   <span class="comment">// true，apple 是由 Fruit 所初始化的物件實體</span></span><br><span class="line"><span class="built_in">console</span>.log(shawn <span class="keyword">instanceof</span> Person)  <span class="comment">// true，shawn 是由 Person 所初始化的物件實體</span></span><br><span class="line"><span class="built_in">console</span>.log(apple <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">// true，apple 是由 Fruit 所初始化的物件實體，且 Fruit 物件本身是繼承於 Object 物件</span></span><br><span class="line"><span class="built_in">console</span>.log(shawn <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">// true，shawn 是由 Person 所初始化的物件實體，且 Person 物件本身是繼承於 Object 物件</span></span><br><span class="line"><span class="built_in">console</span>.log(Fruit <span class="keyword">instanceof</span> Person)   <span class="comment">// false，Fruit 並不繼承於 Person</span></span><br><span class="line"><span class="built_in">console</span>.log(Person <span class="keyword">instanceof</span> Fruit)   <span class="comment">// false，Person 並不繼承於 Fruit</span></span><br></pre></td></tr></table></figure>

<p>以上就是基礎的 <code>prototype</code> 的概念！</p>
<p>（其實還有更多細微的可以講，但一起弄懂可能大家都昏了，我們就慢慢提吧 XD）</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>程式設計心法 避免重複原則（DRY principle）</title>
    <url>/Methodology/Methodology-001-DRY-principle/</url>
    <content><![CDATA[<h1 id="DRY-原則"><a href="#DRY-原則" class="headerlink" title="DRY 原則"></a>DRY 原則</h1><p>這次要來介紹的是我覺得開發程式中最有感的<strong>避免重複原則</strong>（簡稱 DRY 原則，意思即為 Don’t repeat youself!）。</p>
<p>根據此篇<a href="https://www.sharmaprakash.com.np/four-types-of-duplication-in-source-code/#" target="_blank" rel="noopener">文章</a>所述，在 The Pragmatic Programmer 一書中，DRY 發生的原因總共可以分為四種類別：</p>
<ul>
<li>強加的重複(Imposed duplication)</li>
<li>無意的重複(inadvertent duplication)</li>
<li>懶惰的重複(impatient duplication)</li>
<li>開發者間的重複(inter-developer duplication)：</li>
</ul>
<p>以下是四種類別所表示的意義：</p>
<a id="more"></a>

<h2 id="強加的重複-Imposed-duplication"><a href="#強加的重複-Imposed-duplication" class="headerlink" title="強加的重複 Imposed duplication"></a>強加的重複 Imposed duplication</h2><p>這一類的重複是發生在開發者自認為是<strong>開發環境需要</strong>的、被強迫需要的重複，像是<strong>不必要的註解</strong>以及<strong>開發文件</strong>等等。</p>
<p>例如我們寫了一些有關 cookie 用的函式，並為其加上了使用註解，但其實從函式名稱本身就能夠得知其用途：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 這是用來取得 cookie 值的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span> (<span class="params">cname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="string">"; "</span> + <span class="built_in">document</span>.cookie</span><br><span class="line">    <span class="keyword">let</span> parts = value.split(<span class="string">"; "</span> + cname + <span class="string">"="</span>)</span><br><span class="line">    <span class="keyword">if</span> (parts.length == <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> parts.pop().split(<span class="string">";"</span>).shift()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這是用來設定 cookie 值的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span> (<span class="params">cname, cvalue, exdays</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    d.setTime(d.getTime() + (exdays*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>))</span><br><span class="line">    <span class="keyword">let</span> expires = <span class="string">`expires=<span class="subst">$&#123;d.toUTCString()&#125;</span>`</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.cookie = <span class="string">`<span class="subst">$&#123;cname&#125;</span>=<span class="subst">$&#123;cvalue&#125;</span>;<span class="subst">$&#123;expires&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一例則是撰寫開發文件上沒有即時更新的結果，使註解變成多餘；即便是撰寫文檔也與程式中的內容重疊：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* get member data via Number type Member ID.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>id member ID</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;object&#125;</span> </span>member data.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMemberData</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 結果裡面的處理後來需要使用到 Number 類型的 id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>個人認為對於此分類的解決辦法便是使用<strong>清晰可辨別的命名</strong>，註解與文檔在非必要下的情況可以透過命名的方式來解決，例如第一例已經很清楚地寫出該函式的作用，就不必再重複註解；而若是使用函式的 jsDoc 註解，則應該注意內部邏輯，讓程式<strong>本身敘述正在做的事情</strong>會來得更有效率。</p>
<h2 id="無意的重複-inadvertent-duplication"><a href="#無意的重複-inadvertent-duplication" class="headerlink" title="無意的重複 inadvertent duplication"></a>無意的重複 inadvertent duplication</h2><p>第二類是屬於開發者沒有意識到內容上的重複，通常出現在<strong>邏輯設計上</strong>的內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cube</span>(<span class="params">length, width, height, volumn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.length = length</span><br><span class="line">  <span class="keyword">this</span>.width = width</span><br><span class="line">  <span class="keyword">this</span>.height = height</span><br><span class="line">  <span class="keyword">this</span>.volumn = volumn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cube.prototype.getVolumn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.volumn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sixCMcube = <span class="keyword">new</span> Cube(<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>)</span><br><span class="line">sixCMcube.getVolumn()</span><br></pre></td></tr></table></figure>

<p>在這個例子中，首先我們已知 Cube（立方體）長寬高都一樣的情況下，只要給一個邊長（length）即可；除此之外 volumn（體積）其實也就是邊長的三次方，可以由建構式內部算完即可，不應該使其成為公共變數（public variable），因此更改後如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cube</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.length = length</span><br><span class="line">  <span class="keyword">this</span>.volumn = <span class="built_in">Math</span>.pow(length, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cube.prototype.getVolumn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.volumn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sixCMcube = <span class="keyword">new</span> Cube(<span class="number">6</span>)</span><br><span class="line">sixCMcube.getVolumn()</span><br></pre></td></tr></table></figure>

<h2 id="懶惰的重複-impatient-duplication"><a href="#懶惰的重複-impatient-duplication" class="headerlink" title="懶惰的重複 impatient duplication"></a>懶惰的重複 impatient duplication</h2><p>開發者為了節省時間上的重複，可能發生在使用 CV （複製貼上）大法的時候，尤其複製的程式碼量一大的時候，很有可能遺漏某些需要更改的東西。例如在實作多欄位的搜尋表單，有時候只是值上的替換，其程式碼模樣大同小異，就很有可能在複製貼上完後，忘記更改某個表單欄位的 id 值等等。</p>
<p>個人解決辦法是撰寫測試程式碼或模擬（Mock）程式碼，例如單元測試（Unit test）來觀測各函式的結果是否符合預期結果；如此一來可以節省打斷點、寫 <code>console.log</code> 的時間又能同時日後對於維護程式碼的信心度。</p>
<h2 id="開發者間的重複-inter-developer-duplication"><a href="#開發者間的重複-inter-developer-duplication" class="headerlink" title="開發者間的重複 inter-developer duplication"></a>開發者間的重複 inter-developer duplication</h2><p>最難解決也最常發生的重複議題，通常發生在開發者與開發者之間的<del>決鬥</del> 協作開發或接手開發的時候，因為在同個專案底下很容易有共同的需求，有時候沒有協調好或是接手專案對於架構不清楚時，容易開發出概念上重複的程式碼。</p>
<p>最簡單的例子就如同上面第一則 <code>cookie</code> 實作的函式一樣，有可能前人開發時已經有實作 <code>cookie</code> 的 <code>get</code>、<code>set</code> 與 <code>delete</code> 等方法，然後自己又實作了一次相關的方法。</p>
<h1 id="實行-DRY-時的危險之處？"><a href="#實行-DRY-時的危險之處？" class="headerlink" title="實行 DRY 時的危險之處？"></a>實行 DRY 時的危險之處？</h1><p>在遵循 DRY 原則的時候，有時得適度的拿捏這個原則的比例，避免有時為了避免 DRY 而<strong>過度抽象化（Abstraction）</strong>了某個函式的概念，反而犧牲了<strong>可讀性（readability）</strong>。因為就本質上來說其實抽象化與可讀性來說是<strong>矛盾的</strong>概念。因為我們需要抽象來簡化、避免重複程式碼，但同時我們也得兼顧程式碼的易讀性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">symbolParser</span> (<span class="params">source = <span class="string">''</span>, splitSymbol = <span class="string">'/'</span>, filterSymbol = <span class="string">'_'</span>, reverseParseResult = false</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> parseStorage = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> reverseResult = reverseParseResult ? [<span class="number">0</span>,<span class="number">1</span>] : [<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    source</span><br><span class="line">        .split(<span class="string">' '</span>)</span><br><span class="line">        .join(<span class="string">''</span>)</span><br><span class="line">        .split(splitSymbol)</span><br><span class="line">        .filter(<span class="function"><span class="params">req</span> =&gt;</span> req.indexOf(filterSymbol) &gt; <span class="number">-1</span>)</span><br><span class="line">        .forEach(<span class="function"><span class="params">req</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> parse = req.split(filterSymbol)</span><br><span class="line">            parseStorage[parse[reverseResult[<span class="number">0</span>]]] = parse[reverseResult[<span class="number">1</span>]]</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> parseStorage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">'firstname=Shawn&amp;lastname=Lin&amp;Age=25'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> textAfterParse = symbolParser(text, <span class="string">'&amp;'</span>, <span class="string">'='</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(textAfterParse)     <span class="comment">// return &#123;firstname: 'Shawn', lastname: 'Lin', Age: "25"&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>雖然這個函式可以應變不同種的字串（如 url 中的 parameter 或 cookie 中的值）並返回其物件形式，使在解析字串上達到了 DRY 原則，只要解析字串就用這個函式便能快速完成！<br>但是當函式有狀況需要更改調整的時候，能夠使其他開發者能<strong>快速的看出各個實作處理是為什麼要這麼做嗎？</strong></p>
</blockquote>
<p>另一個危險的開端則是類似於<strong>過早最佳化原則（premature-optimization）</strong>所提到的概念。在發生 DRY 的時候，我們可能會忍受不住 DRY 的原則，看到重複就忍不住想改動、優化，但是<strong>真的每次都有達到重複的涵義嗎？</strong></p>
<p>以上方的例子來說，我們有沒有必要使用<strong>同一隻函式</strong>來解決這種解析的需求？針對 <code>cookies</code> 時，使用前面提到的 <code>getCookie</code>、<code>setCookie</code> 會不會更加的容易閱讀？使用了 <code>symbolParser</code> 函式得到了含有全部 <code>cookie</code> 的值時，是否還要再實作寫入 <code>cookies</code> 的函式？諸如此類的問題會在<strong>死命奉守 DRY 原則</strong>時陸續出現，而我們應當使我們的程式保有彈性與自由，才不會因 DRY 而被過度局限於某些情境下。</p>
<p>因此，在遵循 DRY 心法時，仍別忘了考量到避免<strong>過度抽象化（over-abstraction）</strong>與<strong>過早最佳化（premature-optimization）</strong>等議題；適度抽象、適度避免 DRY，最後優化的部分等後續維護時真的出現問題再來解決吧！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://www.itread01.com/p/1318618.html" target="_blank" rel="noopener">優秀程式設計的原則</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/01/abstraction_principles.html" target="_blank" rel="noopener">代码的抽象三原则</a></li>
<li><a href="https://www.cnblogs.com/zhixin9001/p/6777608.html" target="_blank" rel="noopener">《程序员修炼之道》笔记(二)</a></li>
<li><a href="http://www.rocidea.com/one?id=33839" target="_blank" rel="noopener">DRY原則的誤區</a></li>
<li><a href="https://stackoverflow.com/questions/17788738/is-violation-of-dry-principle-always-bad" target="_blank" rel="noopener">Is violation of DRY principle always bad?</a></li>
</ul>
]]></content>
      <categories>
        <category>Methodology</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Methodology</tag>
      </tags>
  </entry>
  <entry>
    <title>程式設計心法 簡單原則（KISS principle）</title>
    <url>/Methodology/Methodology-002-Kiss-principle/</url>
    <content><![CDATA[<h1 id="KISS-原則"><a href="#KISS-原則" class="headerlink" title="KISS 原則"></a>KISS 原則</h1><p>繼上次避免<strong>重複原則</strong>（DRY principle）後這次要來介紹的程式三大開發原則之一的<strong>簡單原則</strong>（簡稱 KISS 原則，即為 Keep it simple and stupid.）。</p>
<p>這個開發原則在古文中早已有驗證，在老子《道德經》之中，有句話叫做「萬物之始，大道至簡，演化至繁。」意思簡單來說就是任何事物之中，一開始都是非常簡單而直白的，經過不斷演化之後，才到達繁的境界，而程式設計也理應如此。</p>
<p>而 KISS 原則追尋的便是那種<strong>大道至簡</strong>的精神。</p>
<p>那麼我們要如何追尋這個原則呢？</p>
<a id="more"></a>

<h1 id="KISS-實踐"><a href="#KISS-實踐" class="headerlink" title="KISS 實踐"></a>KISS 實踐</h1><p>在程式開發的過程中，我們時常會針對將來的擴充性與例外處理做一些防衛性措施，例如針對函式參數設想了一些情境：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name !== <span class="literal">undefined</span> &amp;&amp; name !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Anonymous'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">setName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name = setName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要使其更容易閱讀其實可以這麼寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Anonymous'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或是採用 ES6 的寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name = <span class="string">'Anonymous'</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在這個範例中我們可以看到簡化最後程式碼所想要表達的內容所帶來的效益，使程式碼變得更加的清晰。</p>
<h1 id="KISS-principle-amp-DRY-principle"><a href="#KISS-principle-amp-DRY-principle" class="headerlink" title="KISS principle &amp; DRY principle"></a>KISS principle &amp; DRY principle</h1><p>KISS 原則的誤區如同 DRY 原則一樣要避免<strong>過度抽象化（over-abstraction）</strong>與<strong>過早最佳化（premature-optimization）</strong>。</p>
<p>而 KISS 原則比起 DRY 原則就個人理解下，KISS 更偏向不要去預設任何立場並且稍微重複也有助於後續修改，而 DRY 則對各種意義上的重複概念比較注重；但兩種最終都還是得面向可讀性（readability）這道關卡，所以要適當的拿捏之間的尺度。</p>
<p>正所謂：</p>
<blockquote>
<p><em>“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”<br>「笨蛋都能寫出讓電腦看得懂的程式碼，只有優秀的程式開發者能寫出讓人看得懂的程式碼。」<br>-Martin Fowler</em></p>
</blockquote>
<p>一個良好的程式碼應該可以使其他開發者<strong>容易維護</strong>並且<strong>容易閱讀</strong>，多餘的預設立場只會<strong>限制後續的開發</strong>。</p>
<p>這也是為什麼多半 KISS 原則與 DRY 原則通常會與 YAGNI 原則放在一起討論的原因。</p>
<p>而 YAGNI 原則又是什麼呢？請待下回分曉。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://kknews.cc/zh-tw/home/8q5jj5e.html" target="_blank" rel="noopener">你不得不知的KISS原則（三大軟體原則之一）</a></li>
<li><a href="https://ihower.tw/blog/archives/7181" target="_blank" rel="noopener">Kent Beck 的四個簡單程式設計原則</a></li>
</ul>
]]></content>
      <categories>
        <category>Methodology</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Methodology</tag>
      </tags>
  </entry>
  <entry>
    <title>程式設計心法 你不會需要它（YAGNI principle）</title>
    <url>/Methodology/Methodology-003-YAGNI-principle/</url>
    <content><![CDATA[<h1 id="YAGNI-原則"><a href="#YAGNI-原則" class="headerlink" title="YAGNI 原則"></a>YAGNI 原則</h1><p>繼 DRY 原則與 KISS 原則之後，最常被並列再一起討論的非 YAGNI 原則莫屬了，而 YAGNI 原則（You aren’t gonna need it），顧名思義為你不會需要它。但到底程式設計中我們會不需要什麼呢？</p>
<p>仔細回想一下，有沒有曾經在開發過程中為了預先擴充某樣功能而撰寫程式碼的經驗？</p>
<p>最終那些為了擴充的程式碼最後有真的派上用場還是就默默冷落在角落成為雞肋的存在？</p>
<p>抑或是派上了用場但與當初所預設的規格有所不同？</p>
<p>對於 YAGNI 原則來說，這些都是應該自己盡量避免的，而幾個可以達到 YAGNI 原則的概念：</p>
<a id="more"></a>

<ul>
<li>專注在實現專案文件中需求的功能</li>
<li>不要過早優化程式碼</li>
<li>不要替未來的功能預設立場，去撰寫用不到的程式碼</li>
</ul>
<h1 id="為何需要-YAGNI-原則"><a href="#為何需要-YAGNI-原則" class="headerlink" title="為何需要 YAGNI 原則?"></a>為何需要 YAGNI 原則?</h1><p>對於專案實務上來說，這些預設立場的功能並沒有辦法在專案上實際運用，很有可能自己猜想覺得完美無缺，但實際真的運用時會有沒想到的例外處理。即便是寫了單元測試（Unit testing）去細心維護這些擴充的功能，在將來也很有可能因為<strong>文件規格的改動</strong>使得這些擴充的功能並<strong>不符合預期</strong>效益。</p>
<p>另一點則是對於<strong>人員的調動</strong>與<strong>接手維護</strong>上的問題，當今年這個專案移交給其他人維護時，其他開發人員很有可能<strong>不清楚該段程式碼的想法</strong>，將原意可能良好的設計，<strong>突變（Mutate）了原本的設計，導致概念更加的混亂</strong>。除此之外，預設了越多立場程式碼也會對於後續維護的人在閱讀程式碼時得<strong>花上額外的心力</strong>，才能辨別該段程式碼中的原意。到頭來，還不如一開始留的乾淨直白，<strong>等到需要的時候</strong>，才真正地將原有不符合規格的程式重構（refacting）。</p>
<p>而對於<strong>實務經驗</strong>不多的 Junior 開發者來說，預先立場更是一件可怕的事情，由於實務經驗不多，對於功能將來擴充的方向不明，而做了多不必要的功能，甚至限制了該功能在將來的彈性，再加上針對不必要的功能所進行的防禦性與邊界處理等等，就會產生出更大量沒有必要的程式。</p>
<h1 id="YAGNI-的隱憂"><a href="#YAGNI-的隱憂" class="headerlink" title="YAGNI 的隱憂"></a>YAGNI 的隱憂</h1><p>因為每個開發環節關注的點不同，雷點也不盡相同，究竟要保留彈性到什麼樣的程度對於開發者來說是一個很艱困的難題。畢竟有些雷點即便是我們都聽過，但沒有親自踩過、痛過的經驗，有時候是難以體會的，而這部份真的只能依靠實務經驗來累積，所以除了上班寫的專案之外，下班後就靠 side project 來增加實務經驗吧！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://stackoverflow.com/questions/53595548/what-is-the-point-of-yagni-principle-applied-to-design-patterns" target="_blank" rel="noopener">What is the point of YAGNI principle applied to design patterns?</a></li>
<li><a href="https://www.itexico.com/blog/software-development-kiss-yagni-dry-3-principles-to-simplify-your-life" target="_blank" rel="noopener">KISS YAGNI &amp; DRY Principles | iTexico</a></li>
</ul>
]]></content>
      <categories>
        <category>Methodology</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Methodology</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Synchronous &amp; Asynchronous 同步與非同步</title>
    <url>/JavaScript/JavaScript-synchronous-and-asynchronous/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>在介紹同步（synchronous）與非同步（asynchronous）前一定要來破個題，那就是</p>
<p><strong>JavaScript</strong> 的執行期（runtime）一定是有按行數順序的即時編譯。</p>
<p>可是為何有時執行的函式會稍晚的時候才輸出、執行？</p>
<p>會有這個疑問就讓我們一起來認識認識什麼是同步與非同步吧！</p>
<a id="more"></a>

<p>每個 JavaScript 程式區塊在執行時的步驟可分為呼叫與得到回應，而簡單來說能立即得到回應結果的就是同步（Synchronous），不能立即得到回應的就是非同步（Asynchronous），也就是說同步與非同步辨認的方式可以透過會不會<strong>阻塞（blocking）主程式</strong>來判斷。</p>
<h1 id="Synchronous-同步"><a href="#Synchronous-同步" class="headerlink" title="Synchronous 同步"></a>Synchronous 同步</h1><p>同步的 JavaScript 函式最大的特色就是<strong>會阻塞</strong>主程式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> money = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'do something'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (money &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  money++</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'money'</span>, money)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'do another thing'</span>)</span><br></pre></td></tr></table></figure>

<p>你會發現控制台依序輸出了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'do something'</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">1</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">2</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">3</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">4</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">5</span></span><br><span class="line"><span class="string">'do another thing'</span></span><br></pre></td></tr></table></figure>

<p>這也是我們一般預期寫完程式該要有的順序，然而有時候會有不同的情況發生。</p>
<h1 id="Asynchronous-非同步"><a href="#Asynchronous-非同步" class="headerlink" title="Asynchronous 非同步"></a>Asynchronous 非同步</h1><p>非同步的 JavaScript 函式最大的特色就是<strong>不會阻塞</strong>主程式，</p>
<p>將上面程式碼範例以非同步的方法撰寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> money = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'do something'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (money &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    money++</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'money'</span>, money)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'do another thing'</span>)</span><br></pre></td></tr></table></figure>

<p>你會發現輸出的順序變成了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'do something'</span></span><br><span class="line"><span class="string">'do another thing'</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">1</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">2</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">3</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">4</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>現在你會知道了有同步跟非同步兩種寫法，但為何我們需要非同步，以及要怎麼寫非同步的函式呢？</p>
<h1 id="為何需要非同步？"><a href="#為何需要非同步？" class="headerlink" title="為何需要非同步？"></a>為何需要非同步？</h1><p>之所以在 JavaScript 中會需要使用到非同步的用法原因是 JavaScript 的執行期（runtime）本身是單執行緒（single thread）的，因此若在執行程式時遇到需要長時間執行的程式就會使整個 JavaScript 執行阻塞。</p>
<p>而藉任務循環（Event Loop）的機制，JavaScript 會將其函式交由任務序列（Task Queue）來處理，而一些比較常見被定義為非同步的函式如下：</p>
<ul>
<li><code>XMLHttpRequest</code>：預設採用非同步方式取得資料，它另外也提供同步的方式給需要的開發者。</li>
<li><code>fetch</code>：使用非同步的做法取得資料。</li>
<li><code>setTimeout</code>、<code>setInterval</code>：由於 JavaScript 本身沒有計時器，因此執行後會交由瀏覽器的計時器倒數，時間到了才回傳至任務序列（Task Queue）等待任務循環（Event Loop）機制將其傳入主線程。</li>
<li><code>promise</code></li>
</ul>
<h1 id="怎麼寫非同步的函式？"><a href="#怎麼寫非同步的函式？" class="headerlink" title="怎麼寫非同步的函式？"></a>怎麼寫非同步的函式？</h1><p><strong>JavaScript 工程師其實沒辦法自己定義非同步。</strong></p>
<p>沒錯，JavaScript 本身並沒有提供給你一個機制去定義，準確得來說是依照遵循 ECMA 的規則，由各瀏覽器去實作裡面的內容。</p>
<p>如果需要創建一個非同步的程式區塊，我們可以藉由原本就是被定義為非同步的函式搭配使用，而最快的方式就是 <code>setTimeout(fn, 0)</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'開始執行主程式'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'主程式執行完畢'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'再來執行一些東西吧！'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'處理主程式中'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'處理主程式中'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'處理主程式中'</span>)</span><br></pre></td></tr></table></figure>

<p>可以看見輸出結果為：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'開始執行主程式'</span></span><br><span class="line"><span class="string">'處理主程式中'</span></span><br><span class="line"><span class="string">'處理主程式中'</span></span><br><span class="line"><span class="string">'處理主程式中'</span></span><br><span class="line"><span class="string">'主程式執行完畢'</span></span><br><span class="line"><span class="string">'再來執行一些東西吧！'</span></span><br></pre></td></tr></table></figure>

<p>這裡重點在於 <code>setTimeout</code> 本身是非同步的，所以在 JavaScript 執行時期（runtime）中此程式區塊會先在瀏覽器中 API 中的 <code>Timer</code> 等候 <code>0</code> 秒，接著將其中的 callback function 排入任務隊列中，等待任務循環輪詢時執行。</p>
<p>另一個重點則是並非因為只需要等待 <code>0</code> 秒就會是同步的程式區塊。</p>
<p>如果需要更詳細的解釋可以參考：<br>詳見 回呼函式（Callback Function）一文<br>詳見 <code>Event Loop</code> 一文<br>詳見 <code>Promise</code> 一文<br>詳見 <code>Async</code> / <code>Await</code> 一文</p>
<h1 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h1><ul>
<li><a href="https://blog.huli.tw/2019/10/04/javascript-async-sync-and-callback/#sync" target="_blank" rel="noopener">JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest.js 入門、環境建置與範例（Install, Build environment）</title>
    <url>/Jest.js/Jest-001-intro/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="jest-logo" src='/images/Jest/jest-logo.png' width='200px' height='200px' />
</div>

<h1 id="What-is-Jest-js"><a href="#What-is-Jest-js" class="headerlink" title="What is Jest.js"></a>What is Jest.js</h1><p>Jest.js 是由 Facebook, Inc 公司所維護的測試框架，並且支援了 Babel、TypeScript、Node.js、Vue.js、React.js、Angular.js，基本上支援了全部的現代框架，而 Jest 的核心概念 <strong>batteries-included</strong>，使得我們在使用測試要找一些資源時不太需要費力，因為，Jest 都幫你準備好了！</p>
<a id="more"></a>

<h1 id="環境建置"><a href="#環境建置" class="headerlink" title="環境建置"></a>環境建置</h1><p>環境建置非常的快速，透過 npm 直接安裝 Jest 到 <strong>專案開發環境</strong> 下就完成了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev jest</span><br></pre></td></tr></table></figure>

<h1 id="測試範例"><a href="#測試範例" class="headerlink" title="測試範例"></a>測試範例</h1><p>在專案資料夾中直接新建一個 <code>sum.js</code> 檔案：</p>
<p><strong>sum.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = sum;</span><br></pre></td></tr></table></figure>

<p>你可以直接在同層資料夾新建一個 <code>sum.test.js</code> 檔案，並引入剛才建立好的 <code>sum.js</code> 檔（當然，仍然建議是在 <code>src/__test__/</code> 資料夾底下集中會比較好管理）：</p>
<p><strong>sum.test.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="built_in">require</span>(<span class="string">'./sum'</span>)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'adds 1 + 2 to equal 3'</span>, () =&gt; &#123;</span><br><span class="line">  expect(sum(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>目前的專案目錄應該看起來像是這樣：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">├── node_modules/</span><br><span class="line">├── src/</span><br><span class="line">│   └── __test__/</span><br><span class="line">│      └── sum<span class="selector-class">.test</span><span class="selector-class">.js</span>     <span class="comment">// 剛剛寫好的測試程式碼</span></span><br><span class="line">├── sum<span class="selector-class">.js</span>                 <span class="comment">// 剛剛寫好的程式</span></span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
</blockquote>
<p>接著將 <code>package.json</code> 設定檔增加一條快捷碼：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"jest"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接在終端機下輸入 <code>npm run test</code> 即可跑出測試：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PASS  ./sum.test.js</span><br><span class="line"> √ adds 1 + 2 to equal 3 (5ms)</span><br></pre></td></tr></table></figure>

<p>這個範例簡單的展示了 Jest 測試框架的魅力，自帶的斷言庫（assertion）讓我們在使用斷言判斷時可以與官方較有一致的行為，有利於後續的學習方面（官方文件）及相關的問題討論資源，如果看了 Intro 之後對 Jest.js 感到興趣的話不仿一起來用 Jest.js 吧！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://jestjs.io/docs/en/getting-started" target="_blank" rel="noopener">Jest-getting-started</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Jest.js</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Jest.js</tag>
      </tags>
  </entry>
  <entry>
    <title>程式設計心法 三次原則（Rule Of Three principle）</title>
    <url>/Methodology/Methodology-004-Rule-Of-Three-principle/</url>
    <content><![CDATA[<h1 id="Rule-Of-Three-原則"><a href="#Rule-Of-Three-原則" class="headerlink" title="Rule Of Three 原則"></a>Rule Of Three 原則</h1><p>如果說 DRY 原則是將抽象發揮到極致，而 KISS 原則是保留抽象盡可能的使其單純化，那麼接下來三次原則（Rule Of Three principle）可以說是這兩個原則之間的中庸之道了。</p>
<p>而三次原則顧名思義其實就是<strong>重複到第三次才去抽象它</strong>！</p>
<p>還記得之前所提過的 YAGNI 原則（You aren’t gonna need it 原則）嗎？</p>
<p>三次原則可以說是提供了 YAGNI 原則一個準則，使得在重構上（refacting）的時機更有規則，但是為什麼會需要等待第三次才要抽象呢？接著就來思考這個問題。</p>
<a id="more"></a>

<h1 id="為什麼要第三次才抽象"><a href="#為什麼要第三次才抽象" class="headerlink" title="為什麼要第三次才抽象"></a>為什麼要第三次才抽象</h1><p>如果<strong>依據開發迭代的次數</strong>來討論這個問題的話，在第一次新專案開發時，對於<strong>預設立場</strong>上，YAGNI 原則已經解釋了<strong>預設立場這件事情並實際去開發未使用到的功能</strong>這件事情並不是件好事，原因是因為可能會<strong>限制</strong>將來開發人員對於該功能會綁手綁腳，甚至出現<strong>與實際規格文件不符合的預設立場</strong>。而 KISS （Keep it simple and stupid.）原則也指出應該要使開發程式碼盡可能<strong>乾淨</strong>，以利於往後實際遇到問題時的開發人員可以<strong>有足夠的彈性</strong>去<strong>維護</strong>、<strong>修改</strong>甚至<strong>重構</strong>原有的程式碼。</p>
<p>除此之外，對於 DRY （Don’t repeat youself.）原則來說，第一次新專案開發中的重複規模可能都偏小，由於第一手開發面向的會是開發文件中的功能。所以比較多是在於想<strong>怎麼符合現有的功能</strong>，因此需要做樣板（template)的可能已經有個雛形，並非做到才想到這件事。</p>
<p>而迭代到第二次，也就是接著開發、接手維護專案的時候。這時專案中可能充斥著<strong>已經上線</strong>的程式碼，那些存在伺服器倉庫中的程式碼是已經備受專案經理、測試人員、老闆甚至是使用者的反覆使用所驗證過的程式碼，若沒有特殊情況理論上來說要比新的程式碼還來的<strong>可靠</strong>。<del>就連上檔也會多少避開假日前的這種敏感時刻</del>。</p>
<p>因此，這時的維護開發多半可能多半會檢查既有程式中有沒有<strong>壞</strong>味道（Code smell），沒有的話就迎合既有的程式碼的味道，去持續端出<strong>穩定</strong>的料理，以<strong>便於下一個開發人員來維護</strong>。而即便從原有規格中發現了不符合新需求的程式碼，重構範圍應該不至於太大才是。</p>
<p>直至第三次再度踏入同專案中，需求功能開發與之前又再度類似，便能擁有更多的信心來確認需求面並依據前面的例子去做抽象。</p>
<p>如果<strong>依據代碼重複的次數</strong>來討論這個問題的話，則同上方例子，代碼重複第三次時，這時應該會有更多例子來思考要怎麼抽象來符合這些狀況。</p>
<h1 id="總結而論"><a href="#總結而論" class="headerlink" title="總結而論"></a>總結而論</h1><p>我們已經從情境模擬而出，第三次才抽象是基於第一次開發應保有它的<strong>乾淨</strong>；第二次重複的內容則是為了避免限制到將來的功能彈性，重複的實作在這時可以替程式碼增加可讀性；第三次才抽象是因為已有先前兩例可以有足夠的例子來思考抽象後的結構，並且是屬於真正有需求的時機。而至於在迭代下去的開發，如果更改的東西越簡單但開發時程越長時，該考慮的面相可以會變成是要抉擇重構或重寫升級了。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="http://www.ruanyifeng.com/blog/2013/01/abstraction_principles.html" target="_blank" rel="noopener">代码的抽象三原则</a></li>
<li><a href="https://jaceju.net/refactor-or-rebuild/" target="_blank" rel="noopener">面對 Legacy Code ，該重構還是重寫？</a></li>
</ul>
]]></content>
      <categories>
        <category>Methodology</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Methodology</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome DevTools Performance 與畫面處理</title>
    <url>/Optimization/Optimization-002.performance/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/google/chrome-devtools-logo.png' width='200px' height='200px' />
</div>

<p>之前有文章寫到在替網頁進行優化時會使用到像是 Google Chrome 瀏覽器的 Lighthouse 網頁檢測工具，並且會給予一些可行方案與提示來協助我們優化。而其中指標（Metrics）提示可能會要我們去觀察像是第一次內容繪製（FCP，First Contentful Paint）或是第一次有意義的繪製（FMP，First Meaningful Paint）等等。</p>
<p>但這些指標名詞代表更實際的意義在哪裡？這篇文章就要來整理一下這些東西：</p>
<a id="more"></a>

<h1 id="Chrome-DevTools-Performance"><a href="#Chrome-DevTools-Performance" class="headerlink" title="Chrome DevTools Performance"></a>Chrome DevTools Performance</h1><p>在 Google Chrome 中，檢測頁面的位置在開發人員工具列（DevTools）中的 Performance 分頁，點選左上角的灰色圓圈 Records 後，重整、刷新頁面後再點選一次 Record 關閉錄製，此時就會跑出一張效能表：</p>
<p><img src="/images/google/chrome-landing-page-lighthouse-performance-trace.jpg" alt="chrome-landing-page-lighthouse-performance"></p>
<p>當然我們也可以透過 Google Chrome DevTools 分頁中的 Audit 來檢測網頁相關效能（基於 Lighthouse），在指標（Metrics）一欄我們可以看見幾個被列出來的項目，以及大約執行的秒數（依據每次跑測試環境會有些微差距），而點選左下角的 View Trace，也同樣能產出效能表。</p>
<p><img src="/images/google/chrome-landing-page-lighthouse-performance.jpg" alt="chrome-landing-page-lighthouse-performance"></p>
<h1 id="Performance-Timings"><a href="#Performance-Timings" class="headerlink" title="Performance Timings"></a>Performance Timings</h1><p>在效能表裡的 Timings 中我們可以看見幾個專有名詞的縮寫分別為：</p>
<ul>
<li>FP（First Paint）：第一次繪製開始，各使用裝置開始傳輸像素的時間點，也就是載入的空框到有任何一點視覺上的變更的時間點。</li>
<li>FCP（First Contentful Paint）：第一次內容繪製，比起 FP 來說 FCP 可以看作是一個完整的元素被渲染完畢後的時間點。</li>
<li>FMP（First Meaningful Paint）：第一次有意義的繪製，<a href="https://github.com/berwin/Blog/issues/42" target="_blank" rel="noopener">採用推測</a>布局載入的大小方式來辨識其時間點。</li>
<li>LCP（Largest Contentful Paint）：最大元素渲染，透過 <a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver" target="_blank" rel="noopener">PerformanceObserver API</a> 來計算出最大的元素渲染值。</li>
<li>DCL（DOM Content Loaded）：DOM 載入完畢的時間，也就是開發上時常會監聽的事件。</li>
</ul>
<p>我們瞭解這些指標的用意了，現在我們要來瞭解對於使用者來說，在<strong>網頁載入過程</strong>時什麼會是他們所在乎的？</p>
<ul>
<li>畫面載入時間與過程。</li>
<li>畫面可以開始操作的時間。</li>
</ul>
<h1 id="畫面載入時間"><a href="#畫面載入時間" class="headerlink" title="畫面載入時間"></a>畫面載入時間</h1><p>取得畫面載入時間相對容易，我們可以觀察 FP 與 FCP 的時間點來判斷，並搭配 Performance Record 上方的畫面紀錄來觀察，而 FP 與 FCP 載入的時間點越快，也就表示使用者看到畫面在<strong>載入</strong>這件事情越快。</p>
<p>加快 FP 與 FCP 載入的時間點的方法有：</p>
<ul>
<li>盡可能最小化禁止轉譯的樣式表與第三方的程式碼。</li>
<li>將一些靜態檔案透過 HTTP Caching 處理，讓使用者再度訪問時能夠盡可能的存取未讀取過的資源。</li>
<li>將一些文字化的靜態資源壓縮化、最小化，提升資源載入的時間。</li>
</ul>
<p>而提升了 FP、FCP、FMP 甚至到 LCP 的時間點後，我們還有另一間事情得處理。</p>
<h1 id="畫面操作時間"><a href="#畫面操作時間" class="headerlink" title="畫面操作時間"></a>畫面操作時間</h1><p>當畫面載入時，使用者可能就會開始試圖去操作畫面上的內容，而這另外牽扯到主線程阻塞等等的問題，並且有幾項較為代表的時間點：</p>
<ul>
<li>FCI（First CPU Idle）：第一次 CPU 空閒下來的時間，也就是說此時可以接收到一些來至使用者的 Event 行為了。</li>
<li>TTI（Time to Interactive）：指整個頁面完全可以操作的時間點，而不單只是 FCI 的時間點。</li>
<li>FID（First Input Delay）：使用者第一次嘗試操作頁面元素時所遇到的阻塞時間長度。</li>
</ul>
<p>而依據整體使用者操作的時間點 與 <strong>主線程</strong> 空閒狀態大概會出現幾種情況：</p>
<ul>
<li>使用者根本不與網頁上的內容互動，也就是根本沒有操作問題 (X。</li>
<li>使用者在主線程忙碌時操作，由於此時操作會需要等待主線程空閒時，才能繼續處理，因此需要等待 Input Delay 時間會較長。</li>
<li>使用者在主線程空閒時操作，由於此時可以立即處理該操作，所以這時候 Input Delay 時間會較短。</li>
</ul>
<p>因此面向的問題可能會變成要盡可能的讓使用者可以快速操作（縮短 FCI 時間）。</p>
<p>而解決方法之一可以試著讓主線程忙碌時段分散，如將 Load 量大的程式移交至 Event Loop 當中（例如 <code>setTimeout(fn, 0)</code> 的<a href="https://stackoverflow.com/questions/10180391/javascript-how-to-avoid-blocking-the-browser-while-doing-heavy-work" target="_blank" rel="noopener">黑魔法</a>）</p>
<p>另一方法則是將畫面上蓋上 Loading 的畫面狀態，如此一來可以避免使用者在程式完全載入前操作，發生一些不可預期的錯誤，並且讓使用者在進入 FP 階段後，可以安心地等待整體資料 OnLoad 完成。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint" target="_blank" rel="noopener">First Contentful Paint</a></li>
<li><a href="https://premium.wpmudev.org/blog/improve-first-contentful-meaningful-paint/" target="_blank" rel="noopener">How to Improve First Contentful and Meaningful Paint</a></li>
<li><a href="http://mis101bird.js.org/metrics/" target="_blank" rel="noopener">[Performance]瀏覽器運作與效能指標評估</a></li>
<li><a href="https://blog.hinablue.me/2019-ithome-ironman-day-26/" target="_blank" rel="noopener">[IT 鐵人賽] 大型資料載入實例與狀況 Large of DOMs Day 26</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/98880815" target="_blank" rel="noopener">Web性能领域常见的专业术语</a></li>
<li><a href="https://blog.csdn.net/c_kite/article/details/104237256" target="_blank" rel="noopener">Chrome Performance常见名词解释(FP, FCP, LCP, DCL, FMP, TTI, TBT, FID, CLS)</a></li>
<li><a href="https://juejin.im/post/5dfc709b51882579dc6f7f71" target="_blank" rel="noopener">Chrome Devtool Performance中DCL, L, FP, FCP, FMP, LCP 的含义</a></li>
</ul>
]]></content>
      <categories>
        <category>Optimization</category>
        <category>Chrome DevTools</category>
      </categories>
      <tags>
        <tag>Optimization</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>網路優化不可不知的測評工具 Lighthouse, PageSpeed Insights &amp; Web.dev</title>
    <url>/Optimization/Optimization-001-lighthouse/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="lighthouse-logo" src='/images/Lighthosue/lighthouse-logo.png' width='200px' height='200px' />
</div>

<h1 id="Lighthouse、PageSpeed-Insights"><a href="#Lighthouse、PageSpeed-Insights" class="headerlink" title="Lighthouse、PageSpeed Insights"></a>Lighthouse、PageSpeed Insights</h1><p>Lighthouse 是由 Google 團隊所開發的檢測工具，主要用來檢測網站使用者體驗、效能與 SEO 等等網站優化的部分，若沒有聽過 Lighthouse，那麼應該有聽過同樣為 Google 為所開發的 <a href="https://developers.google.com/speed/pagespeed/insights/?hl=zh-TW" target="_blank" rel="noopener">PageSpeed Insights</a> 檢測網站，而 PageSpeed Insights 也在 2018 年的某次改版中將 Lighthouse 評分整併到 PageSpeed Insights 中。</p>
<p>而兩者相較之下， PageSpeed Insights 整併後主要是增加了較多視覺報表呈現的部分，並且可以選擇語系來看分析後的優化方案；而 Lighthouse 則有多個管道可以查看檢測後的結果：</p>
<ul>
<li>Google DevTools</li>
<li>Google Extensions Lighthouse</li>
<li>Web.dev</li>
</ul>
<p>接下來便介紹這三個工具的用法與差異：</p>
<a id="more"></a>

<h2 id="Google-DevTools"><a href="#Google-DevTools" class="headerlink" title="Google DevTools"></a>Google DevTools</h2><p>在 Google Chrome 瀏覽器中有著非常好用的 DevTools，而在 Chrome 60 版本後， DevTools 新增了一項面板 Audits 便是基於 Lighthouse 所製作出來的。我們只要打開 DevTools 在面板 Audits 執行 Run audits 即可開始測分。</p>
<p>採用這個方法的好處是可以針對於一些未實際架在 server 上的網頁做檢測，例如想在測試機上調校 SEO，或是以 local 端方式開啟的網站也能用這個方法評分。</p>
<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="lighthouse-devtool-audits" src='/images/Lighthosue/lighthouse-devtool-audits.png' width='500px' height='500px' />
</div>

<h2 id="Google-Extensions-Lighthouse"><a href="#Google-Extensions-Lighthouse" class="headerlink" title="Google Extensions Lighthouse"></a>Google Extensions Lighthouse</h2><p>第二項方法則是下載 <a href="https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk?hl=zh-TW" target="_blank" rel="noopener">Google Extension</a>，接著就可以在 Chrome 瀏覽器右上角直接點選使用。</p>
<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="lighthouse-google-extension" src='/images/Lighthosue/lighthouse-google-extension.png' width='500px' height='500px' />
</div>

<p>採用這個方法的好處是可以快速檢測每個頁面，但基本上功能與 DevTools 裡 Audits 面板差不多，若 Chrome 版本已經升到 60 的話直接用 Audits 可能會比較方便。</p>
<p>另外要注意的是使用 Google Extension 版本的 Lighthouse，它產生的 Report Viewer 是會藉由 Server 去訪問的，因此如果是沒對外開放的測試機或以 local 端執行的網站要進行測試就會沒辦法使用。</p>
<h2 id="Web-dev"><a href="#Web-dev" class="headerlink" title="Web.dev"></a>Web.dev</h2><p><a href="https://web.dev/measure/" target="_blank" rel="noopener">Web.dev</a> 也是由 Google 團隊所開發檢測工具裡面的東西，由於基於 Lighthouse 所開發，用起來與 PageSpeed Insights、Lighthouse 基本上是差不多的，比較不一樣的地方在於它的測評是依據衝擊度（Impact）來排名，可以較直覺從比較重要的項目開始優化。另外則是下載報表時會稍微方便一點。</p>
<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="web-dev-page" src='/images/Lighthosue/web-dev-page.png' width='500px' height='500px' />
</div>


<h1 id="Optimization-項目"><a href="#Optimization-項目" class="headerlink" title="Optimization 項目"></a>Optimization 項目</h1><p>上面介紹了一些基於 Lighthouse 有關的檢測工具，緊接著要來介紹有關 Lighthouse 上的設定以及要如何搭配檢測結果來調校我們的程式。</p>
<p>以 Google DevTools 為例，在跑分打開 Audits 面板會看到如下圖所示的設定：</p>
<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="lighthouse-devtool-audits" src='/images/Lighthosue/lighthouse-devtool-audits.png' width='500px' height='500px' />
</div>

<ul>
<li>Device：設定模擬使用桌機還是行動裝置來檢測當前的網頁。</li>
<li>Audits：設定要檢測的項目，可以適當的關掉沒有需要檢測的項目加速檢測時間（例如沒有考慮 PWA 的情況）。</li>
<li>Throttling：設定模擬檢測的網路速度，心臟不夠大顆的話可以考慮先從 <code>No throttling</code> 開始，否則一般慢速模擬的情況通常是以<strong>悲劇</strong>收場，<del>然後你就會想關掉 Lighthouse 結束這回合</del>。</li>
</ul>
<p>我們實際以目前這個 Blog 來跑分。可以看到大致上還算滿意，但仍然可以再補足一些缺漏：</p>
<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="lighthouse-devtool-audits-my-personal-blog" src='/images/Lighthosue/lighthouse-devtool-audits-my-personal-blog.png' width='500px' height='500px' />
</div>

<p>最後檢測報告主要可分為以下幾個面向：</p>
<ul>
<li>Performance：網站效能類，通常會反映在<strong>客戶端與伺服器端上的溝通</strong>為主。</li>
<li>Accessibilty：網站無障礙設計類，面相在<strong>使用非典型裝置（桌機手機平板）類的輔助裝置觀看網站時，能否讓使用者也能順暢的使用</strong>。<br>好比 Modern Web 設計時常使用 CSS 去改動 <code>&lt;a&gt;</code>、<code>&lt;button&gt;</code> 連結按鈕，若標籤內沒有任何文字的話會被視為不可觸及的對象，因此被扣分。</li>
<li>Best Practices：網站最佳實作類，主要是在於<strong>程式碼上的優化</strong>類別，像是使否使用緩存機制與是否用了不推薦的語法。</li>
<li>SEO：搜尋引擎優化類，這個部分應該是最多人關注的點，畢竟很可能會直接影響到網站在搜尋引擎的排名。例如 <code>&lt;meta&gt;</code> 方面的資料有沒有設定完整，<code>&lt;img&gt;</code> 有沒有確實加上 <code>alt</code> 屬性等等都會被考慮在內。</li>
<li>PWA：</li>
</ul>
<p>而要修正的方式也很直覺，往下拉就會看到 Lighthouse 是以什麼樣的檢測標準在審核，並且提示你是哪個地方出了問題，<strong>可能</strong> 需要解決。</p>
<p>不過看到分數有時先不用驚慌，好比將剛剛測驗結果拉到 Best Practice 區，可以看到有用了 <code>document.write</code> 的語法問題，但我們將它打開一看：</p>
<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="lighthouse-devtool-best-practices.png" src='/images/Lighthosue/lighthouse-devtool-best-practices.png' width='500px' height='500px' />
</div>

<p>可以看到哪段程式使用了該段語法。<del>然後就會發現有時所謂的問題，實際上也是可能我們自己無法處理的部分（google ads）。</del></p>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>透過上面例子，我們可以總結出 Lighthouse 的確可以使我們很直接地看出網站目前有哪些問題有需解決，有時可能會為了<strong>視覺</strong>上的美化、<strong>效能、程式實作</strong>上的考量、<strong>第三方</strong>提供的 SDK 等等問題，而拉低分數。但不盡然到要完全符合才能成為一個優質的網站，而在優化上面，最終檢測面向的依舊是要端看使用者<strong>平均的實際體驗</strong>。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10210147" target="_blank" rel="noopener">WEB.DEV – Google SEO 工具</a></li>
<li><a href="https://seo.whoops.com.tw/pagespeed-insights-revamped-with-lighthouse/" target="_blank" rel="noopener">Google PageSpeed Insights 大改版，整合 Lighthouse 引擎提供更多 SEO 細節數據</a></li>
<li><a href="https://www.astralweb.com.tw/google-lighthouse-for-front-end-audits-to-imporve-better-seo-and-user-experience/" target="_blank" rel="noopener">Chrome 推出 Lighthouse 前端稽核功能 – 為了更好的 SEO 與使用者體驗</a></li>
</ul>
]]></content>
      <categories>
        <category>Optimization</category>
        <category>lighthouse</category>
      </categories>
      <tags>
        <tag>Optimization</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest.js 異步測試（Asynchronous Test）</title>
    <url>/Jest.js/Jest-003-async-test/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="jest-logo" src='/images/Jest/jest-logo.png' width='200px' height='200px' />
</div>

<h1 id="Asynchronous"><a href="#Asynchronous" class="headerlink" title="Asynchronous"></a>Asynchronous</h1><p>由於 JavaScript 在瀏覽器的宿主環境裡擁有單線程（single thread）的特性，使得在程式執行時期（Run time）中一些有關非同步（Asynchronous）的操作會等到主線程（Main thread）整個操作結束後才會回來執行處在任務序列（Event queue）中的非同步操作。</p>
<p>因此在測試中，如果遇到有關非同步的操作時，測試程式碼的執行順序（主線程）會先於任務序列，造成測試還未來得及收到非同步執行後的結果，進而導致測試失敗的產出。</p>
<p>我們能做的做法便是要將測試程式碼運行結束的時間，拖延至任務序列當中，讓測試套件（Test suit）中非同步的結果產出之後，才來進行測試中的斷言。</p>
<p>而在 Jest.js 解決這一類非同步測試的問題時，有提供了實際 API 的作法以供參考：</p>
<ul>
<li>callback function 類</li>
<li>promise 類</li>
<li>async / await 類</li>
</ul>
<a id="more"></a>

<h2 id="callback-function"><a href="#callback-function" class="headerlink" title="callback function"></a>callback function</h2><p>在處理 callback function 的作法是，在呼叫測試案例 API <code>test()</code> 時，使用 <code>done</code> API。</p>
<p>我們只需要在第二個回呼函式中給予 <code>done</code> 參數，並在非同步的結果處理完畢時，執行 <code>done()</code>，來表示整個測試案例的結束，而若給予參數 <code>done</code> 卻沒執行 <code>done()</code> 則表示測試失敗，意思也就是非同步的行為操作失敗，符合我們測試的期待。</p>
<p>一般測試寫法，但是這樣填寫會導致在執行非同步的 <code>fetch</code> 前，主線程的測試就已經測試完，因此導致測試失敗：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'查詢商品列表資料是否有正確傳送給輪播功能'</span>, () =&gt; &#123;</span><br><span class="line">  fetch(<span class="string">'某個商品公開列表 API 網址'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 假設完成後須執行 postItemToCarousel 函式</span></span><br><span class="line">      <span class="comment">// 這裡假設我們最後 callback 傳送了 &#123;id: 1, name: 'potato', price: 50 &#125; 進去</span></span><br><span class="line">      res.items.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        postItemToCarousel(&#123;</span><br><span class="line">          id: item.id, </span><br><span class="line">          name: item.name,</span><br><span class="line">          price: item.price</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postItemToCarousel</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    expect(item.id).toBe(<span class="number">1</span>)</span><br><span class="line">    expect(item.name).toBe(<span class="string">'potato'</span>)</span><br><span class="line">    expect(item.price).toBe(<span class="number">50</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>加上 <code>done</code> 參數的寫法，使非同步執行完畢才進行測試：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 測試案例第二個傳參傳入 `done`，如此一來這個測試案例本身就會等待 `done()` 被執行的時候才會開始測試斷言的部分。</span></span><br><span class="line">test(<span class="string">'查詢商品列表資料是否有正確傳送給輪播功能'</span>, done =&gt; &#123;</span><br><span class="line">  fetch(<span class="string">'某個商品公開列表 API 網址'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      res.items.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        postItemToCarousel(&#123;</span><br><span class="line">          id: item.id, </span><br><span class="line">          name: item.name,</span><br><span class="line">          price: item.price</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postItemToCarousel</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    expect(item.id).toBe(<span class="number">1</span>)</span><br><span class="line">    expect(item.name).toBe(<span class="string">'potato'</span>)</span><br><span class="line">    expect(item.price).toBe(<span class="number">50</span>)</span><br><span class="line">    done() <span class="comment">// 到這行表示才進行測試斷言</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>如果資料返回的形式是一個 promise 的話，需透過 <code>return</code> 來返回斷言：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料成功'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">'取得會員社交資料網址'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> expect(res.memberName).toBe(<span class="string">'ShawnL'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因為在 promise 中如果已經取得目標的狀態下（fulfilled）不會讓測試案例失敗，所以如果要測試 promise 中 <code>.catch()</code> 方法，需要透過 <code>expect.assertions</code> 來定義斷言的數量，來確保一定要通過幾筆斷言才算是成功的測試案例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料錯誤處裡'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">'取得會員社交資料網址'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> expect(error)).toMatch(<span class="string">'錯誤處理的訊息'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>除了上面的作法之外，也可以使用 Jest 提供的 <code>.resolves</code>、<code>.rejects</code> 配對器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> expect(fetch(<span class="string">'取得會員社交資料網址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json()).then(<span class="function"><span class="params">res</span> =&gt;</span> res.memberName)).resolves.toBe(<span class="string">'ShawnL'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料錯誤處裡'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> expect(fetch(<span class="string">'取得會員社交資料網址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json()).catch(<span class="function"><span class="params">error</span> =&gt;</span> error)).rejects.toMatch(<span class="string">'錯誤處理的訊息'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h2><p>Jest 關於非同步的議題也納入了 ES7 中的 <code>async</code>、<code>await</code> 用法，我們可以寫出更優雅的非同步測試程式碼：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> memberData = <span class="keyword">await</span> fetch(<span class="string">'取得會員社交資料網址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json()).then(<span class="function"><span class="params">res</span> =&gt;</span> res)</span><br><span class="line">  expect(memberData.name).toBe(<span class="string">'ShawnL'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料錯誤處裡'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  expect.assertions(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> fetch(<span class="string">'取得會員社交資料網址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    expect(err).toMatch(<span class="string">'錯誤處理的訊息'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同樣還可以再搭配 <code>.resolves</code>、<code>.rejects</code> 配對器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(fetch(<span class="string">'取得會員社交資料網址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json()).then(<span class="function"><span class="params">res</span> =&gt;</span> res.name)).resolves.toBe(<span class="string">'ShawnL'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料錯誤處裡'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(fetch(<span class="string">'取得會員社交資料網址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json()).catch(<span class="function"><span class="params">err</span> =&gt;</span> err)).rejects.toMatch(<span class="string">'錯誤處理的訊息'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面介紹了一些在 Jest 中撰寫非同步測試的幾種情境與解決方法。</p>
<p>然而非同步議題在實際測試中，後續測試其實會比較關注在後續視覺與邏輯處理的部分，因為我們可能已經預期非同步執行的結果會是什麼，因此會利用 Mock 來仿造非同步資料，再來撰寫測試程式碼。</p>
<p>但為了真的要去測一些非同步執行的內容的話，還是要知道怎麼使用會比較好 XD</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://jestjs.io/docs/en/asynchronous" target="_blank" rel="noopener">Jest-asynchronous</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Jest.js</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Jest.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest.js 設定、拆除與作用域（setup、teardown &amp; scope）、執行順序</title>
    <url>/Jest.js/Jest-004-setup-teardown/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="jest-logo" src='/images/Jest/jest-logo.png' width='200px' height='200px' />
</div>


<h1 id="setup、teardown"><a href="#setup、teardown" class="headerlink" title="setup、teardown"></a>setup、teardown</h1><p>在執行測試時，有時候會需要初始化一些基本資料以供測試進行，並且在測試完畢的時候要讓測試後的資料復原、整理。</p>
<p>而 Jest 在這方面提供的 API 如下：</p>
<ul>
<li><strong>describe()</strong>：測試套件，可以針對測試鉤子形成作用域（scope）並描述該部分的測試情境。</li>
<li><strong>test()</strong>：測試案例，用以描述該筆正在進行的測試內容與設定相關測試條件。（也可以使用別名 <code>it()</code>）</li>
<li><strong>beforeAll()</strong>：針對該<strong>測試套件</strong>的作用域，在<strong>第一筆</strong>測試案例<strong>開始前</strong>執行一次。</li>
<li><strong>afterAll()</strong>：針對該<strong>測試套件</strong>的作用域，在<strong>最後一筆</strong>測試案例<strong>結束後</strong>執行一次。</li>
<li><strong>beforeEach()</strong>：針對該<strong>測試套件</strong>的作用域，在<strong>每個</strong>測試案例<strong>開始前</strong>執行一次。</li>
<li><strong>afterEach()</strong>：針對該<strong>測試套件</strong>的作用域，在<strong>每個</strong>測試案例<strong>結束前</strong>執行一次。</li>
</ul>
<a id="more"></a>

<p>快速看個案例！</p>
<p>這裡先設置了一個基本的函式 <code>sum.js</code>，並且用 <code>module.exports</code> 來導出：</p>
<p><strong>sum.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = sum</span><br></pre></td></tr></table></figure>

<p>接著來寫給 Jest.js 跑測試用的測試程式碼：</p>
<p><strong>function.test.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入寫好的程式</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="built_in">require</span>(<span class="string">'./sum'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sumResult = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> randomNumberA = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> randomNumberB = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 設定每次測試案例要用的資料，這裡使用 random() 函式賦予每次案例不同的值。</span></span><br><span class="line">    randomNumberA = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>) <span class="comment">// 0 ~ 10</span></span><br><span class="line">    randomNumberB = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>) <span class="comment">// 0 ~ 10</span></span><br><span class="line">    sumResult = randomNumberA + randomNumberB</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'add 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">  expect(sum(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'add 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">  expect(sumResult).toBe(randomNumberA + randomNumberB)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>執行測試後秀出結果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> PASS  ./sum.test.js</span><br><span class="line">  √ add 函式返回兩者相加的值</span><br><span class="line">  √ add 函式返回兩者相加的值</span><br><span class="line">Test Suites: 1 passed, 1 total</span><br><span class="line">Tests:       2 passed, 2 total</span><br><span class="line">Snapshots:   0 total</span><br><span class="line">Time:        3.786s</span><br><span class="line">Ran all <span class="built_in">test</span> suites.</span><br></pre></td></tr></table></figure>

<h1 id="scope-與-執行順序"><a href="#scope-與-執行順序" class="headerlink" title="scope 與 執行順序"></a>scope 與 執行順序</h1><p>使用 JavaScript 都知道 JavaScript 擁有它的作用域，而在 Jest 中也有屬於它自己的作用域，官方提供了兩個很簡單能分別看出 Hook 之間與 <code>describe()</code>、<code>test()</code> 之間執行順序的測試程式碼：</p>
<h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><p>在鉤子中的順序我們可以透過以下程式碼來測試：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1 - beforeAll'</span>));</span><br><span class="line">afterAll(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1 - afterAll'</span>));</span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1 - beforeEach'</span>));</span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1 - afterEach'</span>));</span><br><span class="line">test(<span class="string">''</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'1 - test'</span>));</span><br><span class="line">describe(<span class="string">'Scoped / Nested block'</span>, () =&gt; &#123;</span><br><span class="line">  beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2 - beforeAll'</span>));</span><br><span class="line">  afterAll(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2 - afterAll'</span>));</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2 - beforeEach'</span>));</span><br><span class="line">  afterEach(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2 - afterEach'</span>));</span><br><span class="line">  test(<span class="string">''</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'2 - test'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我們試著觀察測試結果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">● Console</span><br><span class="line">  1 - beforeAll    <span class="comment"># 全域級：最外層雖沒有明寫 describe()，但整個檔案其實算是一個測試套件，因此開始前就會執行一次。</span></span><br><span class="line">  1 - beforeEach   <span class="comment"># 全域級：每個測試案例前執行。</span></span><br><span class="line">  1 - <span class="built_in">test</span>         <span class="comment"># 全域級：測試案例。</span></span><br><span class="line">  1 - afterEach    <span class="comment"># 全域級：每個測試案例後執行。</span></span><br><span class="line">  <span class="comment"># 從這裡進入巢狀級測試套件</span></span><br><span class="line">  2 - beforeAll    <span class="comment"># 巢狀級：測試套件開始時執行一次。</span></span><br><span class="line">  1 - beforeEach   <span class="comment"># 全域級：每個測試案例前執行。</span></span><br><span class="line">  2 - beforeEach   <span class="comment"># 巢狀級：每個測試案例前執行。</span></span><br><span class="line">  2 - <span class="built_in">test</span>         <span class="comment"># 巢狀級：測試案例。</span></span><br><span class="line">  2 - afterEach    <span class="comment"># 巢狀級：每個測試案例後執行。</span></span><br><span class="line">  1 - afterEach    <span class="comment"># 全域級：每個測試案例後執行。</span></span><br><span class="line">  2 - afterAll     <span class="comment"># 巢狀級：測試套件結束時執行一次。</span></span><br><span class="line">  <span class="comment"># 從這裡離開巢狀級測試套件</span></span><br><span class="line">  1 - afterAll     <span class="comment"># 巢狀級：測試套件結束時執行一次。</span></span><br></pre></td></tr></table></figure>

<p>我們可以看到了幾個重點：</p>
<ol>
<li>整個檔案算是一個測試套件，因此全域級別的鉤子都會觸發。</li>
<li>測試開始前 <code>*All</code> 系列的鉤子先於 <code>*Each</code> 系列鉤子；離開時， <code>*All</code> 系列的鉤子則是後於 <code>*Each</code> 系列鉤子。</li>
<li><code>*Each</code> 系列的鉤子不僅只有在當下的級別執行，甚至還會往巢狀的測試套件中也執行。</li>
<li><code>*Each</code> 系列的鉤子，在測試案例前 <strong>全域級</strong> 的鉤子先於 <strong>巢狀級</strong> 的鉤子；在測試案例後， <strong>全域級</strong> 系列的鉤子則是後於 <strong>巢狀級</strong> 的鉤子。</li>
</ol>
<p>簡單來說的話便是：整個鉤子邏輯是屬於後進先出（LIFO，Last in, First Out）原則的，並且父層的鉤子邏輯會<strong>完整</strong>的套用在子層鉤子邏輯中。</p>
<h2 id="describe-與-test-之間的執行順序"><a href="#describe-與-test-之間的執行順序" class="headerlink" title="describe() 與 test() 之間的執行順序"></a>describe() 與 test() 之間的執行順序</h2><p>我們一樣透過官方範例程式碼來測試並觀察：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'outer'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'describe outer-a'</span>)</span><br><span class="line">  describe(<span class="string">'describe inner 1'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'describe inner 1'</span>)</span><br><span class="line">    test(<span class="string">'test 1'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test for describe inner 1'</span>)</span><br><span class="line">      expect(<span class="literal">true</span>).toEqual(<span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'describe outer-b'</span>)</span><br><span class="line">  test(<span class="string">'test 1'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test for describe outer'</span>)</span><br><span class="line">    expect(<span class="literal">true</span>).toEqual(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  describe(<span class="string">'describe inner 2'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'describe inner 2'</span>)</span><br><span class="line">    test(<span class="string">'test for describe inner 2'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test for describe inner 2'</span>)</span><br><span class="line">      expect(<span class="literal">false</span>).toEqual(<span class="literal">false</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'describe outer-c'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>執行的結果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">describe outer<span class="_">-a</span></span><br><span class="line">describe inner 1</span><br><span class="line">describe outer-b</span><br><span class="line">describe inner 2</span><br><span class="line">describe outer-c</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> describe inner 1</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> describe outer</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> describe inner 2</span><br></pre></td></tr></table></figure>

<p>從上列測試碼中我們可以看出幾個重點：</p>
<ol>
<li><code>describe()</code> 的執行順序會優先於所有測試之前，接著才會開始執行 <code>test()</code> 的內容。</li>
<li>遵循上面的規則後，由上到下逐步執行每個測試內容。</li>
</ol>
<p>以上是關於 Jest 測試環境中的設定與執行順序，而真正要寫好測試還是得靠我們自己從實務上去慢慢證明想法與測試碼邏輯是否一致！</p>
<p>如果不確定的話也可以下個簡單的斷言來看斷點是否正常，有時候可能只是不慎打錯字才導致測試失敗喔！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://jestjs.io/docs/zh-Hans/setup-teardown" target="_blank" rel="noopener">Jest-setup-teardown</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Jest.js</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Jest.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest.js 配對器（Matchers）a.k.a. 斷言（Assertion）</title>
    <url>/Jest.js/Jest-002-matchers-assertion/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="jest-logo" src='/images/Jest/jest-logo.png' width='200px' height='200px' />
</div>

<h1 id="斷言-Assertion"><a href="#斷言-Assertion" class="headerlink" title="斷言 Assertion"></a>斷言 Assertion</h1><p>在測試庫中，斷言（assertion）是一個很重要的概念，意思即為開發程式中執行完畢時，程式碼執行結果應與斷言所設定的結果一致，否則該處斷言碼會拋出錯誤的意思。你可能已經在某些情況下「斷言」過好幾次了，例如在 JavaScript 裡面使用全等比較（<code>===</code>）來比較兩者的資料類型是否一致，這便是斷言。而在 Jest.js 框架中，Jest 選擇的是使用 Matchers 配對器這個名稱，兩者其實在概念上是差不多的東西。</p>
<p>Jest.js 中的配對器（Matchers），主要採用的是 <code>expect()</code> 的方法，但 Jest.js 中的 expect 與 Node.js 和其他斷言庫（如 Chai.js）中的 <code>expect()</code> 是不一樣的，別搞混了！XD，我自認為比較好辨識 Jest 方法是當斷言中出現了 <code>expect().toBe()</code> 這個東西，基本上看到這個可以確認大概率是使用 Jest.js 了。</p>
<p>而為什麼辨識文件中是用誰家的斷言有一點小重要的點是，當你試著按照例如 Vue.js 的測試文件 Vue-test-utils 測試時，可能會遇到斷言方法 API 不一樣的情況，那麼你可能得回去翻翻其他斷言庫本身的斷言 API 文件了。</p>
<a id="more"></a>

<h1 id="配對器-Matchers"><a href="#配對器-Matchers" class="headerlink" title="配對器 Matchers"></a>配對器 Matchers</h1><p>在 Jest.js 中，我們可以直接使用 <code>expect()</code> 來寫斷言中的期望值，而關於 <code>expect</code> API 官方也有整理很棒的<a href="https://jestjs.io/docs/zh-Hans/expect" target="_blank" rel="noopener">列表</a>可以看，私心覺得比起隔壁棚的框架好讀多了（？<br>但在一開始學習配對器時，或許我們可能不是每個都會用得到，因此接下來，我們要跟著官方的範例一起來看看幾個常用的 API。</p>
<h2 id="toBe"><a href="#toBe" class="headerlink" title="toBe()"></a>toBe()</h2><p>一開始我們可以使用 <code>expect()</code> 來寫斷言中的期望值，後面接上 <code>.toBe()</code> 來寫下預期的配對值，<code>toBe()</code> 最主要的功用是在與檢查<strong>值的相等</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'1 加上 1 等於 2'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">1</span> + <span class="number">1</span>).toBe(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="toEqual"><a href="#toEqual" class="headerlink" title="toEqual()"></a>toEqual()</h2><p>如果要檢查<strong>資料型別（data type）</strong>的話，官方建議使用 <code>toEqual()</code> 來判斷（因為在 JavaScript 中物件會有記憶體存取位置不同而導致某些議題產生）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'物件中的值應該相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">'shawn'</span>&#125;</span><br><span class="line">  person[age: <span class="number">25</span>]</span><br><span class="line">  expect(obj).toEqual(&#123;<span class="attr">name</span>: <span class="string">'shawn'</span>, <span class="attr">age</span>: <span class="number">25</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Truthiness-類"><a href="#Truthiness-類" class="headerlink" title="Truthiness 類"></a>Truthiness 類</h2><p>Truthiness 主要在判斷的是有關於真假值上的問題，有經驗的開發者應該都體會過 JavaScript 中 truthy 與 falsy 的威力…（害怕.png），但在 Jest.js 中有一系列的真假值斷言可以直接使用。</p>
<ul>
<li>toBeNull： 斷言 null 值。</li>
<li>toBeUndefined： 斷言 undefined 值。</li>
<li>toBeDefined： 斷言不是 undefined 值。</li>
<li>toBeTruthy： 斷言該值在 if 判斷句中為 truthy。</li>
<li>toBeFalsy： 斷言該值在 if 判斷句中為 falsy。</li>
</ul>
<h2 id="Number-類"><a href="#Number-類" class="headerlink" title="Number 類"></a>Number 類</h2><p>數字類基本上就是那幾位大於小於等於家族。</p>
<ul>
<li>.toBeGreaterThan()：大於。</li>
<li>.toBeGreaterThanOrEqual()：大於等於。</li>
<li>.toBeLessThan()：小於。</li>
<li>.toBeLessThanOrEqual()：小於等於。</li>
<li>.toBe()：等於，同上方介紹。</li>
<li>.toEqual()：等於，同上方介紹。</li>
</ul>
<h2 id="String-類"><a href="#String-類" class="headerlink" title="String 類"></a>String 類</h2><ul>
<li>.toMatch：可以利用正則表達式（Regex）來配對是否相等。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'"test" is not to match "text"'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="string">'test'</span>).not.toMatch(<span class="regexp">/text/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Array、Iterables"><a href="#Array、Iterables" class="headerlink" title="Array、Iterables"></a>Array、Iterables</h2><ul>
<li>.toContain()：比較陣列或可迭代的值是否含有某個特定值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> favoFruits = [<span class="string">'orange'</span>, <span class="string">'banana'</span>, <span class="string">'strawberry'</span>]</span><br><span class="line">test(<span class="string">'my favo fruits'</span>, () =&gt; &#123;</span><br><span class="line">  expect(favoFruits).toContain(<span class="string">'durian'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="例外處理"><a href="#例外處理" class="headerlink" title="例外處理"></a>例外處理</h2><ul>
<li>.toThrow()：程式中可能會需要會拋出錯誤的情況，要比對是否拋出可以使用此 API。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwErrorMsg</span> (<span class="params">Msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(Msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'it should throw Error Msg'</span>, () =&gt; &#123;</span><br><span class="line">  expect(throwErrorMsg(<span class="string">'Error: Account data is missing.'</span>)).toThrow()</span><br><span class="line">  expect(throwErrorMsg(<span class="string">'Error: Account data is missing.'</span>)).toThrow(<span class="built_in">Error</span>)</span><br><span class="line">  expect(throwErrorMsg(<span class="string">'Error: Account data is missing.'</span>)).toThrow(<span class="string">'Error: Account data is missing.'</span>)</span><br><span class="line">  expect(throwErrorMsg(<span class="string">'Error: Account data is missing.'</span>)).toThrow(<span class="regexp">/missing/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上是 Jest.js 一些常見的配對器，接下來的章節將會介紹有關於一些 callback function、promise、async 與 await 等等的處理。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://jestjs.io/docs/en/using-matchers" target="_blank" rel="noopener">Jest-using-matchers</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Jest.js</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Jest.js</tag>
      </tags>
  </entry>
  <entry>
    <title>重新解構：無瑕的程式碼（Clean Code） Chapter 2 有意義的命名（下）－命名規則</title>
    <url>/cleancode/clean-code-a-handbook-of-agile-software-craftsmanship-003-naming-rule/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/Book/Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship.jpg' width='200px' height='200px' />
</div>

<p>上一章節整理了偏向心法方面的命名設計理念，本篇將會整理有關於命名實際上的規則與做法。</p>
<a id="more"></a>


<h1 id="命名的規則"><a href="#命名的規則" class="headerlink" title="命名的規則"></a>命名的規則</h1><p>命名的規則，相較於心法的概念來說，則多了一點明文規定。</p>
<p>諸多的規則限制是來自於許多工程師的長期經驗，以及程式編譯與操作環境設備上的考量，透過命名來能幫助我們加速開發。</p>
<p>而同樣的我將其歸納成下列幾種：</p>
<ul>
<li><p>常見應避免的用法。</p>
</li>
<li><p>依資料型態的命名規則。</p>
</li>
<li><p>JavaBeans 規範。</p>
</li>
<li><p>添加資訊。</p>
</li>
<li><p>容易被搜尋的字眼</p>
</li>
<li><p>真的還是不行？</p>
<h2 id="常見應避免的用法"><a href="#常見應避免的用法" class="headerlink" title="常見應避免的用法"></a>常見應避免的用法</h2></li>
<li><p>避免使用無意義命名。<br>例如：<code>abc</code>、<code>a1</code>、<code>a2</code>。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> abc = <span class="string">'...'</span>;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="string">'...'</span>;</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="string">'...'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免單個字命名。<br>例如：<code>a</code>、<code>b</code>、<code>c</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'...'</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'...'</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="string">'...'</span>;</span><br></pre></td></tr></table></figure>

<p>尤其這對搜尋來說非常難以找到這個單字的源頭，試著想一下你打開了搜尋，然後輸入了 <code>a</code> 因為你想看看這個變數所儲存的來源是怎麼操作的，電腦只能跟你說很抱歉：這裡有 <code>9527</code> 個搜尋到的結果。</p>
<p>但如果是迴圈中常用的 <code>i</code>、<code>j</code>、<code>k</code>，則可以使用，因為這些對於工程師來說是有既定印象的，並且我們並不會在全域範圍中一直使用它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumArrayNumber</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++)  &#123;</span><br><span class="line">    result += array[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免匈牙利命名法。<br>例如：<code>string_Phone</code>、<code>string_Name</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string_Phone = <span class="string">'0912345678'</span>;</span><br><span class="line"><span class="keyword">let</span> string_Name = <span class="string">'shawn'</span>;</span><br></pre></td></tr></table></figure>
<p>這裡並非說匈牙利命名不好，因為它是有歷史背景的因素才出現的。</p>
<p>然而，在現代開發環境中，資料型態已經可以透過編譯器來一系列的檢查。</p>
<p>並且在 JavaScript 之中，型態很有可能會轉變，將變數命名型態會有很大的機率誤導他人。如果真的要有效辨別，則可以使用 TypeScript ，透過型別系統來定義變數才更有強制力。</p>
<h2 id="依資料型態的命名規則"><a href="#依資料型態的命名規則" class="headerlink" title="依資料型態的命名規則"></a>依資料型態的命名規則</h2><ul>
<li>常數與純數字中的命名<br>如果專案中某個特定的數字有原因的，可以試著賦予一個名稱，這會讓搜尋時與閱讀時更容易瞭解這個數字的來由。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target_item_price = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">50</span> &gt; target_item_price) &#123;</span><br><span class="line">  buyTarget()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target_item_price = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> current_balance = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current_balance &gt; target_item_price) &#123;</span><br><span class="line">  buyTarget()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更棒的好處是，當我們後續維護如果要變更該數字，我們也更容易能夠找到它。</p>
<ul>
<li>物件與類別的命名<br>物件與類別可以使用名詞來命名。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> member = &#123;</span><br><span class="line">  name: <span class="string">'Shawn'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函式與方法的命名<br>函式與方法可以使用動詞與動詞片語來命名。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postArticle</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特定領域的命名<br>有時候專案中是有關於某些特定領域，一般來說如果能採用工程師能理解的用語為優先。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title = <span class="string">'某某職稱'</span></span><br></pre></td></tr></table></figure>

<p>若真的找不到用語，至少也要使用該特定領域的名稱，之後也才有辦法詢問名稱的意義。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> agent = <span class="string">'某某代理人'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JavaBeans 規範<br>JavaBeans 原先是屬於 Java 語言中的一個類別（class），而要使用它必須遵守一些規則。</li>
</ul>
<p>例如提取統一使用 <code>get</code>，修改則是 <code>set</code>，布林值判斷則使用 <code>is</code>。</p>
<p>另外還有像是類別名稱首個單字大寫後續小寫，方法、變數名稱則是首個單字小寫後續大寫等等</p>
<p>舉例來說好比操作瀏覽器物件中的 localStroage 中的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'hello'</span>, <span class="string">'world'</span>);</span><br><span class="line">localStorage.getItem(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>添加資訊<br>有時候單一個詞彙解決不了的東西，那就試試第二個吧！</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Shawn'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">'Shawn'</span>;</span><br><span class="line"><span class="keyword">let</span> lastName =  <span class="string">'Lin'</span>;</span><br></pre></td></tr></table></figure>

<p>但前綴後綴的時候如果有遇到大量的情況，則應該考慮是否要將其便成為一個物件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> memberFirstName = <span class="string">'Shawn'</span>;</span><br><span class="line"><span class="keyword">let</span> memberLastName =  <span class="string">'Lin'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> member = &#123;</span><br><span class="line">  firstName: <span class="string">'Shawn'</span>,</span><br><span class="line">  lastName:  <span class="string">'Lin'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>容易被搜尋的字眼<br>最後一個則是容易被搜尋為原則。因為在維護舊專案時，第一件事情可能先要瞭解整個架構，而其中可能會用了大量的方法來建構，如果用了一個不好搜尋到的名稱，可能接手維護的人會感受到很挫折甚至是憤怒，這也跟前面的心法與規則息息相關。</li>
</ul>
<p>再來複習一次：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">t(<span class="number">9527</span>) ;  <span class="comment">// 這到底是什麼...</span></span><br></pre></td></tr></table></figure>

<p>搜尋結果:</p>
<blockquote>
<p>55 個檔案中有 10130 個結果。</p>
</blockquote>
<ul>
<li>真的還是不行<br>有的時候礙於規模大小還是發展的時候，當時的狀況確實沒辦法想到一個最好的命名。因此覺得真的不是一個好命名的時候，那麼就透過註解來提醒後續維護的人，記得幫忙想個好名字啊。</li>
</ul>
<p>警告：是真的無法才這麼做。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tmp = <span class="string">'something'</span>; <span class="comment">// 名稱仍有待改進</span></span><br></pre></td></tr></table></figure>

<p>以上是第一章節的觀後感，自己仔細整理過後真心覺得程式中的命名，比玩遊戲創角色時的命名真的難太多了…。</p>
]]></content>
      <categories>
        <category>Book</category>
        <category>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</category>
      </categories>
      <tags>
        <tag>Book</tag>
        <tag>w3HexSchool</tag>
        <tag>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest.js 測試替身 Test double &amp; Mocks Functions</title>
    <url>/Jest.js/Jest-005-test-double-and-mocks/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="jest-logo" src='/images/Jest/jest-logo.png' width='200px' height='200px' />
</div>

<h1 id="Test-double-測試替身"><a href="#Test-double-測試替身" class="headerlink" title="Test double 測試替身"></a>Test double 測試替身</h1><p>測試替身最主要是透過封裝好的函式來協助開發者模擬一些函式、功能、模組所返回的值。</p>
<p>像是 Mocha.js 就會搭配像是 Sinon.js 這一類的隔離庫來使用測試替身。而 Jest 本身核心概念是屬於 <strong>batteries-included</strong> 類型的框架（即為你需要的功能，框架都盡量幫你準備好了），因此 Jest 在模擬測試替身上則是看 Jest 本身的 Mock API 即可！</p>
<a id="more"></a>

<h1 id="Mock-基礎範例"><a href="#Mock-基礎範例" class="headerlink" title="Mock 基礎範例"></a>Mock 基礎範例</h1><p>我們根據 Jest mock 中的範例程式，在自己的測試程式碼中寫入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">items, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; items.length; index++) &#123;</span><br><span class="line">    callback(items[index]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mockCallback = jest.fn(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">42</span> + x);</span><br><span class="line">forEach([<span class="number">0</span>, <span class="number">1</span>], mockCallback);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'mock test'</span>, () =&gt; &#123;</span><br><span class="line">  expect(mockCallback.mock.calls.length).toBe(<span class="number">2</span>); <span class="comment">// mockCallback 函式應該被呼叫了 `2` 次</span></span><br><span class="line">  expect(mockCallback.mock.calls[<span class="number">0</span>][<span class="number">0</span>]).toBe(<span class="number">0</span>); <span class="comment">// mockCallback 函式第一次呼叫時第一個參數是 `0`</span></span><br><span class="line">  expect(mockCallback.mock.calls[<span class="number">1</span>][<span class="number">0</span>]).toBe(<span class="number">1</span>); <span class="comment">// mockCallback 函式第二次呼叫時第一個參數是 `1`</span></span><br><span class="line">  expect(mockCallback.mock.results[<span class="number">0</span>].value).toBe(<span class="number">42</span>); <span class="comment">// mockCallback 函式第一次呼叫時，callback 返回的值是 42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>範例程式碼中的解釋，<br>1-5 行是一般的函式。<br>7 行是透過 Jest 所提供的 <code>jest</code> 物件，透過 API <code>fn</code> 的方法，來模擬一個函式，而使用該函式會得到類似有關呼叫與傳參等等行為上的資訊。<br>8 行則是實際使用 1-5 行函式，並在 callback function 的傳參中使用了被 Mock 了的函式，因此 <code>mockCallback</code> 會記載一些關於透過 <code>fn</code> 被記錄的內容。<br>好比測試案例（Test case）中的第 11 行，<code>mockCallback</code> 裡面有被記載到被呼叫了幾次，而我們透過 <code>fn.mock.calls.length</code> 可以得到該資訊。</p>
</blockquote>
<p>上面範例中可以看到被 <code>jest.fn</code> 所 Mock 的函式，我們可以透過 <code>.mock</code> 繼續取得該函式的相關資訊，而這裡使用另一個函式來模擬：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mockAdd = jest.fn(<span class="function">(<span class="params">a, b</span>)=&gt;</span> a + b)</span><br><span class="line">mockAdd(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">mockAdd(<span class="string">'test'</span>,<span class="string">'String'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'get mock info'</span>, mockAdd.mock)</span><br></pre></td></tr></table></figure>
<p>我們將裡面的 mock console.log 出來：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  calls: [</span><br><span class="line">      [ <span class="number">1</span>, <span class="number">2</span> ],</span><br><span class="line">      [ <span class="string">'test'</span>, <span class="string">'String'</span> ]</span><br><span class="line">    ],</span><br><span class="line">  instances: [ <span class="literal">undefined</span>, <span class="literal">undefined</span> ],</span><br><span class="line">  invocationCallOrder: [ <span class="number">1</span>, <span class="number">2</span> ],</span><br><span class="line">  results:[</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'return'</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'return'</span>, <span class="attr">value</span>: <span class="string">'testString'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>從 console.log 中我們可以得知經由 jest.fn 所模擬後我們能在 mock 裡面撈到什麼：</p>
<ul>
<li><strong>calls</strong>：顯示所使用過的傳參，並且依照函式呼叫順序排列。例如：第一次的呼叫兩個傳參為 <code>[1, 2]</code>。</li>
<li><strong>instances</strong>：顯示指向經由 <code>jest.fn()</code> 創建並經過 <code>new</code> 關鍵字所創造出來的實體。但範例中沒有使用，所以兩次都是 <code>undefined</code>。</li>
<li><strong>results</strong>：顯示函式最後返回的結果。例如：第一次的呼叫最後 <code>return</code> 了一個值 <code>3</code>。</li>
<li><strong>invocationCallOrder</strong>：回傳記錄了函式呼叫次數的陣列。換言之我們可以從這個陣列中的 length 值來判斷這個函式被呼叫了幾次。</li>
</ul>
<h1 id="Mocks-Functions"><a href="#Mocks-Functions" class="headerlink" title="Mocks Functions"></a>Mocks Functions</h1><p>除了以上基礎的 Mock 之外，Jest 還有多達十多種 Mock 函式可以模擬數值上的呈現。</p>
<h2 id="模擬-return-數值"><a href="#模擬-return-數值" class="headerlink" title="模擬 return 數值"></a>模擬 return 數值</h2><ul>
<li>mockReturnValueOnce()：使 Mock 函式接下來返回的數值被強制回傳其傳參值 <strong>一次</strong>。</li>
<li>mockReturnValue()：使 Mock 函式接下來返回的數值被 <strong>強制</strong> 回傳其傳參值。<br>我們直接來看一段測試碼：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'mockFn return value'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = jest.fn()</span><br><span class="line">  <span class="built_in">console</span>.log(myMock()) <span class="comment">// undefined</span></span><br><span class="line">    mockFn</span><br><span class="line">      .mockReturnValueOnce(<span class="number">10</span>)</span><br><span class="line">      .mockReturnValueOnce(<span class="string">'x'</span>)</span><br><span class="line">      .mockReturnValue(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">console</span>.log(mockFn(), mockFn(), mockFn(), mockFn())</span><br><span class="line">  <span class="comment">// &gt; 10, 'x', true, true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
我們可以從範例中看到，不論原先 Mock function 中的處理，只要被綁定之後就會強制返回其數值。</li>
</ul>
<p>第一次看到這個 Mock 肯定會一頭霧水，因為要回傳一個寫死的值為什麼不乾脆直接寫死在斷言中呢？</p>
<p>原因是為了<strong>有效分割測試的範圍</strong>，例如我們在某段程式邏輯中，依賴到其他函式邏輯，但我們並沒有要測試那個範圍就可以這麼做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'mockFn return value'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> alwaysReturnTrue = jest.fn()</span><br><span class="line">  alwaysReturnTrue.mockReturnValue(<span class="literal">true</span>) <span class="comment">// 強制將值返回為 true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> DBdata = [<span class="number">0</span>, <span class="string">""</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未經 Mock 所返回的 filter 處理</span></span><br><span class="line">  <span class="keyword">const</span> filterFunction = DBdata.filter(<span class="function"><span class="params">data</span> =&gt;</span> data) </span><br><span class="line">  <span class="built_in">console</span>.log(filterFunction) <span class="comment">// []</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 經 Mock 所返回的 filter 處理</span></span><br><span class="line">  <span class="keyword">const</span> afterMockfilterFunction = DBdata.filter(<span class="function"><span class="params">data</span> =&gt;</span> alwaysReturnTrue(data))</span><br><span class="line">  <span class="built_in">console</span>.log(afterMockfilterFunction) <span class="comment">// [ 0, '', false ]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>範例中我們透過 <code>alwaysReturnTrue</code> 函式加上 <code>mockReturnValue(true)</code> 來將值強制返回 true，而在原先 Array.prototype.filter 邏輯當中，<code>0</code>、<code>&quot;&quot;</code>、<code>false</code> 都屬於 <code>falsy</code> 值，應該要被 filter 篩選出來，因此返回一個空陣列。</p>
<p>但如果我們想檢測如果都 <strong>通過</strong> 的情況 filter 應該要返回哪些值，這時我們就可以使用 <code>mockReturnValue(true)</code> 來將返回值都修改判定為 <code>true</code>，如此一來就可以比對經由這個 <code>filter</code> 邏輯判斷返回值的前後差異。</p>
<p>而以上就是測試替身的基礎概念以及 Jest 中 Mock 的基礎用法，在實作中可能會有不少處需要 Mock 的情況，若沒有出現上述情況的話可以先翻翻 Jest API 中有沒有專門針對的 Mock API 可以使用。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://jestjs.io/docs/zh-Hans/mock-functions" target="_blank" rel="noopener">Jest-mock</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Jest.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Jest.js</tag>
      </tags>
  </entry>
  <entry>
    <title>重新解構：無瑕的程式碼（Clean Code） Chapter 3 函式－函式語句（上）</title>
    <url>/cleancode/clean-code-a-handbook-of-agile-software-craftsmanship-004-function-statement/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/Book/Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship.jpg' width='200px' height='200px' />
</div>

<p>上回我們探討了命名的技巧，緊接著要來討論所有程式與語言幾乎都不可避免的函式！</p>
<p>這回我們要來重新檢視我們長期以來使用的函式方式，並重新解構函式本身的原貌，來探討可以怎麼使用函式會更好！</p>
<a id="more"></a>

<h1 id="為何我們需要函式"><a href="#為何我們需要函式" class="headerlink" title="為何我們需要函式"></a>為何我們需要函式</h1><p>使用函式時我們是否曾經想過：為何我們需要函式呢？我們真的有必要用它嗎？還是我們從來沒有考慮過使用它的時機呢？</p>
<p>此書的作者提及了其中一個使用函式的時機，那就是違反<strong>重複原則（DRY，Don’t repeat youself.）</strong>的時候。</p>
<p>當我們重複使用同樣程式碼的時後，我們可能付出許多代價來修改同樣的程式，這時我們就可以利用函式來將其中的概念封裝起來重複使用，藉此達到更高的效率與方便後續維護的人員能夠輕易地閱讀。</p>
<p>而對於重複程式碼的容忍度則可以遵循之前程式心法系列中所提及過的 <strong>三次原則（Rule Of Three principle）</strong>，達到一定次數的重複率再進行封裝，以避免過度的抽象來降低疑慮。</p>
<p>在有了使用函式的理由後，我們便可以開始來討論函式的細節：</p>
<h1 id="解構函式的細節"><a href="#解構函式的細節" class="headerlink" title="解構函式的細節"></a>解構函式的細節</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">parameter</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定義 function 的語句（statements）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方展示了一個簡單的宣告函式，我們可以清楚的看到函式至少包含了三個部分：</p>
<ul>
<li>函式名稱（naming）：以供辨識、呼叫用的名稱。</li>
<li>函式參數（parameter）：提供連結外部變數，傳送到內部語句的傳送參數。</li>
<li>函式語句（statements）：實際函式所執行的區域。</li>
</ul>
<p>我也將其重構原書的內容，以這三個部分重新整理內容。</p>
<h1 id="函式語句（statements）"><a href="#函式語句（statements）" class="headerlink" title="函式語句（statements）"></a>函式語句（statements）</h1><p>首先我想討論語句的部分，因為對於函式來說，當你透過程式編輯器的搜尋功能去尋找一個函式時，假如在找得到的情況下，通常最想做的事情是去觀看這函式裡面做了什麼事情，因此內部的語句是至關重要的地方。</p>
<p>而在語句（statement）之中我們可以探討的點可分為：</p>
<ul>
<li>語句類別（type）：探討函式是怎麼被開發者使用的。</li>
<li>語句結構（structure）：探討內部語句的寬度與深度。</li>
<li>語句脈絡（context）：探討內部語句的長度與敘述。</li>
</ul>
<h2 id="語句類別（type）"><a href="#語句類別（type）" class="headerlink" title="語句類別（type）"></a>語句類別（type）</h2><p>函式根據語句的處理則可分為<strong>指令型</strong>和<strong>查詢型</strong>：</p>
<h3 id="指令型（command）"><a href="#指令型（command）" class="headerlink" title="指令型（command）"></a>指令型（command）</h3><p>指令型的函式表示它將做了某件事情：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeUrlTo</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">  location.href = url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時：</span></span><br><span class="line">changeUrlTo(<span class="string">'https://www.google.com.tw'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="查詢型（query）"><a href="#查詢型（query）" class="headerlink" title="查詢型（query）"></a>查詢型（query）</h3><p>查詢型的函式表示它會回答某件事情：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> number === <span class="string">'number'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時：</span></span><br><span class="line"><span class="keyword">if</span> (isNumber(+<span class="string">'123'</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Magic! Nice job, JavaScript.'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在書中的筆者建議函式盡量不要將指令型與查詢型混合使用，否則很容易產生疑惑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAndCheckItem</span> (<span class="params">itemID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!shop[itemID]) &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line">  fetch(<span class="string">'...?itemID='</span> + itemID)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123; <span class="keyword">return</span> res.json()&#125;</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> res.data.info <span class="comment">// 回傳 &lt;object&gt;商品資料</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時：</span></span><br><span class="line"><span class="keyword">let</span> itemInfo = getAndCheckItem(<span class="string">'c8763'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(itemInfo) <span class="comment">// 無法確定回傳的資料到底是沒有此商品還是物件形式的商品資料</span></span><br></pre></td></tr></table></figure>

<h2 id="語句結構（structure）"><a href="#語句結構（structure）" class="headerlink" title="語句結構（structure）"></a>語句結構（structure）</h2><p>在語句結構的部分我們需要考量到它的深度問題，而深度最大的問題即是巢狀結構所造成的，例如一個函式中有太多的 <code>if/else</code> 結構，或是出現 <code>switch</code> 結構。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Single Page Application 假換頁</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goPage</span>(<span class="params">pipePageName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> page = pipePageName.split(<span class="string">'|'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (page[<span class="number">0</span>] === <span class="string">'main'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (page[<span class="number">1</span>] === <span class="string">'search'</span>) &#123;</span><br><span class="line">      history.pushState(<span class="string">''</span>,<span class="string">''</span>,<span class="string">'/main/search'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      history.pushState(<span class="string">''</span>,<span class="string">''</span>,<span class="string">'/main'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page[<span class="number">0</span>] === <span class="string">'contact'</span>) &#123;</span><br><span class="line">    history.pushState(<span class="string">''</span>,<span class="string">''</span>,<span class="string">'/contact'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    history.pushState(<span class="string">''</span>,<span class="string">''</span>,<span class="string">'/404'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時：</span></span><br><span class="line"><span class="keyword">let</span> searchButton = <span class="built_in">document</span>.querySelector(<span class="string">'#goSearchPage'</span>)</span><br><span class="line">searchButton.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  goPage(<span class="string">'main|search'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>往後想要增添頁面的時候，<code>goPage</code> 函式內部的結構將會成為阻礙，內部大量的判斷即便更改成 <code>switch</code> 來做也是一樣令人難以接受，並且還沒考量到要傳入 <code>pushState</code> 的參數就已經如此複雜。</p>
<p>我們將其判斷結構挪至外層，將判斷這件事情交給外面的邏輯來處理，使 <code>goPage</code> 函式專心做好它應該做的事情：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goPage</span> (<span class="params">pageName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(history.state)) || [];</span><br><span class="line">  <span class="keyword">let</span> title = <span class="built_in">document</span>.title;</span><br><span class="line">  <span class="keyword">let</span> stateFormat = &#123; <span class="attr">pageName</span>: pageName, <span class="attr">url</span>: location.href &#125;</span><br><span class="line"></span><br><span class="line">  state.push(stateFormat)</span><br><span class="line">  history.pushState(state, title, pageName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時：</span></span><br><span class="line"><span class="keyword">let</span> searchButton = <span class="built_in">document</span>.querySelector(<span class="string">'#goSearchPage'</span>)</span><br><span class="line">searchButton.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  goPage(<span class="string">'search'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我們可以發現將判斷邏輯移出後可以使得原本的 <code>goPage</code> 函式將會更加清楚，並且還補上了其他的資訊，將來還可以藉由 <code>history.state</code> 來操作如同歷史頁面的紀錄。</p>
<p>而書中筆者則是建議，我們應該避免將巢狀結構納入其中，如果真的有必要這麼處理，應該確保這個函式是處於低層次的抽象概念當中，意思即為該函式幾乎不再被使用。</p>
]]></content>
      <categories>
        <category>Book</category>
        <category>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</category>
      </categories>
      <tags>
        <tag>Book</tag>
        <tag>w3HexSchool</tag>
        <tag>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</tag>
      </tags>
  </entry>
  <entry>
    <title>重新解構：無瑕的程式碼（Clean Code） Chapter 2 有意義的命名（上）－命名心法</title>
    <url>/cleancode/clean-code-a-handbook-of-agile-software-craftsmanship-002-naming-methodology/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/Book/Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship.jpg' width='200px' height='200px' />
</div>

<p>命名，對於工程師來說是一門重要的學問，因為它無所不在。不僅除了變數與函式，廣泛到連圖片、資料夾、甚至是文章標題、標籤都得經過命名的環節。</p>
<p>好的命名，可以讓其他人清楚的瞭解它的作用、功能；壞的命名，則會讓人擁有錯誤的印象，得花更多時間來釐清原本所該敘述的內容。</p>
<p>那麼，我們要怎麼取出有意義的命名呢？</p>
<a id="more"></a>

<p>在這一章節中，作者整理了幾個概念來闡述，而其中許多的概念是可以融會貫通的。因此我以命名的心法與規則為劃分，將其重新整理：</p>
<ul>
<li>命名心法：為何這樣命名？詮釋在命名前心中所具備的前提。</li>
<li>命名規則：實際怎麼命名？遵循與避免什麼樣的規則才可以接近所謂好的命名。</li>
</ul>
<h1 id="命名的心法"><a href="#命名的心法" class="headerlink" title="命名的心法"></a>命名的心法</h1><p>在命名前，工程師可以先想想以往所碰過的程式碼是如何命名的？有沒有遇過命名實際上與本身作用不同？或是實際上做的事情比命名本身來的多？</p>
<p>而在命名心法之中，我們將試著揣測往後看到同段程式碼時，自己或他人的想法。我將其區分了幾個性質來做為解釋：</p>
<ul>
<li>闡述性</li>
<li>符合性</li>
<li>一致性</li>
</ul>
<h2 id="闡述性"><a href="#闡述性" class="headerlink" title="闡述性"></a>闡述性</h2><p>闡述性即為命名本身做了什麼。具有闡述性的命名，可以使其解釋被命名的性質、作用，讓其他人能夠瞭解原先命名者的思維。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list =  [<span class="string">'apple'</span>,<span class="string">'banana'</span>];</span><br></pre></td></tr></table></figure>

<p>較好的作法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shopping_basket =  [<span class="string">'apple'</span>,<span class="string">'banana'</span>];</span><br></pre></td></tr></table></figure>

<p>透過 <code>shopping_basket</code> 來取代 <code>list</code>，讓後續閱讀的人可以知道這個陣列內容其實代表的是什麼。</p>
<h2 id="符合性"><a href="#符合性" class="headerlink" title="符合性"></a>符合性</h2><p>與闡述性的概念相近，但符合性更在意的是命名不只是解釋（explain），更是命名本身要能夠符合（match）背後的意義，才能避免解釋反而誤導了它人。以下舉例如果命名只具備了闡述，但不具備符合性時會發生什麼事情？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位於某個檔案中的函式呼叫</span></span><br><span class="line">getBook(<span class="function"><span class="keyword">function</span> (<span class="params">book</span>)) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(book) <span class="comment">// 預期會返回某個書籍的詳細資料</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一處檔案中，被呼叫的函式本身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBook</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'某個書籍清單'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> callback(res)) <span class="comment">// 只有回傳書籍清單，並沒有詳細資料</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程式呈現了一個預期從回呼函式（callback function）中拿到書籍的詳細資料，結果返回的是一個書籍的清單資料。</p>
<p>的確 <code>getBook</code> 函式解釋了拿取書籍有關的內容，但它並沒有說明拿的應該是什麼，因此名稱不完全符合它背後所做的事情。</p>
<p>而顯而易見的是我們可以讓命名再加上符合它所做的事情來解決這個問題。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得書籍清單的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBookList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得含有書籍詳細資料的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBookDetail</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>命名的一致性則是在說明同個概念、想法、作用的名稱，應該盡量用同個命名來代表它，不要用兩個或多個以上的詞彙。</p>
<p>如果命名時不考慮到一致性的話，影響的是下一個接手維護的人（甚至是半年後的自己）無法連貫。例如下列程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位於某個檔案中的資料來源</span></span><br><span class="line"><span class="keyword">let</span> member = [&#123;</span><br><span class="line">  name: <span class="string">'xxx'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位於某個檔案中的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAccountInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 裡面操作有關於 member 變數中的內容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在這段程式碼中，你可能會好奇 <code>account</code> 與 <code>member</code> 之間的不同點在哪？甚至如果後續維護的時候又不慎出現了一個被命名為 <code>getMemberInfo</code>　的函式時會有多頭痛。</p>
<p>因此我們將有關於同個概念的內容修改一致：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位於某個檔案中的資料來源</span></span><br><span class="line"><span class="keyword">let</span> member = [&#123;</span><br><span class="line">  name: <span class="string">'xxx'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位於某個檔案中的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMemberInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 裡面操作有關於 member 變數中的內容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一來我們可以透過名稱就能大概猜想這個函式與資料物件是有關聯的。</p>
<p>這章節整理了比較偏向心法方面的設計理念，而下一篇將會整理有關於命名實際上的規則與做法。</p>
]]></content>
      <categories>
        <category>Book</category>
        <category>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</category>
      </categories>
      <tags>
        <tag>Book</tag>
        <tag>w3HexSchool</tag>
        <tag>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</tag>
      </tags>
  </entry>
  <entry>
    <title>重新解構：無瑕的程式碼（Clean Code）書序 及 Chapter 1 無暇的程式碼</title>
    <url>/cleancode/clean-code-a-handbook-of-agile-software-craftsmanship-001-intro/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/Book/Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship.jpg' width='200px' height='200px' />
</div>

<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>經過一段時間終於有機會再把它拿出來拜讀了！這本由 <strong>Robert C. Martin（Uncle Bob）</strong> 所撰寫的著作，為 《Agile software development principles patterns and practices.》（敏捷軟件開發）一書的前傳。而無暇的程式碼（Clean Code）究竟表示的是什麼？我想推薦序一文做了非常良好的解釋：</p>
<a id="more"></a>

<blockquote>
<p><em>“God is in the details.” -Ludwig Mies van der Rohe 「神就藏在細節裡面。」</em></p>
</blockquote>
<p>在推薦序中，<strong>James O. Coplien</strong> 引用了建築大師 <strong>Ludwig Mies van der Rohe</strong> 的這句名言來開場。描述程式開發，如同是在處於建築行業一般，我們在開發程式中每個環節，其實就如同在蓋房時所堆砌的一磚一瓦一樣，要成為建築大師、優良的程式開發人員，我們必須小心謹慎地對待每個角落。好比在 <strong>變數命名</strong> 議題上，我們總是對待變數得像是對待自己的小孩一般，不會隨意取下它們的姓名。</p>
<p>但真正在面相專案中的程式開發時，我們是否會受到時程開發、臨時需求變動等等需求，而影響到了這些想法？還是能像日本維護的優良方針（Total Productive Maintenance）中，身美（Shutsuke）概念一樣 <strong>保持堅守自身的信念</strong>？</p>
<blockquote>
<p>身美（Shutsuke）在日本維護優良方針中表示，在工作實踐的過程中，能夠遵守紀律、並無時無刻的反省自身在任務上是否能有改善之處。</p>
</blockquote>
<p>我想就 <strong>James O. Coplien</strong> 所引用的另一句丹麥諺語所說的一樣：</p>
<blockquote>
<p>丹麥諺語：<br>“Ærlighed i små ting er ikke nogen lille ting.” <em>「在小事情上誠實不是一件小事情。」</em></p>
</blockquote>
<p>當我們在小事都能夠堅守信念時，在大事上就不致馬虎了。<del>有夢最美希望相隨</del></p>
<h1 id="為什麼我們需要無瑕的程式碼？"><a href="#為什麼我們需要無瑕的程式碼？" class="headerlink" title="為什麼我們需要無瑕的程式碼？"></a>為什麼我們需要無瑕的程式碼？</h1><p>在寫得非常精闢的序文之後，隨即進入了第一章節 <strong>無瑕的程式碼</strong>，而第一章正是描述為什麼我們會需要無瑕的程式碼。</p>
<p>在實際開發過程中，比起撰寫真正提交出去的程式碼，我們更多時間是花費在<strong>閱讀之前的程式碼</strong>，我們從閱讀之前專案中留下來的程式碼，來暸解<strong>前開發者的思維與開發架構</strong>；或是來維護前幾個月、甚至是幾週前<strong>由自己所撰寫</strong>的程式碼。我們總是盡可能模仿裡面的味道，再來烹飪出類似的料理，好讓後續接手維護的人員，能夠品嘗到一手好菜。</p>
<blockquote>
<p><em>有時候並非是因為我們擁有強大的閱讀能力，而是厲害的開發者能端出五星級的料理，讓其他人輕易讓品嚐其中的滋味。</em></p>
</blockquote>
<p>如果我們若不這麼做、迫於專案時程關係，或是不慎端出了臭味道的料理怎麼辦？有些經驗的程式開發者可能已經透過了<del>惡劣的</del>環境來學習過了。如前面所說，我們花費在閱讀程式碼的時間已經隨著專案的大小，長得越來越大，閱讀時間也可能從短短的幾分鐘，進化到弄了一小時才解決，而<strong>越雜亂的程式碼也將花費更多的時間來去維護</strong>。<br></p>
<blockquote>
<p>童子軍原則：讓你所到之處，離開後比原先來得更加乾淨</p>
</blockquote>
<p>如同營地一般，某個專案中的程式可能已經歷經了一段風霜。不論當初撰寫專案的人是誰，我們所及之處的程式碼，最終應該都必須保持乾淨，在將來後續維護時，才不會受到歷史的阻礙。</p>
<p><del>當然，你也可以選擇重構或死亡，但在不重構的前提下，我們還是能做很多事的。</del></p>
<h1 id="重新解構再重構"><a href="#重新解構再重構" class="headerlink" title="重新解構再重構"></a>重新解構再重構</h1><p>標題中所提到重新解構再重構的意思是：這系列的文章拜讀，不會只是閱讀書本的心得文章而已，我所希望的是能藉由自己的思維將其內容重新解構再重構，透過這樣的方式訓練自己的思維，組合出屬於我自己的脈絡。</p>
<p>其中，解構的部分並不會打亂整本書的章節，因為我認為作者這樣規劃有其中的含意，而且如果我這麼做的話，也就喪失了許多原書的大脈絡；因此，解構的部分會縮小至章節的內容，讓整個系列的文章有如每個原書章節中的再譯版本，希望使有閱讀過此書的讀者也能夠有新的讀書體驗。</p>
<p>當然，如果你從來沒看過這本書的話，我仍然很推薦你一定要看過一次原書。</p>
<p>而在下一章開始，此系列文章將會從程式中最重要的部分－－命名（naming）部分，開始講起！</p>
]]></content>
      <categories>
        <category>Book</category>
        <category>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</category>
      </categories>
      <tags>
        <tag>Book</tag>
        <tag>w3HexSchool</tag>
        <tag>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js Why D3.js： D3.js 是什麼？</title>
    <url>/d3.js/D3-001-why-d3js/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<p>今天開始要進入到 D3.js 的單元啦，在進入 D3.js 的常用 API 章節前，我們一樣要先來介紹一下 D3.js：</p>
<a id="more"></a>

<blockquote>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190918/20119062xiIiM2NaBx.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190918/20119062xiIiM2NaBx.jpg"><br><del>絕對不是這個 D3，但有機會的話或許也可以介紹（？</del></p>
</blockquote>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190918/20119062fyOApfWwWF.png" alt="https://ithelp.ithome.com.tw/upload/images/20190918/20119062fyOApfWwWF.png"></p>
<h2 id="D3-js"><a href="#D3-js" class="headerlink" title="D3.js"></a>D3.js</h2><p>這個才是我們今天的主角 D3.js，D3.js 全名（<strong>D</strong>ata-<strong>D</strong>riven <strong>D</strong>ocuments），即為<strong>資料驅動文件</strong>，而其中的資料所驅動的文件，則是我們很熟悉的 <strong>DOM（Document Object Model）</strong>，與同樣為操作 DOM 的 JavaScript 函式庫 jQuery 有許多相似的概念與用法：</p>
<ul>
<li>兩者同樣都是在操作 <strong>DOM</strong> 的新增修改刪除</li>
<li>兩者同樣都採用了<strong>鍊式語法（chain syntax）</strong></li>
<li>D3.js 選擇器（selector）向 jQuery 選擇器看齊</li>
</ul>
<p>以上三點在實際使用 D3.js 便能深刻感受到他們類似的地方，所以有寫過 jQuery 的開發者們學習 D3.js 會更容易上手。不同的地方在於， D3.js 最主要是關注在<strong>資料視覺化</strong>（Data Visualization）的部分，我們可以透過 D3.js 來將資料轉化為視覺圖表，例如像是：</p>
<p>將資料繪製成簡單的<strong>圓餅圖</strong>：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190918/201190628OQTGlFrhY.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190918/201190628OQTGlFrhY.jpg"></p>
<p>甚至是程式語言列表的<strong>文字雲</strong>：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190918/20119062QEaKxTyJA7.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190918/20119062QEaKxTyJA7.jpg"></p>
<p>而這些由 D3.js 製成的圖表，由於是基於支援瀏覽器的 JavaScript 語言所製作而成的，因此開發者可以透過已經熟稔的 HTML、CSS 以及 JavaScript 技術，搭配 SVG 或 Canvas 標籤產生對應的元素後，來動態操作這些視覺圖表，讓圖表不在只是死板板的一張圖，更可以是一個富有相關資訊的多功能圖表。</p>
<blockquote>
<p>其中在台灣目前較為多人知曉的專案 <a href="http://budget.g0v.tw/budget" target="_blank" rel="noopener">零時政府-中央政府總預算視覺化</a> 便是由 D3.js 所製成的。</p>
</blockquote>
<h2 id="Why-D3-js"><a href="#Why-D3-js" class="headerlink" title="Why D3.js?"></a>Why D3.js?</h2><p><strong>這一類製作圖表的 JavaScript 函式庫並不是只有 D3.js，為何我們要選擇他呢？</strong></p>
<p>除了 D3.js 之外，這類以<strong>資料視覺化</strong>為主的 JavaScript 函式庫還有 Chart.js、C3.js、Echarts、CanvasJS……等等，為何要特別挑選 D3.js 的理由則是在於 D3.js <strong>富有高度的自由性</strong>，開發者可以透過 D3.js 的 API 繪製出各種點線面的圖，配合 DOM 圖層的概念與操作，來實現其他函式庫較難以做到的功能，但副作用也是在於它的高度自由性，一開始接觸 D3.js 需要多花一點時間來熟悉他的概念與文件，但等到熟悉 D3.js 之後就會對於他的方便與自由感到驚嘆！所以如果有興趣想要製作<strong>可以在網頁上與使用者互動的高度客製化動態圖表</strong>，不彷來訂閱一波吧！</p>
<blockquote>
<p>D3.js 的魅力如同黑黑漩渦一樣令人深陷而不能自拔。<br> <img src="https://ithelp.ithome.com.tw/upload/images/20190919/20119062HIUjY2oBLF.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190919/20119062HIUjY2oBLF.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 重新認識圖表</title>
    <url>/d3.js/D3-003-recognize-chart/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="對於圖表的認知"><a href="#對於圖表的認知" class="headerlink" title="對於圖表的認知"></a>對於圖表的認知</h2><p>開發者學習 D3.js 的理由可能有很多種，有人可能是為了自己<strong>興趣</strong>、也有人可能是為了<strong>專案需求</strong>，不論出發點在哪，最終 D3.js 目標都是在<strong>產出圖表給使用者看</strong>，因此圖表實際的意涵<strong>是否能達到我們要訴說的</strong>便是我們所要關切的地方。若開發者對於圖表的認知不足，即使製作出來的圖表有對應資料，並且使用了較為困難的技術來呈現，<strong>對於使用者來說</strong>也只是個無效的資訊。</p>
<a id="more"></a>

<h2 id="圖表種類"><a href="#圖表種類" class="headerlink" title="圖表種類"></a>圖表種類</h2><p>對於圖表的認知與呈現上要有所精進，最簡單的方式就是先認識<strong>圖表類型</strong>有哪些，並且知道各圖表所想要<strong>強調的資訊</strong>在哪，進而才在圖表上做一些補強，而以下將介紹幾種最常見的圖表：</p>
<h3 id="長條圖-Bar-Chart"><a href="#長條圖-Bar-Chart" class="headerlink" title="長條圖 Bar Chart"></a>長條圖 Bar Chart</h3><p><img src="https://ithelp.ithome.com.tw/upload/images/20190921/20119062DXISTs8RoJ.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190921/20119062DXISTs8RoJ.jpg"><br>（英文單字使用字母頻率表 圖源來至 D3.js official website）</p>
<p>長條圖一般使用在<strong>二維的資料處理</strong>，其中一軸用來表示<strong>資料的類別</strong>，而長條的長度則表示<strong>該項資訊的大小</strong>，最常使用在於<strong>資料間的相互比較</strong>。</p>
<p>若類別軸資訊是屬於連續的資料（如年份、月份），則可以看出連續的資料趨勢，但可以使用折線圖可能較好表達。</p>
<p>若要表達三維的資訊則可以透過長條的寬度來顯示，但同樣會使得資訊較為混亂，也是要慎選處理。</p>
<blockquote>
<p>變化、相似圖型：堆積長條圖、雙向長條圖、百分比長條圖……等等</p>
</blockquote>
<h3 id="圓餅圖-Pie-Chart"><a href="#圓餅圖-Pie-Chart" class="headerlink" title="圓餅圖 Pie Chart"></a>圓餅圖 Pie Chart</h3><p><img src="https://ithelp.ithome.com.tw/upload/images/20190921/20119062OlFBnOYBz6.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190921/20119062OlFBnOYBz6.jpg"><br>（2015 美國人口年齡分布 圖源來至 D3.js official website）</p>
<p>圓餅圖一般用於比較<strong>資料的比例大小</strong>，通常會輔以其他數字資訊來搭配（如附註百分比比例），而若是資料之間比例如果差異不大的話，使用這個圖表將會難以看出差異。</p>
<blockquote>
<p>變化、相似圖型：玫瑰圖、環形圖、旭日圖</p>
</blockquote>
<h3 id="散點圖-Scatter-Chart"><a href="#散點圖-Scatter-Chart" class="headerlink" title="散點圖 Scatter Chart"></a>散點圖 Scatter Chart</h3><p><img src="https://ithelp.ithome.com.tw/upload/images/20190921/20119062gLfzdj0YEP.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190921/20119062gLfzdj0YEP.jpg"><br>（燃油效率與馬力散點圖 圖源來至 D3.js official website）</p>
<p>散點圖可以用來表示三維的資料處理，如附圖中<code>燃油效率</code>與<code>馬力</code>各為 X 軸與 Y 軸，而各家汽車廠商品牌資料則是透過點來對應前兩項資訊，散點圖可以用<strong>強調視覺上的資料呈現何種的關係取向</strong>（如正相關、負相關等等），而<strong>實際上是否相關仍須以統計計算來判斷</strong>。</p>
<blockquote>
<p>變化、相似圖型：氣泡圖</p>
</blockquote>
<h3 id="折線圖-Line-Chart"><a href="#折線圖-Line-Chart" class="headerlink" title="折線圖 Line Chart"></a>折線圖 Line Chart</h3><p><img src="https://ithelp.ithome.com.tw/upload/images/20190921/20119062isRTSm4IZH.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190921/20119062isRTSm4IZH.jpg"><br>（Apple 股票市值折線圖 圖源來至 D3.js official website）</p>
<p>折線圖與長條圖類似，但更強調於<strong>連續的資料走勢</strong>，透過其中一軸的資料變化（如時間）來觀測固定軸（如商品名稱）的資料變化。</p>
<blockquote>
<p>變化、相似圖型：面積圖、堆積面積圖、百分比面積圖……</p>
</blockquote>
<p>而其餘的圖表還有：</p>
<ul>
<li>熱圖</li>
<li>地圖</li>
<li>雷達圖</li>
<li>儀表圖</li>
<li>瀑布圖</li>
<li>桑葚圖</li>
<li>和弦圖</li>
<li>族繁不及備載</li>
</ul>
<p>以上是今天認識圖表的章節，章節雖簡單卻重要，瞭解資料適合以何種圖表呈現之後，再來決定圖表要做哪些修正與改良，才不會落得使用一手好技術使用者卻不以為意的窘境，而明天將開始介紹使用 D3.js 的基礎用法與繪製簡單圖型。</p>
<blockquote>
<p>每日一貓：黑黑表示我來看看你最近到底在打蝦米碗糕……<br><img src="https://ithelp.ithome.com.tw/upload/images/20190921/20119062lUJiSgzUz7.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190921/20119062lUJiSgzUz7.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 環境建置</title>
    <url>/d3.js/D3-002-build/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="渲染範圍"><a href="#渲染範圍" class="headerlink" title="渲染範圍"></a>渲染範圍</h2><p>使用樣本語法時，我們可以在 HTML 中使用<strong>兩對花括號</strong>來表示要顯示的資料，並且透過 Vue.js 實體中的 <code>el</code> 來指定 Vue.js 渲染的範圍，並且在子元件的 <code>template</code> 中同樣也可以使用，然而如果是在 HTML 中的子元件標籤裡<strong>直接使用則會導致失效</strong>，如下面範例：</p>
<a id="more"></a>

<p>HTML部分：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span><span class="template-variable">&#123;&#123; childMessage &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>JavaScript部分：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:`<span class="symbol">&lt;div&gt;</span>&lt;/div&gt;`,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    message : <span class="string">'parent component'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後樣板語法將不會顯示任何資料。（這並非是什麼 BUG，而是 Vue.js 預設的渲染。）</p>
<h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><p>假使想要在子元件標籤中放些自定義的文字或內容，可以透過 <code>&lt;slot&gt;</code> 標籤來達成，我們試著將上面的元件稍微改寫一下：</p>
<p>JavaScript 部分：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.component</span>(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  <span class="attribute">template</span>:</span><br><span class="line">  `</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt; // 加入 slot 標籤</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line">  <span class="selector-tag">data</span>()&#123;</span><br><span class="line">    <span class="selector-tag">return</span> &#123;</span><br><span class="line">      <span class="attribute">childMessage </span>: <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>HTML 部分：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span><span class="xml"> //這裡的message 將會傳入父元件的資料物件</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>這樣將會使得在 <code>&lt;child-element&gt;&lt;/child-element&gt;</code> 標籤中的資料，傳入到子元件裡的<code>&lt;slot&gt;&lt;/slot&gt;</code>的位置，將其替換掉。並且我們可以也可以傳入 HTML 元素、甚至是其他的元件以及父元件的資料物件：</p>
<p><strong>注意</strong>當使用這樣的方法在子元件內使用樣板語法傳入資料，此時傳入的資料將會是<strong>父元件的資料物件</strong>，若要使用子元件的資料物件，仍然只能在子元件的<code>template</code>中去呼叫。</p>
<p>而當我們使用 <code>&lt;slot&gt;</code> 後，若沒有 HTML 部分中所綁定的元件中傳入資訊，則預設將會顯示<code>&lt;slot&gt;&lt;/slot&gt;</code>所包含的資料：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:</span><br><span class="line">  `</span><br><span class="line">  <span class="symbol">&lt;div&gt;</span></span><br><span class="line">    <span class="symbol">&lt;slot&gt;</span>Hello Vue!&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    message : <span class="string">'parent component'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後顯示的結果會是 <code>&lt;div&gt;Hello Vue!&lt;/div&gt;</code>。</p>
<h2 id="指定slot"><a href="#指定slot" class="headerlink" title="指定slot"></a>指定slot</h2><p>當今天 <code>slot</code> 所要傳入的對象越來越多時，可以透過指定插入的方式去分配 <code>slot</code> 要怎麼對應資料，方法是在子元件中使用 <code>template</code> 標籤並加上<code>v-slot</code>屬性，<code>v-slot</code>的值會對應到的是 <code>slot</code> 標籤的 <code>name</code> 屬性，這樣一來當我們有需要放多個 <code>slot</code> 時就不必擔心對應位置的問題，範例如下：</p>
<p>HTML部分：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:first</span>&gt;</span>First<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:second</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:third</span>&gt;</span>Third<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>JavaScript部分：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:</span><br><span class="line">  `</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"first"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"second"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"third"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  `,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = new Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    message : <span class="string">'parent component'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後 HTML 部分子元件的內容將會對應的傳入子元件中，並顯示出來。而這個 API 好用的地方在於今天有個元件我們純粹只是想要更換部分的顯示內容，就可以在父元件引入該子元件，並且透過 <code>v-slot</code> 直接傳入子元件中，而不用資料整筆 props 進去再接出來。</p>
<p>以上是目前 Vue.js 的最後一章節，而實作的部分將會等到我們以 Vue-cli 創建環境時，再搭配 D3.js 一起介紹！</p>
<blockquote>
<p>隨文附上今日的黑黑，據家人說他今天在同個地方躺了連續八小時 ( XD???<br><img src="https://ithelp.ithome.com.tw/upload/images/20190917/20119062Gz4i7Zt1Ic.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190917/20119062Gz4i7Zt1Ic.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 如何繪製圖形？</title>
    <url>/d3.js/D3-004-how-d3-draw/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<p>今天要來介紹 D3.js 如何繪製圖形，而其實 D3.js <strong>本身程式並不會繪圖</strong>，嚴格來說是藉由操作 <strong>HTML DOM</strong> 來達到<strong>新增修改刪除</strong>等功能，而<strong>實際繪製圖形</strong>的部分則是會依靠 <strong>SVG</strong> 來產生，這裡要來稍微介紹一下這些名詞來幫助大家更快理解 D3.js 是怎麼運作的：</p>
<a id="more"></a>

<h2 id="DOM（Document-Object-Model）"><a href="#DOM（Document-Object-Model）" class="headerlink" title="DOM（Document Object Model）"></a>DOM（Document Object Model）</h2><p><img src="https://ithelp.ithome.com.tw/upload/images/20190921/201190628ubodsiOQU.png" alt="https://ithelp.ithome.com.tw/upload/images/20190921/201190628ubodsiOQU.png"></p>
<p>DOM 簡單來說是一種 HTML、XML、SVG 的程式介面，我們可以<strong>透過這個介面來操作 HTML 上的節點</strong>，如附圖中展示的是當 <code>table</code> 元素與裡面的內容以 DOM 樹狀圖結構描述時的樣子，<code>table</code> 底下包了一個子節點 <code>rows</code>，而 <code>rows</code> 底下又有兩項 <code>tr</code> 節點，往下延伸最後可以看到最左邊則是 <code>td</code> 節點裡面放入了一個文字節點 <code>Shady Grove</code>，這個文件在 HTML 程式中則相當於：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rows</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Shady Grove<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Aeollan<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Over the River, Charlie<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Dorian<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rows</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="SVG（Scalable-Vector-Graphics）"><a href="#SVG（Scalable-Vector-Graphics）" class="headerlink" title="SVG（Scalable Vector Graphics）"></a>SVG（Scalable Vector Graphics）</h2><p>SVG 主要是用來描述<strong>平面圖形的一種格式</strong>，並且是以 <strong>XML 格式</strong>來描述，因此開發者可以直接在 HTML 檔案中使用 SVG，下面以一段簡單的 SVG 程式碼來說明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;svg xmlns=<span class="string">"http://www.w3.org/2000/svg"</span> version=<span class="string">"1.1"</span> </span><br><span class="line">    width=<span class="string">"450"</span> height=<span class="string">"450"</span>&gt;</span><br><span class="line">  &lt;rect x=<span class="string">"0"</span> y=<span class="string">"0"</span> width=<span class="string">"100"</span> height=<span class="string">"100"</span> fill=<span class="string">"blue"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure>

<p>在這段程式碼中可以看到要在 HTML 中使用 SVG，首先要使用 SVG 標籤來，並且在屬性中定義渲染的範圍與基本的文件說明與版本，接著在標籤內容放入要繪製的圖形標籤以及相關的位置、寬高以及填入的顏色等等。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190922/20119062ehXvPXwJ6G.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190922/20119062ehXvPXwJ6G.jpg"></p>
<p>如此一來，瀏覽器就會依照其 DOM 結構來繪製圖形（如上方），而我們也能透過 JavaScript 來操作這些 HTML DOM，至於 D3.js 提供的功能便是<strong>一系列操作這些圖形介面 DOM 的方法集</strong>給我們使用，透過包裝好的函式，我們可以更快速、方便的去取得這些內容與新增修改。</p>
<p>而目前 SVG 的標籤有以下幾種：</p>
<ul>
<li>圓形 <code>&lt;circle&gt;</code></li>
<li>橢圓形 <code>&lt;ellipse&gt;</code></li>
<li>矩形 <code>&lt;rect&gt;</code></li>
<li>線條 <code>&lt;line&gt;</code></li>
<li>折線 <code>&lt;polyline&gt;</code></li>
<li>多邊形 <code>&lt;polygon&gt;</code></li>
<li>路徑 <code>&lt;path&gt;</code></li>
</ul>
<p>明天我們則會繼續介紹這幾種基本圖形在 SVG 中要如何設定！</p>
<blockquote>
<p>今日一貓：最近黑黑每天都在找新的地方可以趴著，從南趴到北在從北趴到南的那種<br><img src="https://ithelp.ithome.com.tw/upload/images/20190922/20119062DmPChMevas.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190922/20119062DmPChMevas.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
        <tag>SVG</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js SVG 基本圖型繪製（續）</title>
    <url>/d3.js/D3-005-svg-draw-2/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<p>SVG 除了基本的圖形繪製之外，另外還可以做到繪製文字、更改樣式、等等功能，今天我們將要來看看還有哪些功能沒介紹到的部分：</p>
<h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>SVG 中有提供一個 <code>text</code> 標籤以供我們繪製文字的部分：</p>
<ul>
<li><code>x</code> ：文字左上角的 X 座標。</li>
<li><code>y</code> ：文字左上角的 Y 座標。</li>
<li><code>dx</code> ：以 <code>x</code> 座標為基準，平行移動文字距離（正為往右，負為往左）。</li>
<li><code>dy</code> ：以 <code>y</code> 座標為基準，垂直移動文字距離（正為往上，負為往下）。</li>
<li><code>textLength</code> ：文字字距。</li>
<li><code>rotate</code> ：<strong>每個文字</strong>的旋轉角度。（若是要整組文字一起旋轉可以使用 <code>transform=&quot;rotate()&quot;</code> 。）</li>
</ul>
<a id="more"></a>

<p>範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">height</span>=<span class="string">"50"</span> <span class="attr">width</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">"20"</span> <span class="attr">y</span>=<span class="string">"20"</span> <span class="attr">fill</span>=<span class="string">"red"</span> <span class="attr">rotate</span>=<span class="string">"180"</span> <span class="attr">transform</span>=<span class="string">"rotate(30 20,40)"</span>&gt;</span>SVG<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>呈現結果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190924/20119062o2JJVfwDpH.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190924/20119062o2JJVfwDpH.jpg"></p>
<h2 id="基本樣式"><a href="#基本樣式" class="headerlink" title="基本樣式"></a>基本樣式</h2><p>SVG 的樣式幾乎都能夠依照我們所熟悉的 CSS 來使用，只是開發時需要依照 SVG 標籤定義好的樣式屬性來編寫樣式表，下面列出幾個比較不常出現的樣式屬性：</p>
<ul>
<li><code>fill</code> ：圖形內部顏色。</li>
<li><code>stroke</code> ：圖形邊框顏色。</li>
<li><code>stroke-width</code> ：圖形邊框寬度。</li>
<li><code>stroke-linecap</code> ：輪廓線兩端的樣式（可設為直角、圓角）。</li>
<li><code>stroke-dasharray</code> ：輪廓線條樣式（實線、虛線……等等）。</li>
</ul>
<p>範例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">&lt;svg <span class="built_in">height</span>=<span class="string">"30"</span> <span class="built_in">width</span>=<span class="string">"200"</span>&gt;</span><br><span class="line">    &lt;path <span class="built_in">stroke</span>=<span class="string">"black"</span> <span class="built_in">stroke</span>-<span class="built_in">width</span>=<span class="string">"4"</span> <span class="built_in">stroke</span>-dasharray=<span class="string">"5,5"</span> d=<span class="string">"M0 10 l200 0"</span> /&gt;</span><br><span class="line">    &lt;path <span class="built_in">stroke</span>=<span class="string">"black"</span> <span class="built_in">stroke</span>-<span class="built_in">width</span>=<span class="string">"6"</span> <span class="built_in">stroke</span>-dasharray=<span class="string">"10,10"</span> d=<span class="string">"M0 25 l200 0"</span> /&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>呈現結果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190924/20119062PQy5MXmhCn.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190924/20119062PQy5MXmhCn.jpg"></p>
<h2 id="定義樣式"><a href="#定義樣式" class="headerlink" title="定義樣式"></a>定義樣式</h2><p>在 SVG 中還有一些樣式需要<strong>先定義</strong>後才能使用的，而這些內容最後都會放在一個 <code>&lt;defs&gt;</code> 標籤當中，在 <code>&lt;defs&gt;</code> 這個標籤中，除了用來定義樣式外，最主要的功用是可以將其定義的樣式內容<strong>重覆給予其他圖形標籤作為使用</strong>，而以下為需要放在定義標籤中作為使用的樣式：</p>
<h3 id="濾鏡"><a href="#濾鏡" class="headerlink" title="濾鏡"></a>濾鏡</h3><p>常使用 CSS 開發的人應該多少有用過 <code>filter</code> 這個 CSS 屬性，而在 SVG 中也可以使用類似的功能，而樣式標籤名稱正也是 <code>&lt;filter&gt;</code> 。</p>
<p>使用方法也很簡單，在 <code>&lt;defs&gt;</code> 標籤中，放入 <code>&lt;filter&gt;</code> 標籤並輸入 <code>id</code> 屬性以供接指定，接著在子層中放入濾鏡標籤（濾鏡標籤可參考<a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter#See_also" target="_blank" rel="noopener"> MDN </a>上的列表）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">id</span>=<span class="string">"Blur"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">feGaussianBlur</span> <span class="attr">in</span>=<span class="string">"SourceGraphic"</span> <span class="attr">stdDeviation</span>=<span class="string">"5"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最後在使用圖形標籤時，在 <code>filter</code> 屬性中，使用 <code>url</code> 來指定剛剛定義好的樣式及可套用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">width</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">id</span>=<span class="string">"Blur"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">feGaussianBlur</span> <span class="attr">in</span>=<span class="string">"SourceGraphic"</span> <span class="attr">stdDeviation</span>=<span class="string">"5"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">"50"</span> <span class="attr">y</span>=<span class="string">"50"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>  <span class="attr">stroke-width</span>=<span class="string">"3"</span> <span class="attr">fill</span>=<span class="string">"blue"</span> <span class="attr">filter</span>=<span class="string">"url(#Blur)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>呈現結果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190924/20119062m0NRzIXNEV.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190924/20119062m0NRzIXNEV.jpg"></p>
<h3 id="漸層"><a href="#漸層" class="headerlink" title="漸層"></a>漸層</h3><p>漸層的標籤可分為線性漸層 <code>&lt;linearGradient&gt;</code> 以及放射性漸層 <code>&lt;radialGradient&gt;</code> ，使用上兩者大同小異，最主要是最後呈現結果的不同。</p>
<p>在 <code>Gradient</code> 標籤的屬性中，可以透過 <code>X</code> 與 <code>Y</code> 去定義漸層顏色的起點與終點：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">"linearGradient"</span> <span class="attr">x1</span>=<span class="string">"0%"</span> <span class="attr">y1</span>=<span class="string">"0%"</span> <span class="attr">x2</span>=<span class="string">"100%"</span> <span class="attr">y2</span>=<span class="string">"0%"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>並在內層中可以放入 <code>&lt;stop&gt;</code> 標籤，透過 <code>offset</code> 屬性來指定漸層位置，style 中的 <code>stop-color</code> 則可以用來指定該位置的顯示顏色：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"0%"</span> <span class="attr">style</span>=<span class="string">"stop-color:rgb(255,0,0);stop-opacity:1"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>完整範例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">width</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">"linearGradient"</span> <span class="attr">x1</span>=<span class="string">"0%"</span> <span class="attr">y1</span>=<span class="string">"0%"</span> <span class="attr">x2</span>=<span class="string">"100%"</span> <span class="attr">y2</span>=<span class="string">"0%"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"0%"</span> <span class="attr">style</span>=<span class="string">"stop-color:rgb(255,0,0);stop-opacity:1"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"50%"</span> <span class="attr">style</span>=<span class="string">"stop-color:rgb(255,255,0);stop-opacity:1"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"100%"</span> <span class="attr">style</span>=<span class="string">"stop-color:rgb(0,255,255);stop-opacity:1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">"100"</span> <span class="attr">cy</span>=<span class="string">"100"</span> <span class="attr">rx</span>=<span class="string">"75"</span> <span class="attr">ry</span>=<span class="string">"50"</span> <span class="attr">fill</span>=<span class="string">"url(#linearGradient)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>呈現結果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190924/20119062nE5Uo8ixmi.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190924/20119062nE5Uo8ixmi.jpg"></p>
<h3 id="標記"><a href="#標記" class="headerlink" title="標記"></a>標記</h3><p>標記主要可以用來繪製線段上的箭頭，藉由 <code>&lt;marker&gt;</code>標籤來定義相關屬性：</p>
<ul>
<li><code>viewBox</code> ：用來定義 <code>marker</code> 內繪製圖形的比例（概念好比從五樓陽台上看陸地上的行人與從二十樓陽台上看的差別）。</li>
<li><code>refX</code>、<code>refY</code> ：繪製時從該點（如起點或終點）延伸成坐標系，再將 <code>viewBox</code> 所設定好的圖形放在此點上。</li>
<li><code>markerWidth</code>、<code>markerHeight</code> ：標記圖形顯示的寬高。</li>
<li><code>markerUnits</code> ：指定標記大小的參考對象（如線的寬度 <code>strokeWidth</code>）。</li>
</ul>
<p>而在圖形標籤中，則可以藉由 <code>marker-start</code> 、<code>marker-mid</code> 及 <code>marker-end</code> 來將上方製作好的標記放入線段的起點、中點以及結尾的部分。</p>
<p>範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">marker</span> <span class="attr">id</span>=<span class="string">"m1"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 100 100"</span> <span class="attr">refX</span>=<span class="string">"25"</span> <span class="attr">refY</span>=<span class="string">"25"</span> <span class="attr">markerWidth</span>=<span class="string">"20"</span> <span class="attr">markerHeight</span>=<span class="string">"50"</span> <span class="attr">orient</span>=<span class="string">"auto"</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">"25"</span> <span class="attr">cy</span>=<span class="string">"25"</span> <span class="attr">rx</span>=<span class="string">"25"</span> <span class="attr">ry</span>=<span class="string">"50"</span> <span class="attr">fill</span>=<span class="string">"black"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">marker</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">marker</span> <span class="attr">id</span>=<span class="string">"m2"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 100 100"</span> <span class="attr">refX</span>=<span class="string">"50"</span> <span class="attr">refY</span>=<span class="string">"22"</span> <span class="attr">markerWidth</span>=<span class="string">"50"</span> <span class="attr">markerHeight</span>=<span class="string">"20"</span> <span class="attr">orient</span>=<span class="string">"auto"</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">"25"</span> <span class="attr">cy</span>=<span class="string">"25"</span> <span class="attr">rx</span>=<span class="string">"50"</span> <span class="attr">ry</span>=<span class="string">"25"</span> <span class="attr">fill</span>=<span class="string">"black"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">marker</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">"25,25 100,100"</span> <span class="attr">fill</span>=<span class="string">"none"</span> <span class="attr">stroke</span>=<span class="string">"black"</span> <span class="attr">stroke-width</span>=<span class="string">"1"</span> <span class="attr">marker-end</span>=<span class="string">"url(#m1)"</span> <span class="attr">marker-start</span>=<span class="string">"url(#m2)"</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>呈現結果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190924/20119062vHOREh7m48.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190924/20119062vHOREh7m48.jpg"></p>
<p>以上就是 SVG 繪製圖形的一些輔助功能，而接下來的章節將會介紹 D3.js 如何選取與資料綁定！</p>
<blockquote>
<p>早上感冒請假去打針，回到家想發文，發現阿橘直接霸佔我的位置，動他還會生氣的那種（起床氣？），只好一個哭笑不得地拿書去其他地方看了……<br><img src="https://ithelp.ithome.com.tw/upload/images/20190924/20119062WcVX8mYlHe.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190924/20119062WcVX8mYlHe.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js SVG 基本圖型繪製</title>
    <url>/d3.js/D3-005-svg-draw-1/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="繪製圖形"><a href="#繪製圖形" class="headerlink" title="繪製圖形"></a>繪製圖形</h2><p>上次提到了 D3.js 實際上是透過 HTML DOM 來操作元素標籤，並且透過 SVG 來繪圖的，而 SVG 繪圖十分簡單，各種基本圖形在 SVG 中都有標籤能夠直接使用，並且使用方法大同小異，只要控制該元素標籤的屬性，就能夠相對應的產生想要製作的圖形，以下列出 SVG 目前支援的標籤以及介紹各個標籤中有哪些屬性可以操控：</p>
<ul>
<li>圓形 <code>&lt;circle&gt;</code></li>
<li>橢圓形 <code>&lt;ellipse&gt;</code></li>
<li>矩形 <code>&lt;rect&gt;</code></li>
<li>線條 <code>&lt;line&gt;</code></li>
<li>折線 <code>&lt;polyline&gt;</code></li>
<li>多邊形 <code>&lt;polygon&gt;</code></li>
<li>路徑 <code>&lt;path&gt;</code></li>
</ul>
<a id="more"></a>

<h3 id="圓形"><a href="#圓形" class="headerlink" title="圓形"></a>圓形</h3><ul>
<li><code>cx</code> ：表示圓心在 SVG 畫布中的 X 座標</li>
<li><code>cy</code> ：圓心在 SVG 畫布中的 Y 座標</li>
<li><code>r</code> ：圓半徑</li>
</ul>
<p>例：產生一個半徑為 50 px 的圓形圖案</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"50"</span> <span class="attr">style</span>=<span class="string">"fill:red"</span>&gt;</span><span class="tag">&lt;/<span class="name">circle</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062JftvAFXvM1.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062JftvAFXvM1.jpg"></p>
<h3 id="橢圓形"><a href="#橢圓形" class="headerlink" title="橢圓形"></a>橢圓形</h3><ul>
<li><code>cx</code> ：圓心在 SVG 畫布中的 X 座標</li>
<li><code>cy</code> ：圓心在 SVG 畫布中的 Y 座標</li>
<li><code>rx</code> ：橢圓形的 X 軸半徑</li>
<li><code>ry</code> ：橢圓形的 Y 軸半徑</li>
</ul>
<p>例：產生一個 X 軸半徑為 50 px，Y 軸半徑為 25 px 的橢圓形圖案</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"50"</span> <span class="attr">rx</span>=<span class="string">"50"</span> <span class="attr">ry</span>=<span class="string">"25"</span> <span class="attr">style</span>=<span class="string">"fill:orange"</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062o05UzrfJUw.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062o05UzrfJUw.jpg"></p>
<h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><ul>
<li><code>width</code> ：矩形寬度</li>
<li><code>height</code> ：矩形高度</li>
<li><code>x</code> ：以矩形左上角為基準的 X 座標</li>
<li><code>y</code> ：以矩形左上角為基準的 Y 座標</li>
<li><code>rx</code> ：導圓角的 X 軸半徑</li>
<li><code>ry</code> ：導圓角的 Y 軸半徑</li>
</ul>
<p>例：產生一個長寬為 50 px 且導圓角 10px 的矩形</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">"50"</span> <span class="attr">height</span>=<span class="string">"50"</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">rx</span>=<span class="string">"10"</span> <span class="attr">ry</span>=<span class="string">"10"</span> <span class="attr">style</span>=<span class="string">"fill:yellow"</span>&gt;</span><span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/2011906278Z9CQEVGO.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/2011906278Z9CQEVGO.jpg"></p>
<h3 id="線條"><a href="#線條" class="headerlink" title="線條"></a>線條</h3><ul>
<li><code>x1</code> ：起始位置的 X 座標</li>
<li><code>x2</code> ：終點位置的 X 座標</li>
<li><code>y1</code> ：起始位置的 Y 座標</li>
<li><code>y2</code> ：終點位置的 Y 座標</li>
</ul>
<p>例：產生一個 50 px 長寬，左上到右下與左下到右上的叉叉圖案</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"50"</span> <span class="attr">height</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">"0"</span> <span class="attr">x2</span>=<span class="string">"50"</span> <span class="attr">y1</span>=<span class="string">"0"</span> <span class="attr">y2</span>=<span class="string">"50"</span> <span class="attr">style</span>=<span class="string">"stroke: green; stroke-width: 2"</span> &gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">"0"</span> <span class="attr">x2</span>=<span class="string">"50"</span> <span class="attr">y1</span>=<span class="string">"50"</span> <span class="attr">y2</span>=<span class="string">"0"</span> <span class="attr">style</span>=<span class="string">"stroke: green; stroke-width: 2"</span> &gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062OIzxjDgTw3.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062OIzxjDgTw3.jpg"></p>
<h3 id="折線、多邊形"><a href="#折線、多邊形" class="headerlink" title="折線、多邊形"></a>折線、多邊形</h3><p>折線與多邊形基本上會以 <code>points</code> 屬性來表示每個點之間的 X、Y 座標，透過多個座標來連成一條線，多邊形與折線的差異在於多邊形的最後一點座標點會連回起始座標點。</p>
<p>例：產生一個上下彎折的折線與多邊形</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">"0,0 25,25 50,0 75,25"</span> <span class="attr">style</span>=<span class="string">"fill: none;stroke: blue;stroke-width: 4"</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062cslj7ius7N.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062cslj7ius7N.jpg"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">points</span>=<span class="string">"0,0 25,25 50,0 75,25"</span> <span class="attr">style</span>=<span class="string">"fill: none;stroke: purple;stroke-width: 4"</span>&gt;</span><span class="tag">&lt;/<span class="name">polygon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062xxws5OfM3F.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062xxws5OfM3F.jpg"></p>
<h3 id="路徑"><a href="#路徑" class="headerlink" title="路徑"></a>路徑</h3><p>路徑則是 SVG 標籤裡面功能最多樣的標籤元素，除了擁有類似於折線、多邊形的座標軸來定義各個點來繪製線條之外還可以透過其他輔助的屬性值來描述如何移動到下個座標軸，最後透過屬性 <code>d</code> 來將下列有用到的內容來定義圖形：</p>
<ul>
<li><code>M</code> ：移動到該座標軸（不繪製線條）。</li>
<li><code>L</code> ：繪製線條到下一個座標。</li>
<li><code>H</code> ：繪製水平線到下個 X 座標</li>
<li><code>V</code> ：繪製水平線到下個 Y 座標</li>
<li><code>C</code> ：經兩個指定座標來繪製貝茲曲線</li>
<li><code>S</code> ：輸入終點座標後與前一條貝茲曲線的指定座標，對稱產生下個貝茲曲線指定座標，來繪製貝茲曲線。</li>
<li><code>A</code> ：繪製一個橢圓曲線到下一個座標。</li>
<li><code>Z</code> ：繪製一條到起點座標的線條。（效果看起來像是封閉圖形）</li>
</ul>
<p>例：如 D3.js 官網本身的 LOGO 就是由 SVG 所定義而成的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"96"</span> <span class="attr">height</span>=<span class="string">"91"</span> <span class="attr">style</span>=<span class="string">"position:relative;top:22px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">clipPath</span> <span class="attr">id</span>=<span class="string">"clip"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M0,0h7.75a45.5,45.5 0 1 1 0,91h-7.75v-20h7.75a25.5,25.5 0 1 0 0,-51h-7.75zm36.2510,0h32a27.75,27.75 0 0 1 21.331,45.5a27.75,27.75 0 0 1 -21.331,45.5h-32a53.6895,53.6895 0 0 0 18.7464,-20h13.2526a7.75,7.75 0 1 0 0,-15.5h-7.75a53.6895,53.6895 0 0 0 0,-20h7.75a7.75,7.75 0 1 0 0,-15.5h-13.2526a53.6895,53.6895 0 0 0 -18.7464,-20z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">clipPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">"gradient-1"</span> <span class="attr">gradientUnits</span>=<span class="string">"userSpaceOnUse"</span> <span class="attr">x1</span>=<span class="string">"7"</span> <span class="attr">y1</span>=<span class="string">"64"</span> <span class="attr">x2</span>=<span class="string">"50"</span> <span class="attr">y2</span>=<span class="string">"107"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"0"</span> <span class="attr">stop-color</span>=<span class="string">"#f9a03c"</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"1"</span> <span class="attr">stop-color</span>=<span class="string">"#f7974e"</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">"gradient-2"</span> <span class="attr">gradientUnits</span>=<span class="string">"userSpaceOnUse"</span> <span class="attr">x1</span>=<span class="string">"2"</span> <span class="attr">y1</span>=<span class="string">"-2"</span> <span class="attr">x2</span>=<span class="string">"87"</span> <span class="attr">y2</span>=<span class="string">"84"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"0"</span> <span class="attr">stop-color</span>=<span class="string">"#f26d58"</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"1"</span> <span class="attr">stop-color</span>=<span class="string">"#f9a03c"</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">"gradient-3"</span> <span class="attr">gradientUnits</span>=<span class="string">"userSpaceOnUse"</span> <span class="attr">x1</span>=<span class="string">"45"</span> <span class="attr">y1</span>=<span class="string">"-10"</span> <span class="attr">x2</span>=<span class="string">"108"</span> <span class="attr">y2</span>=<span class="string">"53"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"0"</span> <span class="attr">stop-color</span>=<span class="string">"#b84e51"</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"1"</span> <span class="attr">stop-color</span>=<span class="string">"#f68e48"</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span> <span class="attr">clip-path</span>=<span class="string">"url(#clip)"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M-100,-102m-27,0v300h300z"</span> <span class="attr">fill</span>=<span class="string">"url(#gradient-1)"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M-100,-102m27,0h300v300z"</span> <span class="attr">fill</span>=<span class="string">"url(#gradient-3)"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M-100,-102l300,300"</span> <span class="attr">fill</span>=<span class="string">"none"</span> <span class="attr">stroke</span>=<span class="string">"url(#gradient-2)"</span> <span class="attr">stroke-width</span>=<span class="string">"40"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062iOg34QXBk8.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062iOg34QXBk8.jpg"></p>
<p>以上光是看到屬性可能大家就已經暈了，而實際上開發時<strong>我們通常不會親自一個一個輸入</strong>這些座標屬性值，開發者除了可以<strong>透過 D3.js 的函式去產生</strong>對應的路徑之外，像是使用繪圖軟體 AI （Adobe Illustrator）也可以將圖片儲存為 SVG 的格式將其放置在網頁當中，最後就能產出像是上方 D3.js 官網的 SVG 程式碼了。</p>
<blockquote>
<p>阿橘固定都會在我要打文章的時候來蹭螢幕。前幾天阿橘還差一點幫我發文章 XD<br><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062xqlw5CfNow.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062xqlw5CfNow.jpg"><br>（阿橘一臉無辜地看著我）</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 資料圖形繪製與重繪 enter(), exit() &amp; update()</title>
    <url>/d3.js/D3-007-enter-exit-update/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="enter"><a href="#enter" class="headerlink" title="enter()"></a>enter()</h2><p>昨天我們已知 <code>enter</code> 資料類型的定義是<strong>當綁定資料時，選取元素不足以綁定時，該筆資料類型會被分類為 enter 類型</strong>。</p>
<p>因此，我們可以透過綁定一個頁面上沒有的元素類別，利用 <code>enter()</code>找出不夠資料塞入的元素筆數，再透過 <code>append()</code> 函式新增元素：</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleData = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line">d3.select(<span class="string">'body'</span>)</span><br><span class="line">    .selectAll(<span class="string">'div'</span>)</span><br><span class="line">    .data(sampleData)</span><br><span class="line">    .enter()</span><br><span class="line">    .append(<span class="string">'p'</span>)</span><br><span class="line">    .text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> d</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>最後畫面上就會顯示三筆剛透過 <code>append()</code> 產生的資料：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062pCiVqVa5G3.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062pCiVqVa5G3.jpg"><br>這三筆資料在 HTML DOM 中的結構：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062fUsBdpY8yd.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062fUsBdpY8yd.jpg"></p>
<p>現在我們再把他與 SVG 標籤圖形結合，透過 D3.js 新增一個 SVG 畫布：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleData = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line"><span class="keyword">let</span> svg = d3.select(<span class="string">'body'</span>)</span><br><span class="line">    .append(<span class="string">'svg'</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>,<span class="number">500</span>)</span><br><span class="line">    .attr(<span class="string">'height'</span>,<span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<p>再將資料綁定在 SVG 中的圖形標籤上並產生圖形，這裡的範例是用上次講解到的圓形標籤 <code>&lt;circle&gt;</code>，透過 <code>attr()</code> 來依序將屬性給予 <code>&lt;circle&gt;</code> 以供網頁瀏覽器渲染：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">svg.selectAll(<span class="string">'circle'</span>)          <span class="comment">// 這裡選了 cirlce 標籤 （對於當前網頁來說是空元素）</span></span><br><span class="line">    .data(sampleData)             <span class="comment">// 綁定 sampleData 資料給予接下來的元素</span></span><br><span class="line">    .enter()                      <span class="comment">// 透過 enter() 找到仍需要三個元素來存放資料</span></span><br><span class="line">    .append(<span class="string">'circle'</span>)             <span class="comment">// 將 enter() 返回的元素數量新增為 circle 標籤</span></span><br><span class="line">    .attr(<span class="string">'cx'</span>,<span class="function"><span class="keyword">function</span><span class="params">(d,i)</span></span>&#123;     <span class="comment">// 透過 attr() 來將前面教學提到的屬性給予 circle 標籤</span></span><br><span class="line">    <span class="keyword">return</span> (i+<span class="number">1</span>)*<span class="number">100</span>              <span class="comment">// 其中的 d 為 data， i 為 資料的陣列索引值</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">'cy'</span>,<span class="number">100</span>)</span><br><span class="line">    .attr(<span class="string">'r'</span>,<span class="function"><span class="keyword">function</span><span class="params">(d)</span></span>&#123;        <span class="comment">// 這裡的圓形半徑採用綁定的資料</span></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">    &#125;)</span><br><span class="line">    .style(<span class="string">'fill'</span>,<span class="string">'red'</span>)          <span class="comment">// 為圓形增添一下樣式</span></span><br></pre></td></tr></table></figure>

<p>最後網頁瀏覽器渲染出的樣子：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062Gqr5s6gE2s.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062Gqr5s6gE2s.jpg"></p>
<p>在 HTML DOM 中的結構：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/2011906276oUN1w5zx.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/2011906276oUN1w5zx.jpg"></p>
<h2 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h2><p><code>exit()</code> 用法與 <code>enter()</code> 類似，差異在於我們需要透過 <code>remove()</code> 來刪除 <code>exit()</code> 所篩選出來的多餘元素。</p>
<p>同樣以上方的例子做參考：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleData = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>] </span><br><span class="line"><span class="keyword">let</span> svg = d3.select(<span class="string">'body'</span>)</span><br><span class="line">    .append(<span class="string">'svg'</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>,<span class="number">500</span>)</span><br><span class="line">    .attr(<span class="string">'height'</span>,<span class="number">500</span>)</span><br><span class="line">    </span><br><span class="line">svg.selectAll(<span class="string">'circle'</span>)</span><br><span class="line">	.data(sampleData)</span><br><span class="line">  .enter()</span><br><span class="line">  .append(<span class="string">'circle'</span>)</span><br><span class="line">  .attr(<span class="string">'cx'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d,i</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> (i+<span class="number">1</span>)*<span class="number">100</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .attr(<span class="string">'cy'</span>,<span class="number">100</span>)</span><br><span class="line">  .attr(<span class="string">'r'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> d</span><br><span class="line">  &#125;)</span><br><span class="line">  .style(<span class="string">'fill'</span>,<span class="string">'red'</span>)</span><br><span class="line"> <span class="comment">// 上半部與上方相同，已預期會產生出三個依據 data 而產生不同半徑大小的圓</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> sampleData2 = [<span class="number">10</span>,<span class="number">20</span>] <span class="comment">// 這裡假設有另一筆新的資料產生</span></span><br><span class="line">  </span><br><span class="line">svg.selectAll(<span class="string">'circle'</span>)   <span class="comment">// 選取已經含有 sampleData 資料的圓形標籤</span></span><br><span class="line">    .data(sampleData2)    <span class="comment">// 將新的資料作為綁定</span></span><br><span class="line">    .exit()               <span class="comment">// 篩選出符合 exit 類別的資料元素</span></span><br><span class="line">    .remove()             <span class="comment">// 刪除符合上方條件的元素</span></span><br></pre></td></tr></table></figure>

<p>最後網頁瀏覽器渲染出的樣子，可以看到最右邊的圓形已經消失了：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062dxW3iCmZZQ.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062dxW3iCmZZQ.jpg"></p>
<p>同樣再來觀察 HTML DOM 的狀態，可以確認該圓形標籤是直接<strong>從 HTML DOM 上移除的</strong>，並<strong>非使用 CSS 樣式來消失該元素</strong>：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062QOZHdTTW25.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062QOZHdTTW25.jpg"></p>
<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>在 D3.js 中，<code>update</code> 類型的資料會直接覆蓋到對應的元素上，並且將舊的數據資料 <code>__data__</code> 直接替換成新的數據資料，所以 <code>updata</code> 類型的資料並不需要特地去操作，若如果需要利用新的數據資料來更動原本的圖表的作法只能依靠<strong>重新繪製</strong>一次新的圖表。</p>
<p>而目前 D3.js 並沒有方法驅動重新繪製圖表這件事情，因此比較好的做法是自己做一個可以重繪的方法來處理，以供資料變動時可以直接重複利用 D3.js 繪製圖形的程式碼：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleData = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">let</span> svg = d3</span><br><span class="line">    .select(<span class="string">"body"</span>)</span><br><span class="line">    .append(<span class="string">"svg"</span>)</span><br><span class="line">    .attr(<span class="string">"width"</span>, <span class="number">500</span>)</span><br><span class="line">    .attr(<span class="string">"height"</span>, <span class="number">500</span>);</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> circle = d3.select(<span class="string">"svg"</span>).selectAll(<span class="string">"circle"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> update = circle.data(sampleData);</span><br><span class="line">    <span class="keyword">let</span> enter = update.enter();</span><br><span class="line">    <span class="keyword">let</span> exit = update.exit();</span><br><span class="line"></span><br><span class="line">    update</span><br><span class="line">        .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">        .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">        &#125;)</span><br><span class="line">        .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">    enter</span><br><span class="line">        .append(<span class="string">"circle"</span>)</span><br><span class="line">        .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">        .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">        &#125;)</span><br><span class="line">        .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">    exit.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br><span class="line"></span><br><span class="line">sampleData = [<span class="number">5</span>, <span class="number">30</span>];</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure>

<p>原本瀏覽器渲染後的圖：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062KdZ8KBy1h3.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062KdZ8KBy1h3.jpg"></p>
<p>啟動 <code>draw</code> 函式後渲染的圖：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062qcv9LbhK24.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062qcv9LbhK24.jpg"></p>
<p>如此一來若是 <code>sampleData</code> 資料有變更時，只要重新啟用 <code>draw</code> 函式就能將舊有資料去除後重新繪製新一筆的圖。</p>
<blockquote>
<p>然而……事情並沒有阿橘想像中這麼快就結束……<br>阿橘：蝦……蝦咪！？<br><img src="https://ithelp.ithome.com.tw/upload/images/20190927/20119062yzvRdt1WEE.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190927/20119062yzvRdt1WEE.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 資料選取 d3-selection 與資料綁定 Joining Data</title>
    <url>/d3.js/D3-006-selection-data-datum/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="資料選取"><a href="#資料選取" class="headerlink" title="資料選取"></a>資料選取</h2><p>在繪製圖表前，首先要掌握 D3.js 如何 <strong>選取元素</strong>，接著才能將要修改的資料輸出到選取的元素裡。而 D3.js 選取元素的部分與 jQuery 是同一套作法，也就是以往撰寫 CSS 相關程式時，開發者怎麼比對元素，就是以那一套為基準即可！</p>
<blockquote>
<p>例如選取 id 為 test 的元素則是使用 <code>#test</code> 作為選取器。</p>
<p>這裡假定開發者已稍微瞭解基礎的 CSS 選擇器（selector ），如果對於 CSS 選擇器還不熟悉的話，可以透過這個 <a href="https://flukeout.github.io" target="_blank" rel="noopener">有趣的盤子遊戲</a> 來快速學習 CSS 選擇器！</p>
</blockquote>
<p>而 D3.js 目前提供了兩種方法以供開發者捕捉元素：</p>
<a id="more"></a>

<ul>
<li><code>d3.select</code> ：捕捉符合選取器的第一個元素</li>
<li><code>d3.selectAll</code> ：捕捉符合選取器的所有元素</li>
</ul>
<p>使用 D3.js 選取器捕捉到的元素（選擇集），後續則可以繼續透過 D3.js 的方法來進行 DOM 的操作修改，例如將選取到的 <code>p</code> 元素中所有的文字都改成紅色：</p>
<p>JavaScript 部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">d3.selectAll(<span class="string">'p'</span>).style(<span class="string">'color'</span>,<span class="string">'red'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若想要測試語法，除了使用前面章節提到的開發環境建置之外，你可以直接在 <a href="https://d3js.org/" target="_blank" rel="noopener">D3.js 官方網站</a> 開啟開發者工具（DevTools）直接測試！</p>
</blockquote>
<h2 id="資料綁定"><a href="#資料綁定" class="headerlink" title="資料綁定"></a>資料綁定</h2><p>現在我們已經可以透過 D3.js 選取到資料集了，然而選取集上的元素裡面並<strong>沒有帶任何的資料</strong>，我們得透過 D3.js 提供的資料綁定方法將<strong>資料綁定於選取的資料集</strong>中，目前 D3.js 提供了兩種方法供開發者使用，接著就來介紹一下他們用法與差異：</p>
<ul>
<li><code>selection.datum</code></li>
<li><code>selection.data</code></li>
</ul>
<h3 id="datum"><a href="#datum" class="headerlink" title="datum"></a>datum</h3><p>datum 的用法有兩種，一種是<strong>未帶參數直接使用其函式</strong>，如<code>d3.selection.datum()</code> 將會<strong>返回選取集所綁定的數據資料</strong>。</p>
<p>第二種就是<strong>將數據資料當作參數帶入函式當中</strong>，如<code>d3.selection.datum(&#39;數據資料&#39;)</code> <strong>將會把數據資料綁定到選取集中每一個元素身上</strong>，而數據資料<strong>綁定的類型</strong>除了<code>undefined</code>與<code>null</code>值之外<strong>都可以賦予該元素</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d3datum = d3.selectAll(<span class="string">'p'</span>).datum(<span class="string">'綁定資料'</span>)</span><br></pre></td></tr></table></figure>

<p>以 D3.js 官網觀察，透過 <code>console.log(d3datum)</code> 可以很清楚的看到該選取集元素物件屬性中含有一個 <code>__data__</code> 的欄位，而這個欄位就是 D3.js 賦予這個元素的資料位置。（如下圖）</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190925/20119062yg0GqFbt7u.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190925/20119062yg0GqFbt7u.jpg"></p>
<p>綁定資料後可以接著以 D3.js 的提供方法來使用這筆資料，例如將透過 <code>text</code> 函式將內容更換為所綁定的資料：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d3datum = d3.selectAll(<span class="string">'p'</span>)</span><br><span class="line">                .datum(<span class="string">'綁定資料'</span>)</span><br><span class="line">                .text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure>

<p>所有被綁定到的資料透過 <code>text</code> 內函式的<strong>第一個傳送參數</strong>（<code>d</code>）替換進去，而 <code>text</code> 用法則是將返回（<code>return</code>）的數值替換為該文字節點的內容。</p>
<blockquote>
<p>註：部分 D3.js 提供的方法第一個傳送參數皆為<strong>元素所綁定的資料</strong>（<code>data</code>），第二個則為<strong>資料集的索引值</strong>（<code>index</code>）。</p>
</blockquote>
<p>最後就會看到 D3.js 官方網站變成了這樣：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190925/20119062XFSQrvYrxe.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190925/20119062XFSQrvYrxe.jpg"></p>
<p>要注意的是，datum 在綁定資料的過程時，有一個特性是若透過被綁定資料的元素來新增一個新的元素時，其<strong>子元素也會繼承父元素的數據資料</strong>（<code>__data__</code>）。</p>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>data 使用方法與 datum 相同，而不一樣的是其綁定資料的邏輯是會<strong>按照陣列索引值</strong>或<strong>指定的方法</strong>來依序的綁定資料到元素上。</p>
<p>例如網站上目前有三個<code>&lt;div&gt;</code>元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>若是有一筆數據資料為<code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code>，透過 data、datum 方法綁定後：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleData = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line">D3.selectAll(<span class="string">'div'</span>).data(sampleData)</span><br></pre></td></tr></table></figure>


<p>接著再觀察 <code>__data__</code> 將會得到：</p>
<table>
<thead>
<tr>
<th>\</th>
<th>透過 data 綁定得到的<code>__data__</code></th>
<th>透過 datum 綁定得到的<code>__data__</code></th>
</tr>
</thead>
<tbody><tr>
<td>第一個 <code>&lt;div&gt;</code>：</td>
<td><code>a</code></td>
<td><code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code></td>
</tr>
<tr>
<td>第二個 <code>&lt;div&gt;</code>：</td>
<td><code>b</code></td>
<td><code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code></td>
</tr>
<tr>
<td>第三個 <code>&lt;div&gt;</code>：</td>
<td><code>c</code></td>
<td><code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code></td>
</tr>
</tbody></table>
<p>由此可見，<code>data</code> 所綁定的數據資料的邏輯會依照其<strong>綁定的元素集</strong>下去做分配，因此若是綁定的元素數量與數據資料的數量不同時，將會被 D3.js 歸納為以下三種邏輯：</p>
<ul>
<li><strong>update</strong> : 輸入該筆數據資料時若<strong>還有</strong>元素可供資料輸入，該筆輸入的資料會被歸納 <code>update</code> 資料。</li>
<li><strong>enter</strong> : 輸入該筆數據資料時若<strong>沒有</strong>元素可供資料輸入，該筆輸入的資料會被歸納 <code>enter</code> 資料。</li>
<li><strong>exit</strong> : 若是資料已經輸入完了，還有剩餘被綁定的元素，則剩下的元素將會被歸納為 <code>exit</code> 資料。</li>
</ul>
<p><strong>例如被綁定的元素有三個，而數據資料有四筆時：</strong></p>
<table>
<thead>
<tr>
<th>元素</th>
<th>數據資料</th>
<th>整筆被綁定的元素會被歸納為</th>
</tr>
</thead>
<tbody><tr>
<td>第一筆被綁定的元素</td>
<td><code>a</code></td>
<td><code>update</code> 資料</td>
</tr>
<tr>
<td>第二筆被綁定的元素</td>
<td><code>b</code></td>
<td><code>update</code> 資料</td>
</tr>
<tr>
<td>第三筆被綁定的元素</td>
<td><code>c</code></td>
<td><code>update</code> 資料</td>
</tr>
<tr>
<td>無</td>
<td><code>d</code></td>
<td><code>enter</code> 資料</td>
</tr>
</tbody></table>
<p><strong>例如被綁定的元素有四個，而數據資料只有兩筆時：</strong></p>
<table>
<thead>
<tr>
<th>元素</th>
<th>數據資料</th>
<th>整筆被綁定的元素會被歸納為</th>
</tr>
</thead>
<tbody><tr>
<td>第一筆被綁定的元素</td>
<td><code>a</code></td>
<td><code>update</code> 資料</td>
</tr>
<tr>
<td>第二筆被綁定的元素</td>
<td><code>b</code></td>
<td><code>update</code> 資料</td>
</tr>
<tr>
<td>第三筆被綁定的元素</td>
<td>無</td>
<td><code>exit</code> 資料</td>
</tr>
<tr>
<td>第四筆被綁定的元素</td>
<td>無</td>
<td><code>exit</code> 資料</td>
</tr>
</tbody></table>
<p>透過 <code>d3.selection.data()</code> 返回的數值中，可以看到一個屬於 <code>update</code> 資料的陣列物件以及 <code>enter</code> 函式與 <code>exit</code> 函式分別可以找到對應類型的資料，而這個類別資料的重要性在於，繪製圖型時我們需要透過這些類型的資料來判斷那些是我們要更動的資料或哪些元素是我們不需要的。若開發者能夠分清楚這三種數據資料的差別，對往後的資料處理上將會更加的容易！</p>
<p>而我們今天已經能夠透過 D3.js 選取到資料集以及將資料綁定給元素了，並且我們還能夠判斷出哪些資料是屬於要更新 <code>update</code> 、進入 <code>enter</code> 以及離開 <code>exit</code>，接下來明天我們將會活用這三個類別資料來進行資料處理，就讓我們明天見啦！</p>
<blockquote>
<p>橘橘舉頭望明月<br><img src="https://ithelp.ithome.com.tw/upload/images/20190925/20119062iIohG6Xuvh.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190925/20119062iIohG6Xuvh.jpg"></p>
</blockquote>
<h2 id="9-26-更新"><a href="#9-26-更新" class="headerlink" title="9/26 更新"></a>9/26 更新</h2><p>不排斥英文文章閱讀的話，D3.js 作者本人 Mike Bostock 也有一篇文章詳細介紹了 D3.js 中 <a href="https://bost.ocks.org/mike/selection/" target="_blank" rel="noopener">選擇集的運作</a>，並且還有提供視覺動畫解釋之間的關係。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js in Vue.js</title>
    <url>/d3.js/D3-008-d3-in-vue/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="D3-js-in-Vue-js-阿彌陀丸-in-春雨"><a href="#D3-js-in-Vue-js-阿彌陀丸-in-春雨" class="headerlink" title="D3.js in Vue.js 阿彌陀丸 in 春雨"></a>D3.js in Vue.js <del>阿彌陀丸 in 春雨</del></h2><p><img src="https://ithelp.ithome.com.tw/upload/images/20190927/20119062asFjpda8Cf.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190927/20119062asFjpda8Cf.jpg"></p>
<p>既然最近介紹的主題是 Vue.js 跟 D3.js，那就沒有道理不把 D3.js 融合進 Vue.js 啦！我們接下來把昨天的繪製函式加入到我們 Vue.js 中，並著利用 Vue.js 的一些特色來完成我們的融合：</p>
<a id="more"></a>

<ol>
<li>首先最基本的是 HTML 部分需要一個元素作為 <strong>Vue.js 初始化</strong>的地方：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>由於 Vue.js 是依靠<strong>資料來驅動視覺層</strong>的，因此我們把 D3.js 資料的部分挪到 Vue.js 的 data 當中以供綁定：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        sampleData: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>再來則是針對 Vue.js 生命週期中的 <code>created</code> 階段，透過 Vue.js 初始化時將 D3.js 所需要的 SVG 畫布設置好：</li>
</ol>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">let vm = new Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        sampleData: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123; // 複習一下，這個 hook 將會在 Vue.js 初始化的階段會啟動它</span><br><span class="line">        d3.select(<span class="string">"#app"</span>)</span><br><span class="line">            .append(<span class="string">"svg"</span>)</span><br><span class="line">            .attr(<span class="string">"width"</span>, <span class="number">500</span>)</span><br><span class="line">            .attr(<span class="string">"height"</span>, <span class="number">500</span>)<span class="comment">;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>接著在 Vue.js 中的 <code>methods</code> 放入重新繪製的函式以供 Vue 實體使用，並把原先 D3.js 中 <code>data()</code> 所綁定的資料更改為 <code>dataset</code> ，加上一點邏輯判斷，使 <code>draw</code> 函式能夠接受外來的參數：</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let vm = new Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        sampleData: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        d3.select(<span class="string">"#app"</span>)</span><br><span class="line">            .append(<span class="string">"svg"</span>)</span><br><span class="line">            .attr(<span class="string">"width"</span>, <span class="number">500</span>)</span><br><span class="line">            .attr(<span class="string">"height"</span>, <span class="number">500</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        draw(newData) &#123; <span class="regexp">//</span> 加入剛剛辛苦改好的重繪函式</span><br><span class="line">            let dataset = newData || this.sampleData; <span class="regexp">//</span> 若沒有傳入資料，則會使用 Vue.js 實體中的 sampleData</span><br><span class="line">            let circle = d3.select(<span class="string">"svg"</span>).selectAll(<span class="string">"circle"</span>);</span><br><span class="line"></span><br><span class="line">            let update = circle.data(dataset); <span class="regexp">//</span> 更改一下綁定資料</span><br><span class="line">            let enter = update.enter();</span><br><span class="line">            let <span class="keyword">exit</span> = update.<span class="keyword">exit</span>();</span><br><span class="line"></span><br><span class="line">            update</span><br><span class="line">                .attr(<span class="string">"cx"</span>, <span class="keyword">function</span>(d, i) &#123;</span><br><span class="line">                return (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">                .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">                .attr(<span class="string">"r"</span>, <span class="keyword">function</span>(d) &#123;</span><br><span class="line">                return d;</span><br><span class="line">                &#125;)</span><br><span class="line">                .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">            enter</span><br><span class="line">                .append(<span class="string">"circle"</span>)</span><br><span class="line">                .attr(<span class="string">"cx"</span>, <span class="keyword">function</span>(d, i) &#123;</span><br><span class="line">                return (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">                .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">                .attr(<span class="string">"r"</span>, <span class="keyword">function</span>(d) &#123;</span><br><span class="line">                return d;</span><br><span class="line">                &#125;)</span><br><span class="line">                .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">exit</span>.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 Vue.js 生命週期中的 <code>mounted</code> 放入從 Vue.js <code>methods</code> 撈來的繪製函式，使得 Vue.js 載入資料完畢後會繪製一次最初的圖形：</li>
</ol>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">let vm = new Vue(&#123;</span><br><span class="line"><span class="symbol">    el:</span> <span class="string">"#app"</span>,</span><br><span class="line"><span class="symbol">    data:</span> &#123;</span><br><span class="line"><span class="symbol">        sampleData:</span> [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123; </span><br><span class="line">        this.draw(); <span class="comment">// 等到 Vue.js 一載入完成就執行這個繪圖函式</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="symbol">    methods:</span> &#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>利用 Vue.js 的 <code>watch</code> 來監聽 <code>sampleData</code> 資料是否有改動，若有改動則啟用該函式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        sampleData: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>] <span class="comment">// watch 監控並執行對應的函式</span></span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123; </span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        sampleData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.draw(<span class="keyword">this</span>.sampleData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>methods</code> 中再次加入一個函式 <code>changeData</code> 用來模擬新資料非同步的載入：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    changeData() &#123; </span><br><span class="line">        <span class="keyword">this</span>.sampleData = [<span class="number">5</span>, <span class="number">30</span>]; <span class="comment">// 模擬新資料的載入</span></span><br><span class="line">    &#125;,</span><br><span class="line">    draw(newData) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最後我們在 HTML 中加入一個按鈕來驅動 Vue.js 內的 <code>changeData</code> 函式：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeData"</span>&gt;</span>New Data<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>於是我們就得到了一個藉由資料驅動完成 D3.js 繪製的 Vue.js 程式！<a href="https://codepen.io/ShawnLin0201/pen/rNBbyqX" target="_blank" rel="noopener">程式碼範例請點這裡</a></p>
<p>而我們接下來的目標就是完善<strong>資料處理</strong>的部分與<strong>繪製圖形</strong>的部分，明天將會介紹有什麼方法可以調整資料與篩選。</p>
<blockquote>
<p>阿橘：終於可以來慵懶地曬著陽光了<br><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062wcMRwdS8v4.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062wcMRwdS8v4.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
        <category>前端</category>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 資料處理與篩選</title>
    <url>/d3.js/D3-009-d3-data-processing/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<p>昨天我們已經成功的將 D3.js 放入 Vue.js 裡面，藉由 Vue.js 的 <code>生命週期鉤子</code> 與 <code>監聽</code> 來驅動函式重新繪製圖表，而今天要來說明的是 D3.js 中的資料處理與篩選：</p>
<blockquote>
<p>註：這裡指的資料處理是指對以優化過的資料集做延伸的處理，倘諾資料集本身需要大量的欄位調整、優化則建議需在資料庫、後端回傳 API 前就先將資料集處理完畢。</p>
</blockquote>
<a id="more"></a>

<h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p>在 D3.js 中的 <code>filter()</code> 與 JavaScript 中的 <code>filter()</code> 使用起來的功用差不多，主要用意是回傳<strong>資料集中符合條件的資料</strong>內容，主要使用時機與位置是在<strong>綁定資料集之後</strong>才來篩選，我們以昨天合併完的程式碼為例：</p>
<p>昨天範例在 Vue.js <code>methods</code> 中，我們有一段 <code>draw()</code> 函式用來繪製圖表，我們將 <code>filter()</code> 插入在新增元素之前：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">draw(newData) &#123;</span><br><span class="line">  <span class="keyword">let</span> dataset = newData || <span class="keyword">this</span>.sampleData;</span><br><span class="line">  <span class="keyword">let</span> circle = d3.select(<span class="string">"svg"</span>).selectAll(<span class="string">"circle"</span>);</span><br><span class="line">  <span class="keyword">let</span> update = circle.data(dataset);</span><br><span class="line">  <span class="keyword">let</span> enter = update.enter();</span><br><span class="line">  <span class="keyword">let</span> exit = update.exit();</span><br><span class="line"></span><br><span class="line">  update</span><br><span class="line">    .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">    .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">    &#125;)</span><br><span class="line">    .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">  enter</span><br><span class="line">    .filter(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;  <span class="comment">// 將 filter 插入在這裡，藉由 d 參數傳入綁定的資料集</span></span><br><span class="line">      <span class="keyword">return</span> d &gt; <span class="number">20</span>;       <span class="comment">// 將資料集中每筆資料拿出來比對，大於 20 才返回該筆資料</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .append(<span class="string">"circle"</span>)</span><br><span class="line">    .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">    .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">    &#125;)</span><br><span class="line">    .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">  exit.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最後因為資料集中 <code>[10, 20, 30]</code>中只剩下一筆資料符合，因此可以看到畫面上只剩下一個半徑為 <code>30</code> 的圓形。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190928/20119062nNh8BPrhSx.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190928/20119062nNh8BPrhSx.jpg"></p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><p><code>sort()</code> 的功用則也與 JavaScript 原生的用法類似，<strong>目的在於排列資料集中的順序</strong>，並且我們也同樣可以傳入排列的函式，來變更排序的方法：</p>
<ul>
<li>sort() ：若不填入比較函式，則預設內部會返回 <code>d3.ascending(a,b)</code> 的遞增排列。</li>
<li>d3.ascending(a,b)： 將資料集的資料<strong>遞增</strong>排列。</li>
<li>d3.descending(a,b)： 將資料集的資料<strong>遞減</strong>排列。</li>
</ul>
<p>使用時機是放在<strong>綁定資料的後方</strong>，例如昨天程式碼中，我們在 <code>update</code> 變數中綁定資料的位置裡：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">draw(newData) &#123;</span><br><span class="line">  <span class="keyword">let</span> dataset = newData || <span class="keyword">this</span>.sampleData;</span><br><span class="line">  <span class="keyword">let</span> circle = d3.select(<span class="string">"svg"</span>).selectAll(<span class="string">"circle"</span>);</span><br><span class="line">  <span class="keyword">let</span> update = circle.data(dataset.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123; <span class="comment">// 在綁定的資料集上做好排序</span></span><br><span class="line">      <span class="keyword">return</span> d3.descending(a,b) <span class="comment">// 這裡選擇資料集要返回遞減的排列</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="comment">// 以上寫法等同於 let update = circle.data(dataset.sort(d3.descending));</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> enter = update.enter();</span><br><span class="line">  <span class="keyword">let</span> exit = update.exit();</span><br><span class="line"></span><br><span class="line">  update</span><br><span class="line">    .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">    .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">    &#125;)</span><br><span class="line">    .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">  enter</span><br><span class="line">    .append(<span class="string">"circle"</span>)</span><br><span class="line">    .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">    .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">    &#125;)</span><br><span class="line">    .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">  exit.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一來， <code>dataset</code> 在綁定資料給 D3.js 的選擇集之前，就會將原本的資料 <code>[10, 20, 30]</code> 重新排列成 <code>[30, 20, 10]</code>，因此繪製圖型時最後便會顯示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190928/20119062mS7TsTuKQs.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190928/20119062mS7TsTuKQs.jpg"></p>
<h2 id="D3-js-常用的封裝函式"><a href="#D3-js-常用的封裝函式" class="headerlink" title="D3.js 常用的封裝函式"></a>D3.js 常用的封裝函式</h2><p>而除了以上兩種資料處理方法，D3.js 也提供了許多已經封裝好的數學函式可以直接對資料集做運算，以下列出幾個較為常用的運算函式：</p>
<h3 id="求數值"><a href="#求數值" class="headerlink" title="求數值"></a>求數值</h3><ul>
<li><code>d3.min()</code>：找出傳入陣列中的<strong>最小值</strong>。</li>
<li><code>d3.max()</code>：找出傳入陣列中的<strong>最大值</strong>。</li>
<li><code>d3.extent()</code>：找出傳入陣列中的<strong>最小值、最小值</strong>，返回一個<code>[最小值, 最大值]</code>。</li>
<li><code>d3.sum()</code>：將傳入陣列中的每筆資料<strong>加總</strong>起來。</li>
<li><code>d3.mean()</code>：求出傳入陣列中的<strong>平均數</strong>，並且<strong>忽略掉陣列中的 <code>undefined</code>、<code>NaN</code> 等等資料</strong>。</li>
<li><code>d3.median()</code>：求出傳入陣列中的<strong>中位數</strong>。</li>
<li><code>d3.deviation()</code>：求出傳入陣列中的<strong>標準差</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dataset = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">d3.min(dataset) <span class="comment">// 1</span></span><br><span class="line">d3.max(dataset) <span class="comment">// 9</span></span><br><span class="line">d3.extent(dataset) <span class="comment">// [1, 9]</span></span><br><span class="line">d3.sum(dataset) <span class="comment">// 20</span></span><br><span class="line">d3.mean(dataset) <span class="comment">// 4</span></span><br><span class="line">d3.median(dataset) <span class="comment">// 3</span></span><br><span class="line">d3.deviation(dataset) <span class="comment">// 3.1622776601683795</span></span><br></pre></td></tr></table></figure>

<h3 id="操作陣列"><a href="#操作陣列" class="headerlink" title="操作陣列"></a>操作陣列</h3><ul>
<li><code>d3.shuffle()</code>：將傳入陣列資料隨機打亂。</li>
<li><code>d3.merge()</code>：傳入一個陣列，將陣列中所有資料合併為一個陣列。</li>
<li><code>d3.range()</code>：返回一個等差數列。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dataset = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> dataset2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">d3.shuffle(dataset) <span class="comment">// [3, 5, 1, 9, 2]</span></span><br><span class="line">d3.merge([dataset, dataset2]) <span class="comment">// [1, 3, 2, 5, 9, 1, 2, 3]</span></span><br><span class="line">d3.range(<span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>) <span class="comment">// [1, 2, 3, 4] ，意即從 0 開始到 5 為止，回傳每筆資料數值差為 1 的陣列（不包含 5）</span></span><br></pre></td></tr></table></figure>

<p>以上為 D3.js 對資料集操作的常用 API 整理，而其餘沒列到內容可在 <a href="https://github.com/d3/d3/blob/master/API.md" target="_blank" rel="noopener">官方網站</a> 中查詢，因此假若下次要對資料集操作時，不彷可以看看官方網站是否已經有提供 API 來操作資料集，透過已經提供的 API 來操作資料就可以寫出味道聞起來<strong>較為 D3.js 的程式碼</strong>，而讓其他人一看就能瞭解資料邏輯是怎麼處理的囉！</p>
<blockquote>
<p>今天的阿橘看 UI/UX 書看到睡著。<br><img src="https://ithelp.ithome.com.tw/upload/images/20190928/20119062Gq1p2HvJVx.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190928/20119062Gq1p2HvJVx.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 繪製比例尺 scale</title>
    <url>/d3.js/D3-010-scale/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<blockquote>
<p>在圖表當中不可或缺的除了基本的<strong>資料</strong>與<strong>圖表</strong>之外，另一項就是<strong>比例尺</strong>的部分。在 D3.js 中，開發者可以透過比例尺<strong>將一段範圍的某個數值對應到另一段範圍的數值</strong>，這麼做的好處在於我們可以將資料轉換成一個具有比例意義的圖表，並且依比例縮放成我們所要的大小而不是毫無比例根據的作圖。</p>
</blockquote>
<a id="more"></a>

<h2 id="線性比例尺-d3-scaleLinear"><a href="#線性比例尺-d3-scaleLinear" class="headerlink" title="線性比例尺 d3.scaleLinear"></a>線性比例尺 d3.scaleLinear</h2><p>線性比例尺指的是一段<strong>連續的</strong>數值可以<strong>依照一個線性函數來換算</strong>出數值：</p>
<blockquote>
<p>例如區間 <code>[0,20]</code> 依照 <code>y=2x</code> 可以換算出 <code>[0, 40]</code>，因此假如今天有一個值為 <code>10</code> ，我們便可以帶入函數 <code>y=2*10</code> 來求出 Y 值為 <code>20</code>。</p>
</blockquote>
<p>而使用方法很簡單，我們透過 D3.js 4版以後的語法 <code>d3.scaleLinear</code> 來創造一段比例尺，並由 <code>domain()</code> 定義範圍（如設為資料最大最小範圍），再使用 <code>range()</code> 定義一個取值的範圍（如圖表中的軸長），如此一來就可以將資料的大小比例對應到圖表中的 X 軸、Y 軸內：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let dataset = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">50</span>]</span><br><span class="line">let linear = d3</span><br><span class="line">    .scaleLinear()                    <span class="comment">// 使用 d3 線性比例尺</span></span><br><span class="line">    .domain([<span class="number">0</span>, d3.max(dataset)])     <span class="comment">// 設定比例範圍 0 到 資料集的最大值</span></span><br><span class="line">    .range([<span class="number">0</span>, <span class="number">100</span>])                  <span class="comment">// 設定輸出範圍 0 到 100 ，例如圖表想要的高度</span></span><br><span class="line">  </span><br><span class="line">console.log(linear(<span class="number">10</span>))               <span class="comment">// 得到 20，可以將其設定為例如矩形的高度</span></span><br><span class="line">console.log(linear(<span class="number">50</span>))               <span class="comment">// 得到 100，可以將其設定為例如矩形的高度</span></span><br></pre></td></tr></table></figure>

<p>另一個以 Vue.js in D3.js 的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"#app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      sampleData: [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">50</span>]              <span class="comment">// 設定基礎的資料集</span></span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      d3.select(<span class="string">"#app"</span>)                             <span class="comment">// SVG 畫布基礎設定</span></span><br><span class="line">        .append(<span class="string">"svg"</span>)</span><br><span class="line">        .attr(<span class="string">"width"</span>, <span class="number">200</span>)</span><br><span class="line">        .attr(<span class="string">"height"</span>, <span class="number">200</span>)</span><br><span class="line">        .style(<span class="string">"border"</span>, <span class="string">"1px solid #00000060"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="keyword">this</span>.draw();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      draw(newData) &#123;</span><br><span class="line">        <span class="keyword">let</span> dataset = newData || <span class="keyword">this</span>.sampleData;    <span class="comment">// 設定綁定資料等相關設定</span></span><br><span class="line">        <span class="keyword">let</span> rect = d3.select(<span class="string">"svg"</span>).selectAll(<span class="string">"rect"</span>);</span><br><span class="line">        <span class="keyword">let</span> update = rect.data(dataset);</span><br><span class="line">        <span class="keyword">let</span> enter = update.enter();</span><br><span class="line">        <span class="keyword">let</span> exit = update.exit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> linear = d3                              <span class="comment">// 這裡建立一個線性比例尺</span></span><br><span class="line">          .scaleLinear()</span><br><span class="line">          .domain([<span class="number">0</span>, d3.max(dataset)])              <span class="comment">// 設定比例範圍 0 與 50 (資料集最大值)</span></span><br><span class="line">          .range([<span class="number">0</span>, <span class="number">200</span>]);                          <span class="comment">// 設定取值範圍 0 至 200（SVG 畫布高）</span></span><br><span class="line"></span><br><span class="line">        enter</span><br><span class="line">          .append(<span class="string">"rect"</span>)</span><br><span class="line">          .attr(<span class="string">"width"</span>, <span class="number">30</span>)</span><br><span class="line">          .attr(<span class="string">"height"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;              <span class="comment">// 繪製矩形高時，採用資料輸入進去比例尺</span></span><br><span class="line">            <span class="keyword">return</span> linear(d);                        <span class="comment">// 例如第一筆資料為 10 ，比例尺取值後會得到 20</span></span><br><span class="line">          &#125;)</span><br><span class="line">          .attr(<span class="string">"x"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i * <span class="number">40</span> + <span class="number">5</span>;</span><br><span class="line">          &#125;)</span><br><span class="line">          .attr(<span class="string">"y"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;                   <span class="comment">// 矩形的屬性 y 是從上往下算</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">200</span> - linear(d);                  <span class="comment">// 因此要倒過來繪製需用最大高度去減資料高度</span></span><br><span class="line">          &#125;)                                         <span class="comment">// 所以在這邊矩形的高度也需換算成比例尺取值的高</span></span><br><span class="line">          .attr(<span class="string">"fill"</span>, <span class="string">"blue"</span>);</span><br><span class="line"></span><br><span class="line">        exit.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>顯示結果：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190929/20119062mroGQIbD8X.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190929/20119062mroGQIbD8X.jpg"></p>
<p>圖中可以看到 SVG 畫布 長高各為 <code>200px</code> 的情況，我們設定資料範圍為 <code>0</code> 至 <code>50</code> （資料集最大值），並把輸出範圍設定為 <code>0</code> 至 <code>200</code>，因此最後一筆資料 <code>50</code> 經由比例尺轉換後繪製出高度為 <code>200</code>的矩形，可以看到確實撐滿了整個 SVG 的高。</p>
<blockquote>
<p>由此範例可以看出比例尺在 D3.js 中潛力，像是 RWD 網頁透過 JavaScript 監聽視窗大小變動時，便可以藉由將視窗比例等等資訊傳遞進 D3.js 來調整比例尺，達到圖表縮放的功能。</p>
</blockquote>
<p>而比例尺的功能除了簡單的依比例輸出外還有其他的 API 可供調整：</p>
<ul>
<li><code>rangeRound()</code> ：替換 <code>range()</code> 使用，使最後輸出的數值會四捨五入到個位數。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dataset = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">50</span>]</span><br><span class="line"><span class="keyword">let</span> linear = d3</span><br><span class="line">    .scaleLinear()                    </span><br><span class="line">    .domain([<span class="number">0</span>, d3.max(dataset)])     </span><br><span class="line">    .rangeRound([<span class="number">0</span>, <span class="number">100</span>])             </span><br><span class="line">    </span><br><span class="line"><span class="built_in">console</span>.log(linear(<span class="number">9.84521</span>))          <span class="comment">// 得到 20，若以 range 取則得到 19.69042。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>clamp()</code> ：啟用後會將輸入超過範圍的數值，輸出時縮放為範圍的最大、最小值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dataset = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">50</span>]</span><br><span class="line"><span class="keyword">let</span> linear = d3</span><br><span class="line">    .scaleLinear()                    </span><br><span class="line">    .domain([<span class="number">0</span>, d3.max(dataset)])     </span><br><span class="line">    .range([<span class="number">0</span>, <span class="number">100</span>])             </span><br><span class="line">linear.clamp(<span class="literal">true</span>)                     <span class="comment">// true，啟用該設定；反之 false （預設）為仍會縮放該數值。</span></span><br><span class="line"><span class="built_in">console</span>.log(linear(<span class="number">1000</span>))              <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(linear(<span class="number">-1000</span>))             <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>nice()</code> ：將定義範圍中的無窮小數捨去至合理的範圍，<strong>用以資料集當 <code>domain</code> 範圍時若遇到無窮小數需要整理時</strong>可使用此函數。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> linear = d3</span><br><span class="line">    .scaleLinear()                    </span><br><span class="line">    .domain([<span class="number">0.62271947</span> , <span class="number">0.13879428</span>])     </span><br><span class="line">    .range([<span class="number">0</span>, <span class="number">100</span>])             </span><br><span class="line">linear.nice()</span><br><span class="line"><span class="built_in">console</span>.log(linear.domain())           <span class="comment">// [0.65, 0.1]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ticks()</code> ：將比例尺的定義範圍切成數段，並且返回一個較有意義段落的陣列，用來<strong>製作座標軸數值</strong>非常方便。</p>
</li>
<li><p><code>tickFormat()</code> ：如同 <code>ticks</code> 用法，但是可以在第二個傳送參數中定義返回的數值格式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dataset = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">50</span>]</span><br><span class="line"><span class="keyword">let</span> linear = d3</span><br><span class="line">    .scaleLinear()                    </span><br><span class="line">    .domain([<span class="number">0</span>, d3.max(dataset)])     </span><br><span class="line">    .range([<span class="number">0</span>, <span class="number">100</span>])             </span><br><span class="line"><span class="keyword">let</span> ticks = linear.ticks(<span class="number">2</span>)           </span><br><span class="line"><span class="built_in">console</span>.log(ticks)                    <span class="comment">// [0, 20, 40]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tickFormat = linear.tickFormat(<span class="number">0</span>, <span class="string">'+'</span>)</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ticks.length; i++)&#123;</span><br><span class="line">	ticks[i] = tickFormat(ticks[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ticks)                    <span class="comment">// ["+0", "+20", "+40"]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>以上是<strong>線性比例尺</strong>的用法，而除此之外還有像是 <strong>序列比例尺</strong>、<strong>量化比例尺</strong>、<strong>分位數比例尺</strong>等等不同的比例尺以供不同時機使用，這裡舉出一個比較常用到的比例尺來作為例子，往後圖表中若有用到其他比例尺時再仔細好好來介紹它們的細項，另外以下是 D3.js 比例尺在三版與四版的 API 差異表！</p>
<h2 id="附註-D3-js-比例尺-3-版與-4-版差異補充"><a href="#附註-D3-js-比例尺-3-版與-4-版差異補充" class="headerlink" title="附註 D3.js 比例尺 3 版與 4 版差異補充"></a>附註 D3.js 比例尺 3 版與 4 版差異補充</h2><ul>
<li>d3.scale.linear ↦ d3.scaleLinear</li>
<li>d3.scale.sqrt ↦ d3.scaleSqrt</li>
<li>d3.scale.pow ↦ d3.scalePow</li>
<li>d3.scale.log ↦ d3.scaleLog</li>
<li>d3.scale.quantize ↦ d3.scaleQuantize</li>
<li>d3.scale.threshold ↦ d3.scaleThreshold</li>
<li>d3.scale.quantile ↦ d3.scaleQuantile</li>
<li>d3.scale.identity ↦ d3.scaleIdentity</li>
<li>d3.scale.ordinal ↦ d3.scaleOrdinal</li>
<li>d3.time.scale ↦ d3.scaleTime</li>
<li>d3.time.scale.utc ↦ d3.scaleUtc</li>
</ul>
<blockquote>
<p>明天颱風天只好跟貓咪一起在家繼續研究 D3.js 啦！附上黑黑美照一張：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190929/2011906256tqok0zxy.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190929/2011906256tqok0zxy.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>重新解構：無瑕的程式碼（Clean Code） Chapter 3 函式－函式語句（下）</title>
    <url>/cleancode/clean-code-a-handbook-of-agile-software-craftsmanship-005-function-statement/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/Book/Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship.jpg' width='200px' height='200px' />
</div>

<p>在上篇文章中，我們將<strong>函式（function）</strong>拆成了三個部分：</p>
<ul>
<li>函式名稱（naming）：以供辨識、呼叫用的名稱。</li>
<li>函式參數（parameter）：提供連結外部變數，傳送到內部語句的傳送參數。</li>
<li>函式語句（statements）：實際函式所執行的區域。</li>
</ul>
<p>其中<strong>函式語句（statements）</strong>的部分又可以拆為：</p>
<ul>
<li>語句類別（type）：探討函式是怎麼被開發者使用的。</li>
<li>語句結構（structure）：探討內部語句的寬度與深度。</li>
<li>語句脈絡（context）：探討內部語句的長度與敘述。</li>
</ul>
<p>而這篇文章將延續上篇文章繼續介紹語句脈絡的概念。</p>
<a id="more"></a>

<h2 id="語句脈絡（context）"><a href="#語句脈絡（context）" class="headerlink" title="語句脈絡（context）"></a>語句脈絡（context）</h2><p>別於語句結構的巢狀、深度，語句脈絡指的部分是在函式中的，語句整體的敘述與長度，包含了輸入、輸出值等等邏輯。</p>
<p>而根據無暇的程式碼一書中，一個較好的語句脈絡應該包含了：</p>
<ul>
<li>由上而下的敘述</li>
<li>越短越好</li>
<li>無副作用</li>
<li>只有一件目的</li>
<li>結構化函式</li>
</ul>
<h3 id="由上而下的敘述"><a href="#由上而下的敘述" class="headerlink" title="由上而下的敘述"></a>由上而下的敘述</h3><p>由上而下的敘述是指，在函式語句（statement）的過程中，我們可能會使用其他的函式來輔助，那麼這些函式應該要有父層（parent）、子層（child）這些相對的概念：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 計算淨利的程式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countIncome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> totalIncome = <span class="number">0</span></span><br><span class="line">  totalIncome = totalRevenue() - totalCost() - calcTax(totalRevenue())</span><br><span class="line">  <span class="keyword">return</span> totalIncome</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">totalRevenue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 計算並返回總營業額</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">totalCost</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 計算並返回總成本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcTax</span>(<span class="params">NTD</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 將總營業額帶入並計算營業稅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時</span></span><br><span class="line"><span class="keyword">const</span> INCOME = countIncome()</span><br><span class="line"><span class="built_in">console</span>.log(INCOME)</span><br></pre></td></tr></table></figure>

<p>我們可以看見將來實際使用時，我們會首先暴露相較於父層的 <code>countIncome</code> 函式。</p>
<p>因此如果將來想了解 <code>INCOME</code> 值是怎麼處理而來的時候，會先找到 <code>countIncome</code> 函式，接著在從內部語句中找到其餘計算相關內容的 <code>totalRevenue</code>、<code>totalCost</code> 與 <code>calcTax</code> 函式，我們就能輕易的透過這種由上而下的引入關係理解這些函式之間的關聯性。</p>
<h3 id="越短越好"><a href="#越短越好" class="headerlink" title="越短越好"></a>越短越好</h3><p>語句越短越好可以說是接著上節由上而下的敘述的補充。</p>
<p>經過剛剛的範例可以看見，當我們在閱讀 <code>countIncome</code> 時，內部並沒有做太多複雜的計算，而是將這些計算分工給其餘的程式，如此一來我們可以加快閱讀每個函式本身在做的事情，藉由快速理解各個函式本身的行為，強化理解函式與函式之間的關聯。</p>
<h3 id="無副作用"><a href="#無副作用" class="headerlink" title="無副作用"></a>無副作用</h3><p>無副作用的意思即為，在處理函式數值時，函式本身應該是針對其數值做運算、針對功能做出相對應的行為；如果函式背地裡修改了其他數值、執行其他的行為，將會大大的加深理解函式的困難度。</p>
<!-- todo -->

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span> (<span class="params">userID</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'...'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> location.reload())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時</span></span><br><span class="line">getUserInfo(<span class="string">'c8763'</span>) <span class="comment">// 找不到，但錯誤時直接重整，所以也不知道發生什麼事情</span></span><br></pre></td></tr></table></figure>

<p>在這段程式碼中，欲使用 <code>getUserInfo</code> 函式取得使用者相關資訊，但是卻不知道為何直接重整的案例。</p>
<p>去爬了定義 <code>getUserInfo</code> 的函式後，才發現語句中對於 ajax 的錯誤處理中，使用了 <code>location.reload()</code> 來重整頁面。</p>
<p>即便是直接使用了有副作用的函式都讓人覺得疑惑了，可以試想當你是在深層度的層次中使用到時會發生什麼情況：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderPage</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.init = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pageData = getPageData(obj.pageName) <span class="comment">// 取得 &lt;object&gt;頁面資料</span></span><br><span class="line">    <span class="keyword">let</span> userInfo = getUserInfo(obj.userID) <span class="comment">// 取得 &lt;object&gt;會員資料</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;userInfo.nickname&#125;</span>!`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.init(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPageData</span>(<span class="params">pageName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;</span><br><span class="line">  <span class="comment">// 取得頁面資料</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">userID</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'...'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> location.reload())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時，預期要渲染一個名稱為 'main' 的頁面。</span></span><br><span class="line">renderPage(&#123;</span><br><span class="line">  pageName: <span class="string">'main'</span></span><br><span class="line">  userID: <span class="string">'c8763'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你能夠輕易地看出為何 <code>renderPage()</code> 最後會導致不正常的頁面刷新嗎？如果可以的話，想像它只是某個不明顯的數值變更看看，你還能輕易地找到錯誤的地方嗎？</p>
<h3 id="只有一件目的"><a href="#只有一件目的" class="headerlink" title="只有一件目的"></a>只有一件目的</h3><p>一個函式語句（statement）應該要只有一件目的，如此一來閱讀程式碼時就不需要在多種目的下來回猜測，使函式本身做的事情更容易被表達。</p>
<p>例如錯誤處理中的 <code>catch</code> 本身就算是一件目的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMemberInfo</span> (<span class="params">memberID</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'...'</span> + memberID&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err)) <span class="comment">// 錯誤處理</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// 若無錯誤時的處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在這 <code>getMemberInfo</code> 中，本身目的在於取得資料這件事情，因此我們可以掌握取得資料與沒有取得資料的行為。</p>
<p>如果我們在取得資料錯誤之後又做了其他事情，則會使函式變成有副作用的情況，將來要除錯時會無法聚焦錯誤訊息。</p>
<p>而透過讓函式符合專一職責的思維，最後可以帶來像是單元測試（unit testing）會更很容易測試他的邏輯以及重構時（refactoring）的抽象處理等等好處。</p>
<h3 id="結構化函式"><a href="#結構化函式" class="headerlink" title="結構化函式"></a>結構化函式</h3><p>現在我們知道只有一件目的的函式的語句脈絡的好處了，結構化函式則是在整體語句脈絡上訂下一個輸出輸入的準則。</p>
<p>例如在需要初始化區域變數我們應該在函式語句的開頭就定義完畢，這樣可以使我們更容易找到值的來源：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSomething</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = x</span><br><span class="line">  <span class="keyword">let</span> b = y</span><br><span class="line">  <span class="keyword">let</span> c = z</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 假設函式語句有一些長度，以至於你可能需要滑鼠滾動檢查整段語句。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  c += <span class="number">1</span> </span><br><span class="line">  d = a + b</span><br><span class="line">  <span class="keyword">return</span> a + b - c </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上方的例子中，我們快速檢查 c 變數的源頭是誰以及意識到 d 變數可能是來自更外一層的區域所宣告的區域變數或可能是忘記初始化，最後變成全域變數的危險分子。</p>
<p>另一個結構化的方式則是將進入點<strong>輸出點</strong>集中管理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumArray</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>; <span class="comment">// 將輸出值，透過變數初始化在上方</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;  <span class="comment">// 防禦處理、例外處理（exception handling），也可以移置上方管理。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    result += arr[i]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result <span class="comment">// 輸出的來源現在可以很確定是源自哪裡了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣的作法在函式語句需要 <code>if/else</code>、<code>switch</code> 判斷時會更加的明顯：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 沒有控制的情況</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPageData</span>(<span class="params">pageName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pageName === <span class="string">''</span>)  &#123;</span><br><span class="line">    <span class="keyword">let</span> something = <span class="string">''</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 進入流程處理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> something <span class="comment">// 處理完直接輸出值</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pageName  === <span class="string">'search'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> something = <span class="string">''</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 進入流程處理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> something <span class="comment">// 處理完直接輸出值</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> something = <span class="string">''</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 進入流程處理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> something <span class="comment">// 處理完直接輸出值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在沒有控制的情況，這個判斷流程（condition）將會逐漸使開發、除錯漸漸變得困難，我們可能要不斷在各種流程中下斷點來判斷裡面返回的數值狀況。</p>
<p>雖然不是不可，但是如果預期輸出的值是相同概念的話，可以將其控制為一點輸出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPageData</span>(<span class="params">pageName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>; <span class="comment">// 依照輸出的資料類型定義初始值，提供預期的輸出資料類型</span></span><br><span class="line">  <span class="keyword">if</span> (pageName === <span class="string">''</span>)  &#123;</span><br><span class="line">    <span class="keyword">let</span> something = <span class="string">''</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 進入流程處理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    result = something  <span class="comment">// 將處理好的數值接回輸出變數</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pageName  === <span class="string">'search'</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> something = <span class="string">''</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 進入流程處理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    result = something  <span class="comment">// 將處理好的數值接回輸出變數</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> something = <span class="string">''</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 進入流程處理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    result = something  <span class="comment">// 將處理好的數值接回輸出變數</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result <span class="comment">// 統一輸出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一來我們可以針對其 <code>result</code> 變數的過程作監控，在最後輸出前監控該數值的變化是否合乎預期。</p>
<p>以上兩篇就是有關於函式語句（statement）上的處理，下一篇文章我們將會介紹不同的函式參數所帶來的影響以及函式命名的做法。</p>
]]></content>
      <categories>
        <category>Book</category>
        <category>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</category>
      </categories>
      <tags>
        <tag>Book</tag>
        <tag>w3HexSchool</tag>
        <tag>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 繪製散點圖與折線圖 scatter chart &amp; line chart</title>
    <url>/d3.js/D3-012-scatter-chart-and-line-chart/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="繪製散點圖-scatter-chart"><a href="#繪製散點圖-scatter-chart" class="headerlink" title="繪製散點圖 scatter chart"></a>繪製散點圖 scatter chart</h2><p>昨天我們已經繪製出座標軸了，而接下來要繪製散點圖就非常的容易了，繪製散點圖的原理與繪製座標軸的原理類似，並且更簡單，我們只要在圖表內生成 SVG 圓形標籤時，藉由其屬性 <code>cx</code> 與 <code>cy</code> 定義圓形標籤的位置之後，即可將圓點產生在資料對應的位置。</p>
<p>以下範例用昨天已繪製好的座標軸繼續延伸：</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// draw() 函式內部</span></span><br><span class="line">enter.append(<span class="string">'circle'</span>)</span><br><span class="line">    .attr(<span class="string">'cx'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Xscale(d.x)                        <span class="comment">// 將 X 資料換算成 X 軸的比例</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">'cy'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Yscale(d.y)                        <span class="comment">// 將 Y 資料換算成 Y 軸的比例</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">'r'</span>,<span class="number">5</span>)</span><br><span class="line">    .attr(<span class="string">'fill'</span>,<span class="string">'#000'</span>)</span><br><span class="line">    .attr(<span class="string">"transform"</span>, <span class="string">"translate(30,20)"</span>);       <span class="comment">// 調整原點產生位置，對齊座標軸中心</span></span><br></pre></td></tr></table></figure>

<p>結果顯示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191001/20119062s7pR6uUYWP.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191001/20119062s7pR6uUYWP.jpg"></p>
<p>而要注意的事情是，<strong>圓點之間距離比例需要對應到圖表坐標軸的比例</strong>，藉由坐標軸的比例，將原先的資料能隨著比例一同對應到畫面上，另一方面也要記得調整<strong>生成圓點群組時的位置</strong>要對應到座標軸的中心位置 <code>(0, 0)</code>。</p>
<h2 id="繪製折線圖-line-chart"><a href="#繪製折線圖-line-chart" class="headerlink" title="繪製折線圖 line chart"></a>繪製折線圖 line chart</h2><p>繪製完散點圖後，另一個跟散點圖有異曲同工之妙的圖表就是折線圖啦，折線圖與散點圖的邏輯其實差不了多少，主要都是<strong>將資料輸出給圖形座標點 <code>(X, Y)</code> 來繪製</strong>。而 D3.js 的線段，便是<strong>藉由 SVG 中的 <code>path</code> 路徑標籤來繪製</strong>，以<strong>屬性 <code>d</code></strong> 來描述路徑，如果大家還記得的話我們曾經在 <a href="https://ithelp.ithome.com.tw/articles/10219120" target="_blank" rel="noopener">SVG 基本圖型繪製</a> 章節中介紹過下面這段<strong>符咒</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M0,0h7.75a45.5,45.5 0 1 1 0,91h-7.75v-20h7.75a25.5,25.5 0 1 0 0,-51h-7.75zm36.2510,0h32a27.75,27.75 0 0 1 21.331,45.5a27.75,27.75 0 0 1 -21.331,45.5h-32a53.6895,53.6895 0 0 0 18.7464,-20h13.2526a7.75,7.75 0 1 0 0,-15.5h-7.75a53.6895,53.6895 0 0 0 0,-20h7.75a7.75,7.75 0 1 0 0,-15.5h-13.2526a53.6895,53.6895 0 0 0 -18.7464,-20z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本上這段 <code>path</code> 路徑要由人類來編寫實在是太辛苦了，縱使有能力能通靈繪製出這個線段，一但要改變某段線條，那將會非常痛苦，因此 D3.js 提供一個 <code>d3.line()</code> 來協助我們定義這條線，而我們只要將座標傳入到 <code>x()</code> 以及 <code>y()</code> 中即可產生出這條線段的路徑，並且在產生圖表時將其帶入屬性 <code>d</code> 即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// draw() 函式內部</span></span><br><span class="line"><span class="keyword">let</span> line = d3.line()                        <span class="comment">// 定義線段</span></span><br><span class="line">    .x(<span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Xscale(d.x);</span><br><span class="line">    &#125;)</span><br><span class="line">    .y(<span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Yscale(d.y);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">d3.select(<span class="string">'svg'</span>).append(<span class="string">'path'</span>)</span><br><span class="line">    .attr(<span class="string">'d'</span>, line(dataset))               <span class="comment">// 使用定義線段</span></span><br><span class="line">    .attr(<span class="string">"transform"</span>, <span class="string">"translate(30,20)"</span>)</span><br><span class="line">    .attr(<span class="string">'stroke'</span>, <span class="string">'black'</span>)</span><br><span class="line">    .attr(<span class="string">'stroke-width'</span>,<span class="number">2</span>)</span><br><span class="line">    .attr(<span class="string">'fill'</span>, <span class="string">'none'</span>);</span><br></pre></td></tr></table></figure>

<p>畫面上結果顯示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191001/20119062cDgJma6soy.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191001/20119062cDgJma6soy.jpg"></p>
<p>打開開發者工具來看看這條線：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191001/20119062Fj2hKV7SAa.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191001/20119062Fj2hKV7SAa.jpg"></p>
<p>…恩，我想還是關起來好了。</p>
<h3 id="客製化線條"><a href="#客製化線條" class="headerlink" title="客製化線條"></a>客製化線條</h3><p>D3.js 除了已經處理好 <code>path</code> 基本路徑之外，還提供了一些客製化功能：</p>
<ul>
<li><code>line.defined()</code>：定義繪製的資料範圍<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> line = d3.line()</span><br><span class="line">    .x(<span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Xscale(d.x);</span><br><span class="line">    &#125;)</span><br><span class="line">    .y(<span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Yscale(d.y);</span><br><span class="line">    &#125;)</span><br><span class="line">    .defined(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;<span class="keyword">return</span> d.y &gt; <span class="number">30</span> &#125;); <span class="comment">// 只繪製資料 Y 中大於 30 的點所連起來的線段</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>結果顯示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191001/201190628HUbwC6NmB.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191001/201190628HUbwC6NmB.jpg"></p>
<ul>
<li><code>line.curve()</code>：定義線段樣式，前身在 3 版中為 <code>line.interpolate</code>。</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">let line = d3.line()</span><br><span class="line">    .x(<span class="keyword">function</span> <span class="title"></span>(d) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Xscale(d.x)</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .y(<span class="keyword">function</span> <span class="title"></span>(d) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Yscale(d.y)</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .curve(d3.curveBasis);         // 加入這段 curve 來定義線條，並且樣式採用 d3.curveBasis 呈現</span><br></pre></td></tr></table></figure>

<p>結果顯示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191001/20119062NgAh5xLKsN.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191001/20119062NgAh5xLKsN.jpg"></p>
<p>以上即為 D3.js 中繪製散點圖以及折線圖的部分，明天就是鐵人賽的最後一天啦，老實說還有很多東西可以講，像是 Vue-cli 與 D3.js 的結合、透過 Vuex 撈取資料給 D3.js 繪圖等等，或許有機會就會直接繼續寫下去吧？總之，明天我們將會來繪製 D3.js 裡面算是最經典的圖表－－地圖！</p>
<blockquote>
<p>黑黑黑到只剩眼睛跟鈴鐺<br><img src="https://ithelp.ithome.com.tw/upload/images/20191001/20119062eMtIHfEnSu.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191001/20119062eMtIHfEnSu.jpg"></p>
</blockquote>
<h2 id="附註-D3-js-3-版與-4-版線段相關-API-差異表"><a href="#附註-D3-js-3-版與-4-版線段相關-API-差異表" class="headerlink" title="附註 D3.js 3 版與 4 版線段相關 API 差異表"></a>附註 D3.js 3 版與 4 版線段相關 API 差異表</h2><blockquote>
<p>// 線段相關<br>d3.svg.line ↦ d3.line<br>d3.svg.line.radial ↦ d3.radialLine<br>// 線段樣式<br>linear ↦ d3.curveLinear<br>linear-closed ↦ d3.curveLinearClosed<br>step ↦ d3.curveStep<br>step-before ↦ d3.curveStepBefore<br>step-after ↦ d3.curveStepAfter<br>basis ↦ d3.curveBasis<br>basis-open ↦ d3.curveBasisOpen<br>basis-closed ↦ d3.curveBasisClosed<br>bundle ↦ d3.curveBundle<br>cardinal ↦ d3.curveCardinal<br>cardinal-open ↦ d3.curveCardinalOpen<br>cardinal-closed ↦ d3.curveCardinalClosed<br>monotone ↦ d3.curveMonotoneX</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 繪製座標軸 axis</title>
    <url>/d3.js/D3-011-axis/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="繪製座標軸"><a href="#繪製座標軸" class="headerlink" title="繪製座標軸"></a>繪製座標軸</h2><p>透過 D3.js 比例尺後，我們現在已經可以透過資料得到對應比例尺的數值了，而今天要緊接著透過這個數值來繪製座標軸，並且一樣採用 Vue.js 框架來說明。</p>
<p>而在 Vue.js 中的實體設定基本上與前幾天差不多，最主要我們將資料集換成<strong>每筆資料各有兩個屬性資料</strong>的格式：</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      sampleData: [</span><br><span class="line">        &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">80</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">x</span>: <span class="number">70</span>, <span class="attr">y</span>: <span class="number">40</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">x</span>: <span class="number">60</span>, <span class="attr">y</span>: <span class="number">50</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">x</span>: <span class="number">30</span>, <span class="attr">y</span>: <span class="number">100</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">x</span>: <span class="number">90</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      d3.select(<span class="string">"#app"</span>)</span><br><span class="line">        .append(<span class="string">"svg"</span>)</span><br><span class="line">        .attr(<span class="string">"width"</span>, <span class="number">250</span>)</span><br><span class="line">        .attr(<span class="string">"height"</span>, <span class="number">250</span>)</span><br><span class="line">        .style(<span class="string">"border"</span>, <span class="string">"1px solid #00000060"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="keyword">this</span>.draw();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      draw(newData) &#123;</span><br><span class="line">        <span class="keyword">let</span> dataset = newData || <span class="keyword">this</span>.sampleData;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>此時應該會看的到目前我們 SVG 畫布（灰線標示框內），應該是沒有任何東西的：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062zZPgxGAmfB.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062zZPgxGAmfB.jpg"></p>
<p>接著來繪製 X 軸線，首先我們得取出用來當作 X 軸線資料參考的資料：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// draw() 函式內部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dataset = newData || <span class="keyword">this</span>.sampleData;</span><br><span class="line"><span class="keyword">let</span> Xdata = dataset.map(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d.x;                              <span class="comment">// [10, 70, 60, 30, 90]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>再來是用到我們昨天剛學到的比例尺換算，來換算 <strong>X 軸要顯示的比例長度</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// draw() 函式內部</span></span><br><span class="line"><span class="keyword">let</span> dataset = newData || <span class="keyword">this</span>.sampleData;</span><br><span class="line"><span class="keyword">let</span> Xdata = dataset.map(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d.x;                              <span class="comment">// [10, 70, 60, 30, 90]</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> Xscale = d3</span><br><span class="line">  .scaleLinear()</span><br><span class="line">  .domain([<span class="number">0</span>, d3.max(Xdata)])              <span class="comment">// 座標 X 軸的長度將會依據 0 至 Xdata 資料的最大值</span></span><br><span class="line">  .range([<span class="number">0</span>, <span class="number">200</span>]);                        <span class="comment">// 換算成實際上會輸出的長度 0 至 200</span></span><br></pre></td></tr></table></figure>

<p>緊接著下方加入 D3.js 軸線的樣式定義：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Xaxis = d3.axis<span class="constructor">Bottom(Xscale)</span>;         <span class="comment">// 繪製一個數值朝下的平行座標線，並依據 Xscale 比例尺換算</span></span><br></pre></td></tr></table></figure>

<p>建立一個 X 座標軸的群組：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">let gXaxis = d3</span><br><span class="line"><span class="meta">  .select</span>(<span class="string">"svg"</span>)</span><br><span class="line"><span class="meta">  .append</span>(<span class="string">"g"</span>)</span><br><span class="line"><span class="meta">  .attr</span>(<span class="string">"transform"</span>, <span class="string">"translate(30,220)"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>最後呼叫 <code>Xaxis</code> 來執行繪圖：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Xaxis(<span class="name">gXaxis</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>畫面上最後顯示：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062IYr3UlvqlZ.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062IYr3UlvqlZ.jpg"></p>
<p>整段程式跑的邏輯在於，最後呼叫 <code>Xaxis</code> 時，會回傳 <code>gXaxis</code> 建立好的範圍給 <code>d3.axisBottom(Xscale)</code> 做新增，接著 <code>d3.axisBottom(Xscale)</code> 接收到範圍後， <code>d3.axisBottom()</code> 會幫我們 <code>gXaxis</code> 範圍中繪製一條數值朝下的平行座標線，並採用 <code>Xscale</code> 比例尺換算。</p>
<p>釐清觀念後，快速歸納出以下步驟：</p>
<ol>
<li>建立 <code>Xscale</code> ，放入比例尺設定，供 X 軸產生時有依據可供參考（<code>domain</code> 負責<strong>座標軸資料</strong>對應、<code>range</code> 負責<strong>座標軸長度</strong>對應。</li>
<li>建立 <code>Xaxis</code> ，放入 D3.js 座標軸定義，並採用 <code>Xscale</code> 比例來繪製。</li>
<li>建立 <code>gXaxis</code> ，在 SVG 新增一塊群組範圍 <code>&lt;g&gt;</code>，供繪製座標時的 <strong>實際位置範圍</strong></li>
<li>啟用 <code>Xaxis</code> 來繪製座標軸。</li>
</ol>
<p>而 Y 軸的部分則也是依樣畫葫蘆即可完成：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> Ydata = dataset.<span class="built_in">map</span>(function(d) &#123;</span><br><span class="line">  <span class="built_in">return</span> d.y;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">let</span> Yscale = d3</span><br><span class="line">  .scaleLinear()</span><br><span class="line">  .<span class="built_in">domain</span>([<span class="number">0</span>, d3.<span class="built_in">max</span>(Ydata)])</span><br><span class="line">  .<span class="built_in">range</span>([<span class="number">200</span>, <span class="number">0</span>]);</span><br><span class="line"><span class="built_in">let</span> Yaxis = d3.axisLeft(Yscale);</span><br><span class="line"><span class="built_in">let</span> gYaxis = d3</span><br><span class="line">  .select(<span class="string">"svg"</span>)</span><br><span class="line">  .<span class="built_in">append</span>(<span class="string">"g"</span>)</span><br><span class="line">  .attr(<span class="string">"transform"</span>, <span class="string">"translate(30,20)"</span>);</span><br><span class="line"></span><br><span class="line">Yaxis(gYaxis);</span><br></pre></td></tr></table></figure>

<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062JaD1vQwZWL.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062JaD1vQwZWL.jpg"></p>
<p>這樣就完成了座標軸繪製的部分，很簡單吧！</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062TlhU0te1Un.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062TlhU0te1Un.jpg"></p>
<h2 id="座標軸客製化"><a href="#座標軸客製化" class="headerlink" title="座標軸客製化"></a>座標軸客製化</h2><p>若繪製完還對於座標軸有些不滿意的話，D3.js 還有提供一些客製化的部分：</p>
<ul>
<li><p><code>ticks()</code> ：將座標軸劃分為指定的段落（會自動取成較為代表意義的範圍）。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">let Xaxis = d<span class="number">3.</span>axisBottom<span class="comment">(Xscale)</span>.ticks<span class="comment">(4)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/201190622kWbFtC8s0.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/201190622kWbFtC8s0.jpg"></p>
</li>
<li><p><code>tickValues()</code> ：只顯示特定座標數值的刻線</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let Xaxis = d3.axisBottom(Xscale).tickValues([<span class="number">13</span>, <span class="number">55</span>, <span class="number">79</span>]);</span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062ZqjUOZHw6U.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062ZqjUOZHw6U.jpg"></p>
</li>
</ul>
<ul>
<li><p><code>tickSize()</code> ：更改座標軸刻線長度</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Xaxis = d3.axis<span class="constructor">Bottom(Xscale)</span>.tick<span class="constructor">Size(0)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/2011906228iavULhvG.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/2011906228iavULhvG.jpg"></p>
</li>
<li><p><code>tickPadding()</code> ：座標軸與座標軸標籤之間的距離（例如調整一下剛剛上方調整刻線長度後，數值太接近座標線的問題。）</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Xaxis = d3</span><br><span class="line">    .axis<span class="constructor">Bottom(Xscale)</span></span><br><span class="line">    .tick<span class="constructor">Size(0)</span></span><br><span class="line">    .tick<span class="constructor">Padding(10)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/201190624jAQNY7hPi.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/201190624jAQNY7hPi.jpg"></p>
</li>
<li><p><code>tickFormat()</code> ：定義座標軸數值的格式，可以傳入一個回呼函式（callback function）來定義內容，也可以參考 <a href="https://github.com/d3/d3-format" target="_blank" rel="noopener">d3-format</a> 文件定義資料格式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Xaxis = d3.axisBottom(Xscale).tickFormat(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d + <span class="string">"元"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062Vsix7e4oAh.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062Vsix7e4oAh.jpg"></p>
</li>
</ul>
<h2 id="附註-D3-js-座標軸-3-版與-4-版差異補充"><a href="#附註-D3-js-座標軸-3-版與-4-版差異補充" class="headerlink" title="附註 D3.js 座標軸 3 版與 4 版差異補充"></a>附註 D3.js 座標軸 3 版與 4 版差異補充</h2><p>在 D3.js 3 版中，原先座標軸會<strong>需要以 CSS 以及 JavaScript 去定義座標軸的樣式</strong>，否則座標軸只會呈現一條線：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062ma7eL0TCiC.png" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062ma7eL0TCiC.png"></p>
<blockquote>
<p>（圖源源自 D3.js <a href="https://github.com/d3/d3/blob/master/CHANGES.md" target="_blank" rel="noopener">官方網站</a> 座標軸圖）</p>
</blockquote>
<p>而在 4 版本之後我們可以透過藉由直接呼叫座標軸方向的 API 來直接採用他的基本樣式與相關設定。</p>
<ul>
<li><code>d3.axisTop</code> ：繪製一個數值朝 <strong>上</strong> 的 <strong>平行</strong> 座標線</li>
<li><code>d3.axisRight</code> ：繪製一個數值朝 <strong>右</strong> 的 <strong>垂直</strong> 座標線</li>
<li><code>d3.axisBottom</code> ：繪製一個數值朝 <strong>下</strong> 的 <strong>平行</strong> 座標線</li>
<li><code>d3.axisLeft</code> ：繪製一個數值朝 <strong>左</strong> 的 <strong>垂直</strong> 座標線</li>
</ul>
<p>以上便是今天 D3.js 繪製座標軸的說明，會繪製座標軸後，基本上要繪製各種座標圖表類型也難不倒了我們了，而明天我們將要來繪製與座標軸有關的相關圖表。</p>
<blockquote>
<p>今天外面颱風天時而暴雨時而寧靜，只要一下雨，阿橘就會很好奇的趴在窗邊看天空。<br><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062K6oywinqWO.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062K6oywinqWO.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 繪製臺灣地圖</title>
    <url>/d3.js/D3-013-geojson-topojson/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="D3-js-地圖"><a href="#D3-js-地圖" class="headerlink" title="D3.js 地圖"></a>D3.js 地圖</h2><p>今天我們要來繪製 D3.js 人人必<strong>繪</strong>的地圖啦！</p>
<p>我們首先到臺灣 <a href="https://data.gov.tw/dataset/7442" target="_blank" rel="noopener">政府資料開放平臺</a> 的網站中下載以縣市為界的台灣地圖 SHP 檔案：</p>
<a id="more"></a>

<p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062X0e9kJFd5j.png" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062X0e9kJFd5j.png"></p>
<blockquote>
<p>Shapefile（SHP），是美國環境系統研究所公司（ESRI）開發的空間資料開放格式。目前 SHP 檔案格式為地理資訊軟體界的開放標準。（資料來源： <a href="https://zh.wikipedia.org/wiki/Shapefile" target="_blank" rel="noopener">SHP Wiki</a>）</p>
</blockquote>
<p>接著透過 <a href="https://mapshaper.org/" target="_blank" rel="noopener">mapshaper</a> 網站將下載好的 SHP 檔案轉成 D3.js 能夠編寫的 GeoJson 格式（或 TopoJson 格式），直接將剛下載好的解壓縮檔案丟進去即可：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062OjzoV2L2q3.png" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062OjzoV2L2q3.png"></p>
<p>選擇 Import 匯入：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062XzLfH86A9a.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062XzLfH86A9a.jpg"></p>
<p>就可以畫面上顯示出預覽地圖：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062jsybOxZlUW.png" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062jsybOxZlUW.png"></p>
<p>而在輸出檔案前我們還要先把地圖優化一下，點選右上方的 Simplify 簡化地圖：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062B231g98mW7.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062B231g98mW7.jpg"></p>
<p>將地圖簡化到 30% 左右，此時可以稍微看到地圖邊緣稍微被簡化一些，但失真程度不大還能接受：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062kl3blfOO3d.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062kl3blfOO3d.jpg"></p>
<p>最後點選右上方 Export 輸出檔案，可以看到有各種檔案類型可供選擇，這裡可以選擇 GeoJSON 或 TopoJSON，而本章範例將會採用 TopoJSON 的格式來示範：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062UTQsSF9wUN.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062UTQsSF9wUN.jpg"></p>
<p>而為什麼範例要選擇 TopoJSON 的格式呢？我們可以來比較一下簡化後與兩種檔案格式的大小差異：</p>
<p>GeoJSON 100% 檔案大小：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062kdwThk8UlU.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062kdwThk8UlU.jpg"><br>GeoJSON  30% 檔案大小：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062TK14DueitY.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062TK14DueitY.jpg"><br>TopoJSON 30% 檔案大小：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062E4cQI1EJrK.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062E4cQI1EJrK.jpg"></p>
<p>我們可以看到簡化過的檔案容量降了將近快要 10MB ，而 TopoJSON 又還能比 GeoJSON 更少了約八成左右，最後檔案從 12.1MB 的大怪物被優化到剩下 622KB 的檔案大小，並且品質還在能接受的範圍。</p>
<p>而這兩種檔案究竟差在哪裡呢？</p>
<h2 id="GeoJSON"><a href="#GeoJSON" class="headerlink" title="GeoJSON"></a>GeoJSON</h2><blockquote>
<p>RFC 7946:<br>GeoJSON is a geospatial data interchange format based on JavaScript Object Notation (JSON). </p>
</blockquote>
<p>根據 <a href="https://tools.ietf.org/html/rfc7946" target="_blank" rel="noopener">RFC 7946</a> 的定義，GeoJSON 主要是基於 JSON 編寫的一種地理交換資料格式。也就是說 <strong>GeoJSON 其實就是 JSON 格式的檔案，並非是一種新的格式</strong>，只是將地理的一些訊息描述以 JSON 規則呈現並受嚴格的定義控管。</p>
<blockquote>
<p>Geometry Object<br>A Geometry object represents points, curves, and surfaces in coordinate space.  Every Geometry object is a GeoJSON object no matter where it occurs in a GeoJSON text.</p>
</blockquote>
<p>而在幾何物件（Geometry Object）的 <a href="https://tools.ietf.org/html/rfc7946#section-3" target="_blank" rel="noopener"> RFC 文件章節</a>  裡也提到：不論用來描述的點、線、面等等訊息在檔案的何處，<strong>都需要以 GeoJSON 物件形式呈現</strong>，並且底下也詳細列出了描述地圖的一些規範和代表含意說明（如位置、點、多點、線段、多邊形等等）。</p>
<h2 id="TopoJSON"><a href="#TopoJSON" class="headerlink" title="TopoJSON"></a>TopoJSON</h2><p>由 D3.js 作者 Mike Bostock 所發明的 <a href="https://github.com/topojson/topojson-specification/blob/master/README.md" target="_blank" rel="noopener">TopoJSON</a> 則是以 GeoJSON 為基礎，以拓樸學的科學基礎編碼而成的格式。其最大的特色就是原先在 GeoJSON 中描述地理訊息的邊緣，會以共同邊（<code>arcs</code>）所表示，並且消除掉一些較為冗贅的地理資訊後而產生。</p>
<h2 id="繪製地圖"><a href="#繪製地圖" class="headerlink" title="繪製地圖"></a>繪製地圖</h2><p>D3.js 根據了 GeoJSON 與 TopoJSON 格式來處理地圖訊息，透過像是 SVG 中的路徑 <code>path</code> ，將處理好的的資訊轉換為視覺呈現，而要以 TopoJSON 檔案來繪製地圖的話，可以透過 Mike Bostock 在 <a href="https://github.com/topojson/topojson" target="_blank" rel="noopener">TopoJSON 專案</a> 中的 API 來解碼使用，目前專案上也提供了 CDN 連結供快速開發使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://unpkg.com/topojson@3"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>接著如同前面幾章，我們依樣畫葫蘆開一個 Vue.js 的 HTML 版面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">'500'</span> <span class="attr">height</span>=<span class="string">'500'</span> <span class="attr">style</span>=<span class="string">'border:1px solid #00000060;'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">g</span> <span class="attr">class</span>=<span class="string">"counties"</span>&gt;</span><span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span> <span class="attr">class</span>=<span class="string">"county-borders"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Vue 實體中則是開了一個 data <code>taiwanCountry</code> 給予預設值，待實體載入完畢時將我們前面處理好的 TopoJSON 檔 <code>COUNTY_MOI_1080726.json</code> 透過 fetch 的方式載入我們的地圖資料以供取用，並且呼叫 <code>draw()</code> 函式來繪製地圖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        taiwanCountry: []</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        fetch(<span class="string">'COUNTY_MOI_1080726.json'</span>)</span><br><span class="line">            .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">            .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.taiwanCountry = result</span><br><span class="line">                <span class="keyword">this</span>.draw(<span class="keyword">this</span>.taiwanCountry)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        draw(mapData) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 <code>draw</code> 函式中，使用 <code>d3.geoMercator()</code> 來定義投影模式，並以 <code>center</code> 定義經緯度位置，<code>scale</code> 定義縮放比例尺：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> projection = d3.geoMercator()</span><br><span class="line">    .center([<span class="number">123</span>, <span class="number">24</span>])</span><br><span class="line">    .scale(<span class="number">5500</span>);</span><br></pre></td></tr></table></figure>

<p>接著加入 <code>d3.geoPath()</code> （用來產生供 <code>path</code> 路徑標籤所使用的 <code>d</code>），並且傳入剛才定義好的投影模式 <code>projection</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> path = d3.geoPath(projection);</span><br></pre></td></tr></table></figure>

<p>最後透過 d3.js 選擇器選擇我們剛以開好的 HTML 版面，在 <code>g.counties</code> 產生地圖面積、<code>path.county-borders</code> 產生地圖輪廓：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">d3.select(<span class="string">'g.counties'</span>)</span><br><span class="line">    .selectAll(<span class="string">"path"</span>)</span><br><span class="line">    .data(topojson.feature(mapData, mapData.objects[<span class="string">"COUNTY_MOI_1080726"</span>]).features)</span><br><span class="line">    .enter().append(<span class="string">"path"</span>)</span><br><span class="line">    .attr(<span class="string">"d"</span>, path);</span><br><span class="line"></span><br><span class="line">d3.select(<span class="string">'path.county-borders'</span>)</span><br><span class="line">    .attr(<span class="string">"d"</span>, path(topojson.mesh(mapData, mapData.objects[<span class="string">"COUNTY_MOI_1080726"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a !== b; &#125;)));</span><br></pre></td></tr></table></figure>

<p>而裡面使用到的 <code>topojson</code> API 方法說明如下：</p>
<ul>
<li><code>topojson.feature</code> ：將 TopoJSON 轉換成 GeoJSON 的格式。</li>
<li><code>topojson.mesh</code> ：將 TopoJSON 中的 geometry 物件轉換成 GeoJSON 中的線段。<br>其餘未使用到的 API 可參考 GitHub 上的 <a href="https://github.com/topojson/topojson" target="_blank" rel="noopener">topojson 專案</a></li>
</ul>
<p>加上一點點 CSS 來點綴：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-class">.counties</span> &#123;</span><br><span class="line">        <span class="attribute">fill</span>:<span class="number">#33474e</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.counties</span> <span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">fill</span>: <span class="number">#7f9ca7</span>;</span><br><span class="line">        <span class="attribute">transition</span>: <span class="number">0.5s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.county-borders</span> &#123;</span><br><span class="line">        <span class="attribute">fill</span>: none;</span><br><span class="line">        <span class="attribute">stroke</span>: <span class="number">#fff</span>;</span><br><span class="line">        <span class="attribute">stroke-width</span>: <span class="number">0.5px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>最後畫面上顯示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062PzAXSvqUed.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062PzAXSvqUed.jpg"></p>
<p><a href="https://codepen.io/ShawnLin0201/pen/zYOgdXM" target="_blank" rel="noopener">範例程式碼</a></p>
<blockquote>
<p>躺爆！<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062tKSJRlr5q4.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062tKSJRlr5q4.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown筆記</title>
    <url>/markdown/tool-001-markdown/</url>
    <content><![CDATA[<h1 id="Markdown由來"><a href="#Markdown由來" class="headerlink" title="Markdown由來"></a>Markdown由來</h1><p>　　Markdown語言創始人為<strong><em>John Gruber</em></strong>，與<strong><em>Aaron Swartz</em></strong>共同合作完成。他的宗旨在於創造一個<strong>「易於閱讀、撰寫的純文字格式」</strong>語言，並且觀念圍繞在它的可讀性，因此在編寫時就算沒有解析器的輔助其實也是很容易可以看得懂文章的脈絡。而隨著時間的推移之下，markdown語言由廣大的開發人員開發了許多新的功能，但在沒有規範的情況下使得Markdown解析器的開發人員，在開發解析器的時候感到困難，因此標準化討論的議題便浮上檯面。而作者<strong><em>John Gruber</em></strong>在2014年的twitter上對此議題發表了一段話：</p>
<blockquote>
<p>Because different sites (and people) have different needs. No one syntax would make all happy.<br>節自：<a href="https://twitter.com/gruber/status/507670720886091776" target="_blank" rel="noopener">https://twitter.com/gruber/status/507670720886091776</a></p>
</blockquote>
<p>　　縱使作者認為Markdown不應受到標準化的影響，最終2016年3月還是發布了RFC7763與RFC7764，其中RFC7764的討論也就是目前開發社群知名的網站Github也將其格式註冊了上去<strong>(GitHub Flavored Markdown)</strong>。而在2017年，GitHub也發布了GFM的正式規範，並且在他們的網站上實作了他們的解析器，使得開源專案的說明文件有較為統一的格式，也讓開發人員有一個更容易閱讀文件的模式。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>使用 Markdown 格式在如今的規範下非常的簡單，大部分都只依靠簡單的符號與數字便能完成：</p>
<a id="more"></a>

<h3 id="1-標題"><a href="#1-標題" class="headerlink" title="1.標題"></a>1.標題</h3><p>使用hash符號，來當作標題，越多#符號表示層級越小<br>效果：</p>
<h4 id="可以當作標題"><a href="#可以當作標題" class="headerlink" title="可以當作標題"></a>可以當作標題</h4><h3 id="2-粗體與斜體"><a href="#2-粗體與斜體" class="headerlink" title="2.粗體與斜體"></a>2.粗體與斜體</h3><p>使用單一星號框住為斜體，兩個為粗體，三個為粗斜體。<br>效果：<br><em>字體變斜體</em><br><strong>字體變粗體</strong><br><strong><em>字體變粗斜體</em></strong></p>
<h3 id="3-區塊"><a href="#3-區塊" class="headerlink" title="3.區塊"></a>3.區塊</h3><p>使用&gt;大於符號，將會把後方文字框住表示<br>效果：</p>
<blockquote>
<p>可以用來當作說明文字</p>
</blockquote>
<h3 id="4-無序清單"><a href="#4-無序清單" class="headerlink" title="4.無序清單"></a>4.無序清單</h3><p>使用-星號來來表示清單項目<br>效果：</p>
<ul>
<li>清單一</li>
<li>清單二</li>
</ul>
<h3 id="5-有序清單"><a href="#5-有序清單" class="headerlink" title="5.有序清單"></a>5.有序清單</h3><p>使用數字來來表示清單項目<br>效果：</p>
<ol>
<li>清單一</li>
<li>清單二</li>
</ol>
<h3 id="6-程式碼"><a href="#6-程式碼" class="headerlink" title="6.程式碼"></a>6.程式碼</h3><p>而身為工程師最常需要在文章內使用程式碼片段的部分markdown也有提供啦！<br>使用‵‵‵　‵‵‵‵來框住的程式碼<br>效果：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span> = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span> = <span class="number">2</span> ;</span><br><span class="line">console.log( a + b )</span><br></pre></td></tr></table></figure>

<p>介紹完了這些基本的Markdown用法外，其實還有更多可以參考<a href="https://docs.microsoft.com/zh-tw/contribute/how-to-write-use-markdown" target="_blank" rel="noopener">Mircosoft的文件</a>，官方文件還是說明得比較清楚啦哈哈哈。我之後文章將會主力討論程式語言的部分，若有其他想要我介紹的部分歡迎來信告知，那麼我們下次再見囉，掰掰！</p>
<p>參考文件：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Markdown</a></li>
<li><a href="https://docs.microsoft.com/zh-tw/contribute/how-to-write-use-markdown" target="_blank" rel="noopener">https://docs.microsoft.com/zh-tw/contribute/how-to-write-use-markdown</a></li>
</ul>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Mocha.js 入門、環境建置與範例（Install, Build environment）</title>
    <url>/mocha.js/Mocha-001-intro/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="mocha-logo" src='/images/Mocha/mocha-logo.svg' width='200px' height='200px' />
</div>

<h1 id="What-is-Mocha-js"><a href="#What-is-Mocha-js" class="headerlink" title="What is Mocha.js"></a>What is Mocha.js</h1><p>Mocha.js 是一款基於 Node.js 的 JavaScript 測試框架，用意在於使開發人員可以寫出更優雅且容易閱讀的測試程式碼，並且支援不同斷言庫來判斷程式。而彈性、多樣的配置是 Mocha.js 最大的特點，不同於像是 Jest.js 的 <strong>batteries-included</strong> 的概念，Mocha.js 只提供了最基本的測試環境，而斷言與隔離的選擇，都可以自由地搭配其他的函式庫來使用。例如：選配 Chai.js 斷言庫以及 Sinon.js 隔離庫。如此一來就能使用較自由的測試風格來撰寫測試程式碼。</p>
<a id="more"></a>

<blockquote>
<p>註：<br>斷言（assertion）意思即為開發程式中執行完畢時，程式碼執行結果應與斷言所設定的結果一致，否則該處斷言碼會拋出錯誤。<br>隔離則表示在測試中，我們會透過工具來仿造原先開發中的模組、元件、函式、數值等，來使測試能夠集中於某個特定的進入點。</p>
</blockquote>
<h1 id="環境建置"><a href="#環境建置" class="headerlink" title="環境建置"></a>環境建置</h1><p>首先，我們可以透過 npm 來安裝 Mocha 到 <strong>全域環境</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --global mocha</span><br></pre></td></tr></table></figure>
<p>或是將它安裝到 <strong>專案開發環境</strong> 下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev mocha</span><br></pre></td></tr></table></figure>

<p>安裝完畢後，我們需要在專案中新建一個名稱為 <code>test</code> 的資料夾，並且在資料夾裡面再新建一個 <code>sample.spec.js</code> 檔案。</p>
<blockquote>
<p>創立 <strong>sample.spec.js</strong> 之後，目前的專案目錄應該看起來像是這樣：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">├── node_modules/       <span class="comment">// 使用 npm 下載管理的模組會集中在此</span></span><br><span class="line">├── test/               <span class="comment">// 測試程式碼預設資料夾位置</span></span><br><span class="line">│   └── sample<span class="selector-class">.spec</span><span class="selector-class">.js</span>     <span class="comment">// 測試程式碼檔案</span></span><br><span class="line">├── package-lock<span class="selector-class">.json</span>   <span class="comment">// npm 文件檔（管理 npm 預設模組，不必去動他）</span></span><br><span class="line">└── package<span class="selector-class">.json</span>        <span class="comment">// npm 文件檔（管理專案中客製的模組）</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>如此一來 <code>Mochajs</code> 便能根據預設設定去找尋 <code>test</code> 資料夾底下有 <code>spec.js</code> 結尾的檔案來執行測試。</p>
<h1 id="撰寫測試程式碼"><a href="#撰寫測試程式碼" class="headerlink" title="撰寫測試程式碼"></a>撰寫測試程式碼</h1><p>在撰寫測試程式碼前，我們先來準備一隻檔案 <code>sum.js</code> 以供測試：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = sum</span><br></pre></td></tr></table></figure>
<p>範例中展示的是一個簡單的加法運算函式，我們透過 <code>module.exports = sum</code> 來導出我們的函式，使待會我們可以在測試程式碼 <code>sample.spec.js</code> 中使用 <code>require</code> 來導入。</p>
<blockquote>
<p>創立 <strong>sum.js</strong> 之後，目前的專案目錄應該看起來像是這樣：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">├── node_modules/</span><br><span class="line">├── test/</span><br><span class="line">│   └── sample<span class="selector-class">.spec</span>.js</span><br><span class="line">├── sum<span class="selector-class">.js</span>              <span class="comment">// 剛剛寫好的 JavaScript 檔案</span></span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
</blockquote>
<p>接著我們回到 <code>sample.spec.js</code> 準備來撰寫測試程式碼：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>)  <span class="comment">// 引入 Mocha 的斷言庫。</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="built_in">require</span>(<span class="string">'../sum'</span>)   <span class="comment">// 引入寫好的程式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述測試環境</span></span><br><span class="line">describe(<span class="string">'sum 函式測試'</span>, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述測試案例</span></span><br><span class="line">    it(<span class="string">'1 加上 2 應該等於 3'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 透過斷言庫來寫判斷式</span></span><br><span class="line">        assert.equal(sum(<span class="number">1</span>,<span class="number">2</span>), <span class="number">3</span>,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述另一個測試案例</span></span><br><span class="line">    it(<span class="string">'100 加上 200 應該等於 300'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(sum(<span class="number">100</span>, <span class="number">200</span>), <span class="number">300</span>,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在這個範例程式碼中，主要是在測試剛剛我們寫好的 <code>sum.js</code> 函式，並且透過兩個測試案例來描述情境，並斷言該情境預期的結果。（語法在後面的篇章將會有更詳細的介紹。）</p>
<h1 id="執行測試"><a href="#執行測試" class="headerlink" title="執行測試"></a>執行測試</h1><p>準備好測試程式碼後，我們回到 <code>package.json</code> 來撰寫最後要執行用的快捷程式碼：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"test"</span>: <span class="string">"mocha"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一來，我們在終端機中執行 <code>npm run test</code> 便可以執行 <code>Mocha</code> 來根據測試程式碼來測試程式了。而本次測試執行的結果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span> sum 函式測試</span><br><span class="line">    √ 1 加上 2 應該等於 3</span><br><span class="line">    √ 100 加上 200 應該等於 300</span><br><span class="line">2 passing (13ms)</span><br></pre></td></tr></table></figure>

<p>我們看到測試結果首先跑出我們前面使用 <code>describe</code> 所描述的測試情境，並且在底下顯示兩條通過的測試案例，後面帶有使用 <code>it</code> 所描述的測試案例說明，到這裡基本上我們已經完成了一個測試基本的概念雛型。</p>
<p>有興趣的讀者，可以再試試看假設今天的程式結果與斷言不一致時會發生什麼事情？</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://mochajs.org/#installation" target="_blank" rel="noopener">Mocha-installation</a></li>
<li><a href="https://mochajs.org/#getting-started" target="_blank" rel="noopener">Mocha-get-started</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Mocha.js</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Mocha.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Mocha.js 運行週期、週期鉤子（Run cycle, Hook）</title>
    <url>/mocha.js/Mocha-002-run-cycle/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="mocha-logo" src='/images/Mocha/mocha-logo.svg' width='200px' height='200px' />
</div>

<h1 id="Run-Cycle-運行週期"><a href="#Run-Cycle-運行週期" class="headerlink" title="Run Cycle 運行週期"></a>Run Cycle 運行週期</h1><p>Mocha.js 在執行測試時，會遵循它的運行週期，只要瞭解了它的運行週期，我們便能快速掌握撰寫測試程式碼的基本架構：</p>
<a id="more"></a>

<p><img src="/images/Mocha/mocha-run-cycle.png" alt="mocha-run-cycle.png"></p>
<ol>
<li>執行 Mocha 主程式</li>
<li>生成並進入子處理程序。</li>
<li>處理並執行 Mocha options 選項內容。</li>
<li>依序單筆地執行所有 spec 檔案。</li>
<li>在 spec 檔案中，依序執行所有的測試套件 <code>describe()</code> 中的 callback function。</li>
<li>第一筆測試案例開始前，執行 <code>before()</code> 週期鉤子。</li>
<li>在執行每個測試案例前，都各別觸發一次 <code>beforeEach()</code> 週期鉤子。</li>
<li>執行測試案例 <code>it()</code> 中的 callback function。</li>
<li>在執行每個測試案例後，都各別觸發一次 <code>afterEach()</code> 週期鉤子。</li>
<li>最後一筆測試案例結束後，執行 <code>after()</code> 週期鉤子。</li>
<li>執行完所有 spec 檔案。</li>
<li>結束子處理程序。</li>
</ol>
<p>而整個週期最重要的概念在於每個 spec 檔案被執行的時候，會觸發測試套件（Test suit）與測試案例（Test case）的 callback function 以及週期鉤子（Hook），而我們最主要的撰寫測試程式碼的邏輯都會集中在個週期內。接下來要來介紹這些 API 大致上在做什麼。</p>
<hr>
<h1 id="Test-suit-測試套件"><a href="#Test-suit-測試套件" class="headerlink" title="Test suit 測試套件"></a>Test suit 測試套件</h1><p>每個 spec 檔案中可以允許有多個測試套件，可用來劃分每種測試情境。</p>
<ul>
<li><strong>describe(‘test suit name’, callback function())：</strong><br>第一個參數主要用來描述該測試套件中的整體環境，而第二個參數則是用來呼叫測試案例以及週期鉤子。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'App router test'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 放入 it() 或其他週期鉤子 before()、beforeEach()、after()、afterEach()</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="Test-case-測試案例"><a href="#Test-case-測試案例" class="headerlink" title="Test case 測試案例"></a>Test case 測試案例</h1><p>每個測試套件中可以允許有多個測試案例，可用來釐清該筆案例所測試的內容。</p>
<ul>
<li><strong>it(‘test case name’, callback function())</strong><br>第一個參數主要用來描述該筆測試案例（Test Case）的情境，而第二個參數則是用來呼叫斷言（assertion）的內容。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'App router test'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 放入斷言內容</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><p>運行週期裡面最主要的概念在於每個 spec 檔案被執行的時候，會依序觸發的 callback function 與週期鉤子（Hook），接下來來介紹與週期有關的 API：</p>
<ul>
<li><p><strong>before()</strong><br>進入測試套件時便會執行一次，主要用來放入執行測試案例前的測前資料。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 測前資料</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>beforeEach()</strong><br>每個測試案例（Test Case）開始前都會執行一次，用來更新每筆測試案例的測前資料。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 更新測前資料</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>afterEach()</strong><br>每個測試案例（Test Case）結束後都會執行一次，用來更新每筆測試案例的結束後的資料。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">afterEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 更新測後資料</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>after()</strong><br>離開測試套件時便會執行一次，用來更新整個測試套件結束後的資料，以避免測試時汙染到原先的資料，影響到下一個測試套件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 測後資料</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>釐清了上述的週期、測試套件、測試案例、與鉤子後，現在我們可以嘗試來寫一個跟週期鉤子有關的測試 spec 檔（建置的部分可參考之前的 Mocha 環境建置 文章）。</p>
<p><strong>sum.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = sum</span><br></pre></td></tr></table></figure>

<p><strong>minus.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minus</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = minus</span><br></pre></td></tr></table></figure>

<p><strong>function.spec.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 Mocha 的斷言庫。</span></span><br><span class="line"><span class="keyword">let</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>)</span><br><span class="line"><span class="comment">// 引入寫好的程式</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="built_in">require</span>(<span class="string">'../sum'</span>)   </span><br><span class="line"><span class="keyword">const</span> minus = <span class="built_in">require</span>(<span class="string">'../minus'</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述測試環境</span></span><br><span class="line">describe(<span class="string">'函式測試'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 給予容器資料類型應有的預設值</span></span><br><span class="line">    <span class="keyword">let</span> sumResult = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> minusResult = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> randomNumberA = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> randomNumberB = <span class="number">0</span></span><br><span class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">        <span class="comment">// 設定每次測試案例要用的資料，這裡使用 random() 函式賦予每次案例不同的值。</span></span><br><span class="line">        randomNumberA = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>) <span class="comment">// 0 ~ 10</span></span><br><span class="line">        randomNumberB = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>) <span class="comment">// 0 ~ 10</span></span><br><span class="line">        sumResult = randomNumberA + randomNumberB</span><br><span class="line">        minusResult = randomNumberA - randomNumberB</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'add 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(sum(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'add 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(sum(<span class="number">100</span>, <span class="number">200</span>), <span class="number">300</span>,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'add 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(sum(randomNumberA, randomNumberB), sumResult,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'minus 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(minus(<span class="number">3</span>, <span class="number">2</span>), <span class="number">1</span>,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'minus 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(minus(<span class="number">300</span>, <span class="number">200</span>), <span class="number">100</span>,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'minus 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(minus(randomNumberA, randomNumberB), minusResult,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>執行測試後秀出結果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">函式測試</span><br><span class="line">  √ add 函式返回兩者相加的值</span><br><span class="line">  √ add 函式返回兩者相加的值</span><br><span class="line">  √ add 函式返回兩者相加的值</span><br><span class="line">  √ minus 函式返回兩者相加的值</span><br><span class="line">  √ minus 函式返回兩者相加的值</span><br><span class="line">  √ minus 函式返回兩者相加的值</span><br></pre></td></tr></table></figure>

<p>以上便是一個簡單搭配週期鉤子的範例。當然，這比起真正的測試還有段距離，得隨著不斷的練習才能寫出快速有效率的測試程式碼！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://mochajs.org/#run-cycle-overview" target="_blank" rel="noopener">Mocha-run-cycle</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Mocha.js</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Mocha.js</tag>
      </tags>
  </entry>
  <entry>
    <title>【初始ノ章】前言與 TOC</title>
    <url>/testing/ithelp-2022-vitest-01/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>進入公司後已有一段時間，交手過林林總總的專案，除了新專案的開發之外，免不了會碰到既有服務的維護需求。而這些服務當中，年紀輕則有三、四年歷史，更不用提那些年邁的部分了；這些程式碼本身是沒什麼問題，但剛進入公司的我年少輕狂，天真的以為改動程式碼是件簡單的事情，結果一不小心就落入「依賴」的陷阱之中。</p>
<p>過了一年後，我雖然從依賴的泥沼中（？）爬了出來，但回想身在其中時的過程難免感嘆，一邊思考要怎麼樣才能主動防止這種事情發生呢？與此同時，我正好專注於如何整潔（clean）程式碼、重構（refactor）等等心法與技術的應用，因此迫切的需要一樣東西來保證更動的地方沒有出錯，碰巧從相關的資訊文章中看到了「測試」這個詞彙，稍微搜尋了一下，令人嘆為觀止，剛好它填補了我需要的一切。</p>
<p>因此，我迫不及待地踏上了研究測試的道路，深刻的記得當時我最早是看到了保哥分享不同測試之間差異的<a href="[https://blog.miniasp.com/post/2019/02/18/Unit-testing-Integration-testing-e2e-testing](https://blog.miniasp.com/post/2019/02/18/Unit-testing-Integration-testing-e2e-testing)">文章</a>，慢慢瞭解到原來測試還能面向不同的需要，近而拆分成不同的測試類型，甚至根據測試類型搭配的工具也可能有所不同。</p>
<p>然而，研究的過程不如我一開始所想的那樣簡單，我慢慢地陷入了另一個「泥沼」——關鍵字地獄。「斷言是什麼玩意⋯⋯？」、「Dummy Object 又是什麼⋯⋯？」，為了搞清楚這些東西只好一步一步嗑文章與書籍。從單元測試中會玩到的 Mocha + chai + sinon 或 Jest，甚至透過 Cypress 進行端對端測試與視覺回歸測試，然後又遇到不同設備導致快照上出現差異等等想都沒想過的問題⋯⋯。</p>
<p>而這篇系列文的誕生，主要是希望能幫助到那些也想瞭解測試的讀者，透過文章的引導，有脈絡的從單元測試開始學習，並快速瞭解不同的測試工具各自的用途，提供一個魚竿後續再依照自己的需求去改造它；次要的部分則是藉由系列文重新梳理一下目前研究測試的成果，轉化既有的知識為可保存可閱讀的文字；最後則是想與已經在寫測試的開發者們交流心得。</p>
<a id="more"></a>

<h1 id="系列文會提到的部分"><a href="#系列文會提到的部分" class="headerlink" title="系列文會提到的部分"></a>系列文會提到的部分</h1><p>本系列文重點將著重於 Vue3 在 Vite 開發工具底下，要如何透過 Vitest 與 Vue-test-utils 等測試工具來執行「單元測試」，後續文章也會提及若以不同工具或開發框架要選用哪些工具來配合。</p>
<p>除此之外，本系列文也會提供專用的測試專案供讀者下載，可以一邊在觀看文章的同時，也能一邊操作測試程式碼，實際感受一下測試程式在執行的過程與結果。</p>
<p>而文章架構的部分主要分為六個章節，各個章節希望能達成的目的如下：</p>
<ul>
<li>初始章節：瞭解一下這系列文想傳達的內容 &amp; 學習如何建立一個含有單元測試的專案</li>
<li>概念章節：培養寫單元測試的思考脈絡</li>
<li>語法章節：在不同測試情境下，專注語法上的學習，之後遇到同類型的案例就有膝反射的效果</li>
<li>試驗章節：透過題目促進學習的效果</li>
<li>進階章節：加強有關單元測試的品質與延伸單元測試的作用</li>
<li>雜談章節：訪談已導入測試的團隊紀錄與心得分享，與回顧本次參與鐵人賽</li>
</ul>
<h1 id="「預期」的系列文目錄編排"><a href="#「預期」的系列文目錄編排" class="headerlink" title="「預期」的系列文目錄編排"></a>「預期」的系列文目錄編排</h1><ol>
<li>【初始ノ章】前言與系列文 TOC</li>
<li>【初始ノ章】測試建置：跟著系列文專案一起學測試</li>
<li>【初始ノ章】測試建置：在自己的專案加入單元測試來學測試</li>
<li>【初始ノ章】測試建置：Vitest Config Setting 初見</li>
<li>【概念ノ章】測試價值</li>
<li>【概念ノ章】測試脈絡－測試類型：測試金字塔、決定測試目標與工具</li>
<li>【概念ノ章】測試脈絡－測試案例（happy, alternate, sad &amp; edge）</li>
<li>【概念ノ章】測試脈絡－測試程式碼的（Setup, Execise, Verify, Teardown）與 3A</li>
<li>【概念ノ章】測試脈絡－撰寫測試碼</li>
<li>【語法ノ章】案例與情境：describe &amp; it 與實用相關指令</li>
<li>【語法ノ章】Setup &amp; Teardown：beforeAll, beforeEach, AfterAll &amp; AfterEach</li>
<li>【語法ノ章】斷言（Assertion）</li>
<li>【試験ノ章】第一個測驗</li>
<li>【語法ノ章】容器：Wrapper</li>
<li>【語法ノ章】選擇器：Selector</li>
<li>【語法ノ章】容器方法：Method</li>
<li>【語法ノ章】模擬行為：Event</li>
<li>【試験ノ章】第二個測驗</li>
<li>【語法ノ章】Vue API：data, props &amp; emit</li>
<li>【語法ノ章】Vue API：slot, provide/inject &amp; directive</li>
<li>【試験ノ章】第三個測驗</li>
<li>【語法ノ章】模擬替身：Dummy, Stub, Spy, Mock &amp; Fake</li>
<li>【語法ノ章】測試 Vue Router</li>
<li>【語法ノ章】測試 Store (pinia)</li>
<li>【試験ノ章】第四個測驗</li>
<li>【進階ノ章】優良測試：F.I.R.S.T.</li>
<li>【進階ノ章】透過 Vitest UI 檢視測試與觀察依賴</li>
<li>【進階ノ章】覆蓋率</li>
<li>【進階ノ章】漏網之魚</li>
<li>【進階ノ章】TDD</li>
<li>【進階ノ章】重構</li>
<li>【雜談ノ章】訪談</li>
<li>【雜談ノ章】那些沒寫到的</li>
</ol>
<p>以上是這次系列文預計會想寫的內容，之後會依照實際寫的內容略為調整。</p>
<p>最後，對於團隊本身已經有導入測試環節或是本身很熟稔測試的開發者，若文中有錯誤之處還請多包涵與指正，也歡迎在文章下方留言討論！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【初始ノ章】測試建置：跟著系列文一起學測試</title>
    <url>/testing/ithelp-2022-vitest-02/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>在進入測試的正文前，本文將帶著讀者一起來安裝系列文專用的測試專案，這份專案內含後續文章會介紹到的測試程式碼以及各元件基本的視覺操作介面，接下來的幾天就可以一邊看著文章一邊操作，同時如果想修改測試程式碼來觀看差異也非常方便。</p>
<p>本文章提供兩種安裝指南供讀者閱讀，可視讀者的需求來選擇觀看唷：</p>
<ul>
<li>若讀者本身電腦已安裝並熟悉 <code>NVM</code> 與 <code>Git</code> 操作，請參考【快速通道】指南。</li>
<li>若尚未接觸過 <code>NVM</code> 或 <code>Git</code> 的讀者，想一步一步操作，請參考【詳細安裝說明】指南。</li>
</ul>
<a id="more"></a>

<h1 id="【快速通道】："><a href="#【快速通道】：" class="headerlink" title="【快速通道】："></a>【快速通道】：</h1><p>由於 <code>Vitest</code> 需求本身需要 <code>Node.js</code> 14 以上的版本，請將 <code>Node.js</code> 版本調整至 14 以上複製專案：</p>
<p><code>git clone https://github.com/shawnlin0201/ithelp2022-vue3-unit-test.git</code></p>
<p>接著透過 <code>npm install</code> 安裝依賴工具後，就能透過 <code>npm run dev</code> 啟動專案。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220917/20119062CcuD1FBnHO.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/20119062CcuD1FBnHO.png"></p>
<p>而測試的部分則可以透過終端機執行 <code>npm run test:unit</code> 。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220917/20119062hNv22uoifE.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/20119062hNv22uoifE.png"></p>
<p>若專案跟測試都能順利啟動，就沒問題了。<br>作者也會依照當天系列文來更新專案，所以別忘了透過 <code>Git</code> 來抓取當天最新進度唷！<br>接下來讓我們跟著系列文一起學習單元測試吧！</p>
<hr>
<h1 id="【詳細安裝說明】："><a href="#【詳細安裝說明】：" class="headerlink" title="【詳細安裝說明】："></a>【詳細安裝說明】：</h1><p>接下來安裝專案的部分由於有切換或管理 <code>Node.js</code> 版本的需求，因此這裡建議安裝 <code>NVM</code> 來處理；而專案本身後續會依照每日需要的做即時更新，因此我們需要透過 <code>Git</code> 來更新與安裝我們專案程式碼。</p>
<p>所以接下來的步驟主要會是：<br>一、安裝 NVM<br>二、透過 NVM 安裝 Node.js 並切換到對應版本<br>三、安裝 Git GUI Tool<br>四、透過 Git GUI Tool Clone 系列文專案<br>五、啟動系列文專案</p>
<h2 id="一、安裝-NVM"><a href="#一、安裝-NVM" class="headerlink" title="一、安裝 NVM"></a>一、安裝 NVM</h2><p>在開發的過程中，有時候會遇到不同的專案間要使用不同的 Node.js 版本，而透過 <code>NVM</code> ，我們就能在不同情境下快速切換到我們需要的 <code>Node.js</code> 版本。</p>
<h3 id="使用-Windows-系統安裝-NVM："><a href="#使用-Windows-系統安裝-NVM：" class="headerlink" title="使用 Ｗindows 系統安裝 NVM："></a>使用 Ｗindows 系統安裝 NVM：</h3><ol>
<li>請至官方 release 文件中下載 <a href="[https://github.com/coreybutler/nvm-windows/releases](https://github.com/coreybutler/nvm-windows/releases)">nvm-setup</a>。</li>
<li>依照 Windows 安裝精靈下載完成。</li>
<li>打開「命令提示字元」後輸入 <code>nvm</code> ，若有出現 Runnine version x.x.x 版本號碼表示安裝成功。</li>
</ol>
<h3 id="使用-MacOS-系統安裝-NVM："><a href="#使用-MacOS-系統安裝-NVM：" class="headerlink" title="使用 MacOS 系統安裝 NVM："></a>使用 MacOS 系統安裝 NVM：</h3><ol>
<li>同時按下 <code>cmd(⌘) + 空白鍵</code> ，輸入 terminal 後，打開「終端機」，執行下面一種指令：</li>
</ol>
<ul>
<li><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</code></li>
</ul>
<ol start="2">
<li>此時應該會自動生成 <code>nvm</code> 路徑檔案至你的環境中，請務必關掉「終端機」，再繼續以下步驟。</li>
<li>重新打開「終端機」後，輸入指令 <code>nvm -v</code> 確認是否有版本號跳出表示安裝成功，可以準備來安裝 <code>Node.js</code> 了。</li>
</ol>
<h4 id="若步驟-3-時出現-command-not-found-怎麼辦？"><a href="#若步驟-3-時出現-command-not-found-怎麼辦？" class="headerlink" title="若步驟 3 時出現 command not found 怎麼辦？"></a>若步驟 3 時出現 <code>command not found</code> 怎麼辦？</h4><p>正常安裝完 <code>NVM</code> 後系統應該會自動根據終端機的指令工具補上對應的語法路徑，若沒有表示可能指令工具的路徑出現了狀況，因此我們需要確認當下的指令工具，並補上對應的 <code>nvm</code> 設定。</p>
<ol>
<li>首先，在終端機輸入 <code>echo $SHELL</code> 來檢視目前所使用的指令工具。</li>
<li>接著依據不同的指令工具在對應的地方補上 <code>nvm</code> 指令設定：</li>
</ol>
<h5 id="echo-SHELL-出來的指令工具為-bin-bash-或顯示為-bash："><a href="#echo-SHELL-出來的指令工具為-bin-bash-或顯示為-bash：" class="headerlink" title="echo $SHELL 出來的指令工具為 /bin/bash 或顯示為 bash："></a><code>echo $SHELL</code> 出來的指令工具為 /bin/bash 或顯示為 bash：</h5><p>a. 執行 <code>touch ~/.bash_profile</code> ，若環境根目錄尚未有 <code>.bash_profile</code>檔案會自動會生成出來。<br>b. 打開 Finder，點開上方「前往」。<br>c. 點選「個人專屬」。<br>d. 同時按下 <code>cmd(⌘) + Shift + .</code> 顯示隱藏檔案。<br>e. 用文字編輯器打開 <code>.bash_profile</code> 檔案。<br>f. 將底下程式碼複製貼上到 <code>.bash_profile</code> 檔案的末端，並存檔。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> NVM_DIR=<span class="string">"$HOME/.nvm"</span></span><br><span class="line">[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh"  # This loads nvm</span><br><span class="line">[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion</span><br></pre></td></tr></table></figure>

<h5 id="echo-SHELL-出來的指令工具為-zsh："><a href="#echo-SHELL-出來的指令工具為-zsh：" class="headerlink" title="echo $SHELL 出來的指令工具為 zsh："></a><code>echo $SHELL</code> 出來的指令工具為 zsh：</h5><p>a. 打開 Finder，點開上方「前往」。<br>b. 點選「個人專屬」。<br>c. 按下 <code>cmd(⌘) + Shift + .</code> 顯示隱藏檔案。<br>d. 用文字編輯器打開 <code>.zshrc</code> 檔案。<br>e. 將底下程式碼複製貼上到 <code>.zshrc</code> 檔案的末端，並存檔。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> NVM_DIR=<span class="string">"$HOME/.nvm"</span></span><br><span class="line">[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh"  # This loads nvm</span><br><span class="line">[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>補上指令後，回到「終端機」執行 <code>nvm -v</code> ，這時候應該就會有版本號訊息了。</li>
</ol>
<hr>
<h2 id="二、透過-NVM-安裝-Node-js-並切換到對應版本"><a href="#二、透過-NVM-安裝-Node-js-並切換到對應版本" class="headerlink" title="二、透過 NVM 安裝 Node.js 並切換到對應版本"></a>二、透過 NVM 安裝 Node.js 並切換到對應版本</h2><p>在上個步驟我們確認好 <code>NVM</code> 已經安裝完畢，接著我們要透過 <code>NVM</code> 來下載與切換我們 <code>Node.js</code> 的版本號碼。</p>
<ol>
<li>在命令提示字元或終端機中輸入 <code>nvm ls</code> 此時會顯示目前電腦中對應的 <code>node.js</code> 版本號，若未下載過則通常會指著 system。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   ...</span><br><span class="line">-&gt; system</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>若有透過 <code>nvm</code> 裝過不同 <code>Node.js</code> 版本的出現像這樣的版本號：<br><img src="https://ithelp.ithome.com.tw/upload/images/20220917/201190628Yp8opdtfJ.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/201190628Yp8opdtfJ.png"></p>
<ol start="2">
<li>接著執行 <code>nvm ls-remote</code> 會列出目前可供安裝的 Node.js 版本號碼列表。</li>
</ol>
<blockquote>
<p>補充說明：<br>其中有 <code>LTS(Long-term support)</code> 標記的為有長期支援服務的版本。<br>按照 Node.js LTS 維護週期表來說，每年4月份發佈的偶數版本號會在為期 18 個月的 LTS 維護啟動後還多了個 Maintenanece 維護期來保證會處理一些嚴重的 Bug, 安全問題等等的修復。<br>因此除了工具本身的限制以外，若要挑選一個適當的 Node.js 版本來啟動專案，可以尋找偶數 LTS 版本號。</p>
</blockquote>
<ol start="3">
<li>挑選合適的版本後，透過 <code>nvm install v16.17.0</code> 來安裝我們所需要的版本號碼。</li>
<li>透過 <code>nvm use v16.17.0</code> 便可以切換版本號了，再一次透過 <code>nvm ls</code> 確認，此時應該會看到箭頭改為指向 <code>v16.17.0</code>。<br><img src="https://ithelp.ithome.com.tw/upload/images/20220917/201190620qyiJGjY4K.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/201190620qyiJGjY4K.png"></li>
</ol>
<hr>
<h2 id="三、安裝-Git-GUI-Tool"><a href="#三、安裝-Git-GUI-Tool" class="headerlink" title="三、安裝 Git GUI Tool"></a>三、安裝 Git GUI Tool</h2><p>在專案的控管中，版本控管是一門不簡單的學問，而在這個專案我們會使用到 Git 版控系統來管理專案，透過相關指令我們就可以操作基於同個版控系統的專案（新增、複製、修改與更新等等功能）！</p>
<blockquote>
<p>若對於 Git 指令操作有興趣，想深入學習這裡推薦這本由高見龍前輩所撰寫的<a href="[https://www.tenlong.com.tw/products/9789864342662?utm_source=gitbook&utm_medium=site](https://www.tenlong.com.tw/products/9789864342662?utm_source=gitbook&utm_medium=site)">《為你自己學 Git》</a>書籍！</p>
</blockquote>
<p>然而一開始操作大量的指令對於尚未熟悉終端機的讀者可能會感到害怕，因此這裡推薦採用 GitHub Desktop（Git GUI Tool） 來安裝系列文專案：</p>
<blockquote>
<p>Git GUI Tool<br>其中的 GUI 意思為 Graphic User Interface（圖形使用者介面），因此 Git GUI Tool  簡單來說就是讓你能夠方便操作 Git 指令的圖形化工具。</p>
</blockquote>
<blockquote>
<p>GitHub Desktop<br>GitHub 所開源的一套 Git GUI Tool ，除了可以快速操作 Git 相關動作也有結合 GitHub 網站本身的一些服務。</p>
</blockquote>
<ol>
<li>首先到 GitHub Desktop <a href="[https://desktop.github.com/](https://desktop.github.com/)">官方網站</a>下載軟體，網站會自動偵測當下的系統環境提供適合的版本。</li>
<li>下載完成後開啟 GitHub Desktop 就會進入歡迎畫面，直接點選 Skip this step（這邊主要是方便原先有在使用 GitHub 的用戶可以快速結合相關服務的地方，所以不用註冊其實也是能使用的。）</li>
</ol>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220917/20119062NeaFUosjBZ.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/20119062NeaFUosjBZ.png"></p>
<ol start="3">
<li>進入下一頁來到 Configure Git，這頁簡單來說主要是讓你後續變更時，Git 版控系統需要紀錄是「誰」在操作的，因此這頁會需要填寫一下基本的稱呼與可以聯絡到你的信箱。</li>
</ol>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220917/20119062ELJbe4EQKf.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/20119062ELJbe4EQKf.png"></p>
<ol start="4">
<li>填寫完畢後就會看到 GitHub Desktop 主要頁面，點選右方的 Clone a repository。<br>（或是點選左上角 <code>Current repository</code> 按鈕，再點選 <code>Add</code> 按鈕，也會有個 Clone a repository 。）</li>
</ol>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220917/20119062JSkOSHYCf4.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/20119062JSkOSHYCf4.png"></p>
<ol start="5">
<li>出現小視窗後點選右方的 URL 頁籤，在上方 Repository URL 填入  <code>[https://github.com/shawnlin0201/ithelp2022-vue3-unit-test.git](https://github.com/shawnlin0201/ithelp2022-vue3-unit-test.git)</code> ，下方的 Local Path 則可以點選右方的 Choose，自行選擇一個好的位置來放置這個專案（後續若要開啟專案的會這個就會是放置專案的實際位置）。</li>
</ol>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220917/20119062DFdHlW74u1.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/20119062DFdHlW74u1.png"></p>
<ol start="6">
<li>Clone 完成後，畫面的佈局就會長得像這樣子（這邊以 MacOS 版本 Dark 模式為例），左上角就會顯示當下檢視中的 repository（<code>ithelp2022-vue3-unit-test</code>）。</li>
</ol>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220917/20119062pQKDiT5bJz.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/20119062pQKDiT5bJz.png"></p>
<ol start="7">
<li>後續觀看系列文若想更新當下最新的版本下來，只需要點選軟體上方 Repository 頁籤後，點擊 Pull，即可更新本地端的檔案囉。</li>
</ol>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220917/20119062h3s2VuNasT.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/20119062h3s2VuNasT.png"></p>
<p>確認專案已經下載好後，接下來我們要準備安裝專案本身要用的工具，使用 GitHub Desktop 的話則可以從上方 Repository &gt; Open in Terminal 中快速開啟。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220917/20119062OKCN0L0k01.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/20119062OKCN0L0k01.png"></p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220917/20119062ixG26cyrHP.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/20119062ixG26cyrHP.png"></p>
<p>從這種方式開啟後，終端機所在目錄就會是該專案的根目錄了。<br>確認沒問題後就可以來安裝專案所需要的工具啦！</p>
<h2 id="安裝與啟動系列文專案"><a href="#安裝與啟動系列文專案" class="headerlink" title="安裝與啟動系列文專案"></a>安裝與啟動系列文專案</h2><p>在安裝完 NVM 與 Git 之後，讓我們先在終端機執行 <code>nvm ls</code> 重新確認一下現在 Node.js 版本號是否為 14 以上：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220917/201190624JgnsPQP41.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/201190624JgnsPQP41.png"></p>
<p>沒問題的話接下來就可以在終端機執行 <code>npm install</code> 安裝專案中所需要的工具。</p>
<h3 id="啟動專案"><a href="#啟動專案" class="headerlink" title="啟動專案"></a>啟動專案</h3><p>待安裝完畢後，終端機執行 <code>npm run dev</code> 可啟動專案：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VITE v3.1.0  ready <span class="keyword">in</span> 1369 ms</span><br><span class="line"></span><br><span class="line">  ➜  Local:   http://127.0.0.1:5173/</span><br><span class="line">  ➜  Network: use --host to expose</span><br></pre></td></tr></table></figure>

<p>在瀏覽器中輸入 <code>[http://127.0.0.1:5173/](http://127.0.0.1:5173/)</code> （請依據你當下終端機顯示的 Local 為主），開啟後弱看到下方畫面就算完成囉！</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220917/20119062CUKPJhSrZf.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/20119062CUKPJhSrZf.png"></p>
<h3 id="啟動測試"><a href="#啟動測試" class="headerlink" title="啟動測試"></a>啟動測試</h3><p>啟動測試的話，則只需要在終端機執行 <code>npm run test:unit</code> ，終端機就會開始執行測試：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220917/20119062hL2GGYdyuI.png" alt="https://ithelp.ithome.com.tw/upload/images/20220917/20119062hL2GGYdyuI.png"></p>
<p>由於目前都先將測試案例跳過的關係，因此目前執行測試應該會只有 <code>skipped</code> 的結果。</p>
<p>到這邊為止如果啟動專案跟測試都沒問題的話，就可以繼續閱讀後續的章節囉！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【初始ノ章】測試建置：在自己的專案加入單元測試來學測試</title>
    <url>/testing/ithelp-2022-vitest-03/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>不論是之後看完系列文有興趣想要加入測試到實際的專案中，或是有經驗的開發者現在就想嘗試自己建立一個屬於自己的專案來測試，本文底下將會根據「剛初始化的專案」與「既有專案」兩種情境分別說明要如何安裝單元測試與需要注意的事項！</p>
<a id="more"></a>
<hr>
<h1 id="【在初始化專案過程加入單元測試】"><a href="#【在初始化專案過程加入單元測試】" class="headerlink" title="【在初始化專案過程加入單元測試】"></a>【在初始化專案過程加入單元測試】</h1><p>建立專案時若要加入單元測試要注意到的是，Node.js 版本必須為 14 以上，否則 Vitest 會無法順利執行！</p>
<blockquote>
<p>若不清楚怎麼調整或確認 Node.js 版本的朋友可以參考上一章節唷。</p>
</blockquote>
<p>確認 Node.js 版本後，在要建立專案的父層路徑底下透過終端機指令輸入 <code>npm create vite@latest</code> 來建立一個基於 Vite 所建構的專案，接著終端機會出現一些問題，視專案需求選擇：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220918/20119062rdNgwTXQMd.png" alt="https://ithelp.ithome.com.tw/upload/images/20220918/20119062rdNgwTXQMd.png"></p>
<ul>
<li>Project name： 輸入自訂的專案名稱後按下 Enter</li>
<li>Select a framework ⇒ 選擇 <code>Vue</code> 後按下 Enter</li>
<li>Select a variant ⇒ 選擇 <code>Customize with create-vue</code> 後按下 Enter</li>
<li>中間可能還會有 TypeScript, ESLint⋯⋯等等問題，請視專案需要加入</li>
<li>Add Vitest for Unit Testing(y/n) ⇒ 選擇 <code>Yes</code> 後按下 Enter（最重要的部分</li>
</ul>
<p>回答完上面的問題後，建構工具就會依據剛才答覆的內容，自動生成需要的部分。</p>
<p>比方在 <code>Add Vitest for Unit Testing</code> 問題回答 <code>Yes</code> 的話，這時建構工具就會在專案中生成單元測試所需要的相關內容如下：</p>
<ul>
<li>一個位於 <code>~專案根目錄/src/components/__test__/HelloWorld.spec.js</code> 的測試範例</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; describe, it, expect &#125; <span class="keyword">from</span> <span class="string">'vitest'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'../HelloWorld.vue'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'HelloWorld'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'renders properly'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(HelloWorld, &#123; <span class="attr">props</span>: &#123; <span class="attr">msg</span>: <span class="string">'Hello Vitest'</span> &#125; &#125;)</span><br><span class="line">    expect(wrapper.text()).toContain(<span class="string">'Hello Vitest'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>~專案根目錄/package.json</code> 自動新增一個啟動單元測試的 scripts 指令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test:unit"</span>: <span class="string">"vitest --environment jsdom"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>~專案根目錄/package.json</code> 自動新增單元測試所需要的工具們</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"@vue/test-utils"</span>: <span class="string">"^2.0.2"</span>,</span><br><span class="line">    <span class="string">"jsdom"</span>: <span class="string">"^20.0.0"</span>,</span><br><span class="line">    <span class="string">"vitest"</span>: <span class="string">"^0.23.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著如剛剛終端機後方的提示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220918/20119062rdNgwTXQMd.png" alt="https://ithelp.ithome.com.tw/upload/images/20220918/20119062rdNgwTXQMd.png"></p>
<ul>
<li>執行 <code>cd {剛才專案名稱}</code> 切換到專案目錄底下</li>
<li>執行 <code>npm install</code> 安裝專案所需要的內容</li>
</ul>
<p>安裝完畢後，接著就可以執行 <code>npm run dev</code> 確認環境，後續要執行測試的話，執行 <code>npm run test:unit</code> 就能立即運作了。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220918/201190624NAdnXTuax.png" alt="https://ithelp.ithome.com.tw/upload/images/20220918/201190624NAdnXTuax.png"></p>
<hr>
<h1 id="【在既有專案中加入單元測試】"><a href="#【在既有專案中加入單元測試】" class="headerlink" title="【在既有專案中加入單元測試】"></a>【在既有專案中加入單元測試】</h1><p>在既有專案中加入 <code>Vitest</code> 來作為執行測試的環境時，需確認專案本身是由 <code>Vite</code>（<code>2.7.10</code> 版本以上）所建構的之外，其 <code>Node.js</code> 版本也必須為 <code>14</code> 以上，否則會無法順利執行測試！</p>
<blockquote>
<p>若目前想加入的專案不是由 <code>Vite</code> 所建立的，後續也有章節會提到要如何替換對應的測試工具。</p>
</blockquote>
<p>確認好必要條件後就可以開始安裝測試工具：</p>
<ul>
<li><code>vitest</code>：單元測試框架（提供了執行測試的環境、斷言、隔離庫⋯⋯等等功能與 API）</li>
<li><code>@vue/test-utils</code>：測試 <code>Vue</code> 元件的工具</li>
<li><code>jsdom</code>：讓我們可以在 <code>Node</code> 環境模擬出瀏覽器中的 <code>DOM</code> 環境（方便測試）</li>
</ul>
<ol>
<li><p>在專案根目錄下執行：<br><code>npm install -D vitest @vue/test-utils jsdom</code>  </p>
</li>
<li><p>新增 <code>npm</code> 執行單元測試的指令</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test:unit"</span>: <span class="string">"vitest --environment jsdom"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這時若心急的執行 <code>npm run test:unit</code> 會發現終端機告訴你 <code>No test files found, exiting with code 1</code> ，原因是你尚未加入任何一個測試案例。</p>
<p>而一開始 <code>Vitest</code> 預設測試的比對規則是 <code>*/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}</code> ，簡單來說你在專案底下使用 <code>A.test.js</code> 或是 <code>B.spec.ts</code> 的方式都會被 Vitest 認為是測試程式檔。</p>
<p>這時，我們可以在 <code>~專案根目錄/src/components/__test__/</code> 底下新建 <code>HelloWorld.spec.js</code> ：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; describe, it, expect &#125; <span class="keyword">from</span> <span class="string">'vitest'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'HelloWorld'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'1 + 1 should be 2'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="number">1</span> + <span class="number">1</span>).toBe(<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>再次執行 <code>npm run test:unit</code> 終端機就會顯示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220918/201190624NAdnXTuax.png" alt="https://ithelp.ithome.com.tw/upload/images/20220918/201190624NAdnXTuax.png"></p>
<p>到這裡就算是成功安裝好囉，接下來明天我們會在把 Vitest Config 初期需要設定的部分調整好後，建置的部分就完成了。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>前端測試相關資源 front-end testing resource</title>
    <url>/testing/front-end-testing-resource/</url>
    <content><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="Test-Runner"><a href="#Test-Runner" class="headerlink" title="Test Runner"></a>Test Runner</h2><ul>
<li><a href="https://vitest.dev/" target="_blank" rel="noopener">Vitest</a></li>
<li><a href="https://jestjs.io/" target="_blank" rel="noopener">Jest</a></li>
<li><a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a></li>
</ul>
<h2 id="Test-Assertion"><a href="#Test-Assertion" class="headerlink" title="Test Assertion"></a>Test Assertion</h2><ul>
<li><a href="https://vitest.dev/api/#expect" target="_blank" rel="noopener">Vitest Expect</a></li>
<li><a href="https://jestjs.io/docs/expect" target="_blank" rel="noopener">Jest Expect</a></li>
<li><a href="https://www.chaijs.com/" target="_blank" rel="noopener">Chai</a></li>
</ul>
<h2 id="Test-Double-amp-Mock"><a href="#Test-Double-amp-Mock" class="headerlink" title="Test Double &amp; Mock"></a>Test Double &amp; Mock</h2><ul>
<li><a href="https://vitest.dev/guide/mocking.html" target="_blank" rel="noopener">Vitest Mock</a></li>
<li><a href="https://jestjs.io/docs/mock-function-api/" target="_blank" rel="noopener">Jest Mock</a></li>
<li><a href="https://sinonjs.org/" target="_blank" rel="noopener">Sinon</a></li>
</ul>
<h2 id="Component-Testing"><a href="#Component-Testing" class="headerlink" title="Component Testing"></a>Component Testing</h2><ul>
<li><a href="https://test-utils.vuejs.org/" target="_blank" rel="noopener">Vue Test Utils</a>: for Vue3</li>
</ul>
<h1 id="測試種類"><a href="#測試種類" class="headerlink" title="測試種類"></a>測試種類</h1><h2 id="Mutation-Testing"><a href="#Mutation-Testing" class="headerlink" title="Mutation Testing"></a>Mutation Testing</h2><ul>
<li><a href="https://stryker-mutator.io/" target="_blank" rel="noopener">Stryker Mutator</a></li>
</ul>
<h1 id="相關書籍、文章"><a href="#相關書籍、文章" class="headerlink" title="相關書籍、文章"></a>相關書籍、文章</h1><ul>
<li><a href="http://xunitpatterns.com/index.html" target="_blank" rel="noopener">XUnit Test Patterns</a></li>
<li><a href="https://www.tenlong.com.tw/products/9789862017050" target="_blank" rel="noopener">Robert C. Martin - 無瑕的程式碼－敏捷軟體開發技巧守則</a></li>
<li><a href="https://www.tenlong.com.tw/products/9789865021832" target="_blank" rel="noopener">Martin Fowler - 重構｜改善既有程式的設計, 2/e</a></li>
<li><a href="https://www.tenlong.com.tw/products/9789864342471" target="_blank" rel="noopener">Roy Osherove - 單元測試的藝術</a></li>
<li><a href="https://www.tenlong.com.tw/products/9789864345618" target="_blank" rel="noopener">Kent Beck 的測試驅動開發：案例導向的逐步解決之道</a></li>
<li><a href="https://www.tenlong.com.tw/products/9789863470090" target="_blank" rel="noopener">Mark Ethan Trostler - 可測試的 JavaScript</a></li>
<li><a href="https://www.tenlong.com.tw/products/9787111646709" target="_blank" rel="noopener">Edd Yerburgh - Vue.js 應用測試</a></li>
<li><a href="https://www.tenlong.com.tw/products/9789864341313" target="_blank" rel="noopener">CODE COMPLETE：軟體開發實務指南, 2/e</a></li>
<li><a href="https://github.com/goldbergyoni/javascript-testing-best-practices" target="_blank" rel="noopener">goldbergyoni/javascript-testing-best-practices</a></li>
</ul>
<h2 id="單元測試-Unit-Testing"><a href="#單元測試-Unit-Testing" class="headerlink" title="單元測試 Unit Testing"></a>單元測試 Unit Testing</h2><ul>
<li><a href="https://martinfowler.com/bliki/UnitTest.html" target="_blank" rel="noopener">Martin - UnitTest</a></li>
<li><a href="https://otischou.tw/2019/08/02/unit-test.html" target="_blank" rel="noopener">otischou - 暸解單元測試</a></li>
</ul>
<h2 id="斷言庫-Assertion-Library"><a href="#斷言庫-Assertion-Library" class="headerlink" title="斷言庫 Assertion Library"></a>斷言庫 Assertion Library</h2><ul>
<li><a href="https://dwatow.github.io/2020/04-18-jest/jest-doc-2/" target="_blank" rel="noopener">Chris - 讀 Jest Doc - 斷言庫</a></li>
</ul>
<h2 id="測試替身-Test-Double"><a href="#測試替身-Test-Double" class="headerlink" title="測試替身 Test Double"></a>測試替身 Test Double</h2><ul>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/09/test-double1.html" target="_blank" rel="noopener">Teddy Chen - Test Double（1）：什麼是測試替身？</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/09/test-double2.html" target="_blank" rel="noopener">Teddy Chen - Test Double（2）：五種替身簡介</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/09/test-double3dummy-object.html" target="_blank" rel="noopener">Teddy Chen - Test Double（3）：Dummy Object</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/09/test-double4test-stub.html" target="_blank" rel="noopener">Teddy Chen - Test Double（4）：Test Stub</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/10/test-double5test-spy.html" target="_blank" rel="noopener">Teddy Chen - Test Double（5）：Test Spy</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/10/test-double6fake-object.html" target="_blank" rel="noopener">Teddy Chen - Test Double（6）：Fake Object</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/10/test-double7mock-object.html" target="_blank" rel="noopener">Teddy Chen - Test Double（7）：Mock Object</a></li>
<li><a href="https://martinfowler.com/bliki/TestDouble.html" target="_blank" rel="noopener">Martin Fowler - TestDouble</a></li>
<li><a href="https://medium.com/starbugs/unit-test-%E4%B8%AD%E7%9A%84%E6%9B%BF%E8%BA%AB-%E6%90%9E%E4%B8%8D%E6%B8%85%E6%A5%9A%E7%9A%84dummy-stub-spy-mock-fake-94be192d5c46" target="_blank" rel="noopener">被蛇咬到的魯卡 - Unit Test 中的替身：搞不清楚的Dummy 、Stub、Spy、Mock、Fake</a></li>
<li><a href="https://jchu.cc/2018/08/16-test.html" target="_blank" rel="noopener">Julian Chu - 測試中常見的名詞：Stub, Dummy, Mock..等等</a></li>
</ul>
<h1 id="Conf"><a href="#Conf" class="headerlink" title="Conf"></a>Conf</h1><ul>
<li><a href="https://www.youtube.com/watch?v=LxXsGNXsMo8" target="_blank" rel="noopener">Edd Yerburgh - Unit testing Vue components Why test, what to test, and how to test Vue components</a></li>
<li><a href="https://www.youtube.com/watch?v=okWjao-Y9Eo" target="_blank" rel="noopener">Natalia Tepluhina - 7 ways to make your Vue Unit tests better</a></li>
<li><a href="https://www.youtube.com/watch?v=CW9uTys0li0" target="_blank" rel="noopener">Anthony Fu - Introduction to Vitest</a></li>
</ul>
<h1 id="測試相關議題"><a href="#測試相關議題" class="headerlink" title="測試相關議題"></a>測試相關議題</h1><h2 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h2><ul>
<li><a href="https://ithelp.ithome.com.tw/users/20010292/ironman/462" target="_blank" rel="noopener">就是91 - 30天快速上手TDD</a></li>
</ul>
<h2 id="Coverage"><a href="#Coverage" class="headerlink" title="Coverage"></a>Coverage</h2><ul>
<li><a href="http://teddy-chen-tw.blogspot.com/2019/02/blog-post.html" target="_blank" rel="noopener">Teddy Chen - 透過測試涵蓋率讓重構更有信心（上）：分支涵蓋率</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2019/02/blog-post_19.html" target="_blank" rel="noopener">Teddy Chen - 透過測試涵蓋率讓重構更有信心（中）：突變測試</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2019/02/blog-post_20.html" target="_blank" rel="noopener">Teddy Chen - 透過測試涵蓋率讓重構更有信心（下）：特徵測試</a></li>
<li><a href="https://martinfowler.com/bliki/TestCoverage.html" target="_blank" rel="noopener">Martin Fowler - TestCoverage</a></li>
</ul>
]]></content>
      <tags>
        <tag>front-end</tag>
        <tag>testing</tag>
      </tags>
  </entry>
  <entry>
    <title>【初始ノ章】測試建置：Vitest Config Setting</title>
    <url>/testing/ithelp-2022-vitest-04/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>開發的過程中，有時候工具原先的設定並不符合當下開發的需求，因此本章節將來看看要如何調整 Vitest 設定，段落的部分將分為：</p>
<ul>
<li>Vitest Config 設定方式</li>
<li>瀏覽常見的 Vitest Config Option</li>
</ul>
<a id="more"></a>

<hr>
<h2 id="Vitest-Config-設定方式"><a href="#Vitest-Config-設定方式" class="headerlink" title="Vitest Config 設定方式"></a>Vitest Config 設定方式</h2><p>Vitest 測試在執行的時候預設會基於原先專案中的 <code>vite.config.js</code> 設定檔，所以沒有需要調整的話不太需要另外設置，需要調整的話 Vitest 也提供了三種方法讓你在不同開發情境下選擇調整方式：</p>
<ul>
<li>透過 <code>vitest.config.js</code> 檔案調整測試設定</li>
<li>執行 <code>npm</code> 指令時帶參數指定設定檔案路徑</li>
<li>直接在原先 <code>vite.config.js</code> 中調整</li>
</ul>
<h3 id="透過-vitest-config-js-檔案調整測試設定"><a href="#透過-vitest-config-js-檔案調整測試設定" class="headerlink" title="透過 vitest.config.js 檔案調整測試設定"></a>透過 vitest.config.js 檔案調整測試設定</h3><p>若想區隔開發與測試用的設定時，可以在專案根目錄中新增 <code>vitest.config.js</code> 檔案，這會比原先參考的 <code>vite.config.js</code> 擁有更高的優先權。</p>
<p>不想將原先在 <code>vite.config.js</code> 設定都重新全寫一次的話，也可以在 <code>vitest.config.js</code> 中，使用 <code>mergeConfig</code> 來融合 <code>vite.config.js</code> 的設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mergeConfig &#125; <span class="keyword">from</span> <span class="string">'vite'</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'vitest/config'</span></span><br><span class="line"><span class="keyword">import</span> viteConfig <span class="keyword">from</span> <span class="string">'./vite.config'</span> <span class="comment">// 原先的 vite 設定檔案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mergeConfig(viteConfig, defineConfig(&#123;</span><br><span class="line">  test: &#123;</span><br><span class="line">    <span class="comment">// 在這裡加入測試設定</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="執行-npm-指令時帶參數指定設定檔案路徑"><a href="#執行-npm-指令時帶參數指定設定檔案路徑" class="headerlink" title="執行 npm 指令時帶參數指定設定檔案路徑"></a>執行 npm 指令時帶參數指定設定檔案路徑</h3><p>若想要在執行的時候去引入不同的設定檔案，則可以在 <code>package.json</code> 指令中透過 <code>--config</code> 加上設定檔案的路徑（e.g. <code>vitest --config ./src/scripts/vitest.config.js</code> ）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test:unit"</span>: <span class="string">"vitest --config ./src/__test__/config/vitest.config.js"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接著該檔案就如設定 <code>vitest.config.js</code> 一樣調整就可以了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'vite'</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">'@vitejs/plugin-vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    vue(),</span><br><span class="line">  ],</span><br><span class="line">  test: &#123;</span><br><span class="line">    <span class="comment">// 在這邊加入設定</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="在專案中的-vite-config-js-中調整測試設定"><a href="#在專案中的-vite-config-js-中調整測試設定" class="headerlink" title="在專案中的 vite.config.js 中調整測試設定"></a>在專案中的 vite.config.js 中調整測試設定</h3><p>若想在原先的 <code>vite.config.js</code> 中調整測試設定，有兩種方式可以使用：</p>
<p>第一種是直接在最上方加入 <code>/// &lt;reference types=&quot;vitest&quot; /&gt;</code> 後，在 <code>test</code> 屬性中加入設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types="vitest" /&gt;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'vite'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  test: &#123;</span><br><span class="line">    <span class="comment">// 在這邊加入設定</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>第二種，把原先的 <code>defineConfig</code> 改由 <code>vitest/config</code> 傳入後，在 <code>test</code> 屬性中加入設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'vitest/config'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  test: &#123;</span><br><span class="line">    <span class="comment">// 在這邊加入設定</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="Vitest-config-option"><a href="#Vitest-config-option" class="headerlink" title="Vitest config option"></a>Vitest config option</h2><p>至於 Vitest config 能調整什麼內容呢，這裡列了幾個常見的調整選項：</p>
<ul>
<li><strong><strong>include</strong></strong></li>
<li><strong><strong>exclude</strong></strong></li>
<li><strong>globals</strong></li>
<li><strong>environment</strong></li>
</ul>
<blockquote>
<p>註：以下部分資料引用 <a href="https://vitest.dev/config/" target="_blank" rel="noopener">Vitest Config Option</a> 並翻譯與補充。</p>
</blockquote>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><ul>
<li>Type：<code>string[]</code></li>
<li>預設值：<code>[&#39;**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}&#39;]</code></li>
</ul>
<p>藉由這個欄位我們可以提供 glob 格式讓 vitest 去比對哪些是測試檔案，也可以放入多個條件在陣列中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'vitest/config'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  test: &#123;</span><br><span class="line">    include: [<span class="string">'**/*.spec.js'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>這個設定主要會影響到後續我們要如何擺放測試程式碼，因此做規劃時可以按需求考量調整。</p>
<h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a><strong>exclude</strong></h3><ul>
<li>Type： <code>string[]</code></li>
<li>預設值： <code>[&#39;**/node_modules/**&#39;, &#39;**/dist/**&#39;, &#39;**/cypress/**&#39;, &#39;**/.{idea,git,cache,output,temp}/**&#39;]</code></li>
</ul>
<p>藉由這個欄位我們可以提供 glob 格式讓 vitest 去排除哪些不是測試檔案，也可以放入多個條件在陣列中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'vitest/config'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  test: &#123;</span><br><span class="line">    exclude: [<span class="string">'**/node_modules/**'</span>, <span class="string">'**/dist/**'</span>, <span class="string">'**/cypress/**'</span>, <span class="string">'**/.&#123;idea,git,cache,output,temp&#125;/**'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>與 <code>include</code> 相反，這次則是要排除哪些路徑不需要尋找是否有測試檔案，其中如果有用到 <code>cypress</code> 做 E2E 測試的話，預設規則中就已經有另外排除了，所以沒必要的話不必特別設置，但可以先記得有這個方便的欄位。</p>
<p><strong>Globals</strong></p>
<ul>
<li>Type：<code>boolean</code></li>
<li>預設值： <code>false</code></li>
</ul>
<p>由於在撰寫測試時，Vitest 預設是需要自己按需要引入對應的方法等等，如果要類似像 Jest 以全域的方式注入到測試中，就可以透過在執行時加上 <code>--globals</code> 選項，或是在 vitest config 選項中加入 <code>globals: true</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'vitest/config'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  test: &#123;</span><br><span class="line">    globals: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>原先設定前，測試程式碼需要如下方引入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; describe, it, expect &#125; <span class="keyword">from</span> <span class="string">'vitest'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'HelloWorld'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'1 + 1 should be 2'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="number">1</span> + <span class="number">1</span>).toBe(<span class="string">'2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>加入 <code>Globals: true</code> 後，就不需要顯示引入 vitest 測試相關的 API，讓測試看起來更乾淨：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'HelloWorld'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'1 + 1 should be 2'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="number">1</span> + <span class="number">1</span>).toBe(<span class="string">'2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a><strong>environment</strong></h3><ul>
<li>Type：<code>&#39;node&#39; | &#39;jsdom&#39; | &#39;happy-dom&#39; | &#39;edge-runtime&#39; | string</code></li>
<li>預設值： <code>&#39;node&#39;</code></li>
</ul>
<p>由於 Vitest 本身默認環境 Node.js，因此若要在測試中仿造瀏覽器的應用程式，可以透過類似 <code>jsdom</code> 等工具來取代，而已經介紹過的npm 指令的寫法之外 <code>-environment jsdom</code> ，還可以在測試檔案上以 docblock 或 comment 風格的方式註記。</p>
<p>Docblock 風格：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@vitest</span>-environment jsdom</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">'use jsdom in this test file'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">  element.innerHTML = <span class="string">'&lt;p&gt;Hello, HTML!&lt;/p&gt;'</span></span><br><span class="line">  expect(element.innerHTML).toBe(<span class="string">'&lt;p&gt;Hello, HTML!&lt;/p&gt;'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Comment 風格：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @vitest-environment jsdom</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">'use jsdom in this test file'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">  element.innerHTML = <span class="string">'&lt;p&gt;Hello, HTML!&lt;/p&gt;'</span></span><br><span class="line">  expect(element.innerHTML).toBe(<span class="string">'&lt;p&gt;Hello, HTML!&lt;/p&gt;'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>寫在 vitest config 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'vitest/config'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  test: &#123;</span><br><span class="line">    environment: <span class="string">'jsdom'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如此一來在測試中我們就可以模擬 Web 端環境來操作了。</p>
<hr>
<p>以上是 Vitest 幾個比較常見的設定，其餘的設定後續也會按需求陸續提到，若對於其他設定選項有興趣的，也可以直接到官方文件中的 <a href="https://vitest.dev/config/" target="_blank" rel="noopener">config 分頁</a> 查看。</p>
<p>明天開始，我們將進入測試概念的環節，開始深入探討測試價值、什麼時候需要測試與撰寫測試的流程等等相關議題。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【概念ノ章】測試價值：為什麼我需要測試</title>
    <url>/testing/ithelp-2022-vitest-05/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>本文將從實作測試的過程中開始，使讀者逐步瞭解基本的測試大概包含了哪些環節，並從中理解到測試工具的好處以及寫了測試後開發的過程或將來能獲得什麼樣的價值。</p>
<a id="more"></a>

<hr>
<h1 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h1><p>要加入測試前首先我們要瞭解到測試的本質究竟是什麼。</p>
<p>測試簡單的來說主要就是藉由操控受測物（SUT, System Under Test），觀察由受測物產生的最終狀態是否如我們所預期的樣子：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220920/201190625aQs9UAQfn.png" alt="https://ithelp.ithome.com.tw/upload/images/20220920/201190625aQs9UAQfn.png"></p>
<p>若最終狀態符合我們的預期，對於開發者的含義來說，就是受測物符合了我們的期待。</p>
<p>但這點好處看似沒有做「測試」的必要，畢竟我們平時開發能驗收完成不就是符合了規格書的期待嗎？</p>
<p>因此為了能夠更加體會測試背後的價值，我們接下來將實際做一個測試工具來來檢驗我們自己所寫的函式。</p>
<hr>
<p>首先，情境假設在專案中有一處邏輯判斷需要檢測傳進來資料的是否為數值（Numeric），而傳進來的資料可能有 <code>1</code>, <code>null</code> , <code>&#39;100&#39;</code> , <code>NaN</code> 等。</p>
<p>我們希望當 <code>1</code> 和 <code>&#39;100&#39;</code> 時，該判斷應該要為 <code>true</code>，而 <code>null</code> 與 <code>NaN</code> 則是要為 <code>false</code>。</p>
<p>接下來的目標我們要做的就是：</p>
<ol>
<li>製作一個簡易的測試工具</li>
<li>寫測試案例</li>
<li>寫受測程式碼的實作</li>
</ol>
<h2 id="簡易的測試工具"><a href="#簡易的測試工具" class="headerlink" title="簡易的測試工具"></a>簡易的測試工具</h2><p>首先規劃一下工具我最後希望用起來像是這個樣子：</p>
<p><code>expect(受測物).toBe(預期狀態)</code></p>
<ul>
<li>回傳 <code>true</code> 表示測試成功 （即為最終狀態與預期狀態相同）</li>
<li>回傳 <code>false</code> 表示測試失敗 （即為最終狀態與預期狀態不同），然後加上 error 提示預期狀態應該要是什麼，最終狀態目前是什麼。</li>
</ul>
<p>接著按照上面的設想，先定義了一個宣告函式 <code>expect</code>，參數則是預計輸入受測物（<code>input</code>）與：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> expect = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再來工具本身呼叫時需回傳了一個叫做 <code>toBe</code> 的驗證方法，該驗證方法的參數為預期目標（<code>expected</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> expect = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> toBe = <span class="function">(<span class="params">expected</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        toBe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著設計該驗證的方法，使其能夠回應測試的結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> expect = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> toBe = <span class="function">(<span class="params">expected</span>) =&gt;</span> input === expected</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        toBe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在我們透過網頁瀏覽器的 devtool console 控制台，就可以透過該測試工具做簡易的測試案例了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> expect = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> toBe = <span class="function">(<span class="params">expected</span>) =&gt;</span> input === expected</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        toBe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect(<span class="number">1</span> === <span class="number">1</span>).toBe(<span class="literal">true</span>)</span><br><span class="line">expect(<span class="number">2</span> !== <span class="number">1</span>).toBe(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>但我們希望他能夠在測試案例失敗的時候回應一下當下預期與結果的狀況，後續我們才能針對紀錄的結果做修正。因此我們再修改一下測試方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> expect = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleOnError = <span class="function">(<span class="params">result, expected</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">`測試失敗：預期應該為 <span class="subst">$&#123;expected&#125;</span>，結果現在為 <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> toBe = <span class="function">(<span class="params">expected</span>) =&gt;</span> input === expected ? <span class="literal">true</span> : handleOnError(input, expected)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        toBe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再執行一個故意寫錯的測試案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(<span class="number">2</span> === <span class="number">1</span>).toBe(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220920/201190627ww12qoxyP.png" alt="https://ithelp.ithome.com.tw/upload/images/20220920/201190627ww12qoxyP.png"></p>
<p>現在可以看到當測試案例發生錯誤的時候，除了會回傳測試結果之外，還會多個錯誤提醒目前錯誤的原因了！</p>
<h2 id="寫測試案例"><a href="#寫測試案例" class="headerlink" title="寫測試案例"></a>寫測試案例</h2><p>在完成測試工具後，現在我們要來寫測試案例，首先我們先寫一個還沒有寫實作部分的判斷函式（<code>isNumeric</code>）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isNumeric = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>接著按照題目所設定的條件，來撰寫測試案例：</p>
<blockquote>
<p>題目設定：<br>當 <code>1</code> 和 <code>&#39;100&#39;</code> 時，該判斷應該要為 <code>true</code>，<br>而 <code>null</code> 與 <code>NaN</code> 則是要為 <code>false</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isNumeric = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">expect(isNumeric(<span class="number">1</span>)).toBe(<span class="literal">true</span>)</span><br><span class="line">expect(isNumeric(<span class="string">'100'</span>)).toBe(<span class="literal">true</span>)</span><br><span class="line">expect(isNumeric(<span class="literal">null</span>)).toBe(<span class="literal">false</span>)</span><br><span class="line">expect(isNumeric(<span class="literal">NaN</span>)).toBe(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>此時執行後會發現會發現四個案例都報錯，因為目前我們還沒撰寫 <code>isNumeric</code> 的判斷實作，但到這一步測試案例就已經算是寫好了，因為我們的目的是要寫對的測試案例，讓實作去符合。</p>
<h2 id="寫受測程式碼的實作"><a href="#寫受測程式碼的實作" class="headerlink" title="寫受測程式碼的實作"></a>寫受測程式碼的實作</h2><p>完成測試案例後，我們將要來寫測試程式碼的實作部分（這裡參考了 <a href="https://github.com/angular/angular/blob/4.3.x/packages/common/src/pipes/number_pipe.ts#L172" target="_blank" rel="noopener">Angular 4.3</a>實作版本）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isNumeric = <span class="function">(<span class="params">value</span>) =&gt;</span> !<span class="built_in">isNaN</span>(value - <span class="built_in">parseFloat</span>(value))</span><br></pre></td></tr></table></figure>

<p>最後，將整個測試與實作合併起來就會像這樣子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 測試工具程式碼部分</span></span><br><span class="line"><span class="keyword">const</span> expect = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleOnError = <span class="function">(<span class="params">result, expected</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">`測試失敗：預期應該為 <span class="subst">$&#123;expected&#125;</span>，結果現在為 <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> toBe = <span class="function">(<span class="params">expected</span>) =&gt;</span> input === expected ? <span class="literal">true</span> : handleOnError(input, expected)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        toBe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 實作程式碼部分</span></span><br><span class="line"><span class="keyword">const</span> isNumeric = <span class="function">(<span class="params">value</span>) =&gt;</span> !<span class="built_in">isNaN</span>(value - <span class="built_in">parseFloat</span>(value))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 測試案例部分</span></span><br><span class="line">expect(isNumeric(<span class="number">1</span>)).toBe(<span class="literal">true</span>) <span class="comment">// true，即為通過測試</span></span><br><span class="line">expect(isNumeric(<span class="string">'100'</span>)).toBe(<span class="literal">true</span>) <span class="comment">// true，即為通過測試</span></span><br><span class="line">expect(isNumeric(<span class="literal">null</span>)).toBe(<span class="literal">false</span>) <span class="comment">// true，即為通過測試</span></span><br><span class="line">expect(isNumeric(<span class="literal">NaN</span>)).toBe(<span class="literal">false</span>) <span class="comment">// true，即為通過測試</span></span><br></pre></td></tr></table></figure>

<p>完成！現在已經不會顯示測試失敗的訊息了，也就表示 <code>isNumeric</code> 方法符合我們的預期囉。</p>
<p>而現在假使我想使實作程式碼的部分更加的完善，只要增加合適的測試案例進去就可以增添受測物本身的信賴與穩定度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(isNumeric(<span class="number">1</span>)).toBe(<span class="literal">true</span>)</span><br><span class="line">expect(isNumeric(<span class="number">1.123</span>)).toBe(<span class="literal">true</span>)</span><br><span class="line">expect(isNumeric(<span class="number">0xFFF</span>)).toBe(<span class="literal">true</span>)</span><br><span class="line">expect(isNumeric(<span class="string">'100'</span>)).toBe(<span class="literal">true</span>)</span><br><span class="line">expect(isNumeric(<span class="literal">undefined</span>)).toBe(<span class="literal">false</span>)</span><br><span class="line">expect(isNumeric(<span class="literal">null</span>)).toBe(<span class="literal">false</span>)</span><br><span class="line">expect(isNumeric(<span class="literal">NaN</span>)).toBe(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>甚至將來改寫實作（<code>isNumeric</code>）的時候，既有的測試內容就會提醒你是否違反了之前所寫的測試案例。</p>
<h1 id="測試工具"><a href="#測試工具" class="headerlink" title="測試工具"></a>測試工具</h1><p>經過上方手刻測試工具後，讀者應該很有感觸，那就是實作測試工具中的驗證其實不太容易，假設今天我想比對的是兩個物件是否結構上相等，就還得自己再生出一個測試驗證方法來。除此之外還有像是測試程式碼的錯誤訊息在不同的情境下可能要更詳細列出比對的值，甚至是測試案例的描述⋯⋯等等功能。</p>
<p>而拜開源生態所賜，現在我們只需要在開發階段中針對需要的測試類型來安裝我們所需要的測試框架與工具即可，基本上測試中所需要的東西工具都幫你準備好了，我們只需要學會如何準備測試後就能享受到測試價值的部分！</p>
<h1 id="測試價值"><a href="#測試價值" class="headerlink" title="測試價值"></a>測試價值</h1><p>測試的價值主要可以分為兩種類型：一種是由測試本身協助的效果，另一部分則是寫測試過程中所獲得的部分。</p>
<h2 id="測試本身"><a href="#測試本身" class="headerlink" title="測試本身"></a>測試本身</h2><p>以我們在專案中實際會遇到的例子來說，有時候遇到有依賴關係的邏輯時，最怕的就是改 A 壞 B，而在這一部分測試做得非常的好，在測試案例合適且足夠的情況下，他就像是一名守門員一樣時時刻刻盯著你，若有錯誤的情況下也會第一時間回報給你，省去事後發生錯誤所產生的時間浪費。</p>
<p>另一種情況則是隱性規則的部分，通常來至於沒有規格書或規格書來不及更新的情況下所產生的，這一類隱性規則在開發當下較為無感，通常是事後有需要維護時會遇到，在沒有合適的註解情況下很難以釐清程式碼段落中的特別之處，究竟是屬於規則的一部分，還是單純是當時開發人員撰寫錯誤。所以某方面來說將特殊規則納入測試當中也可以起到專案領域知識的傳承作用。</p>
<p>而有關於提早發現錯誤的必要性，在《軟體開發實務指南 2版》（Steve McConnell 著）一書中有提及，<em>檢測到缺陷的時間與修復成本*</em>在不同階段*<em>中的影響差別甚巨</em>。畢竟一個功能上線之後才發現有錯誤，除了造成時間上的浪費之外，生產力也大大地受到影響，如果這些錯誤能在開發階段就被發現那會是一件好事。</p>
<h2 id="思考與寫測試的過程"><a href="#思考與寫測試的過程" class="headerlink" title="思考與寫測試的過程"></a>思考與寫測試的過程</h2><p>除了測試本身所能起到主動防禦的功用之外，寫測試的過程中其實也能帶來一些好處。</p>
<p>以《可測試的 JavaScript》（Mark Ethan Trostler 著）一書中所提到的概念與我自身經驗作延伸：一個程式碼要能夠可測試，基本上就意味著程式碼的耦合受到了控制，因此程式碼的複雜度也就會越來越低，而複雜度低了之後，測試程式碼也就會越容易寫，形成正向的循環。</p>
<p>而在有可測試的程式碼某方面來說可維護性也越高，我們將更願意試著去改寫而不是整段丟棄；甚至最後達到可閱讀性也越來越好的境界，我們在開發與除錯的過程中也將越來越容易。</p>
<p>當然，價值的部分會依據專案的重要性不同而產生變化，但究竟加入測試合適的時機是什麼時候呢？我們明天繼續來探究這部分。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【概念ノ章】測試脈絡－1. 決定測試類型</title>
    <url>/testing/ithelp-2022-vitest-07/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>在瞭解測試價值與加入的時機後，接下來的幾天將會從測試脈絡開始講起，為什麼測試脈絡重要呢？因為我認為測試脈絡與會測試程式碼語法是相輔相成且都不可缺失的部分。</p>
<p>若懂得測試的脈絡但不懂得測試程式碼語法；則會空有理想；然而只懂得測試程式碼語法卻不懂撰寫測試的脈絡，則會寫出不明所以的測試。唯有兩者都掌握了才有辦法寫出既合理又有效的測試，且後續遇到需求變更產品程式碼時，對於測試程式碼的改動會更容易視為理所當然與得心應手。</p>
<p>而有關於測試脈絡的部分接下來會陸續講到：</p>
<ol>
<li>測試類型：認識不同測試類型與測試類型的目標</li>
<li>測試工具：根據需要測試的內容選出合適的工具</li>
<li>測試案例：根據測試目標瞭解要如何撰寫案例</li>
</ol>
<a id="more"></a>

<h2 id="測試類型、目標"><a href="#測試類型、目標" class="headerlink" title="測試類型、目標"></a>測試類型、目標</h2><p>在 【測試價值：為什麼我需要測試】 一文中有提到測試本身在做的事情：</p>
<blockquote>
<p>測試簡單的來說主要就是藉由操控受測物（SUT, System Under Test），觀察由受測物產生的最終狀態是否如我們所預期的樣子</p>
</blockquote>
<p>然而由於觀察點的不同，進而產生出不同的測試類型來觀察目標，而跟前端領域較有關聯的測試主要分為：</p>
<ul>
<li>單元測試</li>
<li>整合測試</li>
<li>端對端測試</li>
<li>快照測試</li>
<li>視覺回歸測試</li>
<li>效能測試</li>
<li>靜態測試</li>
</ul>
<h3 id="單元測試（Unit-testing）"><a href="#單元測試（Unit-testing）" class="headerlink" title="單元測試（Unit testing）"></a>單元測試（Unit testing）</h3><p>測試目標：主要針對專案中最小單位的行為做預期結果測試，也就是本系列文的重點項目。</p>
<h3 id="整合測試（Integration-testing）"><a href="#整合測試（Integration-testing）" class="headerlink" title="整合測試（Integration testing）"></a>整合測試（Integration testing）</h3><p>測試目標：將不同行為整合後做預期結果測試，比方元件與 API 有關的交互行為。</p>
<h3 id="端對端測試（End-to-end-testing-E2E-testing）"><a href="#端對端測試（End-to-end-testing-E2E-testing）" class="headerlink" title="端對端測試（End-to-end testing, E2E testing）"></a>端對端測試（End-to-end testing, E2E testing）</h3><p>目標：以模擬終端使用者（End User)的角度來執行測試，常見的做法是工具會模擬瀏覽器的環境並藉由測試程式碼來依序操作，從而找出實際上操作時會遇到的問題與未預期的錯誤。</p>
<h3 id="快照測試（Snapshot-testing）"><a href="#快照測試（Snapshot-testing）" class="headerlink" title="快照測試（Snapshot testing）"></a>快照測試（Snapshot testing）</h3><p>目標：模擬出瀏覽器環境後，工具將測試程式碼所指定的範圍以類似 DOM 渲染後的結構儲存成一個文字檔，用以快速比對結構上的變化，而非比對渲染後視覺上的呈現。</p>
<h3 id="視覺回歸測試（Visual-Regression-testing）"><a href="#視覺回歸測試（Visual-Regression-testing）" class="headerlink" title="視覺回歸測試（Visual Regression testing）"></a>視覺回歸測試（Visual Regression testing）</h3><p>目標：模擬出瀏覽器環境後，工具將測試程式碼所指定的範圍照一張相片下來，並存成圖檔供比對，並且著重在於跨瀏覽器或裝置上是否也能保持一致性。</p>
<h3 id="效能測試（Performance-testing）"><a href="#效能測試（Performance-testing）" class="headerlink" title="效能測試（Performance testing）"></a>效能測試（Performance testing）</h3><p>目標：透過效能檢測工具（如 Lighthouse）針對運行起來的專案做載入、無障礙、PWA 與 SEO 等提出改善建議，或留存前次的紀錄做對比，查看改動後的效能變化。</p>
<h3 id="靜態測試（Static-testing）"><a href="#靜態測試（Static-testing）" class="headerlink" title="靜態測試（Static testing）"></a>靜態測試（Static testing）</h3><p>目標：在撰寫程式碼的階段，透過 IDE 或含有 extension 輔助的文字編輯器中檢查型別或拼寫來檢驗是否有問題。通常會是藉由 TypeScript、ESLint 這一類的語言或工具達成。</p>
<hr>
<h2 id="測試金字塔"><a href="#測試金字塔" class="headerlink" title="測試金字塔"></a>測試金字塔</h2><blockquote>
<p>喝咖啡時若想要製作出拿鐵就需要透過咖啡、牛奶與奶泡以準確的比例混合而成，否則不小心就會做成卡布奇諾；同樣地，在專案中不同測試類型也會有它適當的比例。– 靈感參考於 《Testing Vue.js Applications》 一書中。</p>
</blockquote>
<p>雖然上面介紹了不少種測試內容，但其實我們並不一定每個都需要做到，而是挑選必要的部分來施作。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220922/201190629S7HQKLiiv.png" alt="https://ithelp.ithome.com.tw/upload/images/20220922/201190629S7HQKLiiv.png"></p>
<p>Martin Fowler 提出了<a href="https://martinfowler.com/bliki/TestPyramid.html" target="_blank" rel="noopener">測試金字塔</a>的概念，測試類別主要包含了：端對端測試、整合測試與單元測試。</p>
<p>而最上方的端對端測試最貼近 End User 所需要的，但卻是執行測試速度中最慢、耗費成本也是最高的；相反的單元測試的通過不代表最後 End User 所需要的內容，但卻是執行測試速度中最快、耗費成本也越低的測試類型。</p>
<p>此外，Martin Fowler 也指出，如果單元測試都未通過的情況下，其實端對端測試也不會通過。</p>
<p>所以可以得知用大量的單元測試守護專案算是個成本與效益上的考量。</p>
<p>另一個不同聲音是來至於 Edd Yerburgh，在《Testing Vue.js Applications》一書中，Edd Yerburgh 認為的測試金字塔應該像是這樣子：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220922/20119062AoGVv1N86p.png" alt="https://ithelp.ithome.com.tw/upload/images/20220922/20119062AoGVv1N86p.png"></p>
<p>中間原有的整合測試被快照測試所替代，而理由是因為整合測試的定義其實不好拿捏。</p>
<p>我個人認為的原因在於單元測試中的社交型寫法與整合測試本身概念容易互相混淆：</p>
<p>因為根據 Martin Fowler 對單元測試的<a href="https://martinfowler.com/bliki/UnitTest.html" target="_blank" rel="noopener">分析</a>，單元測試寫法主要可分為兩派，若套用在前端領域的話就像是：</p>
<ul>
<li>獨立型（Solitary）：受測物為一個函式或元件等，而有依賴到的部分（如 store），都會藉由隔離的方式排除。</li>
<li>社交型（Sociable）：受測物指的仍然是一個函式或元件，但有依賴到的部分會真實的去使用，因此在測試案例中看起來像是引入了多個檔案，但測試目標其實仍關注在受測物本身。</li>
</ul>
<p>但無論最後挑選的單元測試風格是哪種，說到底測試金字塔主要就是幫助評估的一種手段而已，因此這需要實際的評估與運用才能得知對團隊來說最適當的比例在哪。</p>
<p>明天我們將繼續來看看在撰寫測試的思路中，要如何來挑選適當的工具來協助我們進行測試。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【概念ノ章】測試脈絡－2. 決定測試工具</title>
    <url>/testing/ithelp-2022-vitest-08/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>正所謂「工欲善其事必先利其器」，決定好專案中要運用哪些測試類型後，接下來就要挑選合適的測試工具來輔助我們執行測試的內容。</p>
<a id="more"></a>

<h2 id="測試工具"><a href="#測試工具" class="headerlink" title="測試工具"></a>測試工具</h2><p>在 【測試價值：為什麼我需要測試】 一文中，我們有提到簡易的測試工具是如何手刻出來的，也稍微談到了手刻測試工具的困難，因此選擇一個適當的測試工具來輔助我們進行測試是有必要性的。</p>
<p>但測試工具百百種，許多工具在提供的功能上又重疊，那麼我們該如何選擇工具呢？</p>
<p>若是以 <strong>「單元測試」</strong> 來說的話，我們在撰寫測試程式碼時可能至少就會有以下的需求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 引入相關檔案 */</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'測試情境描述'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'測試案例描述'</span>, () =&gt; &#123;</span><br><span class="line">     <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">     expect(wrapper.text()).toBe(<span class="string">'Hello, World'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'另一個測試案例描述'</span>, () =&gt; &#123;</span><br><span class="line">     <span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">       props: &#123;</span><br><span class="line">         content: <span class="string">'Unit-test!'</span>   </span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">     expect(wrapper.text()).toBe(<span class="string">'Unit-test!'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>測試環境（test runner）：提供上方測試程式碼執行的環境。</li>
<li>測試情境（test suite）：如上方的 <code>describe</code> ，用來包裹多個測試案例，以及描述測試情境⋯⋯等功能。</li>
<li>測試案例（test case）：如上方的 <code>it</code>，用來包裹該測試案例的實際情況，若有錯誤時需讓我們能夠輕易找到是哪個案例發生的⋯⋯等等功能。</li>
<li>斷言（Assertion）如上方的 <code>expect</code>，主要是用來判斷受測物與預期結果是否一致的方法，甚至依據不同判斷方式內部也提供了多種判斷方式，如 <code>.toBe</code> 可用來判斷選取的目標與預期結果是否相等。</li>
</ul>
<p>除此之外，在必要的情況下甚至會需要：</p>
<ul>
<li>測試替身（test double）：用來模仿依賴工具或函式原先的功能狀況</li>
<li>解析或模擬元件容器</li>
<li>模擬瀏覽器中 DOM 的環境</li>
</ul>
<p>而根據上述需求，就能夠列出一個需求表，來評估各個測試工具是否符合我們測試需要的部分：</p>
<blockquote>
<p>測試工具列表可參考個框架中的測試建議指南，（比方 <a href="https://vuejs.org/guide/scaling-up/testing.html#component-testing" target="_blank" rel="noopener">Vue 的測試建議指南</a>）</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">需求</th>
<th>Vitest</th>
<th>Jest</th>
<th>Mocha</th>
<th>Chai.js</th>
<th>Sinon.js</th>
<th>Vue-test-utils</th>
<th>jsdom</th>
</tr>
</thead>
<tbody><tr>
<td align="left">測試環境（test runner）</td>
<td>✔(註1)</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">測試情境（test suite）</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">測試案例（test case）</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">斷言（Assertion）</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">測試替身（test double）</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">解析或模擬元件容器</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td align="left">提供模擬 DOM 環境</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
</tr>
</tbody></table>
<blockquote>
<p>註1：Vitest 本身基於 Vite 環境，因此專案若非透過 Vite 所構建的話就無法使用。</p>
</blockquote>
<p>現在透過這個表我們可以很清楚的看見，假設專案是基於 <code>Vite</code> 所建立的那麼我可以選擇下列這個組合：</p>
<ul>
<li><code>Vitest</code> + <code>Vue-test-utils</code> + <code>jsdom</code></li>
</ul>
<p>如果專案是基於 <code>Vue-cli</code> 所建立的，那麼就無法使用了 <code>Vitest</code> 作為測試運行的環境了，此時根據表中我們就可以替換為：</p>
<ul>
<li>方案一：<code>Jest</code> + <code>Vue-test-utils</code> + <code>jsdom</code></li>
<li>方案二：<code>Mocha</code> + <code>Chai.js</code> + <code>Sinon.js</code> + <code>Vue-test-utils</code> + <code>jsdom</code></li>
</ul>
<p>而在做工具替換時，需要注意到的是，不同的測試環境（test runner）可能會對於引入（<code>import</code>）檔案時發生解析上的問題，比方若用到 Vue 中的 <code>SFC</code> 類型檔案作為開發，那在 <code>Jest</code> 做為測試環境時我們就需要另外安裝 <code>vue-jest</code> 來做轉換 <code>SFC</code> 上的處理。</p>
<p>當然，上述的需求表只是一個簡單的範例，而隨著撰寫測試的經驗越多，後續慢慢就會瞭解到專案中會需要哪些測試工具來協助我們進行測試，甚至比較各種測試工具的優缺點從而選出最適合團隊的測試工具！</p>
<p>現在我們已經了解要如何挑選測試工具了，明天要來開始聊聊撰寫測試案例時應該要如何思考！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【概念ノ章】測試價值：加入測試的時機</title>
    <url>/testing/ithelp-2022-vitest-06/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>上篇提到了測試價值的部分，瞭解了導入測試能夠帶來什麼樣的價值。然而，若我們想發揮測試的最大效用，我們需要試著在合適的時機來加入測試。</p>
<p>本文接下來會分成兩種探討的方向來說明我心目中加入測試的時機：</p>
<ul>
<li>專案性質</li>
<li>產品階段</li>
</ul>
<a id="more"></a>

<hr>
<h2 id="依據專案性質選擇加入測試"><a href="#依據專案性質選擇加入測試" class="headerlink" title="依據專案性質選擇加入測試"></a>依據專案性質選擇加入測試</h2><p>「為什麼平常開發時都很順利，感覺不需要加入測試啊？」會發生這種情況，很有可能就是因為該專案的性質，加入測試的效益不高，所以才會發生這件事情。</p>
<p>但是每家公司的產業別不同，關注的焦點也就不同；甚至，同公司中不同專案之間重視的程度也會有所差別，因此我以幾個指標來供大家自行權衡哪些專案加入測試對是有益處的：</p>
<h3 id="生命週期：一個產品從創建後到維護，最後消亡的時間。"><a href="#生命週期：一個產品從創建後到維護，最後消亡的時間。" class="headerlink" title="生命週期：一個產品從創建後到維護，最後消亡的時間。"></a>生命週期：一個產品從創建後到維護，最後消亡的時間。</h3><p>專案稍縱即逝：<br>有時候我們可能會承接到來至行銷部門的廣告宣傳頁。而對於廣告宣傳的走期來說很有可能只有短短的兩週不到，這種專案加入測試後可能還沒有機會被測試守護到，線上的頁面就要銷毀了。</p>
<p>專案會長達一段時間：<br>假若處理的專案是屬於平台類型的網站或產品，撇除掉一開始開發的期間，往往上線後可能就進入長達數年的維運期，這類型的專案由於在產品生命週期中的維運期較長，非常有可能會遇到經手維護人員的更換、既有功能的調整甚至於共用元件邏輯異動等情境，此時除了仰賴規格書來傳承專案中的領域知識之外，就可以藉由測試來防禦意外發生的錯誤。</p>
<h3 id="維護頻率：專案初步開發完成後，後續維護的頻率。"><a href="#維護頻率：專案初步開發完成後，後續維護的頻率。" class="headerlink" title="維護頻率：專案初步開發完成後，後續維護的頻率。"></a>維護頻率：專案初步開發完成後，後續維護的頻率。</h3><p>近乎不需維護：<br>有些專案放上線後⋯⋯對，沒有然後了，這種專案甚至不在公司的戰略目標上，只因為「某些特殊理由」需要存在，比起測試我更懷疑將來打開後會啟動不了專案的可能性還高一些，因此補足必須的專案文件（如 <a href="http://Readme.md" target="_blank" rel="noopener">Readme.md</a> 該如何啟動專案）都比測試更為需要。</p>
<p>維護頻率適量：<br>假若一個專案上線後，每個月都仍有改善服務功能等等需求，那麼加入測試就可以鞏固既有的部分不會被牽連到。</p>
<h3 id="專案規模：產品在規劃需求階段後，所評估出來的專案規模大小。"><a href="#專案規模：產品在規劃需求階段後，所評估出來的專案規模大小。" class="headerlink" title="專案規模：產品在規劃需求階段後，所評估出來的專案規模大小。"></a>專案規模：產品在規劃需求階段後，所評估出來的專案規模大小。</h3><p>小如芝麻：<br>一頁式的活動頁等等，如果內容都純屬文案與圖片，比起測試我可能會請相關業務單位仔細審查其文案是否正確、該有的連結有無放錯等素材確認，畢竟寫了測試去對照連結是否錯誤，結果一開始給的就是錯的，以解決問題的觀點來看，此時測試的效益就會低。</p>
<p>功能多到需要安排多人協作：<br>有些專案非一己之利能夠完成時，或是遇到需要團隊配合的情況，這時候品質佳的測試能夠防止雙方無意中更改彼此共用的邏輯。</p>
<h3 id="需求穩定度：需求衝突時的間隔時間。"><a href="#需求穩定度：需求衝突時的間隔時間。" class="headerlink" title="需求穩定度：需求衝突時的間隔時間。"></a>需求穩定度：需求衝突時的間隔時間。</h3><p>方案上午剛確認，下午又變更：<br>偶爾公司應戰略目標考量，在看不到終點雛形的狀態下就要開始開發了，且戰且走的情況下，就會容易因各種原因導致需求不斷變更，更甚者推翻之前的規則，此時加入測試就得衡量其他要素看看是否真的需要，否則很容易遇到測試程式碼不斷被拋棄的狀況。</p>
<h3 id="資源分配：進行開發前的前置期需求規劃是否足夠、開發人員配置與時間是否充沛。"><a href="#資源分配：進行開發前的前置期需求規劃是否足夠、開發人員配置與時間是否充沛。" class="headerlink" title="資源分配：進行開發前的前置期需求規劃是否足夠、開發人員配置與時間是否充沛。"></a>資源分配：進行開發前的前置期需求規劃是否足夠、開發人員配置與時間是否充沛。</h3><p>資源嚴重不足：<br>因應需要得在有限的情況快速開發，光是開發產品程式碼本身就快來不及的情況下，必要時先捨棄撰寫測試程式碼是一種考量，但如果後續想加入測試就會遇到重重困難。</p>
<p>有喘息的空間：<br>開發期給予的時間合適，若有需要就可以考慮加入測試。而熟練測試後，導入測試所增加的開發時間就可以降低不少。</p>
<h2 id="產品階段"><a href="#產品階段" class="headerlink" title="產品階段"></a>產品階段</h2><p>把專案以產品的規格來看待的話我們能加入測試的環節主要是落在初期開發與上線後的維運階段：</p>
<h3 id="專案本身剛進入開發階段"><a href="#專案本身剛進入開發階段" class="headerlink" title="專案本身剛進入開發階段"></a>專案本身剛進入開發階段</h3><p>若是產品剛進入開發階段的話，此時要加入測試是非常容易的，甚至透過像是前一篇文章的所採用的測試驅動開發（TDD, Test-Driven Development）的開發模式能從測試中得到更多回饋。</p>
<p>然而這階段可能比較容易遇到的就是需求不穩定的情況，即便在需求規劃期開發者可能與整理需求的人員已有過會議討論可行性，但難免還是會有部分需求要在實際執行時才會發現需要變更作法，因此測試程式碼需隨著產品程式碼不斷調整是可預期的狀況。</p>
<h3 id="專案本身已進入維運階段"><a href="#專案本身已進入維運階段" class="headerlink" title="專案本身已進入維運階段"></a>專案本身已進入維運階段</h3><p>若產品本身已經開發了一段時間，此時很多功能都是沒有受到測試保護的，根據 《Kent Beck 的測試驅動開發》一書中， Kent Beck 對於這種情況則是表示<em>我們不應該為所有產品程式碼都補上測試，對於沒有需求更動的地方我們應該保留原始的狀態</em>。</p>
<p>因此，我們能做到的應該是對將來需求更動所影響到的地方開始慢慢加入測試，或是依靠其他可信賴的方式，比方透過團隊成員 code review 等等方式逐步前進。</p>
<hr>
<p>以上便是目前我衡量何時該加入測試的基準，也歡迎大家留言提供自己是如何決策何時該加入測試的方式。</p>
<p>而在確認測試的價值也已經做出決策要在哪些專案加入測試之後，明天我們將開始關注在思考如何撰寫測試的流程，並從測試類型與對應的測試工具開始分析。</p>
<blockquote>
<p>作者悄悄話：其實測試寫熟了之後大部分比較像是你願不願意寫</p>
</blockquote>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【概念ノ章】測試脈絡－4. 測試案例中的 3A 模式</title>
    <url>/testing/ithelp-2022-vitest-10/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>接續昨天的測試情境與測試案例章節後，我們大致上瞭解了測試情境與測試案例的基本架構要如何設立，而今天要提的部分則是關於測試案例執行流程與測試案例撰寫架構。</p>
<a id="more"></a>

<hr>
<h2 id="測試案例的-3A-模式"><a href="#測試案例的-3A-模式" class="headerlink" title="測試案例的 3A 模式"></a>測試案例的 3A 模式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'貓咪'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'摸摸，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'餵食，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'拿玩具逗，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'什麼都不做，應該推倒眼前看到的所有東西'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>當我們設立好測試情境與測試案例的敘述結構之後，要開始撰寫測試案例內部的實作時就可以利用所謂的 3A 模式來安排。</p>
<p>3A 模式主要是為（Arrange-Act-Assert）三個英文字的縮寫，而他們分別代表了：</p>
<ul>
<li>準備（Arrange）：準備好受測目標需要的一切，包含依賴的隔離等</li>
<li>操作（Act）：操作受測物目標</li>
<li>斷言（Assert）：預期受測物的某個狀態是否為我們所預期</li>
</ul>
<p>以上方第一項測試案例來套用 3A 模式的話就會像是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'摸摸，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Arrange: 準備好一隻貓</span></span><br><span class="line">    <span class="keyword">const</span> target = <span class="keyword">new</span> Cat()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act: 摸摸那隻貓咪</span></span><br><span class="line">    target.touch()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert: 觀察那隻貓是否發出呼嚕嚕叫聲</span></span><br><span class="line">    expect(target.speaking).toBe(<span class="string">'呼嚕嚕'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那如果這時候你可能會想到每個測試案例都要準備一隻貓貓，對於測試案例來說就會一直不斷地去做「準備（Arrange）」這個行為，因此你可能會很直覺的這麼處理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'貓咪'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="keyword">new</span> Cat()</span><br><span class="line">    it(<span class="string">'摸摸，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        target.touch()</span><br><span class="line">        expect(target.speaking).toBe(<span class="string">'呼嚕嚕'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'餵食，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        target.feed(<span class="string">'乾乾'</span>)</span><br><span class="line">        expect(target.speaking).toBe(<span class="string">'呼嚕嚕'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'拿玩具逗，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        target.play()</span><br><span class="line">        expect(target.speaking).toBe(<span class="string">'呼嚕嚕'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但這樣的後果就是每個測試案例之間就會有關聯了，比方貓貓其實摸太多下他也會覺得厭煩，從而導致測試失敗：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'貓咪'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="keyword">new</span> Cat()</span><br><span class="line">    it(<span class="string">'摸摸下巴，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        target.touch()</span><br><span class="line">        expect(target.speaking).toBe(<span class="string">'呼嚕嚕'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'再摸一次下巴，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        target.touch()</span><br><span class="line">        expect(target.speaking).toBe(<span class="string">'呼嚕嚕'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'再摸一次下巴，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        target.touch()</span><br><span class="line">        expect(target.speaking).toBe(<span class="string">'呼嚕嚕'</span>) <span class="comment">// 預期呼嚕嚕，結果貓咪生氣了</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而要寫好測試案例的其中幾個概念就是要盡量讓每個測試案例之間「不受順序影響測試結果」與「保持獨立」。</p>
<p>因此大多數的「測試環境」的工具都會提供類似相關的 API 來協助處理測試開始前的「Setup」與結束後的「Teardown」環節。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'貓咪'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="keyword">new</span> Cat()</span><br><span class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 每個測試案例開始前要做的事情</span></span><br><span class="line">        target.init() <span class="comment">// 初始化貓貓的各種狀態</span></span><br><span class="line">    &#125;)</span><br><span class="line">    afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 每個測試案例結束後要做的事情</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'摸摸，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        target.touch() <span class="comment">// 這時候的 target 已經是經過 init() 的版本了</span></span><br><span class="line">        expect(target.speaking).toBe(<span class="string">'呼嚕嚕'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'餵食，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        target.feed(<span class="string">'乾乾'</span>) <span class="comment">// 這時候的 target 已經是經過 init() 的版本了</span></span><br><span class="line">        expect(target.speaking).toBe(<span class="string">'呼嚕嚕'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'拿玩具逗，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        target.play() <span class="comment">// 這時候的 target 已經是經過 init() 的版本了</span></span><br><span class="line">        expect(target.speaking).toBe(<span class="string">'呼嚕嚕'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>綜合上述 3A 與處理 Setup &amp; Teardown 的觀念，之後再寫測試案例時，我們可以先從基礎的 3A 模式開始撰寫，而到有需要處理重複的事前準備（Setup）與後續清理時（Teardown），就可以藉由工具來替我們統一處理。後續環節也會提到如何透過工廠模式或模擬物件來快速創造我們要的測試內容。</p>
<p>相信看到這邊讀者應該會發現，測試的基本概念其實不難懂，而在瞭解測試的概念後，剩下的就是把概念轉換為測試工具可讀懂測試程式碼就好了，而明天就要開始講解有關測試程式碼的部分！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【概念ノ章】測試脈絡－3. 決定測試情境與測試案例</title>
    <url>/testing/ithelp-2022-vitest-09/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>經過測試金字塔模型的協助後，我們大致上瞭解要怎麼替專案加入對應的測試類型；並且在上一章節中我們也提到了針對「單元測試」類型做測試工具挑選時，可以從需求表中拉出各種工具做比較。</p>
<p>而接下來我們要談談在選擇這些工具後，我們要如何來思考針對「單元測試」的部分，測試情境與測試案例要怎麼撰寫以及需要注意的地方。</p>
<a id="more"></a>

<hr>
<h1 id="測試情境（test-suite）測試案例（test-case）"><a href="#測試情境（test-suite）測試案例（test-case）" class="headerlink" title="測試情境（test suite）測試案例（test case）"></a>測試情境（test suite）測試案例（test case）</h1><p>提供測試環境的工具一般會給予測試情境與測試案例的相關 API，而測試情境與案例最主要的用意是用來幫助我們規劃與整理整個測試邏輯，並且在我們測試案例錯誤的時候同時提供相對應的資訊。</p>
<p>接下來我們以「貓咪作為元件」為故事主軸來談談單元測試的思路會是怎麼撰寫。</p>
<p>首先我們假設「貓咪」元件會提供下列功能：</p>
<ul>
<li>發出呼嚕嚕叫聲</li>
<li>推倒眼前看到的所有東西</li>
</ul>
<p>而以使用者角度上來看，我們會對「貓咪」做出這些事情：</p>
<ul>
<li>摸摸</li>
<li>餵食</li>
<li>拿玩具逗</li>
</ul>
<p>接著我們就可以以元件作為情境來定義出各種使用上的測試案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'貓咪'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'摸摸，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'餵食，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'拿玩具逗，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'什麼都不做，應該推倒眼前看到的所有東西'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但真實的測試案例不會這麼簡單，總會有一些例外狀況，那麼測試案例應該要包含哪些要素比較好？</p>
<h2 id="案例路徑-happy-path-sad-path＆-bad-path"><a href="#案例路徑-happy-path-sad-path＆-bad-path" class="headerlink" title="案例路徑(happy path, sad path＆ bad path)"></a>案例路徑(happy path, sad path＆ bad path)</h2><p>在設定測試案例時，總會有百百種情況，但是我們不可能每個都寫出來，而根據測試案例的類型主要可以分為三種路徑</p>
<ul>
<li>Happy Path：在我們定義所謂「正常的使用狀況」下，針對「正確的內容」，我們預期應該要做出的反應</li>
<li>Sad Path：在我們定義所謂「正常的使用狀況」下，針對「錯誤的內容」，我們預期應該要做出的反應</li>
<li>Bad Path：在我們定義所謂「錯誤」的使用狀況下，我們預期應該要做出的反應</li>
</ul>
<p>同樣以貓被摸摸作為例子來看，假設對於貓來說能夠接受摸摸的情況只限於「頭與下巴」，而喜歡被摸的部分只有「下巴」，那麼測試案例路徑就可以這麼定義：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'貓咪'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Happy Path</span></span><br><span class="line">    it(<span class="string">'摸摸下巴，應該會發出「呼嚕嚕」聲'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// Sad Path</span></span><br><span class="line">    it(<span class="string">'摸摸頭，應該沒反應'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// Bad Path</span></span><br><span class="line">    it(<span class="string">'摸摸肚子，應該拋出錯誤'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="路徑優先度"><a href="#路徑優先度" class="headerlink" title="路徑優先度"></a>路徑優先度</h2><p>而以各個路徑優先度來說，我們應當盡可能的先完善 Happy Path 與 Sad Path 的各種案例，因為對於實際專案上來說，這些內容是我們預期元件或函式本身應提供的內容。</p>
<p>然而 Bad Path 通常是建立已知哪些情況會是「不正確的使用」，我們只能就已知的狀況來預防。然而，這一部分其實再怎麼縝密，都還是會有極其例外的事情發生：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'貓咪'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Bad Path</span></span><br><span class="line">    it(<span class="string">'摸摸肚子，應該拋出錯誤'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'摸摸尾巴，應該拋出錯誤'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'摸摸手，應該拋出錯誤'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'摸摸腳，應該拋出錯誤'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 舉不完</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因此透過測試來作防禦所有不合理的行為是不治本的行為，我應該從受測物本身提供的操作或是產品規劃上來去考量相對治本的方式；比方在「貓咪」元件上透過程式設計的部分，規劃「摸摸」行為只開放「頭」與「下巴」的部位，從開發階段就阻止其他開發者誤用「摸摸」方法，到最後真的有其必要特別拋出時才針對這一部分寫 Bad Path 案例。</p>
<p>最後，再用一個實際一點的例子說明，假設今天有個登入的表單元件，那麼最簡單預期會有的案例就會是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'登入元件'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Happy Path</span></span><br><span class="line">    it(<span class="string">'輸入正確帳號密碼，應登入到ＯＯ頁面'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// Sad Path</span></span><br><span class="line">    it(<span class="string">'只輸入帳號，應該顯示請輸入密碼'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'只輸入密碼，應該顯示請輸入帳號'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'輸入錯誤帳號密碼，應該顯示登入資訊錯誤'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上就是測試情境與測試案例最基本需要瞭解的部分，明天我們將關注於測試案例中內部應該要如何來撰寫。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【概念ノ章】測試脈絡－5. 撰寫測試碼 FIRST 法則與學習步驟</title>
    <url>/testing/ithelp-2022-vitest-11/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>回顧目前我們經歷過的測試脈絡章節，我們一路上談到了：</p>
<ol>
<li>根據測試金字塔模型思考測試類型</li>
<li>根據測試類型透過需求表單選擇好測試工具</li>
<li>瞭解測試情境與測試案例的結構思維</li>
<li>瞭解測試案例內部應有的架構</li>
</ol>
<p>為什麼要大費周章提測試脈絡呢？</p>
<p>主要是單純的學習測試程式碼只會讓你學到如何用測試程式碼來測試你的實作，但是有脈絡的學習測試將概念與語法抽離開來，才不會在撰寫測試遇到各種心境上的阻礙，所以我們要先排除心魔，確認測試是對我們有益的，那麼接下來就能放心的學習測試語法了。</p>
<p>而今天要來談談最後一部分，那就是關於撰寫測試程式碼前須知的基本觀念！</p>
<a id="more"></a>

<h2 id="撰寫測試程式碼的須保持的心境"><a href="#撰寫測試程式碼的須保持的心境" class="headerlink" title="撰寫測試程式碼的須保持的心境"></a>撰寫測試程式碼的須保持的心境</h2><p>談到撰寫測試，不得不提到 Robert Cecil Martin 有本經典的《無瑕的程式碼：敏捷軟體開發技巧守則》，作者在其中針對了程式碼的部分提了很多優良的建議，不論是撰寫程式碼中的命名、函式參數等等做探討，也在實際的案例中做一些討論與重構，最後回顧那些程式碼中的氣味、清理程式碼，一氣呵成。</p>
<p>而其中有一個章節最主要就是在講有關「單元測試」的部分，也就是系列文前言提到「被推坑」的部分，我把裡面的概念結合我的經驗來重新闡述一次：</p>
<p>若帶著單純學習的心態來看待測試程式碼，其實很容易把它當作一項輔助工具在處理，覺得沒有也沒什麼關係，甚至礙手礙腳的，甚至可能覺得還要特地花了不少心力來瞭解它，但這是一體兩面的。</p>
<p>若你把它當作產品中的一部分就會發現，雖然開發時會受到測試程式碼的「限制」，但同時他其實也是在做「守護」產品程式碼這件事情；甚至因為有了「可信賴的測試」，所以當我們在進行「重構」等等調整時也才能更有信心地去處理。</p>
<p>因此只要確保我們在適當的時機加入它，那麼它就能夠帶來可觀的後續效益，而既然他能夠替我們帶來效益，那我們對待測試程式碼的態度其實也應該要同理產品程式碼，可是除了讓測試程式碼如同產品程式碼一樣保持「整潔」與「可讀性」之外，我們還有什麼辦法呢？</p>
<p>對於這個問題 Martin 給了一個撰寫測試碼的優良準則，那就是 F.I.R.S.T 法則。</p>
<h2 id="F-I-R-S-T-法則"><a href="#F-I-R-S-T-法則" class="headerlink" title="F.I.R.S.T 法則"></a>F.I.R.S.T 法則</h2><p>F.I.R.S.T 法則顧名思義其實就是五個英文單字的縮寫，他們分別是：</p>
<ul>
<li>Fast</li>
<li>Independent</li>
<li>Repeatable</li>
<li>Self-Validating</li>
<li>Timely</li>
</ul>
<h3 id="Fast：快"><a href="#Fast：快" class="headerlink" title="Fast：快"></a>Fast：快</h3><p>簡單來說就是快，因為快才能讓我們快速重複大量地檢驗產品程式碼；這意味著我們在測試程式碼中有可能會遇到要 call API 的情況，那麼我們可以將其隔離並立刻回傳我們預定好的資料來減少等待回應的時間。</p>
<h3 id="Independent：獨立"><a href="#Independent：獨立" class="headerlink" title="Independent：獨立"></a>Independent：獨立</h3><p>如我們上一篇文章所提到的，每個測試案例應該要互相獨立，彼此不受干擾之外，甚至連執行順序上都不會影響到最終結果。</p>
<h3 id="Repeatable：可重複"><a href="#Repeatable：可重複" class="headerlink" title="Repeatable：可重複"></a>Repeatable：可重複</h3><p>可重複性主要提的就是不論在什麼設備狀況下，應該都要保持著一致的結果，這樣我們才能排除掉其他不必要的原因，專注在發生問題的程式碼上。</p>
<h3 id="Self-Validating：能自我驗證"><a href="#Self-Validating：能自我驗證" class="headerlink" title="Self-Validating：能自我驗證"></a>Self-Validating：能自我驗證</h3><p>測試的最終狀態應該要能夠顯示「通過與否」，而這一部分測試工具或框架都會幫我們處理好，甚至都還有提供額外的 diff 差異讓我們快速查看錯誤的地方。</p>
<h3 id="Timely：即時"><a href="#Timely：即時" class="headerlink" title="Timely：即時"></a>Timely：即時</h3><p>測試程式碼要盡可能的與產品程式碼同進退，如果測試程式碼落後產品程式碼太多，測試程式碼會越來越難跟上產品程式碼的步調。</p>
<p>而根據對待測試程式碼的心態以及一些前輩給予的優良法則，在撰寫測試程式碼時就能更容易體會到他的魅力。</p>
<h2 id="語法學習段落"><a href="#語法學習段落" class="headerlink" title="語法學習段落"></a>語法學習段落</h2><p>在概念的部分結束後，接下來我們將專注於如何寫好測試程式碼的語法，而語法這一部分將系統的規劃成下列部分：</p>
<ul>
<li>測試情境與測試案例</li>
<li>測試容器與相關的方法</li>
<li>模擬瀏覽器行為</li>
<li>模擬 Vue 元件</li>
<li>學習各種仿造替身技巧</li>
<li>處理 Vue 周邊生態工具測試（Router, Pinia）</li>
</ul>
<p>同時別忘了明天開始要來利用系列文前面所安裝好的<a href="https://ithelp.ithome.com.tw/articles/10292537" target="_blank" rel="noopener">專案</a>啦！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】案例與情境：describe &amp; it 與輔助 API</title>
    <url>/testing/ithelp-2022-vitest-12/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><blockquote>
<p>本文可利用<a href="https://ithelp.ithome.com.tw/articles/10292537" target="_blank" rel="noopener">系列文專用專案</a>來一邊學習，快來安裝吧！</p>
</blockquote>
<p>今天要進入測試程式碼語法的第一篇哩，接下來每天語法章節都會出個一題來讓大家練習，若還沒安裝專案的快去安裝！！！</p>
<a id="more"></a>

<hr>
<h2 id="describe-amp-it-基礎用法"><a href="#describe-amp-it-基礎用法" class="headerlink" title="describe &amp; it 基礎用法"></a>describe &amp; it 基礎用法</h2><p>稍早有提到的測試情境與測試案例在 <code>Vitest</code> 工具中主要便是透過 <code>describe</code> 與 <code>it</code>（或 <code>test</code>） 來撰寫，而他們的用意除了規劃測試的脈絡之外，最主要是用來包裝斷言結果的資訊：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;describe, it&#125; <span class="keyword">from</span> <span class="string">'vitest'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'測試情境的描述'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'第一個測試案例的描述'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>假設在終端機執行上方的測試程式碼時，依據工具預設設定會在終端機顯示「錯誤的相關資訊」與「綜合結果」。</p>
<p>錯誤的相關資訊：<br><img src="https://ithelp.ithome.com.tw/upload/images/20220927/20119062IZlDfWscFG.png" alt="https://ithelp.ithome.com.tw/upload/images/20220927/20119062IZlDfWscFG.png"></p>
<ul>
<li>FAIL：發生斷言錯誤檔案路徑 + 情境描述 + 案例描述（視當下錯誤所屬的情境與案例）</li>
<li>AssertionError：發生斷言錯誤的原因，與發生錯誤的段落</li>
<li>Expected：預期結果</li>
<li>Received：實際結果</li>
</ul>
<p>綜合結果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20220927/20119062qLlyajQCLy.png" alt="https://ithelp.ithome.com.tw/upload/images/20220927/20119062qLlyajQCLy.png"></p>
<ul>
<li>Test Files：總共測試了幾隻測試檔案，並顯示成功、失敗與跳過的數量</li>
<li>Tests：總共測了幾個測試案例，並顯示成功、失敗與跳過的數量</li>
<li>Start：測試開始時間</li>
<li>Duration：測試過程總共耗費時間</li>
</ul>
<hr>
<p>而除了上述基本用法之外，在同一個測試情境中也能容納數個測試案例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'測試情境的描述'</span> , () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'第一個測試案例的描述'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'第二個測試案例的描述'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>甚至測試情境較為複雜的情況，測試情境（<code>describe</code>）也允許巢狀的方式來建構測試：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'父層情境'</span>, () =&gt; &#123;</span><br><span class="line">  describe(<span class="string">'基於父層情境的情境一'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'測試案例'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  describe(<span class="string">'基於父層情境的情境二'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'測試案例'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'出現提示寄件者姓名與電話將直接註冊成會員'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>相反地，若在簡單的情境的之下，只有測試案例也是允許的方式之一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'測試案例'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">'測試案例'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">'測試案例'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="describe-amp-it-輔助-API"><a href="#describe-amp-it-輔助-API" class="headerlink" title="describe &amp; it 輔助 API"></a>describe &amp; it 輔助 API</h2><p>除了上述的基本用法之外，透過 <code>describe</code> 與 <code>it</code> 撰寫測試的過程中也能透過輔助的 API 來整理測試程式碼：</p>
<ul>
<li><code>.only</code>：測試情境、測試案例皆可使用</li>
<li><code>.skip</code>：測試情境、測試案例皆可使用</li>
<li><code>.todo</code>：測試情境、測試案例皆可使用</li>
<li><code>.fails</code>：測試案例才能使用</li>
</ul>
<h3 id="only"><a href="#only" class="headerlink" title="only"></a>only</h3><p>若在<strong>測試情境</strong>用了此指令，則在同個測試檔案中只會執行帶有 <code>.only</code> 的測試情境，而其餘測試情境底下所有的測試案例將會被跳過（<code>skipped</code>）：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">describe</span><span class="selector-class">.only</span>(<span class="string">'測試情境 1'</span>, () =&gt; &#123; <span class="comment">/* */</span> &#125;)</span><br><span class="line"><span class="selector-tag">describe</span>(<span class="string">'測試情境 2'</span>, () =&gt; &#123; <span class="comment">/* */</span> &#125;) <span class="comment">// skipped</span></span><br><span class="line"><span class="selector-tag">describe</span>(<span class="string">'測試情境 3'</span>, () =&gt; &#123; <span class="comment">/* */</span> &#125;) <span class="comment">// skipped</span></span><br></pre></td></tr></table></figure>

<p>若在<strong>測試案例</strong>中使用，則除了帶有 <code>.only</code> 之外的測試案例都將會被跳過：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'測試情境 1'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  it.only(<span class="string">'測試案例'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/* */</span> &#125;)</span><br><span class="line">  it(<span class="string">'測試案例'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/* */</span> &#125;) <span class="comment">// skipped</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'測試情境 2'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  it.only(<span class="string">'測試案例'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/* */</span> &#125;)</span><br><span class="line">  it(<span class="string">'測試案例'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/* */</span> &#125;) <span class="comment">// skipped</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'測試情境 3'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/* */</span> &#125;) <span class="comment">// skipped</span></span><br></pre></td></tr></table></figure>

<h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>測試情境或測試案例被標注時，將自動跳過該範疇內的測試案例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">describe.skip(<span class="string">'測試情境 1'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">'測試案例'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/* */</span> &#125;) skipped</span><br><span class="line">  it(<span class="string">'測試案例'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/* */</span> &#125;) <span class="comment">// skipped</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'測試情境 2'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">'測試案例'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/* */</span> &#125;)</span><br><span class="line">  it.skip(<span class="string">'測試案例'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/* */</span> &#125;) <span class="comment">// skipped</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h3><p>測試情境或測試案例被標注時，同樣將自動跳過該範疇內的測試案例，但 <code>todo</code> 含義比較接近待加入測試的區塊，並且將來若產出報告時也會特別整理出還有哪些地方需要補上測試。</p>
<h3 id="fails"><a href="#fails" class="headerlink" title="fails"></a>fails</h3><p>最後一個介紹的是測試案例才能使用的輔助 API，還記得列測試案例時的 <code>sad path</code> 嗎？當測試案例應該要失敗的時候就可以透過 <code>fails</code> 顯性標註他們：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it.fails(<span class="string">`'1' + '1' should not to be '11'`</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="built_in">Number</span>(x) + <span class="built_in">Number</span>(y)</span><br><span class="line">  expect(add(<span class="string">'1'</span>, <span class="string">'1'</span>)).toBe(<span class="string">'11'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>當然你也可以單純藉由斷言中的 <code>.not</code> 達到同樣的效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">`'1' + '1' should not to be '11'`</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="built_in">Number</span>(x) + <span class="built_in">Number</span>(y)</span><br><span class="line">  expect(add(<span class="string">'1'</span>, <span class="string">'1'</span>)).not.toBe(<span class="string">'11'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上便是測試程式碼中測試情境與測試案例的部分，有關於輔助 API 的部分有些內容不一定會使用的到，若想更加瞭解所有可用的部分可以參考 Vitest <a href="https://vitest.dev/api/#describe" target="_blank" rel="noopener">測試情境</a> 與 <a href="https://vitest.dev/api/#test" target="_blank" rel="noopener">測試案例</a> 的文件囉。</p>
<hr>
<p>除此之外，今日的練習題已經上傳至 <a href="https://ithelp.ithome.com.tw/articles/10292537" target="_blank" rel="noopener">系列文專用專案</a>，一起來練習吧！</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220927/20119062xGTMo8DXia.png" alt="https://ithelp.ithome.com.tw/upload/images/20220927/20119062xGTMo8DXia.png"></p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】Setup &amp; Teardown：beforeAll, beforeEach, AfterAll &amp; AfterEach</title>
    <url>/testing/ithelp-2022-vitest-13/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h2 id="準備（Setup）與清理（Teardown）"><a href="#準備（Setup）與清理（Teardown）" class="headerlink" title="準備（Setup）與清理（Teardown）"></a>準備（Setup）與清理（Teardown）</h2><p>經過了基本的測試情境與測試案例語法，加上簡單的斷言語法 <code>expect().toBe()</code> 就能夠測試許多簡單的東西了，然而在測試過程中有時會遇到大量重複的「前置操作」或是每次測試後「需要清理測試中的環境」，這時我們可以透過 <code>Vitest</code> 提供的 Setup &amp; Teardown API 來處理：</p>
<a id="more"></a>

<ul>
<li>beforeEach：在每個測試案例執行前呼叫一次</li>
<li>beforeAll：在所有測試案例執行前呼叫一次</li>
<li>afterEach：在每個測試案例執行後呼叫一次</li>
<li>afterAll：在所有測試案例執行後呼叫一次</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 針對測試案例重新初始化</span></span><br><span class="line">    initTestEnv()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Setup-amp-Teardown-API-的範疇"><a href="#Setup-amp-Teardown-API-的範疇" class="headerlink" title="Setup &amp; Teardown API 的範疇"></a>Setup &amp; Teardown API 的範疇</h2><p>Setup &amp; Teardown API 「所有」的定義是根據當下的範疇（context）來決定，除了測試檔案本身之外，使用 <code>describe</code> 來定義測試情境也會形成一個 <code>context</code>，因此假如測試情境有巢狀的情況如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> history = []</span><br><span class="line">describe(<span class="string">'父層情境'</span>, () =&gt; &#123;</span><br><span class="line">  beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    history.push(<span class="string">'beforeAll - 父層情境'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    history.push(<span class="string">'beforeEach - 父層情境'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  afterAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    history.push(<span class="string">'afterAll - 父層情境'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    history.push(<span class="string">'afterEach - 父層情境'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  describe(<span class="string">'子層情境 A'</span>, () =&gt; &#123;</span><br><span class="line">    beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      history.push(<span class="string">'beforeAll - 子層情境 A'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      history.push(<span class="string">'beforeEach - 子層情境 A'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    afterAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      history.push(<span class="string">'afterAll - 子層情境 A'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      history.push(<span class="string">'afterEach - 子層情境 A'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'案例 1'</span>, () =&gt; &#123;</span><br><span class="line">      history.push(<span class="string">'子層情境 A 案例 1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'案例 2'</span>, () =&gt; &#123;</span><br><span class="line">      history.push(<span class="string">'子層情境 A 案例 2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  describe(<span class="string">'子層情境 B'</span>, () =&gt; &#123;</span><br><span class="line">    beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      history.push(<span class="string">'beforeAll - 子層情境 B'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      history.push(<span class="string">'beforeEach - 子層情境 B'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    afterAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      history.push(<span class="string">'afterAll - 子層情境 B'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      history.push(<span class="string">'afterEach - 子層情境 B'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'案例 1'</span>, () =&gt; &#123;</span><br><span class="line">      history.push(<span class="string">'子層情境 B 案例 1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'案例 2'</span>, () =&gt; &#123;</span><br><span class="line">      history.push(<span class="string">'子層情境 B 案例 2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此時將透過 <code>console.log(history)</code> 查看並歸納整理就能得到以下結果：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">--- 進入測試程式碼本身的 Context</span><br><span class="line">--- 進入父層情境的 Context</span><br><span class="line"><span class="keyword">beforeAll </span>- 父層情境</span><br><span class="line">--- 進入子層情境 A 的 Context</span><br><span class="line"><span class="keyword">beforeAll </span>- 子層情境 A</span><br><span class="line"><span class="keyword">beforeEach </span>- 父層情境</span><br><span class="line"><span class="keyword">beforeEach </span>- 子層情境 A</span><br><span class="line">子層情境 A 案例 <span class="number">1</span> // 執行 情境 A 案例 <span class="number">1</span> 的時間點</span><br><span class="line"><span class="symbol">afterEach</span> - 子層情境 A</span><br><span class="line"><span class="symbol">afterEach</span> - 父層情境</span><br><span class="line"><span class="keyword">beforeEach </span>- 父層情境</span><br><span class="line"><span class="keyword">beforeEach </span>- 子層情境 A</span><br><span class="line">子層情境 A 案例 <span class="number">2</span> // 執行 情境 A 案例 <span class="number">2</span> 的時間點</span><br><span class="line"><span class="symbol">afterEach</span> - 子層情境 A</span><br><span class="line"><span class="symbol">afterEach</span> - 父層情境</span><br><span class="line"><span class="symbol">afterAll</span> - 子層情境 A</span><br><span class="line">--- 離開子層情境 A 的 Context</span><br><span class="line"></span><br><span class="line">--- 進入子層情境 <span class="keyword">B </span>的 Context</span><br><span class="line"><span class="keyword">beforeAll </span>- 子層情境 <span class="keyword">B</span></span><br><span class="line"><span class="keyword">beforeEach </span>- 父層情境</span><br><span class="line"><span class="keyword">beforeEach </span>- 子層情境 <span class="keyword">B</span></span><br><span class="line"><span class="keyword">子層情境 </span><span class="keyword">B </span>案例 <span class="number">1</span> // 執行 情境 <span class="keyword">B </span>案例 <span class="number">1</span> 的時間點</span><br><span class="line"><span class="symbol">afterEach</span> - 子層情境 <span class="keyword">B</span></span><br><span class="line"><span class="keyword">afterEach </span>- 父層情境</span><br><span class="line"><span class="keyword">beforeEach </span>- 父層情境</span><br><span class="line"><span class="keyword">beforeEach </span>- 子層情境 <span class="keyword">B</span></span><br><span class="line"><span class="keyword">子層情境 </span><span class="keyword">B </span>案例 <span class="number">2</span> // 執行 情境 <span class="keyword">B </span>案例 <span class="number">2</span> 的時間點</span><br><span class="line"><span class="symbol">afterEach</span> - 子層情境 <span class="keyword">B</span></span><br><span class="line"><span class="keyword">afterEach </span>- 父層情境</span><br><span class="line"><span class="symbol">afterAll</span> - 子層情境 <span class="keyword">B</span></span><br><span class="line"><span class="keyword">--- </span>離開子層情境 <span class="keyword">B </span>的 Context</span><br><span class="line"><span class="symbol">afterAll</span> - 父層情境</span><br><span class="line">--- 離開父層情境的 Context</span><br><span class="line">--- 離開測試程式碼本身的 Context</span><br></pre></td></tr></table></figure>

<p>因此我們在使用這類 API 時要注意當下 context 所包含的範圍。</p>
<h2 id="避免誤區：在-expect-後做清掃處理"><a href="#避免誤區：在-expect-後做清掃處理" class="headerlink" title="避免誤區：在 expect 後做清掃處理"></a>避免誤區：在 expect 後做清掃處理</h2><p>除了上面的用法，有時候你可能會認為既然要清掃，那我何不在斷言後處理就好呢：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">        expect().toBe()</span><br><span class="line">        <span class="comment">// 在這裡做清除</span></span><br><span class="line">        resetTestingEnv()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>這麼做當你在測試案例都是通過的情況下都沒有問題，但是一但某個測試案例發生了錯誤，由於測試案例就會在斷言時拋出 <code>AssertionError</code> 後停止，因此很有可能因為一個測試案例壞了導致接下來所有測試都受到影響：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">        expect().toBe() <span class="comment">// AssertionError，這個測試案例就停在這了</span></span><br><span class="line">        resetTestingEnv() </span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在沒有經過 `resetTestingEnv()` 下進行測試</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在沒有經過 `resetTestingEnv()` 下進行測試</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在沒有經過 `resetTestingEnv()` 下進行測試</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在沒有經過 `resetTestingEnv()` 下進行測試</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因此較佳的作法還是使用 Setup &amp; Teardown API 來處理會比較好：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">    beforeEach(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">        setupTestingEnv()</span><br><span class="line">    &#125;)</span><br><span class="line">    afterEach(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">        resetTestingEnv() </span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">''</span>, () =&gt; &#123;&#125;)</span><br><span class="line">    it(<span class="string">''</span>, () =&gt; &#123;&#125;)</span><br><span class="line">    it(<span class="string">''</span>, () =&gt; &#123;&#125;)</span><br><span class="line">    it(<span class="string">''</span>, () =&gt; &#123;&#125;)</span><br><span class="line">    it(<span class="string">''</span>, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="避免過度使用-Setup-amp-Teardown-API"><a href="#避免過度使用-Setup-amp-Teardown-API" class="headerlink" title="避免過度使用 Setup &amp; Teardown API"></a>避免過度使用 Setup &amp; Teardown API</h2><blockquote>
<p>才剛介紹完 API，馬上又叫人不要用未免也太機車了（？），但凡事有原因請聽我娓娓道來。</p>
</blockquote>
<p>一名對於測試領域頗有研究的 Kent C. Dodds 在 twitter 上發表：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20220928/20119062ywW29eVn1i.png" alt="https://ithelp.ithome.com.tw/upload/images/20220928/20119062ywW29eVn1i.png"></p>
<p>許多人一看了紛紛表示中槍，心想這不就是我在寫的東西嗎？因此發文一出不少人就好奇那麼到底為什麼上方的用法會比較好呢？且讓我們從抽象光譜介紹起。</p>
<h3 id="抽象光譜（The-Spectrum-of-Abstraction）"><a href="#抽象光譜（The-Spectrum-of-Abstraction）" class="headerlink" title="抽象光譜（The Spectrum of Abstraction）"></a>抽象光譜（The Spectrum of Abstraction）</h3><p>Kent C. Dodds <a href="https://kentcdodds.com/blog/aha-testing" target="_blank" rel="noopener">提出</a>在抽象光譜中主要分成了三種概念：</p>
<ul>
<li>ANA：Absolutely No Abstraction</li>
<li>AHA：Avoid Hasty Abstraction</li>
<li>DRY：Don’t Repeat Yourself</li>
</ul>
<p>而後並將此概念應用在 Testing 身上並分別解說了三種抽象型態下的測試的優劣分析。</p>
<p>其中我們往往一開始學習可能因為對語法不熟稔，因此可能會寫出 ANA Testing 形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">''</span> , () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 準備</span></span><br><span class="line">        <span class="comment">// 操作</span></span><br><span class="line">        <span class="comment">// 斷言</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">''</span> , () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 準備：重複的準備類似的內容</span></span><br><span class="line">        <span class="comment">// 操作</span></span><br><span class="line">        <span class="comment">// 斷言</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">''</span> , () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 準備：重複的準備類似的內容</span></span><br><span class="line">        <span class="comment">// 操作</span></span><br><span class="line">        <span class="comment">// 斷言</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而隨著測試經驗越來越熟稔之後，我們可能會想盡各種方法來「節省」撰寫測試上的時間，甚至參考 DRY 心法寫出這樣的測試：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">''</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 統一的事前準備</span></span><br><span class="line">    <span class="keyword">const</span> testEnv = <span class="keyword">new</span> TestEnv()</span><br><span class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        testEnv.init()</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">''</span> , <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 直接操作事先準備好的內容</span></span><br><span class="line">        <span class="comment">// 斷言</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">''</span> , <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 直接操作事先準備好的內容</span></span><br><span class="line">        <span class="comment">// 斷言</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而這樣的下場將會在複雜的巢狀測試情境下越來越難以閱讀與調整：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">''</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    const testEnv = <span class="keyword">new</span> TestEnv()</span><br><span class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        testEnv.init()</span><br><span class="line">    &#125;)</span><br><span class="line">    describe(<span class="string">''</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        const testEnv = <span class="keyword">new</span> TestEnv()</span><br><span class="line">        beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            testEnv.init()</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="regexp">//</span> ...</span><br><span class="line">    &#125;)</span><br><span class="line">    describe(<span class="string">''</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        const testEnv = <span class="keyword">new</span> TestEnv()</span><br><span class="line">        beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            testEnv.init()</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="regexp">//</span> ... 等等 這裡的初始準備有什麼 ？？？</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="regexp">//</span> ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而除了巢狀情境本身是個議題之外，Kent C. Dodds 認為我們應該兼容的方式去看待他，也就是說他不排斥我們去做抽象這件事情，但是首先要做的應該是先保持單純，直到我們看到足夠多共同的案例來分析能抽取出的部分，如果不夠多那甚至原先 <code>inline</code> 的測試案例版本也比過多抽象的版本要好得多。</p>
<blockquote>
<p><a href="https://kentcdodds.com/blog/avoid-nesting-when-youre-testing" target="_blank" rel="noopener">避免過度巢狀情境</a></p>
</blockquote>
<p>最後，共用的部分除非真的有必要透過 setup &amp; teardown 實作處理，否則共用的部分大多也可以透過諸如工廠模式（factory pattern）的形式產生。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 擷取自我某個專案內的元件測試 */</span></span><br><span class="line"><span class="keyword">const</span> factory = (</span><br><span class="line">  options = &#123;</span><br><span class="line">    createSpy: vi.fn,</span><br><span class="line">  &#125;,</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">      plugins: [createTestingPinia(options)],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> store = useMainStore()</span><br><span class="line">  <span class="keyword">return</span> &#123; wrapper, store &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以往後若有使用到這類 API 時不仿先思考一下我們真的需要嗎，還是有更加優雅的方式能夠解決重複的問題呢。</p>
<p>以上便是今日 Setup &amp; Teardown API 的介紹，明天再見~</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】斷言（Assertion）上篇：斷言語法與 Matchers</title>
    <url>/testing/ithelp-2022-vitest-14/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>斷言（Assertion）在程式設計領域中主要指的是「針對一個結果指出為真（<code>true</code>）或假（<code>false</code>）」的邏輯判斷式。</p>
<p>而在測試中斷言主要指的部分如先前提到的 3A 模式中的（Assert）步驟：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// 準備：Arrange</span></span><br><span class="line">      <span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            content: <span class="string">'Hello, Unit-test!'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 操作：Act</span></span><br><span class="line">      wrapper.find(<span class="string">'[data-test="button"]'</span>).click()</span><br><span class="line">      <span class="comment">// 斷言：Assert</span></span><br><span class="line">      expect(wrapper.find(<span class="string">'[data-test="content"]'</span>)).toBe(<span class="string">'Hello, Unit-test!'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其中斷言（Assert）階段中在語法的部分則會使用到所謂的「Matchers」，以上方程式碼為例的話就會是 <code>expect()</code> 後方的 <code>toBe()</code> 這個語法，而不同的「Matchers」能比對的東西也不太一樣，瞭解什麼時候該選什麼 Matchers 基本上寫斷言的時候就能信手捻來。</p>
<a id="more"></a>

<h2 id="斷言語法"><a href="#斷言語法" class="headerlink" title="斷言語法"></a>斷言語法</h2><p>依據不同工具或框架所提供的斷言語法（Assertion），對於 Matchers 來說就會有不同的寫法，所以首先我們要先來簡單認識一下不同工具之間的斷言語法風格上的差異，挑選能接受的斷言風格後再來看該風格的 Matcher 用法，而風格的部分以下將依序介紹：</p>
<ul>
<li>Chai 斷言庫</li>
<li>Jest 框架中的斷言語法</li>
<li>Vitest 中所能用的部分</li>
</ul>
<h3 id="Chai-Assertion"><a href="#Chai-Assertion" class="headerlink" title="Chai Assertion"></a>Chai Assertion</h3><p>Chai.js 本身是一個專注在提供斷言語法的工具庫，它提供了三種<a href="https://www.chaijs.com/guide/styles/" target="_blank" rel="noopener">寫法</a>：</p>
<ul>
<li><p><code>Assert</code>(TDD style)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'Chai/Assert'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="string">'Orange tabby cat'</span></span><br><span class="line">  <span class="keyword">const</span> y = <span class="string">'fat'</span></span><br><span class="line">  assert(x !== y, <span class="string">'Orange tabby cat is not fat'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Expect</code>(BDD style)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'Chai/Expect'</span>, () =&gt; &#123;</span><br><span class="line">  expect([<span class="number">1</span>, <span class="number">2</span>]).to.be.an(<span class="string">'array'</span>).that.does.not.include(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><code>Should</code>(BDD style)：透過擴充物件 <code>prototype</code> 給予 <code>should</code> 屬性的方式使我們可以直接鏈式加入 Matchers 在定義好的變數後。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 選擇一：在斷言前需要呼叫 `chai.should` 方法，</span></span><br><span class="line"><span class="keyword">import</span> chai <span class="keyword">from</span> <span class="string">'chai'</span></span><br><span class="line">chai.should()</span><br><span class="line"><span class="comment">// 選擇二：直接引入下方</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'chai/register-should'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 底下的測試案例就能直接鏈式加上 Matchers</span></span><br><span class="line">it(<span class="string">'Chai/Assert'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="string">'bar'</span></span><br><span class="line">    <span class="keyword">const</span> beverages = &#123; <span class="attr">tea</span>: [<span class="string">'chai'</span>, <span class="string">'matcha'</span>, <span class="string">'oolong'</span>] &#125;</span><br><span class="line"></span><br><span class="line">    foo.should.be.a(<span class="string">'string'</span>)</span><br><span class="line">    foo.should.equal(<span class="string">'bar'</span>)</span><br><span class="line">    foo.should.have.lengthOf(<span class="number">3</span>)</span><br><span class="line">    beverages.should.have.property(<span class="string">'tea'</span>).with.lengthOf(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>BDD style/ TDD style 是什麼</p>
</blockquote>
<h3 id="Jest-Assertion"><a href="#Jest-Assertion" class="headerlink" title="Jest Assertion"></a>Jest Assertion</h3><p>以 Jest 測試框架中所提供的斷言方法則只有：</p>
<ul>
<li>Expect(BDD style)：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'expect/ BDD style'</span>, () =&gt; &#123;</span><br><span class="line">expect(<span class="number">1</span>).toBe(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>需特別注意的是 Jest 中的 <code>expect</code> 與 Chai 的 <code>expect</code> 所提供的 Matchers 是不一樣的。</p>
</blockquote>
<h3 id="Vitest"><a href="#Vitest" class="headerlink" title="Vitest"></a>Vitest</h3><p>以 Vitest 測試工具來說，斷言（Assertion）語法的部分他內建了 Chai 斷言庫與兼容了 Jest 中的斷言語法，因此主要就是在以上介紹的四種寫法中選擇一種使用！</p>
<p>而本系列採用的部分主要會以 Jest Assertion 中的 <code>expect</code> 語法為主，因此接下來主要著重介紹這一部分的 Matchers 要如何使用！</p>
<h2 id="Jest-expect-Matchers"><a href="#Jest-expect-Matchers" class="headerlink" title="Jest expect Matchers"></a>Jest expect Matchers</h2><p>要學習這類 Matchers 除了把 API doc 翻一輪之外，最快的方式之一就是針對不同的測試結果目標類型去歸納，而依照經驗常見種類有：</p>
<ul>
<li>常用：<code>toBe</code>, <code>not</code></li>
<li>純值比對（Primitive）類型: String, Number, Boolean…, etc.</li>
<li>陣列比對與檢查</li>
<li>物件比對與檢查</li>
<li>監聽函式</li>
<li>快照</li>
<li>Error</li>
</ul>
<p>由於 Matchers 繁多，所以從常用跟概念容易搞混的幾個開始先介紹起：</p>
<hr>
<h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><ul>
<li><code>toBe</code>：<br>對資料類型為純值（Primitive Value）來說就是比對值相等<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(<span class="number">1</span>).toBe(<span class="number">1</span>) <span class="comment">// passed</span></span><br><span class="line">expect(<span class="string">'1'</span>).toBe(<span class="number">1</span>) <span class="comment">// failed</span></span><br></pre></td></tr></table></figure>
對非純值（Non-Primitive Value）來說就是比記憶體位置（reference）是否相等<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = obj</span><br><span class="line">expect(obj).toBe(obj2) <span class="comment">// passed</span></span><br><span class="line">expect(&#123;&#125;).toBe(&#123;&#125;) <span class="comment">// failed</span></span><br><span class="line"></span><br><span class="line">- <span class="string">`not`</span>：用於反轉斷言的邏輯</span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">expect(1).toBe(1) // passed</span></span><br><span class="line"><span class="string">expect(1).not.toBe(1) // failed</span></span><br><span class="line"><span class="string">expect(1).not.toBe(2) // passed</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h3 id="純值資料類型比對"><a href="#純值資料類型比對" class="headerlink" title="純值資料類型比對"></a>純值資料類型比對</h3><ul>
<li><p><code>toBeCloseTo</code>：處理浮點數運算時</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(<span class="number">0.1</span> + <span class="number">0.2</span>).toBe(<span class="number">0.3</span>) <span class="comment">// failed 符點溢出，結果應該會為 0.30000000000000004</span></span><br><span class="line">expect(<span class="number">0.1</span> + <span class="number">0.2</span>).toBeCloseTo(<span class="number">0.3</span>) <span class="comment">// passed</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toBeGreaterThan</code>, <code>toBeGreaterThanOrEqual</code> , <code>toBeLessThan</code> &amp; `toBeLessThanOrEqual``</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(<span class="number">5</span>).toBeGreaterThan(<span class="number">1</span>)</span><br><span class="line">expect(<span class="number">5</span>).toBeGreaterThanOrEqual(<span class="number">5</span>)</span><br><span class="line">expect(<span class="number">6</span>).toBeLessThan(<span class="number">7</span>)</span><br><span class="line">expect(<span class="number">6</span>).toBeLessThanOrEqual(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toBeDefined</code> / <code>toBeUndefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">''</span></span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line">expect(a).toBeDefined() <span class="comment">// passed</span></span><br><span class="line">expect(b).toBeUndefined() <span class="comment">// passed</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toBeTruthy</code> / <code>toBeFalsy</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(<span class="number">1</span>).toBeTruthy() <span class="comment">// passed</span></span><br><span class="line">expect(<span class="number">0</span>).toBeFalsy() <span class="comment">// passed</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toBeNull</code>、<code>toBeNaN</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(<span class="literal">null</span>).toBeNull() <span class="comment">// passed</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toMatch</code>：字串或正則比對</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(<span class="string">'0912345678'</span>).toMatch(<span class="regexp">/^09[0-9]&#123;8&#125;$/</span>) <span class="comment">// passed</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h3 id="陣列比對與檢查"><a href="#陣列比對與檢查" class="headerlink" title="陣列比對與檢查"></a>陣列比對與檢查</h3><ul>
<li><p><code>toContain</code>：陣列是否含有目標值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect([<span class="string">'1'</span>, <span class="string">'2'</span>]).toContain(<span class="string">'1'</span>) <span class="comment">// passed</span></span><br><span class="line">expect([<span class="string">'1'</span>, <span class="string">'2'</span>]).toContain(<span class="string">'4'</span>) <span class="comment">// failed</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toContainEqual</code>： 陣列是否含有該值（類型為純值時檢驗是否相等，類型為物件時檢驗結構是否全等）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// passed</span></span><br><span class="line">expect([<span class="string">'1'</span>, <span class="string">'2'</span>]).toContainEqual(<span class="string">'1'</span>) <span class="comment">// passed</span></span><br><span class="line">expect([&#123; <span class="attr">val</span>: <span class="string">'1'</span> &#125;, &#123; <span class="attr">val</span>: <span class="string">'2'</span> &#125;]).toContainEqual(&#123; <span class="attr">val</span>: <span class="string">'1'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// failed</span></span><br><span class="line">expect([&#123; <span class="attr">val</span>: <span class="string">'1'</span>, <span class="attr">something</span>: <span class="string">'other'</span> &#125;]).toContainEqual(&#123; <span class="attr">val</span>: <span class="string">'1'</span> &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toHaveLength</code>：確認其屬性的長度是否相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(<span class="string">'12'</span>).toHaveLength(<span class="number">2</span>) <span class="comment">// passed</span></span><br><span class="line">expect([<span class="number">1</span>, <span class="number">2</span>]).toHaveLength(<span class="number">2</span>) <span class="comment">// passed</span></span><br><span class="line">expect(&#123; <span class="attr">length</span>: <span class="number">2</span> &#125;).toHaveLength(<span class="number">2</span>) <span class="comment">// passed</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h3 id="物件比對與檢查"><a href="#物件比對與檢查" class="headerlink" title="物件比對與檢查"></a>物件比對與檢查</h3><ul>
<li><p><code>toEqual</code>：比對物件結構是否相同，而非比對參照來源（reference），而結構中若值為 <code>undefined</code> 會忽略</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> A = &#123; <span class="attr">num</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">const</span> B = &#123; <span class="attr">num</span>: <span class="number">100</span>, <span class="attr">secret</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">expect(A).toEqual(B) <span class="comment">// passed</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toStrictEqual</code>：<br>與 <code>toEqual</code> 類似，但 <code>undefined</code> 不會被忽略。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> A = &#123; <span class="attr">num</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">const</span> B = &#123; <span class="attr">num</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">const</span> C = &#123; <span class="attr">num</span>: <span class="number">100</span>, <span class="attr">secret</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">expect(A).toStrictEqual(B) <span class="comment">// passed</span></span><br><span class="line">expect(A).toStrictEqual(C) <span class="comment">// failed</span></span><br></pre></td></tr></table></figure>
<p>甚至 Class 所創造的物件與物件實字（Object Literals）相比也視為不同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(num) &#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect(&#123;<span class="attr">num</span>: <span class="number">1</span>&#125;).toStrictEqual(&#123;<span class="attr">num</span>: <span class="number">1</span>&#125;) <span class="comment">// passed</span></span><br><span class="line">expect(<span class="keyword">new</span> MockClass(<span class="number">1</span>)).toStrictEqual(&#123;<span class="attr">num</span>: <span class="number">1</span>&#125;) <span class="comment">// failed</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toHaveProperty</code>：檢查物件含有屬性與其屬性值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">num</span>: <span class="number">100</span> &#125;</span><br><span class="line"></span><br><span class="line">expect(obj).toHaveProperty(<span class="string">'num'</span>) <span class="comment">// passed</span></span><br><span class="line">expect(obj).toHaveProperty(<span class="string">'num'</span>, <span class="number">100</span>) <span class="comment">// passed</span></span><br><span class="line">expect(obj).toHaveProperty(<span class="string">'num'</span>, <span class="number">200</span>) <span class="comment">// failed</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toMatchObject</code>： 檢查物件的子層</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">nested</span>: &#123; <span class="attr">num</span>: <span class="number">200</span> &#125;, <span class="attr">num</span>: <span class="number">100</span> &#125;</span><br><span class="line"></span><br><span class="line">expect(obj).toMatchObject(&#123; <span class="attr">num</span>: <span class="number">100</span> &#125;) <span class="comment">// passed</span></span><br><span class="line">expect(obj).toMatchObject(&#123; <span class="attr">num</span>: <span class="number">200</span> &#125;) <span class="comment">// failed</span></span><br><span class="line">expect(obj).toMatchObject(&#123; <span class="attr">nested</span>: &#123; <span class="attr">num</span>: <span class="number">100</span> &#125; &#125;) <span class="comment">// failed</span></span><br><span class="line">expect(obj).toMatchObject(&#123; <span class="attr">nested</span>: &#123; <span class="attr">num</span>: <span class="number">200</span> &#125; &#125;) <span class="comment">// passed</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>光是以上 Matcher 就已經夠眼花撩亂了，所以大家不仿先停下來慢慢練習，避免腦負荷過重 XD！<br>我們明天將繼續講解下列幾個比較特別的 Matcher，因為其中有些概念上與使用時機要特別注意的地方！</p>
<ul>
<li>監聽函式</li>
<li>快照</li>
<li>Error</li>
</ul>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】斷言（Assertion）下篇： 替身、快照（Snapshot）與拋出錯誤</title>
    <url>/testing/ithelp-2022-vitest-15/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>昨天有關斷言（Assertion）的部分我們已經瞭解到「斷言風格」（Assertion Style）在寫法上有非常大的差異，並且也從裡頭選擇介紹了 Jest 的斷言 <code>expect</code> 相關的 <code>Matcher</code>：</p>
<ul>
<li>常用：<code>toBe</code>, <code>not</code></li>
<li>純值比對（Primitive）類型: <code>String</code>, <code>Number</code>, <code>Boolean</code>…, etc.</li>
<li>陣列比對與檢查</li>
<li>物件比對與檢查</li>
</ul>
<p>而剩下還沒介紹到的 <code>Matcher</code> ，每個部分除了語法本身之外，都有一些值得一提的地方，因此特地拆成另一篇來介紹他們有哪些不同之處！</p>
<a id="more"></a>

<h2 id="再戰-Jest-expect-Matchers"><a href="#再戰-Jest-expect-Matchers" class="headerlink" title="再戰 Jest expect Matchers"></a>再戰 Jest expect Matchers</h2><ul>
<li>監聽函式</li>
<li>快照</li>
<li>Error</li>
</ul>
<h3 id="監聽函式"><a href="#監聽函式" class="headerlink" title="監聽函式"></a>監聽函式</h3><p>在測試的過程中，有時候我們不僅只是斷言受測物（SUT, System Under Test）的狀態，有時候可能會對受測目標的「依賴物」（DOC, Depended-on Component）狀態有興趣，而這時我們就無法單純以 Matchers 來斷言，因為我們需要監聽依賴物前後的變化。</p>
<p>而在程式測試領域中，測試替身（<code>test double</code>）主要就是負責處理這一類非受測物本身所做的事情，並且在需要時還能幫我們紀錄必要的資訊</p>
<p>假若我們今天測試案例受測物本身會去呼叫到的依賴目標是個「函式」時，這時我們可以透過 <code>Vitest</code> 所提供的 <code>vi.fn()</code> 來模仿（spy）函式。</p>
<p><code>vi.fn()</code> 本身會回傳一個實體（<code>CallableMockInstance</code>），在這個實體中會記錄著有關測試函式時會需要的資料與方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vi.fn())</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  called: false,</span></span><br><span class="line"><span class="comment">  callCount: 0,</span></span><br><span class="line"><span class="comment">  results: [],</span></span><br><span class="line"><span class="comment">  calls: [],</span></span><br><span class="line"><span class="comment">  impl: [Function (anonymous)],</span></span><br><span class="line"><span class="comment">  reset: [Function: i],</span></span><br><span class="line"><span class="comment">  nextError: [Function (anonymous)],</span></span><br><span class="line"><span class="comment">  nextResult: [Function (anonymous)],</span></span><br><span class="line"><span class="comment">  restore: [Function: w],</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>因此將受測的目標函式放入 <code>vi.fn</code> 中，後續只要測試過程中如果測試目標去調用了已被 Spy 過的函式時，<code>CallableMockInstance</code> 就會幫我們紀錄相關的資訊，接著我們就可以使用斷言語法相關的 Matcher 去比對我們預期的結果，比方說：</p>
<ul>
<li><p><code>toHaveBeenCalled</code>：斷言函式有被呼叫過</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHi = <span class="function">(<span class="params">something</span>) =&gt;</span> something</span><br><span class="line"><span class="keyword">const</span> spyOnSayHi = vi.fn(sayHi)</span><br><span class="line"></span><br><span class="line">spyOnSayHi()</span><br><span class="line">expect(spyOnSayHi).toHaveBeenCalled()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toHaveBeenCalledTimes</code>：斷言函式被呼叫過幾次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHi = <span class="function">(<span class="params">something</span>) =&gt;</span> something</span><br><span class="line"><span class="keyword">const</span> spyOnSayHi = vi.fn(sayHi)</span><br><span class="line"></span><br><span class="line">spyOnSayHi()</span><br><span class="line">spyOnSayHi()</span><br><span class="line">spyOnSayHi()</span><br><span class="line"></span><br><span class="line">expect(spyOnSayHi).toHaveBeenCalledTimes(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toHaveBeenCalledWith</code>：斷言函式被呼叫時所帶的參數</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHi = <span class="function">(<span class="params">something</span>) =&gt;</span> something</span><br><span class="line"><span class="keyword">const</span> spyOnSayHi = vi.fn(sayHi)</span><br><span class="line"></span><br><span class="line">spyOnSayHi(<span class="string">'Hello, Unit-Test!'</span>)</span><br><span class="line"></span><br><span class="line">expect(spyOnSayHi).toHaveBeenCalledWith(<span class="string">'Hello, Unit-Test!'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toHaveReturned</code>：斷言函式呼叫後應該至少要返回值一次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHi = <span class="function">(<span class="params">something</span>) =&gt;</span> something + <span class="string">' Hello, Spy!'</span></span><br><span class="line"><span class="keyword">const</span> spyOnSayHi = vi.fn(<span class="function">(<span class="params">val</span>) =&gt;</span> sayHi(val))</span><br><span class="line"></span><br><span class="line">spyOnSayHi(<span class="string">'Hello, Unit-Test!'</span>)</span><br><span class="line"></span><br><span class="line">expect(spyOnSayHi).toHaveReturned()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toHaveReturnedTimes</code>：斷言函式經過操作後應該要返回值幾次</p>
</li>
<li><p><code>toHaveLastReturnedWith</code>：斷言函式經過操作後最後應該要返回的值</p>
</li>
<li><p><code>toHaveNthReturnedWith</code>：斷言函式經過操作後第 N 次應該要返回的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHi = <span class="function">(<span class="params">something</span>) =&gt;</span> something</span><br><span class="line"><span class="keyword">const</span> spyOnSayHi = vi.fn(<span class="function">(<span class="params">val</span>) =&gt;</span> sayHi(val))</span><br><span class="line"></span><br><span class="line">spyOnSayHi(<span class="string">'Nice to meet you!'</span>)</span><br><span class="line">spyOnSayHi(<span class="string">'See you again!'</span>)</span><br><span class="line"></span><br><span class="line">expect(spyOnSayHi).toHaveReturnedTimes(<span class="number">2</span>)</span><br><span class="line">expect(spyOnSayHi).toHaveLastReturnedWith(<span class="string">'See you again!'</span>)</span><br><span class="line">expect(spyOnSayHi).toHaveNthReturnedWith(<span class="number">1</span>, <span class="string">'Nice to meet you!'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toHaveReturnedWith</code>：斷言函式呼叫後返回的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHi = <span class="function">(<span class="params">something</span>) =&gt;</span> something + <span class="string">' Hello, Spy!'</span></span><br><span class="line"><span class="keyword">const</span> spyOnSayHi = vi.fn(<span class="function">(<span class="params">val</span>) =&gt;</span> sayHi(val))</span><br><span class="line"></span><br><span class="line">spyOnSayHi(<span class="string">'Hello, Unit-Test!'</span>)</span><br><span class="line"></span><br><span class="line">expect(spyOnSayHi).toHaveReturnedWith(<span class="string">'Hello, Unit-Test! Hello, Spy!'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>而測試替身（test double）除了像是 <code>vi.fn()</code> 這類間諜類型（Spy）之外，還有許多不同的測試替身，它們在測試中都有各自的用途來協助我們更好的測試，後續將會有一篇專門來解說不同測試替身概念與相關的語法。</p>
<h3 id="快照測試（Snapshot-Testing）與快照-matchers"><a href="#快照測試（Snapshot-Testing）與快照-matchers" class="headerlink" title="快照測試（Snapshot Testing）與快照 matchers"></a>快照測試（Snapshot Testing）與快照 matchers</h3><p>在<a href="https://ithelp.ithome.com.tw/articles/10296174" target="_blank" rel="noopener">測試金字塔</a>一文中我們有提到，Edd Yerburgh 在規劃測試類型時除了單元測試外最多佔比的部分就是快照測試（Snapshot Testing），可見快照測試的重要性如此之高，那麼快照測試是什麼呢？</p>
<h4 id="Jest-Snapshot"><a href="#Jest-Snapshot" class="headerlink" title="Jest Snapshot"></a>Jest Snapshot</h4><p>在 Jest 的 <a href="https://jestjs.io/docs/snapshot-testing" target="_blank" rel="noopener">Snapshot Testing</a> 說明文件的定義中主要指的是用來防止 UI 出現尚未預期的變化：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">data-test</span>=<span class="string">"link"</span> <span class="attr">href</span>=<span class="string">"http://ithelp.ithome.com.tw"</span>&gt;</span> Ithelp  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line">it(<span class="string">'渲染連結'</span>, () =&gt; &#123;</span><br><span class="line">  const <span class="keyword">wrapper</span> = mount(component)</span><br><span class="line">  expect(<span class="keyword">wrapper</span>.find([data-test="link"]).toMatchSnapshot();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然而這邊的變化，並非你所想像的把視覺畫面給照相下來比對像素或比例的那種視覺回歸測試（Visual Regression Testing），而是藉由將目標元件透過渲染（Render）元件產生了一個 DOM 結構的文字，並在測試程式檔路徑底下的 <code>__snapshots__</code> 資料夾生成一個 <code>.snap</code> 檔案來做紀錄：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports[<span class="string">`渲染連結`</span>] = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;a</span></span><br><span class="line"><span class="string">    data-test="link"</span></span><br><span class="line"><span class="string">    href="http://ithelp.ithome.com.tw"</span></span><br><span class="line"><span class="string">&gt;</span></span><br><span class="line"><span class="string">    Ithelp</span></span><br><span class="line"><span class="string">&lt;/a&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>截至 Jest Snapshot 頁面中的[程式碼]<a href="https://jestjs.io/docs/snapshot-testing" target="_blank" rel="noopener">https://jestjs.io/docs/snapshot-testing</a>)</p>
</blockquote>
<p>在第二次執行測試的時候，就會再次做一次同樣的流程，而這次所產生的結果會與先前的 <code>.snap</code> 紀錄做比對。</p>
<p>假設比對上有落差就會拋出錯誤：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">- Snapshot - 1</span><br><span class="line">+ Received + 1</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag"><span class="attr">-</span>  <span class="attr">href</span>=<span class="string">"http://ithelp.ithome.com.tw"</span></span></span><br><span class="line"><span class="tag">+  <span class="attr">href</span>=<span class="string">"https://ithelp.ithome.com.tw"</span></span></span><br><span class="line"><span class="tag">&gt;</span> Ithelp</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>藉由這個比對機制從而實現「防止 UI 出現尚未預期的變化」的功能。</p>
<h4 id="Vitest-Snapshot"><a href="#Vitest-Snapshot" class="headerlink" title="Vitest Snapshot"></a>Vitest Snapshot</h4><p>而前面有提到 <code>Vitest</code> 本身兼容了 <code>Jest</code> 的斷言（assertion）語法，所以快照（Snapshot）的 matcher 自然也是不能放過。</p>
<p>在 <code>Vitest</code> 中主要兼容的 matcher 部分有：</p>
<ul>
<li><code>toMatchSnapshot</code></li>
<li><code>toMatchInlineSnapshot</code></li>
</ul>
<p>基本上概念與 Jest Snapshot 相似，都是在做結構快照這件事情，然而 <code>Vitest</code> 文件部分則是沒有特地強調 UI 的部分，而是關注在值（<code>value</code>）的比對。</p>
<p>因此我們單純放入一個陣列物件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'cat snapshot'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> target = [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Orange'</span>,</span><br><span class="line">      age: <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Blank'</span>,</span><br><span class="line">      age: <span class="number">6</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">  expect(target).toMatchSnapshot()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>.snap</code> 的結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports[<span class="string">`component &gt; cat snapshot 1`</span>] = <span class="string">`</span></span><br><span class="line"><span class="string">    [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          "age": 4,</span></span><br><span class="line"><span class="string">          "name": "Orange",</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          "age": 6,</span></span><br><span class="line"><span class="string">          "name": "Blank",</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
<p>甚至也可以引入 JSON 檔案來做快照：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Area <span class="keyword">from</span> <span class="string">'./area.json'</span></span><br><span class="line">it(<span class="string">'static json snapshot'</span>, () =&gt; &#123;</span><br><span class="line">expect(Area).toMatchSnapshot()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>當然元件快照也是能做的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line">it(<span class="string">'snapshot'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">    <span class="keyword">const</span> target = wrapper.find(<span class="string">'[data-test="content"]'</span>)</span><br><span class="line">    expect(target).toMatchSnapshot()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而以上快照部分如果你覺得要生成一個檔案來管理有點囉唆，那麼你可以透過 <code>toMatchInlineSnapshot</code> 來處理這類的需求，其差別在於生成的位置會是在 <code>toMatchInlineSnapshot()</code> 函式本身裡面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'cat snapshot'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> target = [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Orange'</span>,</span><br><span class="line">      age: <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'Blank'</span>,</span><br><span class="line">      age: <span class="number">6</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原先 toMatchInlineSnapshot 內沒有任何東西</span></span><br><span class="line">  <span class="comment">// 在執行測試後就會將快照內容自動生成在 toMatchInlineSnapshot 裡</span></span><br><span class="line">  expect(target).toMatchInlineSnapshot(<span class="string">`</span></span><br><span class="line"><span class="string">    [</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        "age": 4,</span></span><br><span class="line"><span class="string">        "name": "Orange",</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        "age": 6,</span></span><br><span class="line"><span class="string">        "name": "Blank",</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">  `</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後，如果遇到變更的部分是我們所預期的時候，此時就需要更新快照的部分，可以在執行測試的 <code>watch</code> 模式時按下 <code>u</code> 鍵，就將新的快照保存起來，或是透過新增 <code>npm scripts</code> 指令來執行命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test:update"</span>: <span class="string">"vitest -u"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>總結一下快照部分，若有需要預防未預期變更的靜態檔案如「JSON 檔」、「UI 元件」⋯⋯等，都可以透過快照來處理，如果不想特地開一個檔案來管理，可以透過 <code>toMatchInlineSnapshot</code> 來斷言。</p>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>最後想介紹到的則是錯誤類型的 Matcher：</p>
<ul>
<li><code>toThrowError</code></li>
<li><code>toThrowErrorMatchingSnapshot</code></li>
<li><code>toThrowErrorMatchingInlineSnapshot</code></li>
</ul>
<p>先前我們有提到測試案例預想的<a href="https://ithelp.ithome.com.tw/articles/10297571" target="_blank" rel="noopener">三個路徑</a>（Happy path, sad Path &amp; Bad Path），<code>Bad Path</code> 從產品角度上來說 End-User 使用上的錯誤，應該考慮從產品使用角度上去思考要怎麼協助他們去使用，所以不應該為了拋出錯誤而拋出。</p>
<p>但假設今天拋出錯誤的情境是較為合理的部分，比方是針對開發人員在開發時期誤用導致的錯誤⋯⋯等等情況，這時我們就可以透過這一類 Matcher 來處理。</p>
<p>而使用上要比較小心的是，受測目標若會拋出錯誤則要透過 wrap function 的形式來處理，否則拋出的錯誤會造成測試案例的斷言錯誤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">''</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> food = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span>(name === <span class="string">'小黃瓜'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'我不吃小黃瓜'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    expect(food(<span class="string">'小黃瓜'</span>)).toThrowError(<span class="string">'我不吃小黃瓜'</span>) <span class="comment">// 若這樣寫的話裡頭的 Error 會導致測試案例失敗</span></span><br><span class="line">    expect(<span class="function"><span class="params">()</span> =&gt;</span> food(<span class="string">'小黃瓜'</span>)).toThrowError(<span class="string">'我不吃小黃瓜'</span>) <span class="comment">// 需要透過這種方式才能正確斷言</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上包含昨天的部分，主要就是將來我們在撰寫測試案例中的斷言（Assert）時會用到的 Matcher 概念與使用方法，而由於 Matchers 真的有不少東西，所以還有些許部分沒介紹到，若有興趣查看的話可以到 Vitest expect API <a href="https://vitest.dev/api/#expect" target="_blank" rel="noopener">文件</a>中查閱。</p>
<p>而明天的部分我們將要來綜合這三天所習得的語法來個小小的測驗，畢竟學習最快的方式就是動手直接下去做哩！那麼我們明天見！祝大家週末愉快。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【試験ノ章】第一個測驗：測試情境案例、Setup &amp; Teardown 與 Matchers</title>
    <url>/testing/ithelp-2022-vitest-16/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>回顧目前語法章節的部分我們已經學了有關於：</p>
<ul>
<li>測試案例與情境：<code>describe</code>、<code>it</code></li>
<li>測試案例中 Setup 與 Teardown 環節有關的語法： <code>beforeEach</code>、<code>beforeAll</code>、<code>afterEach</code> 與 <code>beforeAll</code></li>
<li>測試斷言中的各種 <code>Matchers</code> 與快照</li>
</ul>
<p>而基於上述幾個語法加上先前的測試概念，我們已經滿足了撰寫基本單元測試的條件了！所以現在是⋯⋯測驗時間！！！</p>
<p>在測驗章節我們主要流程將會是：</p>
<ul>
<li>閱讀故事與題目，釐清需求與規則。</li>
<li>規劃測試情境與測試案例，並列好描述的部分。</li>
<li>撰寫測試程式碼（Testing Code），並執行測試時得到測試案例失敗。</li>
<li>按照題目要求完成產品程式碼（Production Code）</li>
<li>再次執行測試確保測試通過。</li>
</ul>
<p>而本文撰寫測試程式碼與產品程式碼的環節我也會提供 demo 的範例供參考與撰寫思路，那麼就讓我們開始吧！</p>
<a id="more"></a>

<h2 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h2><p>「柯基」在完成上次提到的<a href="https://ithelp.ithome.com.tw/articles/10299474" target="_blank" rel="noopener">任務</a>後，中午下樓到公司附近覓食時，遇到了一隻橘色虎斑貓「阿橘」，然而阿橘正面有難色地看著眼前的機台一直噴出好多貓食乾乾⋯⋯柯基決定上前瞭解狀況。</p>
<p>「你好我是柯基，怎麼這台機器一直噴出乾乾啊！？」柯基驚訝地看著眼前的機台。</p>
<p>「我是乾乾銀行的開發人員，眼前這台是『自動乾乾提存機』」阿橘嘆了口氣說「這台機器主要是供應平常貓貓們在日常被飼主餵太多乾乾，但又不想一次吃完的時候可以把乾乾存到這裡面來。」</p>
<p>「可是⋯⋯」阿橘話還沒說完，機器又噴出更多乾乾把阿橘埋起來了。「⋯⋯這台機器程式不知道為什麼一直有問題，所以我們打算重新來處理他。」</p>
<p>「當然，如果你協助我們的話就給你一年份的乾乾」阿橘邊說邊咬了一口嘴邊的乾乾，然後遞了一張規格書給柯基。柯基直接原地傻眼了幾秒後緩緩說道。</p>
<p>「那⋯⋯乾乾可以換成狗狗可食用的嗎？」</p>
<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p>自動乾乾提存機軟體控制主要是由一個 <code>FoodBank</code> 類別在負責處理，其中核心的功能主要有「開戶」、「存款」和「提款」：</p>
<p>而規格對上述程式功能介面上有一些限制要求：</p>
<ul>
<li>資料規格<ul>
<li>銀行紀錄格式為：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">safe: &#123;</span><br><span class="line">  name: &#123; </span><br><span class="line">        food: <span class="xml"><span class="tag">&lt;<span class="name">number</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><code>name</code>：開戶者名稱，預設資料類型為 <code>string</code>。</li>
<li><code>food</code>：「乾乾」單位，預設資料類型為 <code>number</code>。</li>
</ul>
</li>
<li>開戶<ul>
<li>需傳入 <code>name</code>，並檢查是否開過戶頭，若有開過戶頭則回應 <code>您已開過戶頭囉</code>。</li>
<li>交易成功，在 Safe 物件中建立用戶資料。</li>
<li>開戶完成後該方法要回應 <code>開戶完成</code>。</li>
</ul>
</li>
<li>存款<ul>
<li>需傳入 <code>name</code>，若查詢不到戶頭則交易失敗，該方法要回應 <code>查詢不到該用戶，請重新確認。</code></li>
<li>交易成功，將傳入 <code>food</code> 存入 Safe 物件中</li>
<li>交易完成後該方法要回應 <code>存款完成，戶頭目前餘額 {該用戶乾乾數量}</code></li>
</ul>
</li>
<li>提款<ul>
<li>需傳入 <code>name</code>，若查詢不到戶頭則交易失敗，該方法要回應 <code>查詢不到該用戶，請重新確認。</code></li>
<li>若傳入的 <code>food</code> 要求超過該用戶戶頭則交易失敗，該方法要回應 <code>餘額不足，你帳戶目前餘額為 {該用戶乾乾數量}</code></li>
<li>交易成功，從 Safe 物件中扣除該用戶的 <code>food</code></li>
<li>交易完成後該方法要回應 <code>提款完成，戶頭目前餘額 {該用戶乾乾數量}</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>看到這裡，若有想法的讀者可以先按照自己的方式來寫測試哩，若沒想法或遇到困難時也可以參考底下 demo 的部分。<br>本文可利用<a href="https://ithelp.ithome.com.tw/articles/10292537" target="_blank" rel="noopener">系列文專用專案</a>來一邊學習，幫你準備好測試所需要的環境，快來安裝吧！</p>
</blockquote>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><h2 id="撰寫測試脈絡"><a href="#撰寫測試脈絡" class="headerlink" title="撰寫測試脈絡"></a>撰寫測試脈絡</h2><p>依據之前測試脈絡章節提到的部分，規劃測試時要考量到有以下內容。</p>
<ul>
<li>決定測試類型工具：本系列文主要專注在 Vitest 的單元測試</li>
<li>決定測試情境與測試案例</li>
<li>思考測試案例路徑</li>
<li>撰寫測試案例 3A</li>
</ul>
<h3 id="決定情境與測試案例"><a href="#決定情境與測試案例" class="headerlink" title="決定情境與測試案例"></a>決定情境與測試案例</h3><blockquote>
<p>使用系列文專用檔案的讀者 demo 用的檔案位置如下：<br>測試程式碼 <code>/src/practice/practice-04.spec.js</code><br>產品程式碼 <code>/src/practice/practice-04.js</code></p>
</blockquote>
<p>首先建立好測試程式碼並準備好產品程式碼檔案與基本介面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; describe, it&#125; <span class="keyword">from</span> <span class="string">'vitest'</span></span><br><span class="line"><span class="keyword">import</span> &#123; FoodBank &#125; <span class="keyword">from</span> <span class="string">'./FoodBank.js'</span></span><br><span class="line"><span class="comment">// ....</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FoodBank</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.safe = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  openAccount(name)&#123;&#125;</span><br><span class="line">  deposit(name, food)&#123;&#125;</span><br><span class="line">  withdraw(name, food)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>與接下來開始撰寫測試碼情境，這邊主要依據 FoodBank 提供的方法來拆分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'openAccount()'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line">describe(<span class="string">'deposit()'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line">describe(<span class="string">'withdraw()'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>再來依據規格與設計思考要測試案例與案例路徑的部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'開戶'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// happy path</span></span><br><span class="line">  it(<span class="string">`開戶完成，Safe 物件中應有用戶資訊' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  it(<span class="string">`開戶完成，應該回應 '開戶完成' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  <span class="comment">// sad path</span></span><br><span class="line">  it(<span class="string">`若開過戶頭，應該回應 '您已開過戶頭囉。' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  <span class="comment">// ... 請自由發揮</span></span><br><span class="line">&#125;)</span><br><span class="line">describe(<span class="string">'存款'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// happy path</span></span><br><span class="line">  it(<span class="string">`存入 100 單位，Safe 物件中該用戶的乾乾應為 100 單位`</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  it(<span class="string">`交易完成，應該回應 '存款完成，戶頭目前餘額 &#123;該用戶乾乾數量&#125;' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  <span class="comment">// sad path</span></span><br><span class="line">  it(<span class="string">`若查詢不到戶頭，應該回應 '查詢不到該用戶，請重新確認。' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  <span class="comment">// ... 請自由發揮</span></span><br><span class="line">&#125;)</span><br><span class="line">describe(<span class="string">'提款'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// happy path</span></span><br><span class="line">  it(<span class="string">`提款 100 單位，Safe 物件中該用戶的乾乾應減少 100 單位`</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  it(<span class="string">`交易完成，應該回應 '存款完成，戶頭目前餘額 &#123;該用戶乾乾數量&#125;' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  <span class="comment">// sad path</span></span><br><span class="line">  it(<span class="string">`若查詢不到戶頭，應該回應 '查詢不到該用戶，請重新確認。' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  it(<span class="string">`餘額不足，應該回應 '餘額不足，你帳戶目前餘額為 &#123;該用戶乾乾數量&#125;' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  <span class="comment">// ... 請自由發揮</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接著撰寫測試案例 3A 部分。</p>
<p>開戶情境：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'開戶'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// happy path</span></span><br><span class="line">  it(<span class="string">`開戶完成，Safe 物件中應有用戶資訊' `</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    <span class="keyword">const</span> bank = <span class="keyword">new</span> FoodBank()</span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    bank.openAccount(<span class="string">'Orange'</span>)</span><br><span class="line">    <span class="comment">// Assertion</span></span><br><span class="line">    expect(bank.safe).toEqual(&#123; <span class="attr">Orange</span>: &#123; <span class="attr">food</span>: <span class="number">0</span> &#125; &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">`開戶完成，應該回應 '開戶完成。' `</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    <span class="keyword">const</span> bank = <span class="keyword">new</span> FoodBank()</span><br><span class="line">    <span class="comment">// Assertion</span></span><br><span class="line">    expect(bank.openAccount(<span class="string">'Orange'</span>)).toBe(<span class="string">'開戶完成。'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// sad path</span></span><br><span class="line">  it(<span class="string">`若開過戶頭，應該回應 '您已開過戶頭囉。' `</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    <span class="keyword">const</span> bank = <span class="keyword">new</span> FoodBank()</span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    bank.openAccount(<span class="string">'Orange'</span>)</span><br><span class="line">    <span class="comment">// Assertion</span></span><br><span class="line">    expect(bank.openAccount(<span class="string">'Orange'</span>)).toBe(<span class="string">'您已開過戶頭囉。'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ... 請自由發揮</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>存款情境：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'存款'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// happy path</span></span><br><span class="line">  it(<span class="string">`存入 100 單位，Safe 物件中該用戶的乾乾應為 100 單位`</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    <span class="keyword">const</span> bank = <span class="keyword">new</span> FoodBank()</span><br><span class="line">    <span class="keyword">const</span> user = <span class="string">'Orange'</span></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    bank.openAccount(user)</span><br><span class="line">    bank.deposit(user, <span class="number">100</span>)</span><br><span class="line">    <span class="comment">// Assertion</span></span><br><span class="line">    expect(bank.safe[user]).toEqual(&#123; <span class="attr">food</span>: <span class="number">100</span> &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">`交易完成，應該回應 '存款完成，戶頭目前餘額 &#123;該用戶乾乾數量&#125;' `</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    <span class="keyword">const</span> bank = <span class="keyword">new</span> FoodBank()</span><br><span class="line">    <span class="keyword">const</span> user = <span class="string">'Orange'</span></span><br><span class="line">    <span class="keyword">const</span> food = <span class="number">100</span></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    bank.openAccount(user)</span><br><span class="line">    <span class="comment">// Assertion</span></span><br><span class="line">    expect(bank.deposit(user, food)).toEqual(<span class="string">`存款完成，戶頭目前餘額 <span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// sad path</span></span><br><span class="line">  it(<span class="string">`若查詢不到戶頭，應該回應 '查詢不到該用戶，請重新確認。' `</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    <span class="keyword">const</span> bank = <span class="keyword">new</span> FoodBank()</span><br><span class="line">    <span class="keyword">const</span> user = <span class="string">'Orange'</span></span><br><span class="line">    <span class="keyword">const</span> food = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assertion</span></span><br><span class="line">    expect(bank.deposit(user, food)).toEqual(<span class="string">`查詢不到該用戶，請重新確認。`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ... 請自由發揮</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>提款部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'提款'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// happy path</span></span><br><span class="line">  it(<span class="string">`提款 100 單位，Safe 物件中該用戶的乾乾應減少 100 單位`</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> bank = <span class="keyword">new</span> FoodBank()</span><br><span class="line">    <span class="keyword">const</span> user = <span class="string">'Orange'</span></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    bank.openAccount(user)</span><br><span class="line">    bank.deposit(user, <span class="number">100</span>)</span><br><span class="line">    bank.withdraw(user, <span class="number">100</span>)</span><br><span class="line">    <span class="comment">// Assertion</span></span><br><span class="line">    expect(bank.safe[user]).toEqual(&#123; <span class="attr">food</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">`交易完成，應該回應 '存款完成，戶頭目前餘額 &#123;該用戶乾乾數量&#125;' `</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> bank = <span class="keyword">new</span> FoodBank()</span><br><span class="line">    <span class="keyword">const</span> user = <span class="string">'Orange'</span></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    bank.openAccount(user)</span><br><span class="line">    bank.deposit(user, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assertion</span></span><br><span class="line">    expect(bank.withdraw(user, <span class="number">100</span>)).toBe(<span class="string">'存款完成，戶頭目前餘額 0'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// sad path</span></span><br><span class="line">  it(<span class="string">`若查詢不到戶頭，應該回應 '查詢不到該用戶，請重新確認。' `</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> bank = <span class="keyword">new</span> FoodBank()</span><br><span class="line">    <span class="keyword">const</span> user = <span class="string">'Orange'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assertion</span></span><br><span class="line">    expect(bank.withdraw(user, <span class="number">100</span>)).toBe(<span class="string">'查詢不到該用戶，請重新確認。'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">`餘額不足，應該回應 '餘額不足，你帳戶目前餘額為 &#123;該用戶乾乾數量&#125;' `</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> bank = <span class="keyword">new</span> FoodBank()</span><br><span class="line">    <span class="keyword">const</span> user = <span class="string">'Orange'</span></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    bank.openAccount(user)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assertion</span></span><br><span class="line">    expect(bank.withdraw(user, <span class="number">100</span>)).toBe(<span class="string">'餘額不足，你帳戶目前餘額為 0'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ... 請自由發揮</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接著執行測試，確認測試案例應該是錯誤之後，接著利用 <code>only</code> 將測試案例鎖定在各個情境下，一邊開發產品程式碼，這樣就不會受到其他測試情境底下的案例錯誤干擾開發過程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe.only(<span class="string">'開戶'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 專注在這邊的開發</span></span><br><span class="line">&#125;)</span><br><span class="line">describe(<span class="string">'存款'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 先忽略這部分測試案例</span></span><br><span class="line">&#125;)</span><br><span class="line">describe(<span class="string">'提款'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 先忽略這部分測試案例</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後按著平常開發流程去補齊產品程式碼，完成一部分的情境就透過 <code>.only</code>, <code>.skip</code> 等輔助 API，來觀察測試結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FoodBank</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.safe = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  openAccount(name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.safe[name]) <span class="keyword">return</span> <span class="string">'您已開過戶頭囉。'</span></span><br><span class="line">    <span class="keyword">this</span>.safe[name] = &#123; <span class="attr">food</span>: <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`開戶完成。`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  deposit(name, food) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.safe[name]) <span class="keyword">return</span> <span class="string">'查詢不到該用戶，請重新確認。'</span></span><br><span class="line">    <span class="keyword">this</span>.safe[name].food += food</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`存款完成，戶頭目前餘額 <span class="subst">$&#123;<span class="keyword">this</span>.safe[name].food&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  withdraw(name, food) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.safe[name]) <span class="keyword">return</span> <span class="string">'查詢不到該用戶，請重新確認。'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.safe[name].food &gt;= food) &#123;</span><br><span class="line">      <span class="keyword">this</span>.safe[name].food -= food</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`存款完成，戶頭目前餘額 <span class="subst">$&#123;<span class="keyword">this</span>.safe[name].food&#125;</span>`</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`餘額不足，你帳戶目前餘額為 <span class="subst">$&#123;<span class="keyword">this</span>.safe[name].food&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時一邊開發的過程應該會看到錯誤的部分逐漸陸續通過，直到最後將所有 <code>.only</code>, <code>.skip</code> 等輔助 API 拔除後依然都是通過的情況，就能確保你的開發既符合測試，後續測試也將繼續保護你的產品程式碼！</p>
<p>而這個開發過程也就是所謂的「測試驅動開發（TDD, Test-driven development）」中的「紅燈開發（Red-Green-Refactor）」，很有趣吧！</p>
<p>後續進階章節將會補上有關於 「測試驅動開發（TDD, Test-driven development）」更為詳細的介紹，而明天我們將來繼續學習其餘語法的部分，讓我們能夠測試更多的東西！</p>
<blockquote>
<p>題外話：今天文章寫到最後時已經大概十一點多了，電腦突然一個卡死，差點嚇爆⋯⋯</p>
</blockquote>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【概念ノ章】測試工具： Vue Test Utils 與元件測試</title>
    <url>/testing/ithelp-2022-vitest-17/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>經過昨天的練習後，我們現在已經可以對一些透過預設匯出（default export）或具名匯出（named export）的函式、方法或類別等等邏輯進行單元測試了。</p>
<p>接著，若我們想進一步在專案中測試 Vue 元件的話，我們除了基於前面的概念與語法之外，還得依靠能夠幫助能夠解析 Vue 元件並與其模擬互動的工具：</p>
<ul>
<li>Vue Test Utils</li>
<li>Cypress</li>
<li>Vue Testing Library</li>
</ul>
<p>而本系列文將著重在介紹要怎麼透過 Vue Test Utils 來進行與 Vue 元件有關的「元件測試」，因此本文要來介紹一下 Vue Test Utils 與元件測試是在做什麼，又這又跟單元測試有什麼關係呢。</p>
<a id="more"></a>

<h2 id="Vue-Test-Utils"><a href="#Vue-Test-Utils" class="headerlink" title="Vue-Test-Utils"></a>Vue-Test-Utils</h2><p>首先區辨一下他與我們目前用到的測試工具的各自用處，才能更瞭解接下學的內容是由哪個工具負責的，將來有必要查閱資料時就能更清楚的區別他們。</p>
<p>Vue Test Utils 主要是作為提供測試 Vue 元件的相關工具集，讓我們能更輕易的模擬操作元件來進行測試，但本身並沒有運行測試環境（test runner）的功能，因此我們會需要藉由 Vitest 來作為測試環境以及相關的測試情境案例與斷言 Matcher；除此之外我們還需要用來在 Node 環境中模擬瀏覽器環境的 <code>jsdom</code> 來協助處理有關 DOM 上的操作，如此一來才能順利地使用 Vue Test Utils。</p>
<p>而版本的部分要特別注意到，由於 Vue Test Utils 為了相容 Vue 不同版本之間的 API 因此我們要安裝對應的版本未來才不會出錯：</p>
<ul>
<li>Vue 2：安裝 Vue Test Utils 1</li>
<li>Vue 3：安裝 Vue Test Utils 2</li>
</ul>
<p>確認版本沒問題後，模擬元件的部分交給 Vue Test Utils 基本上就沒問題了，但關於「元件測試」目標主要是要測試什麼東西呢？</p>
<h2 id="元件測試的目標"><a href="#元件測試的目標" class="headerlink" title="元件測試的目標"></a>元件測試的目標</h2><p>測試本質主要是在預期結果與實際是否相等，而在元件測試中作為受測物的元件，其本身主要是負責 UI 上的一切內容，因此我們測試目標在著重於它的「畫面」與「行為」上是否如我們所預期。</p>
<p>因此，在測試案例的操作過程中（也就是 3A 中的 Action 階段），我們主要是藉由操作對元件介面中的：</p>
<ul>
<li>data</li>
<li>props</li>
<li>slot</li>
<li>provide</li>
<li>directive</li>
<li>Event（瀏覽器中的互動行為）</li>
<li>API response（模擬回應）</li>
</ul>
<p>來判斷下列是否如我們所預期：</p>
<ul>
<li>DOM 渲染結果</li>
<li>emit 行為</li>
</ul>
<h2 id="好的元件測試"><a href="#好的元件測試" class="headerlink" title="好的元件測試"></a>好的元件測試</h2><p>當然，做到上面的事項基本上已經可以算是個元件測試了，若我們想讓元件測試寫得更好，除了先前在單元測試提過的一些概念之外，還有一些值得注意的事項：</p>
<p>首先，在撰寫元件測試時的角度，我們並沒有要當個全能全知的神，而是作為「使用者的角度」關注元件介面上來預期結果，所以在測試的過程中我們要「避免又寫了一次實作」。</p>
<p>另外，如果內部邏輯過於複雜時，我們則應該先抽取（extract）其邏輯，透過 composables 的寫法來引入，如此一來我們就能「專注於在元件本身的行為上」，另外也能「針對 composable 的邏輯單獨做測試」。</p>
<p>最後，若元件中有使用到 API 的部分，同樣的我們應該把它當作成是他提供給元件去使用，而元件主要是「接收回應」後就能自行處理後續的內容了，所以在測試上我們應該專注在 API 提供了什麼給元件，透過模擬資料的部分來達成先前提過的 FIRST 原則中的 Fast，最後斷言元件最終的行為是否如預期即可。</p>
<p>現在我們知道 Vue Test Utils 在做什麼了，也知道「元件測試」在做什麼了，但這跟單元測試又有什麼關係呢？</p>
<h2 id="元件測試與單元測試的關係"><a href="#元件測試與單元測試的關係" class="headerlink" title="元件測試與單元測試的關係"></a>元件測試與單元測試的關係</h2><p>在官方文件中測試章節有<a href="https://vuejs.org/guide/scaling-up/testing.html#component-testing" target="_blank" rel="noopener">提到</a>，元件測試（component testing）在顆粒度上其實是高於單元測試（unit testing）的，甚至可以被視為是整合測試（integration testing）的一種形式。</p>
<p>而坊間有不少文章習慣以單元測試來統稱這一類測試，最主要原因是單元測試的定義為「軟體設計」中最小單位的程式或行為，在 Vue 專案中，若以 Vue SFC 類型檔案（.vue）來看其實測試元件也算是最小單位沒錯。</p>
<p>所以從意義上來劃分單元測試與元件測試，某方面來說很容易出現歧異（甚至單元測試本身就已經有分為獨立型與社交型寫法了）。</p>
<p>然而為了接下來在本系列文中方便區分指的測試對象是哪部分，我將名稱含義分為：</p>
<ul>
<li>元件測試：針對 Vue 元件所進行的測試</li>
<li>單元測試：針對元件引入函式、類別等 utils、helper 與 composable 的測試。</li>
<li>工具本身：Pinia 測試、Vue Router 測試。</li>
</ul>
<p>而在弄清楚 Vue Test Utils 工具與元件測試的概念與目標之後，明天我們將來針對這一部分學習元件測試下有哪些重要的語法。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】元件測試：容器方法（Wrapper methods）－取得目標資訊</title>
    <url>/testing/ithelp-2022-vitest-20/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h2 id="容器方法（Wrapper-methods）"><a href="#容器方法（Wrapper-methods）" class="headerlink" title="容器方法（Wrapper methods）"></a>容器方法（Wrapper methods）</h2><p>元件經由容器（Wrapper）包裝後，我們就能在測試案例中透過容器方法（Wrapper methods）來測試各種跟元件有關的資訊，而昨天我們主要介紹到了要如何選定到特定的元素、元件，接著介紹了判斷目標物是否「存在(exists)」與是否「顯示（isVisible）」等相關方法。</p>
<p>今天我們主要來介紹其餘有關資訊的部分：</p>
<ul>
<li>取得屬性（attribute）</li>
<li>取得內容物（content）</li>
</ul>
<a id="more"></a>

<hr>
<h3 id="判斷屬性"><a href="#判斷屬性" class="headerlink" title="判斷屬性"></a>判斷屬性</h3><ul>
<li>attributes</li>
<li>classes</li>
</ul>
<h4 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h4><p>當你想要確認 <code>&lt;a&gt;</code> 中的 <code>href</code> 是否帶有指定的連結或是檢查 <code>&lt;img&gt;</code> 上的屬性時，這時就可以透過 <code>attributes</code> 取得屬性。</p>
<p>而 <code>attributes</code> 用法主要有兩種，直接使用時會獲取目標</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">data-test</span>=<span class="string">"link"</span> <span class="attr">href</span>=<span class="string">"https://ithelp.ithome.com.tw/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>ithelp<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wrapper.find(<span class="string">'[data-test="link"]'</span>).attributes() <span class="comment">// &#123; href: 'https://ithelp.ithome.com.tw/', 'target': '_blank' &#125;</span></span><br></pre></td></tr></table></figure>
<p>當想要直接取得特定屬性值時也可以直接將屬性名稱帶入參數中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wrapper.find(<span class="string">'a'</span>).attributes(<span class="string">'target'</span>) <span class="comment">// '_blank'</span></span><br></pre></td></tr></table></figure>
<h4 id="classes"><a href="#classes" class="headerlink" title="classes"></a>classes</h4><p>同樣的，若想要尋找 <code>class</code> 屬性的話可以透過 <code>classes</code> 語法取得資訊。你可能會直覺地想到 <code>class</code> 也是屬性的一種那應該用 <code>attributes(&#39;class&#39;)</code> 查詢。然而這兩者的差別最主要在於產出的結果會有所不同。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">data-test</span>=<span class="string">"wrap"</span> <span class="attr">class</span>=<span class="string">"container w-full h-full"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>若使用 <code>attributes(&#39;class&#39;)</code> 查詢結果將會是字串形式的資料，後續要處理比對上的問題會稍微麻煩一點：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wrapper.find(<span class="string">'[data-test="wrap"]'</span>).attributes(<span class="string">'class'</span>) <span class="comment">// "container w-full h-full"</span></span><br></pre></td></tr></table></figure>

<p>若是使用 <code>classes</code> 語法查詢的話將得到一個陣列的結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wrapper.find(<span class="string">'[data-test="wrap"]'</span>).classes() <span class="comment">// ["container", "w-full", "h-full"]</span></span><br></pre></td></tr></table></figure>

<p>此時就可以配合 <code>toContain</code> 等陣列的斷言 Matcher 快速處理測試案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(wrapper.find(<span class="string">'[data-test="wrap"]'</span>).classes()).toContain(<span class="string">'container'</span>)</span><br></pre></td></tr></table></figure>

<p>這對於測試樣式採用原子化設計的工具（Tailwind CSS、Windi CSS 等）有奇效，我們可以將視覺層的邏輯透過 <code>classes</code> 的結果斷言。</p>
<p>因為這類原子化設計工具往往依賴 <code>class</code> 屬性來做樣式上的調整與擴充，通常為了美觀與管理方便會順便在使用這類工具時加裝自動排序（sorting）<code>class</code> 屬性等擴充工具，因此 <code>class</code> 的順序將變成不穩定的狀態。</p>
<p>因此元素若從：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"content"</span> <span class="attr">class</span>=<span class="string">"A B C"</span>&gt;</span>content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>變成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>  <span class="attr">data-test</span>=<span class="string">"content"</span> <span class="attr">class</span>=<span class="string">"A C B"</span>&gt;</span>content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>對於快照測試等 Matcher (<code>toMatchSnapshot</code>, <code>toMatchInlineSnapshot</code>)來說將會顯示測試失敗：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(wrapper.find(<span class="string">'.content'</span>)).toMatchSnapshot()</span><br></pre></td></tr></table></figure>

<p>快照比對結果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-     class="A B C"</span><br><span class="line">+     class="A C B"</span><br></pre></td></tr></table></figure>

<p>而以陣列比對是否「包含」的方式，將不受影響。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">expect(<span class="keyword">wrapper</span>.find(<span class="string">'.content'</span>).classes()).toContain(<span class="string">'A'</span>)</span><br><span class="line">expect(<span class="keyword">wrapper</span>.find(<span class="string">'.content'</span>).classes()).toContain(<span class="string">'B'</span>)</span><br><span class="line">expect(<span class="keyword">wrapper</span>.find(<span class="string">'.content'</span>).classes()).toContain(<span class="string">'C'</span>)</span><br></pre></td></tr></table></figure>

<p>後續也可再依照不同情境的需要，擴展比對的寫法。</p>
<hr>
<h3 id="判斷內容物"><a href="#判斷內容物" class="headerlink" title="判斷內容物"></a>判斷內容物</h3><p>最後，有關資訊的部分則是取得目標的內容（content）：</p>
<ul>
<li>text</li>
<li>html</li>
</ul>
<h4 id="text"><a href="#text" class="headerlink" title="text"></a>text</h4><p><code>text</code> 主要是取得目標元素節點後代的所有文字：</p>
<p>RootComponent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-test</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">    Root</span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ChildComponent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>child<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>mount</code> 包裝元件時 <code>wrapper.find(&#39;[data-test=&quot;target&quot;]&#39;).text()</code> 的結果將會是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Rootchildchildchild</span><br></pre></td></tr></table></figure>

<p>使用 <code>shallowMount</code> 包裝元件時 <code>wrapper.find(&#39;[data-test=&quot;target&quot;]&#39;).text()</code> 的結果將會是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Root</span><br></pre></td></tr></table></figure>

<h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><p>與 <code>text</code> 類似，但 <code>html</code> 會將目標元素後代所有元素都記錄下來：</p>
<p>RootComponent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-test</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">    Root</span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ChildComponent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>child<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>使用 <code>mount</code> 包裝元件時 <code>wrapper.find(&#39;[data-test=&quot;target&quot;]&#39;).html()</code> 的結果將會是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Root</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>child<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>child<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>child<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>shallowMount</code> 包裝元件時 <code>wrapper.find(&#39;[data-test=&quot;target&quot;]&#39;).html()</code> 的結果將會是：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Root</span></span><br><span class="line"><span class="section">&lt;child-component-stub&gt;</span><span class="section">&lt;/child-component-stub&gt;</span></span><br><span class="line"><span class="section">&lt;child-component-stub&gt;</span><span class="section">&lt;/child-component-stub&gt;</span></span><br><span class="line"><span class="section">&lt;child-component-stub&gt;</span><span class="section">&lt;/child-component-stub&gt;</span></span><br></pre></td></tr></table></figure>

<p>因此在使用 <code>text</code> 與 <code>html</code> 來進行斷言時，要注意到「測試所需包含的範圍」以及「元件容器」應採用 <code>mount</code> 還是 <code>shallowMount</code> 等議題，才能讓測試更加強韌且不會讓後續開發無相關的內容時一直被測試攔住。</p>
<p>以上就是與取得元素、元件資訊相關的容器方法，明天我們將來看看有關模擬鍵盤與滑鼠操作的容器方法。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】元件測試：容器（Wrapper）</title>
    <url>/testing/ithelp-2022-vitest-18/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="容器-Wrapper"><a href="#容器-Wrapper" class="headerlink" title="容器(Wrapper)"></a>容器(Wrapper)</h1><h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p>當我們需要在測試案例中引入元件時，我們可以透過 Vue Test Utils 提供的方法 <code>mount</code> 來包裹 Vue 元件。而 <code>mount</code> 所返回的內容除了 Vue 實體之外，還包含了一些方法（Wrapper methods）可以讓我們操作元件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> component <span class="keyword">from</span> <span class="string">'@/component/BaseButton.vue'</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">'should emit clicked event after clicking button'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    wrapper.trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    <span class="keyword">export</span>(wrapper.emitted()).toHaveProperty(<span class="string">'clicked'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>假若我們希望在渲染元件的時候同時帶著預設參數與狀態時（如 <code>props</code>, <code>slots</code>⋯⋯等），就能夠透過 <code>mount</code> 方法的第二個參數傳入設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        content: <span class="string">'Hello, Props!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wrapper = mounted(component, options)</span><br><span class="line">expect(wrapper.text()).toBe(<span class="string">'Hello, Props!'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而關於方法（Wrapper methods）與選項（Wrapper options）的部分，會根據元件使用 <strong>Options API</strong> / <strong>Composition API</strong> / <strong><code>setup script</code> 語法糖</strong> 而有不同的用法與限制，因此使用方法與差異的部分將在後續測試各種元件上的章節時陸續會提到。</p>
</blockquote>
<h2 id="shallowMount"><a href="#shallowMount" class="headerlink" title="shallowMount"></a>shallowMount</h2><p>在正常的專案開發下，元件時常會嵌入了另一個元件：</p>
<p>RootComponent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ParentComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">ParentComponent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ParentComponent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">ChildComponent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">ChildComponent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">ChildComponent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ChildComponent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>baby<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>RootComponent 的元件測試：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> component <span class="keyword">from</span> <span class="string">'./RootComponent.vue'</span></span><br><span class="line">it(<span class="string">'should render corrent content'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">  expect(wrapper.html()).toBe(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;p&gt;baby&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;baby&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;baby&lt;/p&gt;</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但如此一來若我們在測試 RootComponent 元件的時候，就有可能因為底下的 ChildComponent 元件更改了內容導致 RootComponent 測試案例也跟著失敗：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>baby<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>若「有意」想要避免這種情況發生，此時就可以將 <code>mount</code> 替換掉，改使用 <code>shallowMount</code> 來作為容器使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> component <span class="keyword">from</span> <span class="string">'./RootComponent.vue'</span></span><br><span class="line">it(<span class="string">'should render corrent content'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = shallowMount(component)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>shallowMount</code> 與 <code>mount</code> 在使用上幾乎大同小異，而唯一有差別在於他會將原先內部有用到元件的部分以替換為一個模擬元件（stub component），並且命名改以烤肉串命名法（<code>Kebab case</code>）並且在最末端加上 <code>-stub</code> 供辨識：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ParentComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">ParentComponent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>經 <code>shallowMount</code> 渲染結果變成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent-component-stub</span>&gt;</span><span class="tag">&lt;/<span class="name">parent-component-stub</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如此一來在撰寫測試案例時，就可以關注在當下「父層元件」與「子層元件」的之間的內容，而不管「子層元件」底下所發生的事情：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> component <span class="keyword">from</span> <span class="string">'./RootComponent.vue'</span></span><br><span class="line">it(<span class="string">'should render corrent content'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = shallowMount(component)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  expect(wrapper.html()).toBe(<span class="string">`&lt;parent-component-stub&gt;&lt;/parent-component-stub&gt;`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>往後在撰寫測試時可依照必要的情境來決定要使用 <code>mount</code> 還是 <code>shallowMount</code> 作為容器，而明天我們要繼續來看用了這個容器後，裡頭有內建了哪些好用的方法來幫助我們撰寫元件測試。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】元件測試：模擬 Vue APIs（data, props）</title>
    <url>/testing/ithelp-2022-vitest-22/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="Vue-API"><a href="#Vue-API" class="headerlink" title="Vue API"></a>Vue API</h1><p>今天要開始介紹的部分是如何透過 Vue Test Utils 工具所提供的 API 來模擬元件的使用，接著我們就可以依照需求模擬出各種情境來測試我們的元件，而今天我們要介紹的部分主要有 <code>data</code> 與 <code>props</code>：</p>
<a id="more"></a>

<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>注意：在模擬 data 之前需要注意的是，在大部分的測試時我們通常不必特意去模擬 data，應該讓其與元件本身的私有方法（private method）自然互動即可，若會需要透過模擬 data 來操作元件則要觀察是否資料與元件本身耦合了，這種情況下可能造成元件本身無法高度重複利用。</p>
<blockquote>
<p><strong>私有方法（private method）</strong><br>封閉在元件、物件⋯⋯等等中的函式，在外部無法存取得到。<br>e.g.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add5</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">(<span class="params">x,y,</span>) =&gt;</span> x + y</span><br><span class="line">    <span class="keyword">return</span> add5(<span class="number">5</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>裡頭的 <code>add</code> 函式即為私有方法。</p>
</blockquote>
<p>若是真的有需要用到模擬 <code>data</code> 屬性時，首先要注意元件是用何種方式（options API /composition API 與 <code>&lt;script setup&gt;</code>）來使用 <code>data</code>，因為寫法上將會有所不同；且依照設定的時機還可分為「初始狀態」與「後續操作」。</p>
<h3 id="data（options-API）"><a href="#data（options-API）" class="headerlink" title="data（options API）"></a>data（options API）</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"target"</span>&gt;</span>&#123;&#123; content &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            content: <span class="string">''</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>data（option API）初始狀態模擬，可透過容器（wrapper）的第二個參數帶入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 測試程式碼 */</span></span><br><span class="line"><span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            content: <span class="string">'test'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">expect(wrapper.find(<span class="string">'[data-test="target"]'</span>).text()).toEqual(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure>

<p>若要模擬後續才設定 data（option API），則可以透過容器方法中的 <code>setData()</code> 設置，此外由於是非同步的方法，要記得 <code>async/await</code> 才能確保斷言正確：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'...'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wrapper.setData(&#123;</span><br><span class="line">        content: <span class="string">'test'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    expect(wrapper.find(<span class="string">'[data-test="target"]'</span>).text()).toEqual(<span class="string">'test'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="data（composition-API-lt-script-setup-gt-語法糖）"><a href="#data（composition-API-lt-script-setup-gt-語法糖）" class="headerlink" title="data（composition API, &lt;script setup&gt; 語法糖）"></a>data（composition API, <code>&lt;script setup&gt;</code> 語法糖）</h3><p>composition API：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    setup() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> content = ref(<span class="string">''</span>)</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">            content</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;script setup&gt;</code> 語法糖：</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span></span><br><span class="line"><span class="xml">import </span><span class="template-variable">&#123; ref &#125;</span><span class="xml"> from 'vue'</span></span><br><span class="line"><span class="xml">const content = ref('')</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>這一類透過 <code>setup()</code> 所處理的資料，若要模擬會遇到不少問題。</p>
<p>在容器方法中的第二個參數所提供的方式，原先是供應給 <code>options</code> API 中的 <code>data</code> 屬性所使用，所以我們必須改以注入的方式嵌入 <code>setup()</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 測試程式碼 */</span></span><br><span class="line"><span class="keyword">const</span> wrapper = monut(component, &#123;</span><br><span class="line">    setup()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            content:<span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但如此一來，元件中原先其他寫在 <code>setup()</code> 內的狀態等就必須一起模擬，還記得好的元件測試守則之一嗎？沒錯，就是不要重複實踐實作。</p>
<p>那比較好的方式之一就是透過容器方法中（wrapper）取得實體來設置變數，並且透過 <code>nextTick</code> 方法確保渲染結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'...'</span> , <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">/* 測試程式碼 */</span></span><br><span class="line">    <span class="keyword">const</span> wrapper = monut(component)</span><br><span class="line">    wrapper.vm.content = <span class="string">'text'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本1: 直接使用 vm 內的 $nextTick</span></span><br><span class="line">    <span class="keyword">await</span> wrapper.vm.$nextTick()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 版本2: import &#123; nextTick &#125; from 'vue' */</span></span><br><span class="line">     * <span class="keyword">await</span> nextTick()</span><br><span class="line">     *<span class="regexp">/</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    expect(wrapper.find('[data-test="target"]').text()).toEqual('test')</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>而關於私有方法或變數的模擬，或許將來 Vue Test Utils 開發團隊會對此有些改觀提供一些逃生艙的方法，不過目前比較一致的角度是盡量別對這一類的私有環境才有的變數與方法去做模擬，即時的相關討論可見於<a href="https://github.com/vuejs/test-utils/pulls?q=composition" target="_blank" rel="noopener">這裡</a>。而本系列文後續相關內容也基於此因素不再提供有關與私有環境要如何模擬，避免讀者搞混。</p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>在不模擬私有情境的前提之下，prop 相較起來單純多了，而關於測試 props 的部分主要有：</p>
<ul>
<li>模擬 props 傳入後，斷言「後續的狀態」。</li>
<li>斷言「是否傳入對的參數給子元件」。</li>
</ul>
<h3 id="模擬-props-傳入"><a href="#模擬-props-傳入" class="headerlink" title="模擬 props 傳入"></a>模擬 props 傳入</h3><p>要模擬 props 傳入的方法依照時機可分為「初始狀態」與「後續操作」：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"target"</span>&gt;</span>&#123;&#123; content &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>初始狀態同樣是藉由容器（Wrapper）中的第二個參數傳入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">''</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            content: <span class="string">'Hello'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    expect(wrapper.find(<span class="string">'[data-test="target"]'</span>).text()).toEqual(<span class="string">'Hello'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若想要後續才傳入 <code>props</code> 則可以透過容器方法 <code>setProps</code>模擬，並且一樣要小心非同步的問題，記得補上 <code>async</code> / <code>await</code> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'...'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            content: <span class="string">'Hello'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    expect(wrapper.find(<span class="string">'[data-test="target"]'</span>).text()).toEqual(<span class="string">'Hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.setProps(&#123; <span class="attr">content</span>: <span class="string">'Good bye'</span> &#125;)</span><br><span class="line">    expect(wrapper.find(<span class="string">'[data-test="target"]'</span>).text()).toEqual(<span class="string">'Good bye'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="斷言是否傳入對-props-參數給子元件"><a href="#斷言是否傳入對-props-參數給子元件" class="headerlink" title="斷言是否傳入對 props 參數給子元件"></a>斷言是否傳入對 props 參數給子元件</h3><p>既然有接收的一方，那就至少會有給予的一方。</p>
<p>在 props 驗證中的另一種方式就是驗證給予其他元件的參數是否正確：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">template</span>&gt;</span><br><span class="line">    &lt;BaseLightbox content<span class="string">"Hello"</span> enableMask=<span class="string">"true"</span> /&gt;</span><br><span class="line">&lt;/<span class="keyword">template</span>&gt;</span><br></pre></td></tr></table></figure>

<p>首先我們要做的是透過之前學的選擇器方法選到特定的元件，接著透過容器方法底下的 <code>props()</code> 來取的傳送資訊，接著就可以透過斷言 Matcher 來比對 props 給元件的資訊是否正確：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BaseLightbox &#125; <span class="keyword">from</span> <span class="string">'./BaseLightbox.vue'</span></span><br><span class="line">it(<span class="string">''</span>, async () =&gt; &#123;</span><br><span class="line">    const <span class="keyword">wrapper</span> = mount(component)</span><br><span class="line">    const target = <span class="keyword">wrapper</span>.<span class="keyword">get</span>(BaseLightbox)</span><br><span class="line">    </span><br><span class="line">    expect(target.props(content)).toEqual(<span class="string">'Hello'</span>)</span><br><span class="line">    expect(target.props(enableMask)).toEqual(<span class="keyword">true</span>)</span><br><span class="line">    expect(target.props()).toEqual(&#123;</span><br><span class="line">        content: <span class="string">'Hello'</span>,</span><br><span class="line">        enableMask: <span class="keyword">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<p>以上是今日有關於如何在測試案例中模擬元件 <code>data</code> 與 <code>props</code> 的介紹。</p>
<p><a href="https://ithelp.ithome.com.tw/articles/10302568" target="_blank" rel="noopener">如先前所提</a>，針對元件在進行測試時，我們所關注的點主要在於「元件溝通介面後續所造成的影響」，比方受測元件做為子層元件的角色時，接收到 <code>prop</code> 、 <code>slot</code> 或 <code>inject</code> 時，是否有「渲染（render）出正確的結果」、「回傳（emit event）預期的內容給父層」等等行為，因此後續寫這方面的測試案例時要多注意是否是因為邏輯設計上的關係，導致必須要用奇形怪狀的方式來寫測試。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】元件測試：容器方法（Wrapper methods）－模擬事件</title>
    <url>/testing/ithelp-2022-vitest-21/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="容器方法（Wrapper-methods）"><a href="#容器方法（Wrapper-methods）" class="headerlink" title="容器方法（Wrapper methods）"></a>容器方法（Wrapper methods）</h1><p>到目前為止容器方法的部分我們已經學到如何選擇目標與取得目標屬性等相關資料後，今天我們要著重學習如何模擬觸發 DOM 所發生的各種事件（Event），而常見的 DOM 事件有下列幾種：</p>
<ul>
<li>滑鼠事件：點擊（click）</li>
<li>鍵盤事件：按下某鍵（keydown）、鬆開某鍵（keyup）</li>
<li>表單事件：針對 <code>&lt;input&gt;</code> 輸入內容、<code>checkbox</code> 與 <code>radio</code> 勾選或 <code>&lt;select&gt;</code> 中的選擇內容。</li>
</ul>
<a id="more"></a>

<p>首先，語法方面除了表單事件之外，要模擬大部分的事件我們可以透過容器方法中的 <code>trigger</code> 方法即可觸發事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wrapper.trigger(event, options)</span><br></pre></td></tr></table></figure>

<p>用法是在第一個參數中傳入要觸發的 <code>DOM</code> 事件名稱（e.g. <code>click</code>, <code>drag</code>），如果有需要補充觸發事件的條件，比方像是按下哪個鍵盤，就可以透過第二個參數帶入資訊（e.g. <code>{ keyCode: 65 }</code>）。</p>
<p>而要注意到的是由於這些事件基本上都會是非同步的用法，所以在撰寫測試案例時可以使用 <code>async/await</code> 來讓斷言（Assertion）保持正確的結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'...'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    <span class="keyword">await</span> wrapper.trigger(event, options)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    expect(<span class="comment">/* ... */</span>).toBe(<span class="comment">/* ... */</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>有了這個概念之後，接下來便可以快速來看看實際上各個事件觸發的實際案例與事件名稱，並且著重關注要特別注意的地方。</p>
<hr>
<h2 id="滑鼠事件"><a href="#滑鼠事件" class="headerlink" title="滑鼠事件"></a>滑鼠事件</h2><ul>
<li>點擊： <code>click</code></li>
<li>雙擊： <code>dblclick</code></li>
<li>指定點擊： <code>click.left</code>, <code>click.middle</code>, <code>click.right</code></li>
</ul>
<h3 id="點擊與雙擊"><a href="#點擊與雙擊" class="headerlink" title="點擊與雙擊"></a>點擊與雙擊</h3><p>點擊與雙擊的部分最主要需要注意的部分是，以事件來說的概念「雙擊（dblclick）」是一個事件，並非「兩個」「點擊（click）」事件：</p>
<p>元件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"content"</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"count++"</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>測試程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'after click button should display correct content'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="content"]'</span>).text()).toBe(<span class="string">'1'</span>)</span><br><span class="line">  <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="content"]'</span>).text()).toBe(<span class="string">'2'</span>)</span><br><span class="line">  <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button"]'</span>).trigger(<span class="string">'dblclick'</span>) <span class="comment">// 觸發不到 @click 事件</span></span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="content"]'</span>).text()).toBe(<span class="string">'4'</span>) <span class="comment">// AssertionError</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="指定按鍵點擊"><a href="#指定按鍵點擊" class="headerlink" title="指定按鍵點擊"></a>指定按鍵點擊</h3><p>有時候你可以會想要指定滑鼠的按鍵來觸發事件，這時就可以使用類似修飾符（modifier）一樣的方式來觸發事件：</p>
<ul>
<li><code>click.left</code></li>
<li><code>click.middle</code></li>
<li><code>click.right</code></li>
</ul>
<p>元件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> result = ref(<span class="string">''</span>)</span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">scirpt</span>&gt;</span></span></span></span><br><span class="line"></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button"</span> @<span class="attr">click.right</span>=<span class="string">"result = 'here we go!'"</span>&gt;</span>Are You ready?<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"target"</span>&gt;</span></span><span class="template-variable">&#123;&#123; result &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure>

<p>測試程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should be display correct text'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">  <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button"]'</span>).trigger(<span class="string">'click.right'</span>)</span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="target"]'</span>).text()).toBe(<span class="string">'here we go!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>除此之外，鍵盤與滑鼠的操作也可以融合再一起：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">trigger(<span class="string">'click.ctrl.left'</span>) <span class="comment">// 左鍵點擊時同時按著 ctrl 鍵</span></span><br><span class="line">trigger(<span class="string">'click.alt.right'</span>) <span class="comment">// 右鍵點擊時同時按著 alt 鍵</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="鍵盤事件"><a href="#鍵盤事件" class="headerlink" title="鍵盤事件"></a>鍵盤事件</h2><p>鍵盤最常見的核心事件主要為：</p>
<ul>
<li>按下某個按鈕 <code>keydown</code></li>
<li>鬆開某個按鈕 <code>keyup</code></li>
</ul>
<p>上述事件如同指定滑鼠按鍵的寫法，一樣擁有修飾符的相關語法，而後方帶的修飾符主要為按鍵的名稱：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">trigger(<span class="string">'keydown.enter'</span>) <span class="comment">// 按下 enter 鍵</span></span><br><span class="line">trigger(<span class="string">'keyup.up'</span>) <span class="comment">// 鬆開 上方向鍵</span></span><br></pre></td></tr></table></figure>

<p>同樣地，鍵盤事件也支援多重的組合修飾符寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">trigger(<span class="string">'keydown.ctrl.tab'</span>) <span class="comment">// 按下 ctrl 鍵 + tab 鍵</span></span><br></pre></td></tr></table></figure>

<p>若你想要更靈活的使用鍵盤事件，也可以用 <code>trigger</code> 方法的第二個參數帶入鍵盤的名稱，而目前有支援的寫法主要有下列三種：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">trigger(<span class="string">'事件名稱'</span>, &#123;</span><br><span class="line">    code?: event.code;</span><br><span class="line">    key?: event.key;</span><br><span class="line">    keyCode?: event.keycode;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若不清楚鍵盤對應的代號也沒有關係，有不少網站專門提供類似的服務供查詢，比方像這個 <a href="https://www.toptal.com/developers/keycode/for/enter" target="_blank" rel="noopener">網站</a> 只要按下任一按鍵就會即時顯示鍵盤對應的代號、名稱等等相關資訊：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221006/20119062C3G2LJAWCj.png" alt="https://ithelp.ithome.com.tw/upload/images/20221006/20119062C3G2LJAWCj.png"></p>
<p>在查到代號後我們就可以將其帶入剛才的方法中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">trigger(<span class="string">'keydown'</span>, &#123; <span class="attr">keyCode</span>: <span class="number">13</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>至於要選擇哪種寫法就看場景本身的需求來做決定囉！</p>
<hr>
<h2 id="表單事件"><a href="#表單事件" class="headerlink" title="表單事件"></a>表單事件</h2><ul>
<li>input 輸入</li>
<li><code>checkbox</code> / <code>radio</code> 勾選</li>
<li><code>&lt;select&gt;</code> 中的選擇內容</li>
</ul>
<blockquote>
<p>原先為了針對不同表單類型，Vue Test Utils 1 版（for Vue2）工具提供了一個專屬的 <code>setChecked</code> 的來對應 <code>checkbox</code> / <code>radio</code> 勾選狀態（checked）；除此之外替 <code>&lt;select&gt;</code> 元素的選擇提供了 <code>setSelected</code> 方法來模擬選擇行為。</p>
</blockquote>
<p>而在 Vue Test utils 2 版時，我們將只要統一使用 <code>setValue</code> 即可自動對應所有表單的行為！</p>
<h3 id="模擬-input-輸入"><a href="#模擬-input-輸入" class="headerlink" title="模擬 input 輸入"></a>模擬 input 輸入</h3><p>輸入表單或是操作日期選擇器：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"textResult"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">data-test</span>=<span class="string">"text"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"result_text"</span>&gt;</span>&#123;&#123;textResult&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"dateResult"</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">data-test</span>=<span class="string">"date"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"result_date"</span>&gt;</span>&#123;&#123;dateResult&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>文字輸入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'模擬 input 輸入'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find([data-test=<span class="string">"text"</span>]).setValue(<span class="string">'Hello, World!'</span>)</span><br><span class="line">    expect(wrapper.find([data-test=<span class="string">"result_text"</span>]).text()).toBe(<span class="string">'Hello, World!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>選擇日期：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'模擬 日期 輸入'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find([data-test=<span class="string">"date"</span>]).setValue(<span class="string">'2022/10/06'</span>)</span><br><span class="line">    expect(wrapper.find([data-test=<span class="string">"result_date"</span>]).text()).toBe(<span class="string">'2022/10/06'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="模擬-radio-勾選"><a href="#模擬-radio-勾選" class="headerlink" title="模擬 radio 勾選"></a>模擬 <code>radio</code> 勾選</h3><p>元件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"radio_1"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"radioResult"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"radio_2"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"radioResult"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"result"</span>&gt;</span>&#123;&#123; radioResult &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>測試程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'模擬 radio 勾選行為'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">  <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="radio_1"]'</span>).setValue(<span class="literal">true</span>)</span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="result"]'</span>).text()).toEqual(<span class="string">'1'</span>)</span><br><span class="line">  <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="radio_2"]'</span>).setValue(<span class="literal">true</span>)</span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="result"]'</span>).text()).toEqual(<span class="string">'2'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="模擬-checkbox-勾選"><a href="#模擬-checkbox-勾選" class="headerlink" title="模擬 checkbox 勾選"></a>模擬 <code>checkbox</code> 勾選</h3><p>元件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"checkbox_1"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checkboxResult"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"checkbox_2"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checkboxResult"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"result"</span>&gt;</span>&#123;&#123; checkboxResult.join(',') &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>測試程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'模擬 checkbox 勾選行為'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">  <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="checkbox_1"]'</span>).setValue(<span class="literal">true</span>)</span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="result"]'</span>).text()).toBe(<span class="string">'1'</span>)</span><br><span class="line">  <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="checkbox_2"]'</span>).setValue(<span class="literal">true</span>)</span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="result"]'</span>).text()).toEqual(<span class="string">'1,2'</span>)</span><br><span class="line">  <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="checkbox_1"]'</span>).setValue(<span class="literal">false</span>)</span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="result"]'</span>).text()).toEqual(<span class="string">'2'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="模擬-select-選擇"><a href="#模擬-select-選擇" class="headerlink" title="模擬 select 選擇"></a>模擬 select 選擇</h3><p>元件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">data-test</span>=<span class="string">"target"</span> <span class="attr">v-model</span>=<span class="string">"result"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"black"</span>&gt;</span>Black<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"result"</span>&gt;</span>&#123;&#123; result &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>測試程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'模擬 select 選擇'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">  <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="target"]'</span>).setValue(<span class="string">'orange'</span>)</span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="result"]'</span>).text()).toEqual(<span class="string">'orange'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<p>今天所介紹的模擬事件中，表單事件是筆者個人最喜歡的部分，因為表單若透過手動測試必須要準備大量的測試資料以及繁複的來回測試，萬一測到有問題等到修復好之後又得再重新來過一次，因此若能把這部分轉為自動化測試將能夠感受到非常多的好處。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】元件測試：容器方法（Wrapper methods）－選擇器與陷阱</title>
    <url>/testing/ithelp-2022-vitest-19/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="容器方法（Wrapper-methods）"><a href="#容器方法（Wrapper-methods）" class="headerlink" title="容器方法（Wrapper methods）"></a>容器方法（Wrapper methods）</h1><p>在進行測試時，前面章節有提到我們會使用 <code>mount</code> 或 <code>shallowMount</code> 來包裹元件，從而得到一個 <code>VueWrapper</code>，而在這個 <code>VueWrapper</code> 裡頭有許多實用的容器方法（Wrapper methods），雖然官方文件中並沒有特意分類，但大意上可分為幾種方法：</p>
<ul>
<li>查詢、選擇指定的元素、元件等選擇器</li>
<li>取得目標屬性或內容（class, attribute）</li>
<li>觸發 DOM 事件（如滑鼠點擊、鍵盤輸入與按鍵⋯⋯等）</li>
<li>取得 emit 事件、設置 data 或 prop、甚至觸發元件 <code>unmmount</code> 等 Vue API 相關的方法</li>
</ul>
<p>而今天要著重在於介紹選擇器的方法使用與測試應用，最後補上相關的討論：</p>
<ul>
<li>元素、元件選擇器</li>
<li>判斷目標是否存在：<code>exists</code> 與 <code>isVisible</code></li>
<li>使用 <code>data-*</code> attribute</li>
</ul>
<a id="more"></a>

<h2 id="選擇器"><a href="#選擇器" class="headerlink" title="選擇器"></a>選擇器</h2><p>在進行元件測試（component testing）的過程中，有時我們可能只想關注在某個特定 DOM 或元件的相關資訊時，這時我們就可以透過容器中的選擇器方法來尋找，而選擇器根據選取對象的不同，主要分為：</p>
<ul>
<li>元素（element）選擇器</li>
<li>元件（component）選擇器</li>
</ul>
<h3 id="元素選擇器"><a href="#元素選擇器" class="headerlink" title="元素選擇器"></a>元素選擇器</h3><p>元素選擇器語法基本上有兩種寫法，一種是基於元素的 <code>refs</code>，另一種則是 <code>querySelector</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">"dogcat"</span>&gt;</span>???<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"dog"</span>&gt;</span>科基<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"cat"</span>&gt;</span>橘貓<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"cat"</span>&gt;</span>黑黑<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ref */</span></span><br><span class="line">wrapper.find(&#123; <span class="attr">ref</span>: <span class="string">'span'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* querySelector */</span></span><br><span class="line">wrapper.find(<span class="string">'#dog'</span>)</span><br><span class="line">wrapper.find(<span class="string">'.cat'</span>)</span><br></pre></td></tr></table></figure>

<p>而容器方法有關選取元素的選擇器一共分為三種：</p>
<ul>
<li>find</li>
<li>findAll</li>
<li>get</li>
</ul>
<p>這三種選擇器在選取到目標後主要都是返回 <code>DOMWrapper</code>，此時我們就可以在串連其他容器方法（Wrapper methods）如 <code>classes</code> 或 <code>text</code> 等等來取得屬性或內容資訊，只是返回的結果內容會有些差異。</p>
<p>比方 <code>find</code>、<code>findAll</code> 的部分主要差別在於 <code>findAll</code> 返回的內容會被放置於陣列當中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"dog"</span>&gt;</span>科基<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"cat"</span>&gt;</span>橘貓<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"cat"</span>&gt;</span>黑黑<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而我們可以透過像這樣的方式取得陣列內的資訊：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should be display correct content'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">    <span class="keyword">const</span> target= wrapper.find(<span class="string">'#dog'</span>) <span class="comment">// &lt;DOMWrapper&gt; </span></span><br><span class="line">    expect(target.text()).toBe(<span class="string">'科基'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">'should be display correct content'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">    <span class="keyword">const</span> target= wrapper.findAll(<span class="string">'.cat'</span>) <span class="comment">// &lt;DOMWrapper&gt;[]</span></span><br><span class="line"></span><br><span class="line">    expect(target[<span class="number">0</span>].text()).toBe(<span class="string">'橘貓'</span>)</span><br><span class="line">    expect(target[<span class="number">1</span>].text()).toBe(<span class="string">'黑黑'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：透過 <code>findAll</code> 斷言時是「有序」的，很容易受到順序改變而導致測試案例失敗，除非撰寫測試案例目標之一就是要確保順序不會調動，否則改用 <code>find</code> 斷言會比較不容易受影響。</p>
</blockquote>
<p>而 <code>find</code> 與 <code>get</code> 的差別在於 <code>find</code> 找不到目標時返回的是 <code>{}</code> 後續若仍繼續操作、斷言時才會由拋出錯誤（由 <code>ErrorWrapper</code> 提供）；然而 <code>get</code> 一開始若找不到目標時就直接拋出錯誤（throw <code>Error</code>）了。</p>
<p>根據 <code>ErrorWrapper</code> <a href="https://github.com/vuejs/test-utils/blob/f61b8aeb84352b29e29666326939531cd81c3bd6/src/errorWrapper.ts" target="_blank" rel="noopener">原始碼</a>，可以看見他主要是針對容器方法中的 <code>exists()</code> 會返回 <code>false</code>。</p>
<p>因此在針對找不到元素的測試案例合法的寫法可以這麼做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(<span class="function"><span class="params">()</span> =&gt;</span> wrapper.get(<span class="string">'.something-that-does-not-exist'</span>)).toThrowError()</span><br><span class="line">expect(wrapper.find(<span class="string">'.something-that-does-not-exist'</span>).exists()).toBeFalsy()</span><br></pre></td></tr></table></figure>

<h4 id="find-判斷元素陷阱"><a href="#find-判斷元素陷阱" class="headerlink" title="find 判斷元素陷阱"></a>find 判斷元素陷阱</h4><p>魔鬼藏在細節裡，或許你可能會想說為什麼不直接用 <code>find</code> 還要再另外透過 <code>exists</code> 判斷呢，讓我們看看一個案例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>無關緊要的東西<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果這時你這麼寫了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">expect(wrapper.find(<span class="string">'.something-that-does-not-exist'</span>)).toBeTruthy()</span><br><span class="line"><span class="comment">// 通過 ！？</span></span><br></pre></td></tr></table></figure>

<p>原因在於 <code>find</code> 在找不到的情況下目標的情況所返回的值會是 <code>ErrorWrapper</code> 物件，所以透過 <code>toBeTruthy</code> 斷言就會通過。</p>
<blockquote>
<p>而為了避免這種情況發生，官方文件其實只有<a href="https://test-utils.vuejs.org/api/#get" target="_blank" rel="noopener">輕描淡述</a>地說道：</p>
<blockquote>
<p><strong>As a rule of thumb</strong>, always use <code>get</code> except when you are asserting something doesn’t exist. In that case use <code>find</code>.</p>
</blockquote>
<p>但上方經驗考量在哪，只有在追了他們相關的 issue 才會逐漸明白考量的根據，而關於這部分，甚至開發團隊未來可能也會考慮將 <code>find</code> 方法給<a href="https://github.com/vuejs/test-utils/issues/138" target="_blank" rel="noopener">拔掉</a>，剩下 <code>exists</code> 本身，但礙於這會是個 breaking change 的做法，所以在 <code>vue-test-utils</code> 跳大版本號之前應該都會暫時維持原樣。 </p>
</blockquote>
<hr>
<h3 id="元件（component）選擇器"><a href="#元件（component）選擇器" class="headerlink" title="元件（component）選擇器"></a>元件（component）選擇器</h3><ul>
<li>findComponent</li>
<li>findAllfindComponents (注意有個 s）</li>
<li>getComponent</li>
</ul>
<p>原則上使用方式與元素選擇器差不多，只是選取語法上除了 <code>refs</code> 與 <code>querySelector</code> 語法之外，還多了：</p>
<ul>
<li>Component name： <code>findComponent({name: &#39;元件名稱&#39;})</code></li>
<li>將 import SFC 直接放入方法中： <code>findComponent(Component)</code></li>
</ul>
<p>但由於使用 <code>querySelector</code> 上也有一些<a href="https://test-utils.vuejs.org/api/#findcomponent" target="_blank" rel="noopener">小陷阱</a>（怎麼又是陷阱？），所以個人建議以 SFC 方式引入或是乾脆透過 <code>shallowMount</code> 將子層元件 stub 掉也是一種方式。</p>
<hr>
<h2 id="判斷目標存在"><a href="#判斷目標存在" class="headerlink" title="判斷目標存在"></a>判斷目標存在</h2><p>經由剛剛陷阱的部分大家應該都很清楚 <code>exists()</code> 的存在了，而判斷選取目標其實他還有個好朋友就是 <code>isVisible()</code>，但他們判斷存在的定義上有一些差別：</p>
<p><code>exists()</code> 主要判斷的是該目標存不存在 DOM 上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(exist, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(Component)</span><br><span class="line">    expect(wrapper.find(<span class="string">'p'</span>).exists()).toBe(<span class="literal">true</span>)</span><br><span class="line">    expect(wrapper.find(<span class="string">'span'</span>).exists()).toBe(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>isVisable()</code> 主要判斷的是該目標存在 DOM 上之外，視覺上有無顯示在畫面中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"false"</span> <span class="attr">class</span>=<span class="string">"dog"</span>&gt;</span>科基<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"orange-cat"</span>&gt;</span>橘貓<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"false"</span> <span class="attr">class</span>=<span class="string">"black-cat"</span>&gt;</span>黑黑<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'v-if false'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">  expect(wrapper.find(<span class="string">'.dog'</span>).isVisible()).toBeFalsy() <span class="comment">// Error： 直接噴錯</span></span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">'v-show true'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">  expect(wrapper.find(<span class="string">'.orange-cat'</span>).isVisible()).toBeTruthy() <span class="comment">// 測試通過</span></span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">'v-show false'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">  expect(wrapper.find(<span class="string">'.black-cat'</span>).isVisible()).toBeFalsy() <span class="comment">// 測試通過</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>關於 <code>isVibile</code> 更為詳細的判斷如下：</p>
<ul>
<li>CSS style 中 含有 display: none =&gt; <code>false</code></li>
<li>CSS style 中 含有 visibility: hidden =&gt; <code>false</code></li>
<li>CSS style 中 含有 opacity :0 =&gt; <code>false</code></li>
<li><detail> 元素中 hidden 屬性為 <code>true</code> =&gt; <code>false</code></li>
</ul>
<p>綜合結論上方陷阱與判斷方法：</p>
<ul>
<li>若要判斷元素是否存在 或 <code>v-if</code>：使用 <code>get</code> 方法是最保險的，真的要用 <code>find</code> 則一定要搭配 <code>exists</code></li>
<li>若要判斷 <code>v-show</code>：使用 <code>find().isVisible()</code></li>
</ul>
<h2 id="使用-data-attribute"><a href="#使用-data-attribute" class="headerlink" title="使用 data-* attribute"></a>使用 <code>data-*</code> attribute</h2><p>在撰寫測試情境時，若依照上面的 <code>querySelector</code> 選了元素、id 或 class 時，初期一定會很開心，因為不會遇到太多困難，但往後在開發的過程執行測試時就很容易有機會遇到各種問題。</p>
<p>原先：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>改成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"content"</span> <span class="attr">data-test</span>=<span class="string">"content"</span>&gt;</span>content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>data-*</code> 作為選擇目標好處最主要在於顯著標記測試內容，而這影響到的範圍有：</p>
<ul>
<li>開發期，過程不用擔心會影響到測試，如上方所見，我只要變更 <code>data-test</code> 以外的內容，預期應該不會影響到測試選擇的目標，使測試案例錯誤能更專注在斷言的目標上，而非選擇目標被替換導致的錯誤。</li>
<li>重構（refactor）過程，能清楚比較範圍，若將來調整結構，只要將屬性轉移到對應的位置即可。</li>
<li>生產期，能夠針對特定的屬性移除，避免留下各種測試痕跡，對於像是輔助閱讀裝置等技術來說就不會被影響到。</li>
</ul>
<h3 id="在生產環境刪除-data-attribute"><a href="#在生產環境刪除-data-attribute" class="headerlink" title="在生產環境刪除 data-* attribute"></a>在生產環境刪除 <code>data-*</code> attribute</h3><p>若想在 <code>vitest</code> 中移除 <code>data-*</code> 也非常的簡單，我們只需要在 <code>vite.config.js</code> 設定中，針對 Vue 底下的編譯選項做一些調整即可（底下示範的版本為移除 <code>data-test</code>，若使用其他命名請自行調整囉）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isProd = process.env.NODE_ENV === <span class="string">'production'</span></span><br><span class="line"><span class="keyword">const</span> removeDataTestAttrs = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> NodeTypes = <span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">    ELEMENT: <span class="number">1</span>,</span><br><span class="line">    ATTRIBUTE: <span class="number">6</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (node.type === NodeTypes[<span class="string">'ELEMENT'</span>]) &#123;</span><br><span class="line">    node.props = node.props.filter(<span class="function">(<span class="params">prop</span>) =&gt;</span> (prop.type === NodeTypes[<span class="string">'ATTRIBUTE'</span>] ? prop.name !== <span class="string">'data-test'</span> : <span class="literal">true</span>)) <span class="comment">// 請自行替換命名 data-test </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      vue(&#123;</span><br><span class="line">        template: &#123;</span><br><span class="line">          compilerOptions: &#123;</span><br><span class="line">            nodeTransforms: isProd ? [removeDataTestAttrs] : [],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上內容便是容器方法（Wrapper Methods）中有關選擇器的用法與相關議題，明天我們將繼續來看其他容器方法！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】元件測試：模擬 Vue APIs（slots, custom directives）</title>
    <url>/testing/ithelp-2022-vitest-24/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="slots"><a href="#slots" class="headerlink" title="slots"></a>slots</h1><p>在開發的過程中，有時候我們可能為了畫面上的彈性，會在元件中透過 <code>&lt;slot&gt;</code> 讓父層來決定要填入什麼內容。</p>
<p>而在針對 <code>slots</code> 撰寫測試時，要注意的地方有：</p>
<ul>
<li><code>slots</code> 至少會有預設未傳入的狀態與傳入資料後的狀態兩種，斷言時應該至少包含這兩種狀態。</li>
<li>以 <code>slots</code> 行為作為案例斷言時，斷言內容要專注在 <code>slots</code> 所影響範圍內，否則可能會受其他因素干擾。</li>
</ul>
<a id="more"></a>

<hr>
<h2 id="預設插槽（Default-slots）"><a href="#預設插槽（Default-slots）" class="headerlink" title="預設插槽（Default slots）"></a>預設插槽（Default slots）</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要針對最基本的預設插槽做斷言時，我們可以透過容器中第二個參數帶入 <code>slots</code> 欄位來模擬帶入內容並透過 <code>default</code> 屬性傳入指定的範圍內。</p>
<p>未傳入測試案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'default slot'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Component)</span><br><span class="line">  expect(wrapper.html()).toMatchInlineSnapshot()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>傳入時測試案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'default slot'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Component, &#123;</span><br><span class="line">    slots: &#123;</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'Slot Content'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  expect(wrapper.html()).toContain(<span class="string">'Slot Content'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="具名插槽（Named-slots）"><a href="#具名插槽（Named-slots）" class="headerlink" title="具名插槽（Named slots）"></a>具名插槽（Named slots）</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"body"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>若在插槽的型態為具名插槽，在撰寫測試案例時的容器選項 <code>slots</code> 就可以依據插槽名稱 <code>name</code> 指定要傳入的內容。</p>
<p>未傳入測試案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'named slot'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Component)</span><br><span class="line"></span><br><span class="line">  expect(wrapper.html()).toMatchInlineSnapshot()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>傳入時測試案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'named slot'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Component, &#123;</span><br><span class="line">    slots: &#123;</span><br><span class="line">      header: <span class="string">'ithelp 2022 鐵人賽'</span>,</span><br><span class="line">      body: <span class="string">'vue3 單元測試'</span>,</span><br><span class="line">      footer: <span class="string">'by Shawn'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  expect(wrapper.html()).toMatchInlineSnapshot()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="作用域插槽（Scoped-slots）"><a href="#作用域插槽（Scoped-slots）" class="headerlink" title="作用域插槽（Scoped slots）"></a>作用域插槽（Scoped slots）</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>貓咪咖啡廳：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>店長：Shawn<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:staffInfo</span>=<span class="string">"staffInfo"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> staffInfo = &#123;</span></span><br><span class="line"><span class="actionscript">  <span class="string">'black-cat'</span>: &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'黑黑'</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="string">'signature-dish'</span>: <span class="string">'拿鐵'</span>,</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript">  <span class="string">'orange-cat'</span>: &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'阿橘'</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="string">'signature-dish'</span>: <span class="string">'焦糖瑪奇朵'</span>,</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有時候我們可能想要給予更高度的彈性，使元件透過 <code>&lt;slot&gt;</code> 傳遞資料給父層時，這時候就會用到作用域插槽。</p>
<p>未傳入測試案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'scoped slots'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Component)</span><br><span class="line"></span><br><span class="line">  expect(wrapper.html()).toMatchInlineSnapshot(<span class="string">`</span></span><br><span class="line"><span class="string">    "&lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;貓咪咖啡廳：&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;店長：Shawn&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;"</span></span><br><span class="line"><span class="string">  `</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>傳入時測試案例：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">it('scoped slots', async () =&gt; &#123;</span></span><br><span class="line"><span class="xml">  const wrapper = mount(Component, &#123;</span></span><br><span class="line"><span class="xml">    slots: &#123;</span></span><br><span class="line"><span class="xml">      default: `</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">template</span> #<span class="attr">staffInfo</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>店員：</span><span class="template-variable">&#123;&#123; staffInfo['orange-cat']['name'] &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>限定項目：</span><span class="template-variable">&#123;&#123; staffInfo['black-cat']['signature-dish'] &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">      `,</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">  &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  expect(wrapper.html()).toMatchInlineSnapshot(`</span></span><br><span class="line"><span class="xml">    "<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>貓咪咖啡廳：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>店長：Shawn<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>店員：阿橘<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>限定項目：拿鐵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>"</span></span><br><span class="line"><span class="xml">  `)</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="插槽載入選項（Mounting-options）"><a href="#插槽載入選項（Mounting-options）" class="headerlink" title="插槽載入選項（Mounting options）"></a>插槽載入選項（Mounting options）</h2><p>若想在測試案例中用不同的方式來模擬 <code>slots</code>，可以透過下面四種語法：</p>
<ul>
<li>傳入 SFC 檔案</li>
<li><code>render function</code></li>
<li>包含 <code>template</code> 屬性的物件</li>
<li>直接傳入一個字串</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should render same layout'</span>, () =&gt; &#123;</span><br><span class="line">  const <span class="keyword">wrapper</span> = mount(Layout, &#123;</span><br><span class="line">    slots: &#123;</span><br><span class="line">      <span class="keyword">default</span>: Component</span><br><span class="line">      // <span class="keyword">default</span>: h(<span class="string">'div'</span>, <span class="string">'相同內容'</span>),</span><br><span class="line">      // <span class="keyword">default</span>: &#123; <span class="keyword">template</span>: <span class="string">'&lt;div&gt;相同內容&lt;/div&gt;'</span> &#125;,</span><br><span class="line">      // <span class="keyword">default</span>: <span class="string">'&lt;div&gt;相同內容&lt;/div&gt;'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  expect(<span class="keyword">wrapper</span>.html()).toContain(<span class="string">'&lt;div&gt;相同內容&lt;/div&gt;'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="custom-directives"><a href="#custom-directives" class="headerlink" title="custom directives"></a>custom directives</h1><p>客製化指令本身搭配了類似元件生命週期的 Hooks，而我們可以在那些 Hook 中任意對我們所綁定的元素做開發，讓繁複的邏輯透過簡單的指令就能夠重複利用，使我們在開發過程中的開發者體驗（Developer experience, DX）有非常良好的體驗。</p>
<p>但相對的來說，要測試客製化指令就有機會運用到各種我們至今學過的許多技巧來斷言，從而使難度大大提升，但我們只要熟悉之前的模擬技巧後，最後只需要關注的一個地方就是，預期指令放入後應達成什麼目標，接著再去尋找要從什麼角度或可取得的資訊去比對來作為我們斷言的內容即可。</p>
<p>而接下來我們以一個 <code>v-foucs</code> 的客製化指令來介紹如何斷言客製化指令與尋找比對資訊：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vFocus = &#123;</span><br><span class="line">  mounted: <span class="function">(<span class="params">el</span>) =&gt;</span> el.focus(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>1.註冊指令</strong></p>
<p>首先，要進行斷言我們可以透過容器中第二個參數的 <code>global.directives</code> 來註冊我們的客製化指令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = mount(..., &#123;</span><br><span class="line">  global: &#123;</span><br><span class="line">    directives: &#123;</span><br><span class="line">      Focus: vFocus, <span class="comment">// 屬性匹配的名稱規則 Abc 會 match 到 v-abc</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>2.仿造元件並放入指令</strong></p>
<p>接著我們要使用到仿造元件的技巧，讓容器一開始就載入一個假的元件，並且放入指令與 <code>data-test</code> 屬性供捕獲：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = &#123;</span><br><span class="line">    template: <span class="string">'&lt;input v-focus data-test="target" type="text"/&gt;'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wrapper = mount(..., &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">          directives: &#123;</span><br><span class="line">            Focus: vFocus,</span><br><span class="line">          &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>3.尋找比對目標</strong><br>再來，由於目標是為了驗證是否該元素為瀏覽器中的 <code>focus</code> 元素，因此要利用到瀏覽器物件 <code>Document</code> 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement" target="_blank" rel="noopener">activeElement</a> 屬性，若有被聚焦的情況下那應該要能夠比對到同個元素。（由 <code>jsdom</code> 提供模擬的瀏覽器環境）</p>
<p><strong>4.斷言</strong><br>最後在斷言的部分，為了取得目標元素，我們可以透過 <code>wrapper.find().element</code> 取得目標的元素實體，最後就可以拿他與 <code>document.activeElement</code> 做比對：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'v-focus'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> Component = &#123;</span><br><span class="line">    template: <span class="string">'&lt;input v-focus data-test="target" type="text"/&gt;'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Component, &#123;</span><br><span class="line">    attachTo: <span class="built_in">document</span>.body,</span><br><span class="line">    global: &#123;</span><br><span class="line">      directives: &#123;</span><br><span class="line">        Focus: vFocus,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="target"]'</span>).element).toBe(<span class="built_in">document</span>.activeElement)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如此一來我們就可以確保將來在使用 <code>v-focus</code> 指令時，該元素在 <code>mounted</code> 後會是聚焦的元素。</p>
<p>以上便是幾個常見的 Vue APIs 要如何在測試案例中模擬的介紹，而到了這邊我們大部分的測試案例都要能寫的出來啦！因此明天將會是我們的⋯⋯測驗時間！！！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】元件測試：模擬 Vue APIs（emit, provide/inject）</title>
    <url>/testing/ithelp-2022-vitest-23/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>今天我們要來繼續學習元件中若有使用到 Vue API 中的 <code>emit</code>、<code>provide</code> 與 <code>inject</code> 時要怎麼來進行測試並且模擬他們的行為。</p>
<a id="more"></a>

<h1 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h1><p>在斷言中我們要測試 <code>emit</code> 主要是試圖捕獲元件所發生的事件，並斷言事件與值是否如我們所預期，而這時可以透過容器方法中的 <code>emitted()</code> 來取得事件發送所有的紀錄。</p>
<p>而 <code>emitted</code> 中所紀錄的格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'事件名稱'</span>: [</span><br><span class="line">        [<span class="comment">/* 第一次發送的值 */</span>],</span><br><span class="line">        [<span class="comment">/* 第二次發送的值 */</span>],</span><br><span class="line">        [<span class="comment">/* 第 n 次發送的值 */</span>]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此假設我們有一個 <code>pagination</code> 元件如下所示：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">div</span> data-<span class="keyword">test</span>=<span class="string">"first"</span> @click=<span class="string">"$emit('changePage', 'first')"</span>&gt;</span><br><span class="line">       第一頁</span><br><span class="line">      &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">div</span> data-<span class="keyword">test</span>=<span class="string">"prev"</span> @click=<span class="string">"$emit('changePage', 'prev')"</span>&gt;</span><br><span class="line">        上一頁</span><br><span class="line">      &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">div</span> data-<span class="keyword">test</span>=<span class="string">"next"</span> @click=<span class="string">"$emit('changePage', 'next')"</span>&gt;</span><br><span class="line">        下一頁</span><br><span class="line">      &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">div</span> data-<span class="keyword">test</span>=<span class="string">"last"</span> @click=<span class="string">"$emit('changePage', 'last')"</span>&gt;</span><br><span class="line">        最後一頁</span><br><span class="line">      &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>


<p>在斷言的時候我們可以透過下列方式檢查是否發送對應的 <code>emit</code> 事件：</p>
<ul>
<li>透過 <code>toHaveProperty</code> 確認 <code>emitted</code> 屬性確認是否發送「預期事件名稱」</li>
<li>透過 <code>emitted().事件名稱</code> 確認該事件名稱「發生次數」</li>
<li>透過 <code>emitted().事件名稱[index]</code> 確認該事件名稱，第幾次送出的「值」</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'...'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(Component)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="first"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line">    </span><br><span class="line">    expect(wrapper.emitted()).toHaveProperty(<span class="string">'changePage'</span>)</span><br><span class="line">    expect(wrapper.emitted().changePage).toHaveLength(<span class="number">1</span>)</span><br><span class="line">    expect(wrapper.emitted().changePage[<span class="number">0</span>]).toEqual([<span class="string">'first'</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="provide"><a href="#provide" class="headerlink" title="provide"></a>provide</h1><p>對於有使用到 <code>provide</code> 的元件來說，我們需要確保他提供預期的 <code>inject</code> 內容，因此我們要建立一個用來接收 <code>provide</code> 的元件，接著才能透過斷言來測試傳遞的內容是否如預期。</p>
<p>接下來我們以這個元件為例：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ChildComponent</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">import </span><span class="xquery">&#123; ref, provide, readonly &#125;</span><span class="xml"> from 'vue'</span></span><br><span class="line"><span class="xml">export default </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">  setup() &#123;</span></span><br><span class="line"><span class="xquery">    const<span class="built_in"> count</span> = ref(<span class="number">1</span>)</span></span><br><span class="line"><span class="xquery">    provide(<span class="string">'count'</span>, readonly<span class="built_in">(count</span>))</span></span><br><span class="line"><span class="xquery">  &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>然而我們為了讓測試案例保持獨立性，因此我們要透過造假的元件來測試 <code>inject</code> 所接收到的是否如預期。</p>
<h2 id="透過元件容器中的-global-stubs-模擬假元件"><a href="#透過元件容器中的-global-stubs-模擬假元件" class="headerlink" title="透過元件容器中的 global.stubs 模擬假元件"></a>透過元件容器中的 global.stubs 模擬假元件</h2><p>透過元件容器（Wrapper）中的第二個參數 <code>global.stubs</code> 我們可以將子元件渲染成我們想要的樣子，而模擬的方式一共分為兩種：</p>
<ul>
<li>渲染成 <code>&lt;-stub&gt;</code> 元件</li>
<li>渲染成特定元件</li>
</ul>
<h3 id="渲染成-lt-stub-gt-元件"><a href="#渲染成-lt-stub-gt-元件" class="headerlink" title="渲染成 &lt;-stub&gt; 元件"></a>渲染成 <code>&lt;-stub&gt;</code> 元件</h3><p>當 <code>global.stub[目標元件名稱]</code> 為 <code>true</code> 時：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = mount(TargetComponent, &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">          stubs: &#123;</span><br><span class="line">                ChildComponent: <span class="literal">true</span>, </span><br><span class="line">          &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我們的目標元件將會被渲染為帶有 <code>-stub</code> 後綴的元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ChildComponent</span> /&gt;</span> <span class="comment">&lt;!-- 會變成 &lt;child-component-stub&gt;&lt;/child-component-stub&gt;  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然而這對於我們要測試 <code>provide</code> 來說沒有幫助，因為他沒有辦法接收 <code>inject</code> 資訊，因此我們要採用下面第二種方法。</p>
<h3 id="渲染成特定元件"><a href="#渲染成特定元件" class="headerlink" title="渲染成特定元件"></a>渲染成特定元件</h3><p>要渲染成特定元件的方式，就是先製作一個假元件，接著再提供給 <code>global.stubs</code> 來當作原先應該要渲染的元件。</p>
<p>首先，我們可以透過 Vue 提供的 <code>defineComponent</code> 建造元件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TestComponent = defineComponent(&#123;</span><br><span class="line">    template: <span class="string">'&lt;p data-test="target"&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;'</span>,</span><br><span class="line">    setup() &#123;</span><br><span class="line">      <span class="keyword">const</span> value = inject(<span class="string">'count'</span>)</span><br><span class="line">      <span class="keyword">return</span> &#123; value &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接著在測試案例就可以透過 <code>global.stubs</code> 中直接使用這個測試元件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TestComponent = defineComponent(&#123;</span><br><span class="line">    template: <span class="string">'&lt;p data-test="target"&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;'</span>,</span><br><span class="line">    setup() &#123;</span><br><span class="line">      <span class="keyword">const</span> value = inject(<span class="string">'count'</span>)</span><br><span class="line">      <span class="keyword">return</span> &#123; value &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'...'</span> , () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(TargetComponent, &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">      stubs: &#123;</span><br><span class="line">        ChildComponent: TestComponent,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如此一來元件 <code>ChildComponent</code> 在測試案例中的渲染結果將變成我們指定的樣子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"target"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因此我們現在就可以斷言 <code>provide</code> 提供的內容是否正確了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TestComponent = defineComponent(&#123;</span><br><span class="line">    template: <span class="string">'&lt;p data-test="target"&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;'</span>,</span><br><span class="line">    setup() &#123;</span><br><span class="line">      <span class="keyword">const</span> count = inject(<span class="string">'count'</span>)</span><br><span class="line">      <span class="keyword">return</span> &#123; count &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">'...'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(TargetComponent, &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">      stubs: &#123;</span><br><span class="line">        ChildComponent: TestComponent,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="target"]'</span>).text()).toBe(<span class="string">'1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="inject"><a href="#inject" class="headerlink" title="inject"></a>inject</h1><p>對於有使用到 <code>inject</code> 的元件來說，我們在意的是提供 <code>provide</code> 特定的值之後，畫面上渲染的結果是否正確。</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-test</span>=<span class="string">"target"</span>&gt;</span></span><span class="xquery">&#123;&#123;<span class="built_in"> count</span> &#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">import </span><span class="xquery">&#123; inject &#125;</span><span class="xml"> from 'vue'</span></span><br><span class="line"><span class="xml">export default </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">  setup() &#123;</span></span><br><span class="line"><span class="xquery">    const<span class="built_in"> count</span> = inject(<span class="string">'count'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="xquery">    <span class="keyword">return</span> &#123;<span class="built_in"> count</span> &#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>此時我們可以透過元件容器（Wrapper）中的第二個參數 <code>global</code> 來指定要提供的 <code>provide</code> 值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = mount(TargetComponent, &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">      provide: &#123;</span><br><span class="line">        count: <span class="number">1</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後我們就可以直接斷言渲染的結果是否如預期：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should be render correct content after providing count'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(TargetComponent, &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">      provide: &#123;</span><br><span class="line">        count: <span class="number">1</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="target"]'</span>).text()).toBe(<span class="string">'1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<p>以上便是如何在測試案例中模擬元件  <code>emit</code>、<code>provide</code> 與 <code>inject</code> 行為的介紹，而這一部分在模擬的過程中會主要需要注意到像是 <code>global.stubs</code> 的模擬元件用法，以及要模擬 <code>provide</code> 的話，須在容器中的 <code>global.provide</code> 中指定，若放錯位置就會沒效果囉。</p>
<p>而明天我們將來介紹最後有關於 Vue 常用的 <code>slot</code> 與指令 <code>directive</code> 要怎麼模擬並測試！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【試験ノ章】第二個測驗：容器（Wrapper）與容器方法（Wrapper methods）</title>
    <url>/testing/ithelp-2022-vitest-25/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>回顧第一次測驗內容，我們已經學會如何利用測試情境與案例（<code>describe</code>, <code>it</code>）的語法並參考測試路徑（test path）寫出基本的測試結構，最後也使用了對應的測試 Matcher 來做最後的斷言（Assertion）。</p>
<p>而第二次測驗將著重在學習容器（Wrapper）中要怎麼透過容器方法（Wrapper methods）與透過容器函式的第二個參數來模擬各種元件中的內容。</p>
<p>另外，我們今天使用的測試檔案要接續先前<a href="https://ithelp.ithome.com.tw/articles/10302202" target="_blank" rel="noopener">第一次測驗</a>中完成的檔案來進行測試！</p>
<p>同樣的測驗章節我們將會做以下的流程：</p>
<ul>
<li>閱讀故事與題目，釐清需求與規則。</li>
<li>規劃測試情境與測試案例，並列好描述的部分。</li>
<li>撰寫測試程式碼（Testing Code），並執行測試時得到測試案例失敗。</li>
<li>按照題目要求完成產品程式碼（Production Code）</li>
<li>再次執行測試確保測試通過。</li>
</ul>
<blockquote>
<p>本文一樣可利用<a href="https://ithelp.ithome.com.tw/articles/10292537" target="_blank" rel="noopener">系列文專案</a>來一邊學習，幫你準備好測試所需要的環境，快來安裝吧！</p>
</blockquote>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221010/20119062IVcelQZ7d1.png" alt="https://ithelp.ithome.com.tw/upload/images/20221010/20119062IVcelQZ7d1.png"></p>
<a id="more"></a>

<h2 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h2><p><a href="https://ithelp.ithome.com.tw/articles/10302202" target="_blank" rel="noopener">前情提要</a>：上回柯基中午要買便當時，碰巧遇到了負責管理『自動乾乾提存機』的橘貓，阿橘；在科基奮不顧身的協助後，終於幫阿橘把『自動乾乾提存機』的邏輯部分寫好了，並得到了一年份的乾乾。</p>
<hr>
<p>「果然⋯⋯」柯基無奈地望著眼前的大袋子說道。「⋯⋯是貓貓專用乾乾。」</p>
<p>眼看中午休息的時間好像快過了，柯基想說拖著一大袋貓乾乾回公司好像也有點怪怪的，於是聯絡了黑黑宅急便公司，想把這包乾乾先寄回家再看要怎麼處理⋯⋯</p>
<p>過了不知道多久，柯基感受到似乎有股視線正在盯著他，「請問是柯基先生嗎？」一名全身黑某某的快遞員正拿著單子看著他。</p>
<p>柯基彷彿看到救贖一樣說道：「你好，我就是柯⋯⋯」還沒說完，黑某某快遞員用她輕快地腳步打斷了柯基的對話，繞到車子的後方並打開車廂，「打開乾乾放進來吧。」</p>
<p>「好的好的！」，柯基一邊打開了乾乾的同時，撇著頭注視了車廂一眼，「這該不會是⋯⋯」</p>
<p>柯基還沒說完話，黑某某快遞員突然用興奮的語氣一邊湊近柯基說道「咪錯咪錯！這就是配有『自動乾乾提存機』的快遞車喔！很酷吧！看來你很懂嗎！喵喵！」被快遞員貼著身上的柯基彷彿能感受到的貓觸鬚刺在他的臉上。</p>
<p>「⋯⋯不過，剛剛不曉得為什麼更新之後，介面就不見了。」黑某某快遞員沮喪的說。「對了，我叫做黑黑。」</p>
<p>「原來⋯⋯黑黑宅急便公司真的是黑貓出來送貨啊⋯⋯」</p>
<p>柯基還沒來得及感嘆完，手機就傳來了一封簡訊寫到：「喂？有空再幫我修一下機器吧，文件我放在副檔裡了。————來自：阿橘。」</p>
<p>「（回覆）⋯⋯這次我要狗狗專用乾乾。」</p>
<h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p>『自動乾乾提存機』主要分為軟體部分與介面部分，而軟體部分目前已有 <a href="https://ithelp.ithome.com.tw/articles/10302202" target="_blank" rel="noopener">FoodBank</a> 程式支援了，然而介面控制部分因為某些問題損壞了，所以我們現在需要將軟體支援的一些功能，透過介面呈現並且讓他能夠操作。</p>
<p>而『自動乾乾提存機』的介面環境主要依賴的是瀏覽器介面來實作的，並且螢幕帶有觸碰功能與模擬鍵盤，因此使用者可以快速點擊畫面上的按鈕來操作，所以可基於瀏覽器環境進行開發。</p>
<p>功能的部分『自動乾乾提存機』有一些明確的限制：</p>
<ul>
<li>狀態顯示欄（Ａ）：  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"status"</span>&gt;</span>&#123;&#123; status &#125;&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>輸入資訊框（Ｂ）<ul>
<li>供開戶使用：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"input_account"</span> <span class="attr">v-model</span>=<span class="string">"account"</span> <span class="attr">type</span>=<span class="string">"text"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>供存款使用：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"input_deposit"</span> <span class="attr">v-model</span>=<span class="string">"deposit"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">min</span>=<span class="string">"0"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>供提款使用：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"input_withdraw"</span> <span class="attr">v-model</span>=<span class="string">"withdraw"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">min</span>=<span class="string">"0"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>開戶按鈕：  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button_open-account"</span>&gt;</span>開戶<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>點擊後應觸發 <code>FoodBank</code> 中的 <code>openAccount</code>，並依結果返回不同資訊：<ul>
<li>若已有開過戶頭應在狀態顯示欄（Ａ）顯示 <code>您已開過戶頭囉。</code></li>
<li>若交易成功，且該名稱未開過戶頭應在狀態顯示欄（Ａ）顯示 <code>開戶完成。</code></li>
</ul>
</li>
</ul>
</li>
<li>存款按鈕：  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button_deposit"</span>&gt;</span>存款<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>點擊後應觸發 <code>FoodBank</code> 中的 <code>deposit</code>，並依結果返回不同資訊：<ul>
<li>若查詢不到戶頭應在狀態顯示欄（Ａ）顯示 <code>查詢不到該用戶，請重新確認。</code></li>
<li>若交易成功，應在狀態顯示欄（Ａ）顯示 <code>存款完成，戶頭目前餘額 {該用戶的乾乾數量}</code></li>
</ul>
</li>
</ul>
</li>
<li>提款按鈕  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button_withdraw"</span>&gt;</span>提款<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>點擊後應觸發 <code>FoodBank</code> 中的 <code>withdraw</code>，並依結果返回不同資訊：<ul>
<li>若查詢不到戶頭應在狀態顯示欄（Ａ）顯示 <code>查詢不到該用戶，請重新確認。</code></li>
<li>若交易成功，提領金額足夠應在狀態顯示欄（Ａ）顯示 <code>存款完成，戶頭目前餘額 {該用戶的乾乾數量}</code></li>
<li>若交易成功，餘額不足提領金額應在狀態顯示欄（Ａ）顯示 <code>餘額不足，你帳戶目前餘額為 {該用戶的乾乾數量}</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><h2 id="1-準備測試用檔案"><a href="#1-準備測試用檔案" class="headerlink" title="1.準備測試用檔案"></a>1.準備測試用檔案</h2><p><code>FoodBank</code> 軟體相關邏輯的部分沿用<a href="https://ithelp.ithome.com.tw/articles/10302202" target="_blank" rel="noopener">上次測驗中寫好的部分</a></p>
<p>而介面的部分我們以一個 <code>App.vue</code> 為例：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button_open-account"</span>&gt;</span>開戶<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"input_account"</span> <span class="attr">v-model</span>=<span class="string">"account"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button_deposit"</span>&gt;</span>存款<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"input_deposit"</span> <span class="attr">v-model</span>=<span class="string">"deposit"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">min</span>=<span class="string">"0"</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button_withdraw"</span>&gt;</span>提款<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"input_withdraw"</span> <span class="attr">v-model</span>=<span class="string">"withdraw"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">min</span>=<span class="string">"0"</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"status"</span>&gt;</span></span><span class="template-variable">&#123;&#123; status &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-撰寫測試案例描述"><a href="#2-撰寫測試案例描述" class="headerlink" title="2.撰寫測試案例描述"></a>2.撰寫測試案例描述</h2><p>在撰寫測試案例時，要注意的是我們這次測試的目標是 <code>App.vue</code> 元件本身，而非 <code>FoodBank</code> 中的邏輯：</p>
<blockquote>
<p>本次 demo 以下列測試案例為主，實際可依造 <a href="https://ithelp.ithome.com.tw/articles/10297571" target="_blank" rel="noopener">happy, sad &amp; bad 路徑 </a>規劃出完整的案例：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'執行開戶'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">`輸入用戶名稱，開戶完成，狀態欄應該顯示 '開戶完成。' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  it(<span class="string">`輸入用戶名稱，若開過戶頭，狀態欄應該顯示 '您已開過戶頭囉。' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">describe(<span class="string">'執行存款'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">`輸入用戶名稱與金額，交易完成，狀態欄應該顯示 '存款完成，戶頭目前餘額 &#123;該用戶乾乾數量&#125;' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  it(<span class="string">`輸入用戶名稱與金額，若查詢不到戶頭，狀態欄應該顯示 '查詢不到該用戶，請重新確認。' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">describe(<span class="string">'執行提款'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">`輸入用戶名稱與金額，交易完成，狀態欄應該顯示 '存款完成，戶頭目前餘額 &#123;該用戶乾乾數量&#125;' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  it(<span class="string">`輸入用戶名稱與金額，若查詢不到戶頭，狀態欄應該顯示 '查詢不到該用戶，請重新確認。' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">  it(<span class="string">`輸入用戶名稱與金額，餘額不足，狀態欄應該顯示 '餘額不足，你帳戶目前餘額為 &#123;該用戶乾乾數量&#125;' `</span>, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-補上測試案例的細節並執行測試確保測試失敗"><a href="#3-補上測試案例的細節並執行測試確保測試失敗" class="headerlink" title="3.補上測試案例的細節並執行測試確保測試失敗"></a>3.補上測試案例的細節並執行測試確保測試失敗</h2><h3 id="3-1-開戶情境"><a href="#3-1-開戶情境" class="headerlink" title="3-1. 開戶情境"></a>3-1. 開戶情境</h3><p>開戶情境部分首先要注意到的是在輸入（<code>input</code>）與點擊（<code>click</code>）按鈕的操作時，本身行為是非同步的因此要使用 <code>async/await</code> 方式來確保執行完畢。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'開戶'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">`輸入用戶名稱，開戶完成，狀態欄應該顯示 '開戶完成。' `</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 輸入用戶</span></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_account"]'</span>).setValue(<span class="string">'Shawn'</span>)</span><br><span class="line">    <span class="comment">// 點擊按鈕</span></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_open-account"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    expect(wrapper.find(<span class="string">'[data-test="status"]'</span>).text()).toEqual(<span class="string">'開戶完成。'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">`輸入用戶名稱，若開過戶頭，狀態欄應該顯示 '您已開過戶頭囉。' `</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立用戶 Shawn</span></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_account"]'</span>).setValue(<span class="string">'Shawn'</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_open-account"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重複創建用戶 Shawn</span></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_account"]'</span>).setValue(<span class="string">'Shawn'</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_open-account"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    expect(wrapper.find(<span class="string">'[data-test="status"]'</span>).text()).toEqual(<span class="string">'您已開過戶頭囉。'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-存款情境"><a href="#3-2-存款情境" class="headerlink" title="3-2. 存款情境"></a>3-2. 存款情境</h3><p>存款情境的部分則是要注意到，是否已經開戶以及存款金額的數量，我們可以透過寫定一個值（如存 100）來去模擬斷言結果應該要有的狀態，甚至透過多次操作持續追蹤狀況：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'存款'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">`輸入用戶名稱與金額，交易完成，狀態欄應該顯示 '存款完成，戶頭目前餘額 &#123;該用戶乾乾數量&#125;' `</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line">    <span class="comment">// 開戶行為</span></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_account"]'</span>).setValue(<span class="string">'Shawn'</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_open-account"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_deposit"]'</span>).setValue(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_deposit"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line">    expect(wrapper.find(<span class="string">'[data-test="status"]'</span>).text()).toEqual(<span class="string">'存款完成，戶頭目前餘額 100'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 技巧：重複操作持續追蹤結果</span></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_deposit"]'</span>).setValue(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_deposit"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line">    expect(wrapper.find(<span class="string">'[data-test="status"]'</span>).text()).toEqual(<span class="string">'存款完成，戶頭目前餘額 200'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">`輸入用戶名稱與金額，若查詢不到戶頭，狀態欄應該顯示 '查詢不到該用戶，請重新確認。' `</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_account"]'</span>).setValue(<span class="string">'Shawn'</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_deposit"]'</span>).setValue(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_deposit"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    expect(wrapper.find(<span class="string">'[data-test="status"]'</span>).text()).toEqual(<span class="string">'查詢不到該用戶，請重新確認。'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-提款部分"><a href="#3-3-提款部分" class="headerlink" title="3-3. 提款部分"></a>3-3. 提款部分</h3><p>最後提款的部分，必須注意到我們必須開戶並且存款到足額數量並提領足額的部分才能測出 happy path 的情境：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'提款'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">`輸入用戶名稱與金額，交易完成，狀態欄應該顯示 '存款完成，戶頭目前餘額 &#123;該用戶乾乾數量&#125;' `</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_account"]'</span>).setValue(<span class="string">'Shawn'</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_open-account"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_deposit"]'</span>).setValue(<span class="number">200</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_deposit"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_withdraw"]'</span>).setValue(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_withdraw"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    expect(wrapper.find(<span class="string">'[data-test="status"]'</span>).text()).toEqual(<span class="string">'存款完成，戶頭目前餘額 100'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">`輸入用戶名稱與金額，若查詢不到戶頭，狀態欄應該顯示 '查詢不到該用戶，請重新確認。' `</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_account"]'</span>).setValue(<span class="string">'Shawn'</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_withdraw"]'</span>).setValue(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_withdraw"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    expect(wrapper.find(<span class="string">'[data-test="status"]'</span>).text()).toEqual(<span class="string">'查詢不到該用戶，請重新確認。'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">`輸入用戶名稱與金額，餘額不足，狀態欄應該顯示 '餘額不足，你帳戶目前餘額為 &#123;該用戶乾乾數量&#125;' `</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_account"]'</span>).setValue(<span class="string">'Shawn'</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_open-account"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_deposit"]'</span>).setValue(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_deposit"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="input_withdraw"]'</span>).setValue(<span class="number">200</span>)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_withdraw"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    expect(wrapper.find(<span class="string">'[data-test="status"]'</span>).text()).toEqual(<span class="string">'餘額不足，你帳戶目前餘額為 100'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上述撰寫測試案例的過程中你可能會發現有些步驟其實相當重複，而這時其實可以善用先前提過的 <code>Setup</code> &amp; <code>Teardown</code> 等語法包裝，但這裡先不做的原因是我們後續會有章節提到要如何更好的完善它！</p>
</blockquote>
<h2 id="4-補上產品程式碼，讓測試中的紅燈逐漸轉變為綠燈"><a href="#4-補上產品程式碼，讓測試中的紅燈逐漸轉變為綠燈" class="headerlink" title="4.補上產品程式碼，讓測試中的紅燈逐漸轉變為綠燈"></a>4.補上產品程式碼，讓測試中的紅燈逐漸轉變為綠燈</h2><p>在撰寫好測試案例後我們現在就可以回頭來開發介面（<code>App.vue</code>）的部分了。</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button_open-account"</span>&gt;</span>開戶<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"input_account"</span> <span class="attr">v-model</span>=<span class="string">"account"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button_deposit"</span>&gt;</span>存款<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"input_deposit"</span> <span class="attr">v-model</span>=<span class="string">"deposit"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">min</span>=<span class="string">"0"</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button_withdraw"</span>&gt;</span>提款<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"input_withdraw"</span> <span class="attr">v-model</span>=<span class="string">"withdraw"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">min</span>=<span class="string">"0"</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"status"</span>&gt;</span></span><span class="template-variable">&#123;&#123; status &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>


<p>首先我們可以先關注在邏輯的部分，在引入我們的 <code>FoodBank</code> 之後，依據 <code>template</code> 需要的部分開立好變數，並建造相關的方法（開戶、存款與提領）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="comment">// 引入必要模組</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; FoodBank &#125; <span class="keyword">from</span> <span class="string">'./FoodBank.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 開設好變數</span></span><br><span class="line"><span class="keyword">const</span> account = ref(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> deposit = ref(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> withdraw = ref(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> status = ref(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立相關方法</span></span><br><span class="line"><span class="keyword">const</span> $FoodBank = <span class="keyword">new</span> FoodBank()</span><br><span class="line"><span class="keyword">const</span> handleOnOpenAccount = <span class="function"><span class="params">()</span> =&gt;</span> (status.value = $FoodBank.openAccount(account.value))</span><br><span class="line"><span class="keyword">const</span> handleOnDeposit = <span class="function"><span class="params">()</span> =&gt;</span> (status.value = $FoodBank.deposit(account.value, deposit.value))</span><br><span class="line"><span class="keyword">const</span> handleOnWithdraw = <span class="function"><span class="params">()</span> =&gt;</span> (status.value = $FoodBank.withdraw(account.value, withdraw.value))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>接著在 <code>template</code> 部分補上我們的方法：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleOnOpenAccount"</span> <span class="attr">data-test</span>=<span class="string">"button_open-account"</span>&gt;</span>開戶<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"input_account"</span> <span class="attr">v-model</span>=<span class="string">"account"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleOnDeposit"</span> <span class="attr">data-test</span>=<span class="string">"button_deposit"</span>&gt;</span>存款<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"input_deposit"</span> <span class="attr">v-model</span>=<span class="string">"deposit"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">min</span>=<span class="string">"0"</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleOnWithdraw"</span> <span class="attr">data-test</span>=<span class="string">"button_withdraw"</span>&gt;</span>提款<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">data-test</span>=<span class="string">"input_withdraw"</span> <span class="attr">v-model</span>=<span class="string">"withdraw"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">min</span>=<span class="string">"0"</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-test</span>=<span class="string">"status"</span>&gt;</span></span><span class="template-variable">&#123;&#123; status &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="5-執行測試，確認所有測試通過！"><a href="#5-執行測試，確認所有測試通過！" class="headerlink" title="5. 執行測試，確認所有測試通過！"></a>5. 執行測試，確認所有測試通過！</h2><p><img src="https://ithelp.ithome.com.tw/upload/images/20221010/20119062OBy5IJidPR.png" alt="https://ithelp.ithome.com.tw/upload/images/20221010/20119062OBy5IJidPR.png"></p>
<p>若以上過程你是拆分為從各情境（開戶、存款或提領）分別處理，那麼你就會發現在實作產品程式碼的過程中，測試案例將逐步地通過！</p>
<p>如同第一次測驗時說的，這種「紅燈開發（Red-Green-Refactor）」的感受是必須基於你先撰寫好測試才能體驗到的美好，若剛才測驗過程中，讀者是先開發才撰寫測試的，請務必反過來從測試撰寫開始嘗試！</p>
<p>以上便是今天的測試驗收！希望大家都有體驗到測試的美好，接下來我們要繼續介紹有關於模擬替身與 Vue 周邊工具要怎麼測試哩！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】測試替身（Test Double）feat. Vue Test Utils</title>
    <url>/testing/ithelp-2022-vitest-27/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>昨天我們提到了 Gerard Meszaros 的五大測試替身概念，釐清我們要在什麼時機下使用何種測試替身來幫助測試案例流程能更加順利，並帶了一點與測試替身相關的語法。</p>
<p>而今天要來詳細談談 Vue Test Utils 工具中有關於測試替身的相關語法有哪些，並思考以五大測試替身的概念去思考其中的應用場景。</p>
<h2 id="Vue-Test-Utils-的測試替身"><a href="#Vue-Test-Utils-的測試替身" class="headerlink" title="Vue Test Utils 的測試替身"></a>Vue Test Utils 的測試替身</h2><p>在 Vue Test Utils 工具中的測試替身，大部分都是在協助有關於替換元件渲染以及替換 <code>&lt;slot&gt;</code> 等 <code>stub</code> 類型的測試替身：</p>
<h3 id="shallowMount"><a href="#shallowMount" class="headerlink" title="shallowMount"></a><code>shallowMount</code></h3><p>第一個不得不提的就是我們熟悉的 <code>shallowMount</code> 元件容器（Wrapper），在前面章節有提過，若我們不使用 <code>mount</code> 而是改由 <code>shallowMount</code> 容器來渲染元件的話：</p>
<p>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ChildComponent</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> component <span class="keyword">from</span> <span class="string">'App.vue'</span></span><br><span class="line"><span class="keyword">const</span> wrapper = shallowMount(component)</span><br></pre></td></tr></table></figure>

<p>那麼上方的 <code>wrapper</code> 渲染結果將會變成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component-stub</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component-stub</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>這麼一來我們就可以測試有關 <code>App.vue</code> 元件本身的行為。</p>
<h3 id="shallow"><a href="#shallow" class="headerlink" title="shallow"></a><code>shallow</code></h3><p>接下來是同樣概念的 <code>shallow</code>，只是差在使用方法是透過 <code>mount</code> 元件容器的第二參數帶上 <code>{ shallow: true }</code>：</p>
<p>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ChildComponent</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> component <span class="keyword">from</span> <span class="string">'App.vue'</span></span><br><span class="line"><span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">    shallow: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>wrapper</code> 將會渲染成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component-stub</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component-stub</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="global-renderStubDefaultSlot"><a href="#global-renderStubDefaultSlot" class="headerlink" title="global.renderStubDefaultSlot"></a>global.renderStubDefaultSlot</h3><p><code>renderStubDefaultSlot</code> 使用場景比較特別，他主要是用來指定是否強迫渲染 <code>slot</code> 內容，即使是在 <code>shallow</code> 元件的時候：</p>
<p>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Child-Component</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> component <span class="keyword">from</span> <span class="string">'App.vue'</span></span><br><span class="line"><span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">    shallow: <span class="literal">true</span>,</span><br><span class="line">    slots: &#123;</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">'&lt;p&gt;force render this!&lt;/p&gt;'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    global: &#123;</span><br><span class="line">        renderStubDefaultSlot: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上方為例最後 <code>wrapper</code> 會變成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>force render this!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component-stub</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component-stub</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但官方也特別強調由於技術限制的關係，<code>renderStubDefaultSlot</code> 語法暫時只支援預設插槽（Default Slots）能被指定渲染。</p>
<h3 id="global-stubs"><a href="#global-stubs" class="headerlink" title="global.stubs"></a>global.stubs</h3><p>前面有稍微提到的 <code>global.stubs</code>，最主要是用來指定子元件渲染成 <code>&lt;-stub&gt;</code> 元件或特定 <code>template</code> 的方法：</p>
<p>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ChildComponent</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> component <span class="keyword">from</span> <span class="string">'App.vue'</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">'should be render...'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">        global: &#123;</span><br><span class="line">          stubs: &#123; <span class="attr">ChildComponent</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    expect(wrapper.html()).toEqual(<span class="string">'&lt;div&gt;&lt;child-component-stub&gt;&lt;/child-component-stub&gt;&lt;/div&gt;'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'should be render...'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">        global: &#123;</span><br><span class="line">          stubs: &#123;</span><br><span class="line">            ChildComponent:</span><br><span class="line">                &#123;</span><br><span class="line">                    name: <span class="string">'StubComponent'</span>,</span><br><span class="line">                    template: <span class="string">'&lt;p&gt;custom content&lt;/p&gt;'</span></span><br><span class="line">                &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    expect(wrapper.html()).toEqual(<span class="string">'&lt;div&gt;&lt;p&gt;custom content&lt;/p&gt;&lt;/div&gt;'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>現在我們就可以針對 <code>stub</code> 後的結果開始斷言啦！</p>
<blockquote>
<p>有沒有覺得看到 <code>Stub</code> 術語就有種親切感呢！</p>
</blockquote>
<h3 id="global-mock"><a href="#global-mock" class="headerlink" title="global.mock"></a>global.mock</h3><p>最後一個 <code>global.mock</code> 主要是用來替身 Vue 開發時常用到的 Router 或 Store 周邊工具庫的語法：</p>
<p>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"handleOnClickButton"</span>&gt;</span>Add 1 to Store<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleOnClickButton() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.dispatch(<span class="string">'add'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>這時我們可以在測試案例中替身（<code>mock</code>）掉原先 <code>store</code> 的方法，甚至仿照出一個新的 <code>store</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> component <span class="keyword">from</span> <span class="string">'App.vue'</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">'should be mocked'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> $store = &#123;</span><br><span class="line">        dispatch: vi.fn(), <span class="comment">// Vitest 中用來記錄用的函式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">        global: &#123;</span><br><span class="line">            mocks: &#123; $store &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button"]'</span>).trigger(<span class="string">'click)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    epxect($store.dispatch).toHaveBeenCalled() // 確認 `dispatch` 有被呼叫</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>如此一來我們就可以捕捉原先受測物（SUT）想要對依賴物（DOC）做的事情，是否如我們預期，這也就是昨天測試替身中 <code>Mock</code> 類型想要做的事情！</p>
<hr>
<p>以上主要是 Vue Test Utils 中有關測試替身的 API，而明天我們將要來繼續介紹在 Vitest 中有哪些測試替身囉！</p>
<blockquote>
<p>結果昨天還在說最近變天有點小感冒，今天眼睛就馬上紅腫RRRRRR⋯⋯<br>還好休息一下吃個 B 群什麼的有稍微好一點<br>決定先把 Vue Test Utils 的部分寫好，明天繼續再戰！！！</p>
</blockquote>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【概念ノ章】測試替身（Test Double）：Dummy, Stub, Spy, Fake &amp; Mock</title>
    <url>/testing/ithelp-2022-vitest-26/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>目前有關測試相關文章幾乎都會提及的 <strong>測試替身（Test Double）</strong> 一詞，主要可追溯自 Gerard Meszaros 於 2007 年所寫的<a href="https://www.tenlong.com.tw/products/9780131495050" target="_blank" rel="noopener">《xUnit Test Patterns》</a>。</p>
<p>在書中的測試替身模式（Test Double Patterns）章節裡。作者詳細描述測試替身在做的事情，並根據測試替身所模擬的環節再進一步細分出五種不同測試替身各自能做的事情，而本文主要將參照該書中所提及的內容，以前端測試的角度來詮釋測試替身的概念。</p>
<a id="more"></a>

<hr>
<h1 id="受測物（SUT）與依賴物（DOC）"><a href="#受測物（SUT）與依賴物（DOC）" class="headerlink" title="受測物（SUT）與依賴物（DOC）"></a>受測物（SUT）與依賴物（DOC）</h1><p>要認識測試替身最有效的方式，要從觀察受測物（System Under Test，SUT）與依賴物（Depended-On Component，DOC）在測試案例中的關係開始。</p>
<p>首先，我們假設專案中有 <code>SectionBlock</code> 與 <code>SectionBlockTitle</code> 兩個元件可供我們使用：</p>
<p>SectionBlock.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section-block-title</span> <span class="attr">:title</span>=<span class="string">"title"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SectionBlockTitle.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span> &#123;&#123; title &#125;&#125; <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>SectionBlock</code> 在樣版中使用了 <code>SectionBlockTitle</code> 元件。</p>
<p>後續若針對 <code>SectionBlock</code> 元件在撰寫元件測試的時候，我們可能會遇到下列這種情況：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> component <span class="keyword">from</span> <span class="string">'./SectionBlock.vue'</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">'should ...'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component) <span class="comment">// 實際上依賴於 SectionBlockTitle 元件</span></span><br><span class="line"></span><br><span class="line">    expect(wrapper.html()).toMatchInlineSnapshot()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在這個測試案例中，我們測試目標主要是以 <code>SectionBlock</code> 元件為主，因此 <code>SectionBlock</code> 即為受測物（SUT），而受測物本身依賴的 <code>SectionBlockTitle</code> 元件即為依賴物（DOC）。</p>
<p>然而，由於我們現在尚未把依賴物給取代掉，因此測試結果會受到依賴物的影響；也就是說，未來若 <code>SectionBlockTitle</code> 元件的更動了，都會有機會間接導致 <code>SectionBlock</code> 的相關測試案例失敗。</p>
<p>這時，若我們想要使測試案例更加的單純，讓測試結果更加地專注在受測物身上，此時我們就會需要測試替身來隔離我們的依賴物。</p>
<hr>
<h1 id="測試替身"><a href="#測試替身" class="headerlink" title="測試替身"></a>測試替身</h1><p><img src="https://ithelp.ithome.com.tw/upload/images/20221011/20119062N17Kuqdtxl.png" alt="https://ithelp.ithome.com.tw/upload/images/20221011/20119062N17Kuqdtxl.png"></p>
<blockquote>
<p>上圖參考《xUnit Test Patterns》一書重新繪製</p>
</blockquote>
<p>測試替身（Test Double）最主要的概念，就是以不同的模仿程度與模仿方式替代我們的依賴物（DOC），而最終目標之一則在於使我們的測試流程能夠更加單純。</p>
<p>以上方的測試案例來說，若我們想更專注於 <code>SectionBlock</code> 元件本身的行為時，這時可以透過先前提過的 <code>shallowMount</code> 容器來隔離子層元件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should ...'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(component) <span class="comment">// 透過 shallowMount 底下的元件將強迫渲染成 &lt;-stub&gt; 元件</span></span><br><span class="line"></span><br><span class="line">    expect(wrapper.html()).toMatchInlineSnapshot()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>經由 <code>shallowMount</code> 的幫助，現在 <code>SectionBlockTitle</code> 將會被固定渲染為 <code>&lt;section-block-title-stub&gt;</code> 元素，因此接下來在測試案例中我們就不用時時刻刻擔心 <code>SectionBlockTitle</code> 元件所帶來的任何影響，而這個 <code>&lt;-stub&gt;</code> 元件，即是測試替身的其中一種類型的呈現。</p>
<p>現在我們已經瞭解測試替身在整個測試中大致上的定位了，然而我們還有什麼時候會需要他呢？</p>
<h2 id="使用時機"><a href="#使用時機" class="headerlink" title="使用時機"></a>使用時機</h2><p>當我們在使用測試替身時，此時可能意味著我們在撰寫測試案例時有下列需求：</p>
<ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10296174" target="_blank" rel="noopener">孤立型（Solitary）</a> 門派的單元測試寫法會想將受測物本身邏輯隔離出來，盡可能不受依賴物影響。</li>
<li>觀察並斷言受測物與依賴物之間的互動，但是沒有可以紀錄的方式。</li>
<li>想查看依賴物所產生的結果，但依賴物本身並不會直接返回結果，因此無法斷言。</li>
<li>依賴物需要執行較長一段時間才會回應受測物需要的內容，固定將其假扮成某個特定回傳值來減少等待時間。（遵循優良測試 <a href="https://ithelp.ithome.com.tw/articles/10298760" target="_blank" rel="noopener">F.I.R.S.T</a>中的快速原則）</li>
</ul>
<p>只要有上面的需求，基本上我們就可以透過測試替身來協助我們達成，而我們要做的事情，便是根據不同的使用時機與目的來挑選合適的測試替身。</p>
<h2 id="測試替身種類與用法"><a href="#測試替身種類與用法" class="headerlink" title="測試替身種類與用法"></a>測試替身種類與用法</h2><p>測試替身型態百百種，而依據 Gerard Meszaros 於《xUnit Test Patterns》一書所劃分的版本，測試替身根據概念來說，總共可以分為以下五大種類型：</p>
<ul>
<li>Dummy Object</li>
<li>Test Stub</li>
<li>Test Spy</li>
<li>Mock Object</li>
<li>Fake Object</li>
</ul>
<p>接下來，我們將參考自 Martin Fowler 在 <a href="https://martinfowler.com/bliki/TestDouble.html" target="_blank" rel="noopener">Test Double</a>一文中對 Meszaros 五種測試替身的概念解說，配著 Gerard Meszaros 的測試替身概念圖，來瞭解各種測試替身的用法。</p>
<hr>
<h3 id="Dummy-Object"><a href="#Dummy-Object" class="headerlink" title="Dummy Object"></a>Dummy Object</h3><p>在整個測試案例過程中，有時候我們可能會遇到某些方法因為參數、介面需要，一定要填入某個資料，但是該資訊跟測試案例中的邏輯完全沒有關聯。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should showing when props isShow = true'</span> , () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            isShow: <span class="literal">true</span>, <span class="comment">// 真正要測試的項目</span></span><br><span class="line">            content: <span class="string">'test'</span> <span class="comment">// 此項在 component 被設為 require 選項，所以一定要填內容。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 斷言時用不到 content 中的內容，我們關注在 isShow 參數與視覺上的呈現</span></span><br><span class="line">    expect(wrapper.get(<span class="string">'[data-test="target"]'</span>).exists()).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h3><p><img src="https://ithelp.ithome.com.tw/upload/images/20221011/201190626HAgRbrP7V.png" alt="https://ithelp.ithome.com.tw/upload/images/20221011/201190626HAgRbrP7V.png"></p>
<blockquote>
<p>上圖參考《xUnit Test Patterns》一書重新繪製</p>
</blockquote>
<p>在撰寫測試時，有時候我們可能會遇到針對受測物斷言時，會受到依賴物的干擾，此時我們可以透過 <code>Stub</code> 的測試替身種類來替換掉我們不在意的部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should stubs by custom component'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> StubComponent = &#123;</span><br><span class="line">    name: <span class="string">'StubComponent'</span>,</span><br><span class="line">    template: <span class="string">'&lt;p&gt;stub content&lt;/p&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Component, &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">      stubs: &#123; <span class="attr">TargetComponent</span>: StubComponent &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  expect(wrapper.html()).toEqual(<span class="string">'&lt;div&gt;&lt;p&gt;stub content&lt;/p&gt;&lt;/div&gt;'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Spy"><a href="#Spy" class="headerlink" title="Spy"></a>Spy</h3><p><img src="https://ithelp.ithome.com.tw/upload/images/20221011/20119062mc0g2WHPpS.png" alt="https://ithelp.ithome.com.tw/upload/images/20221011/20119062mc0g2WHPpS.png"></p>
<blockquote>
<p>上圖參考《xUnit Test Patterns》一書重新繪製</p>
</blockquote>
<p>類似於 <code>Stub</code> 的測試替身情況，但這次我們關注在受測物原先要與依賴物互動的詳細資訊，而這一部分會由測試替身來代替我們捕捉。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'...'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> getApples = vi.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> collectFruit = <span class="function"><span class="params">()</span> =&gt;</span> getApples()</span><br><span class="line"></span><br><span class="line">  collectFruit()</span><br><span class="line">  collectFruit()</span><br><span class="line"></span><br><span class="line">  expect(getApples).toHaveBeenCalledTimes(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h3><p><img src="https://ithelp.ithome.com.tw/upload/images/20221011/20119062JtEfErRYBf.png" alt="https://ithelp.ithome.com.tw/upload/images/20221011/20119062JtEfErRYBf.png"></p>
<blockquote>
<p>上圖參考《xUnit Test Patterns》一書重新繪製</p>
</blockquote>
<p>當我們使用 Mock Object 這類型的測試替身來捕捉受測物的行為時，這時我們測試所關注的焦點會改為放在受測物是否如我們預期般的使用測試替身，間接證明原先使用依賴物時是否正確。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchSomething &#125; <span class="keyword">from</span> <span class="string">'./servce'</span></span><br><span class="line"></span><br><span class="line">vi.mock(<span class="string">'axios'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="keyword">get</span>: vi.fn(),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it('fetch something and axios.<span class="keyword">get</span> should have been called', async () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> fetchSomething()</span><br><span class="line"></span><br><span class="line">  expect(axios.get).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Fake"><a href="#Fake" class="headerlink" title="Fake"></a>Fake</h3><p><img src="https://ithelp.ithome.com.tw/upload/images/20221011/20119062rj1rMnx4ip.png" alt="https://ithelp.ithome.com.tw/upload/images/20221011/20119062rj1rMnx4ip.png"></p>
<blockquote>
<p>上圖參考《xUnit Test Patterns》一書重新繪製</p>
</blockquote>
<p>Fake 這一類的測試替身，基本上可以看作是依賴物的輕量版本，基本上會實作出與依賴物原先差不多的功能，但多半會為了方便測試而調整實作的內容。</p>
<p>比方在 <code>Vitest</code> 中有提供一個 API 叫 <code>vi.useFakeTimers</code>，若我們在測試案例中使用它時，我們就可以操弄有關於 <code>setTimeout</code> 或 <code>setInterval</code> 等等原先計時相關的 API。（e.g. 控制 <code>setTimeout</code> 固定幾秒回傳）</p>
<hr>
<p>看到這裡，相信讀者應該對於測試替身有個基礎的認知了，而明天開始我們將要來介紹到在 Vitest 或 Vue Test Utils 有哪些關於測試替身的語法部分，並結合今天學到的概念，完善我們的測試案例，讓測試更加的簡潔！</p>
<blockquote>
<p>最近變天有點小感冒，差點來不及發文 （怕爆</p>
</blockquote>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】測試替身（Test Double）feat. Vitest Mocking API（Function, Globals &amp; Modules）</title>
    <url>/testing/ithelp-2022-vitest-29/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h2 id="Vitest-的測試替身－續篇"><a href="#Vitest-的測試替身－續篇" class="headerlink" title="Vitest 的測試替身－續篇"></a>Vitest 的測試替身－續篇</h2><p>今天要來繼續介紹 Vitest 的這些 Mocking API：</p>
<ul>
<li>Functions：用於模擬函式</li>
<li>Globals：用於模擬全域變數</li>
<li>Modules：用於模擬模組引入</li>
</ul>
<p>接下來的內容會稍微有複雜一點點，但且讓我們先專注在學習語法的部分！</p>
<a id="more"></a>

<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>在 Vitest 中，主要有下列兩種 API 讓我們可以模擬函式的各種行為：</p>
<ul>
<li><code>vi.fn</code></li>
<li><code>vi.spyOn</code></li>
</ul>
<p>在使用 <code>vi.fn</code> 時，我們可以透過 <code>vi.fn</code> 來建立一個模擬函式，而裡頭的實作可以由我們自己決定；因此 <code>vi.fn</code> 除了可以用來模擬（Fake）某個函式的實作、搭配等等會介紹到的 <code>vi.mock</code> 來作為 <code>Mock Object</code> 的紀錄工具，甚至還能用來作為某個函式的替身（Spy）以便取得被呼叫的次數、被呼叫時帶入哪些參數等等詳細資訊：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should mocking a function'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn() <span class="comment">// 返回一個可呼叫的模擬函式</span></span><br><span class="line"></span><br><span class="line">  mockFn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)   <span class="comment">// 呼叫模擬函式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取得模擬函式的呼叫紀錄</span></span><br><span class="line">  expect(mockFn).toHaveBeenCalled()</span><br><span class="line">  expect(mockFn).toHaveBeenCalledWith(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  expect(mockFn).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而在使用 <code>vi.spyOn</code> 時，我們最主要是用來綁定一個物件的既有方法，在不破壞原有方法實作的情況下作為該方法的替身（Spy）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should spying a function'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> utils = &#123;</span><br><span class="line">    add: <span class="function"><span class="params">()</span> =&gt;</span> cache.count++,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> spy = vi.spyOn(utils, <span class="string">'add'</span>) <span class="comment">// 測試替身綁定在 utils.add 身上</span></span><br><span class="line"></span><br><span class="line">  utils.add() <span class="comment">// 呼叫 utils.add</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 透過 spyOn 取得該方法的相關紀錄</span></span><br><span class="line">  expect(spy).toHaveBeenCalled()</span><br><span class="line">  expect(spy).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">  expect(cache.count).toEqual(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="MockInstance-API"><a href="#MockInstance-API" class="headerlink" title="MockInstance API"></a>MockInstance API</h1><p>而在透過 <code>vi.fn()</code> 或 <code>vi.spyOn()</code> 模擬與綁定過方法時，這兩隻 API 會返回一個 <code>MockInstance</code> 物件，而透過這個物件，我們就可以取得當下模擬函式、方法的相關資訊，甚至進一步對模擬的內容進行更細微的控制來達到測試案例的各種需求。</p>
<p>而 <code>MockInstance</code> 物件本身主要包含了兩大部分：</p>
<ul>
<li>MockInstance Properties</li>
<li>MockInstance Methods</li>
</ul>
<h2 id="MockInstance-Properties"><a href="#MockInstance-Properties" class="headerlink" title="MockInstance Properties"></a>MockInstance Properties</h2><p><code>MockInstance</code> 屬性大部分都是讓我們取得模擬函式、方法呼叫有關的資訊：</p>
<ul>
<li>mock.calls</li>
<li>mock.lastCall</li>
<li>mock.results</li>
<li>mock.instances</li>
</ul>
<h3 id="mock-calls-amp-mock-lastCall"><a href="#mock-calls-amp-mock-lastCall" class="headerlink" title="mock.calls &amp; mock.lastCall"></a>mock.calls &amp; mock.lastCall</h3><p>當我們需要斷言呼叫函式所帶入的參數時，可以透過 <code>mock.calls</code> 來取得，其儲存的格式為二維陣列：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should get mock.calls'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn()</span><br><span class="line"></span><br><span class="line">  mockFn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// first call</span></span><br><span class="line">  mockFn(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// second call</span></span><br><span class="line"></span><br><span class="line">  expect(mockFn.mock.calls).toEqual(</span><br><span class="line">    [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="comment">// first call</span></span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="comment">// second call</span></span><br><span class="line">    ]</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若只想查詢最後一次呼叫時的參數，則可以透過 <code>mock.lastCall</code> 來取得，其儲存的格式為一維陣列：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should get mock.lastCall'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn()</span><br><span class="line"></span><br><span class="line">  mockFn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// first call</span></span><br><span class="line">  mockFn(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// second call &amp; last call</span></span><br><span class="line"></span><br><span class="line">  expect(mockFn.mock.lastCall).toEqual(</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] <span class="comment">// last call</span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="mock-results"><a href="#mock-results" class="headerlink" title="mock.results"></a>mock.results</h3><p>以陣列紀錄函式被呼叫時的回傳值，其中每個物件都有兩個屬性：</p>
<ul>
<li>type： 回傳值的類型。（<code>return</code> 或 <code>throw</code>）</li>
<li>value：回傳值的內容。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should get mock.results'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn()</span><br><span class="line"></span><br><span class="line">  mockFn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// first call</span></span><br><span class="line">  mockFn(<span class="number">4</span>, <span class="number">5</span>) <span class="comment">// second call</span></span><br><span class="line"></span><br><span class="line">  expect(mockFn.mock.results).toEqual(</span><br><span class="line">    [</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">'return'</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;, <span class="comment">// first call</span></span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">'throw'</span>, <span class="attr">value</span>: <span class="built_in">Error</span> &#125;, <span class="comment">// second call</span></span><br><span class="line">    ]</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="mock-instances"><a href="#mock-instances" class="headerlink" title="mock.instances"></a>mock.instances</h3><p>以陣列紀錄函式被呼叫時的參照來源（reference）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should get mock.instances'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">'obj1'</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">'obj2'</span> &#125;</span><br><span class="line"></span><br><span class="line">  mockFn.call(obj1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// first call</span></span><br><span class="line">  mockFn.call(obj2, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// second call</span></span><br><span class="line"></span><br><span class="line">  expect(mockFn.mock.instances).toEqual(</span><br><span class="line">    [</span><br><span class="line">        obj1, <span class="comment">// first call</span></span><br><span class="line">        obj2, <span class="comment">// second call</span></span><br><span class="line">    ]</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="MockInstance-Methods"><a href="#MockInstance-Methods" class="headerlink" title="MockInstance Methods"></a>MockInstance Methods</h2><p>除了上述的屬性（MockInstance Properties）外，<code>MockInstance</code> 物件還包含了一些方法，讓我們可以進一步控制模擬函式、方法的行為，依據不同的用途還可進一步分為：</p>
<p>將 Mock 復原：</p>
<ul>
<li>mockClear</li>
<li>mockReset</li>
<li>mockRestore</li>
</ul>
<p>仿造函式、方法實作：</p>
<ul>
<li>mockImplementation &amp; mockImplementationOnce</li>
</ul>
<p>仿造回傳內容：</p>
<ul>
<li>mockReturnValue &amp; mockReturnValueOnce</li>
<li>mockResolvedValue &amp; mockResolvedValueOnce</li>
<li>mockRejectedValue &amp; mockRejectedValueOnce</li>
</ul>
<h3 id="mockClear"><a href="#mockClear" class="headerlink" title="mockClear"></a>mockClear</h3><p>清除 <code>mock.calls</code>、<code>mock.results</code> 屬性中原先的內容並回傳空陣列：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should clear mock.calls &amp; mock.results'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn()</span><br><span class="line"></span><br><span class="line">  mockFn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// first call</span></span><br><span class="line">  mockFn(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// second call</span></span><br><span class="line"></span><br><span class="line">  mockFn.mockClear()</span><br><span class="line"></span><br><span class="line">  expect(mockFn.mock.calls).toEqual([])</span><br><span class="line">  expect(mockFn.mock.results).toEqual([])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="mockReset"><a href="#mockReset" class="headerlink" title="mockReset"></a>mockReset</h3><p>除了做了與 <code>mockClear</code> 一樣的事情之外，還會將實作替換成一個空的函式並且固定回傳 <code>undefined</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should reset mock.calls &amp; mock.results'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'mock'</span>)</span><br><span class="line"></span><br><span class="line">  mockFn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// first call</span></span><br><span class="line">  mockFn(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// second call</span></span><br><span class="line"></span><br><span class="line">  mockFn.mockReset()</span><br><span class="line"></span><br><span class="line">  expect(mockFn.mock.calls).toEqual([])</span><br><span class="line">  expect(mockFn.mock.results).toEqual([])</span><br><span class="line">  expect(mockFn()).not.toBeUndefined()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="mockRestore"><a href="#mockRestore" class="headerlink" title="mockRestore"></a>mockRestore</h3><p>除了做了與 <code>mockReset</code> 一樣的事情之外，還會將實作替換成原本的實作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should restore mock.calls &amp; mock.results'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'mock'</span>)</span><br><span class="line"></span><br><span class="line">  mockFn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// first call</span></span><br><span class="line">  mockFn(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// second call</span></span><br><span class="line"></span><br><span class="line">  mockFn.mockRestore()</span><br><span class="line"></span><br><span class="line">  expect(mockFn.mock.calls).toEqual([])</span><br><span class="line">  expect(mockFn.mock.results).toEqual([])</span><br><span class="line">  expect(mockFn()).not.toBeUndefined()</span><br><span class="line">  expect(mockFn()).toBe(<span class="string">'mock'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Mock-Implementation"><a href="#Mock-Implementation" class="headerlink" title="Mock Implementation"></a>Mock Implementation</h3><p><code>mockImplementation</code> 會將函式、方法的實作替換成傳入的函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should mockImplementation'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'original'</span>)</span><br><span class="line">  mockFn.mockImplementation(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'mock'</span>)</span><br><span class="line">  expect(mockFn()).toBe(<span class="string">'mock'</span>)</span><br><span class="line">  expect(mockFn()).toBe(<span class="string">'mock'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若你想要只替換一次的話，可以使用 <code>mockImplementationOnce</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should mockImplementationOnce'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn()</span><br><span class="line">  mockFn.mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'mock'</span>)</span><br><span class="line">  expect(mockFn()).toBe(<span class="string">'mock'</span>)</span><br><span class="line">  expect(mockFn()).not.toBe(<span class="string">'mock'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="Mock-Return-Value"><a href="#Mock-Return-Value" class="headerlink" title="Mock Return Value"></a>Mock Return Value</h3><p>若想要將將函式、方法的回傳值替換成傳入的值，可以使用 <code>mockReturnValue</code> 替換：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should mockReturnValue'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn()</span><br><span class="line">  mockFn.mockReturnValue(<span class="string">'mock'</span>)</span><br><span class="line">  expect(mockFn()).toBe(<span class="string">'mock'</span>)</span><br><span class="line">  expect(mockFn()).toBe(<span class="string">'mock'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同樣地若你想要只替換一次的話，可以改使用 <code>mockReturnValueOnce</code> ，這裡不再展示了。</p>
<h3 id="Mock-Promise-Value"><a href="#Mock-Promise-Value" class="headerlink" title="Mock Promise Value"></a>Mock Promise Value</h3><ul>
<li>mockResolvedValue</li>
<li>mockResolvedValueOnce</li>
<li>mockRejectedValue</li>
<li>mockRejectedValueOnce</li>
</ul>
<p>若想要仿造 <code>Promise.resolve</code> 的回傳值，可以使用 <code>mockResolvedValue</code>，仿造一次的話則是使用 <code>mockResolvedValueOnce</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should mockResolvedValue'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'original'</span>)</span><br><span class="line">  mockFn.mockResolvedValue(<span class="string">'mock'</span>)</span><br><span class="line">  expect(<span class="keyword">await</span> mockFn()).toBe(<span class="string">'mock'</span>)</span><br><span class="line">  expect(<span class="keyword">await</span> mockFn()).toBe(<span class="string">'mock'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而若是要仿造 <code>Promise.reject</code> 的回傳值，則是替換為 <code>mockRejectedValue</code> 與 <code>mockRejectedValueOnce</code> 即可。</p>
<p>以上就是 <code>MockInstance</code> 的所有方法，若弄清楚他的屬性與方法的作用，並且分清楚何時使用 <code>vi.fn</code> 與 <code>vi.spyOn</code>，接下來要學習其他 Mocking API 就會變得輕鬆許多。</p>
<hr>
<h3 id="Globals"><a href="#Globals" class="headerlink" title="Globals"></a>Globals</h3><p>若要模擬全域變數，可以使用 <code>vi.stubGlobal</code> 這個 API，它接受兩個參數：</p>
<ul>
<li><code>name</code>：全域變數的名稱</li>
<li><code>value</code>：全域變數實際的內容</li>
</ul>
<p>比方我們在測試案例中有邏輯與 <code>window</code> 有相關的時候，就可以這樣使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should stubGlobal'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockWindow = &#123;</span><br><span class="line">    location: &#123;</span><br><span class="line">      href: <span class="string">'https://example.com'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  vi.stubGlobal(<span class="string">'window'</span>, mockWindow)</span><br><span class="line"></span><br><span class="line">  expect(<span class="built_in">window</span>.location.href).toBe(<span class="string">'https://example.com'</span>)</span><br><span class="line">  expect(<span class="comment">/* 或針對相關邏輯做斷言 */</span>).toBe(<span class="string">'https://example.com'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若是想模擬 <code>localStorage</code> 也沒有問題，甚至結合 <code>vi.fn</code> 來捕捉使用情形：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should stubGlobal'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockLocalStorage = &#123;</span><br><span class="line">    getItem: vi.fn(),</span><br><span class="line">    setItem: vi.fn(),</span><br><span class="line">  &#125;</span><br><span class="line">  vi.stubGlobal(<span class="string">'localStorage'</span>, mockLocalStorage)</span><br><span class="line">  localStorage.setItem(<span class="string">'key'</span>, <span class="string">'value'</span>)</span><br><span class="line">  expect(localStorage.getItem).toHaveBeenCalledWith(<span class="string">'key'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>最後若我們在開發過程中可能會 import 其他的模組來開發，這時候就可以使用 <code>vi.mock</code> 來模擬模組的行為。</p>
<p>而在使用 <code>vi.mock</code> 時，主要可以傳入兩個參數：</p>
<ul>
<li><code>path</code>：模組的路徑</li>
<li><code>factory</code>：工廠函式，用來替代模組的實際內容</li>
</ul>
<p>假設我們有個 <code>utils</code> 工具集：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn, delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 預設匯出(default export)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; debounce, throttle &#125;</span><br></pre></td></tr></table></figure>

<p>則在測試案例中我們可以這樣使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./utils'</span></span><br><span class="line"></span><br><span class="line">vi.mock(<span class="string">'./utils'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 預設匯出(default export)要使用 default 作為屬性名稱</span></span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      debounce: vi.fn(),</span><br><span class="line">      throttle: vi.fn(),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'should mock'</span>, () =&gt; &#123;</span><br><span class="line">  utils.debounce()</span><br><span class="line">  expect(utils.debounce).toHaveBeenCalled()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若是在匯出模組時採用的是具名匯出(named export)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> debounce = <span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> throttle = <span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>

<p>則工廠方法的屬性要使用具名匯出的屬性名稱：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vi.mock(<span class="string">'./utils'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    debounce: vi.fn(),</span><br><span class="line">    throttle: vi.fn(),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>到這裡 Vitest Mocking API 的介紹就差不多結束哩，當然還有一些更細微且深入的用法沒介紹到，不過看到這裡你已經能應付大部分的模擬情境了。</p>
<p>若你覺得意猶未盡的話也可以直接參考 <a href="https://vitest.dev/guide/mocking.html" target="_blank" rel="noopener">Vitest 官方文件</a>，官方也很貼心的準備了 Cheat Sheet，可以根據想模擬的類型來快速找到相關的 API。</p>
<p>而在學習完測試替身之後，接下來我們終於可以來介紹要如何模擬第三方工具庫啦！敬請期待！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】測試替身（Test Double）feat. Vitest Mocking API（Date, Timer）</title>
    <url>/testing/ithelp-2022-vitest-28/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>今天要來介紹在 Vitest 工具中，有關於測試替身的語法有哪些內容，並且一樣會參考 Gerard Meszaros 的<a href="https://ithelp.ithome.com.tw/articles/10307288" target="_blank" rel="noopener">五大測試替身概念</a>，來看看我們應該如何實際應用在真實的測試案例當中！</p>
<a id="more"></a>

<h2 id="Vitest-的測試替身"><a href="#Vitest-的測試替身" class="headerlink" title="Vitest 的測試替身"></a>Vitest 的測試替身</h2><p>Vitest 本身作為測試執行環境工具，提供的測試替身（Test Doubles）種類與應用範圍比起 Vue Test Utils 要來的多且廣泛，而在 Vitest 官方<a href="https://vitest.dev/guide/mocking.html" target="_blank" rel="noopener">文件</a>中對於這一類的測試替身相關的內容泛稱為 「Mocking」；因此，本文將以「Mocking API」 統稱這些 Vitest API，並不代表這些 API 都屬於五大分類中 Mock 類型的測試替身喔！</p>
<p>而 Vitest Mocking API，主要都放置於 <code>vi</code> 模組底下，因此若要使用 Vitest Mocking API 時，我們只要在測試檔案底下引入即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; describe, it, expect, vi&#125; <span class="keyword">from</span> <span class="string">'vitest'</span></span><br></pre></td></tr></table></figure>

<p>若你覺得每個檔案都要這樣引入太麻煩的話，我們可以在 Vitest <a href="https://ithelp.ithome.com.tw/articles/10294024" target="_blank" rel="noopener">Config</a> 中設定 <code>test.globals</code> 為 <code>true</code>，如此一來 Vitest API 將會以全域性的方式提供，我們就不必每次都要在測試檔案中引入 Vitest 了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'vitest/config'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  test: &#123;</span><br><span class="line">    globals: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>倘若專案中有使用到 <a href="https://eslint.org/" target="_blank" rel="noopener">esLint</a> 工具協助糾錯的話，此時會因為 Vitest API 沒有被引入而顯示宣告上有錯誤，因此我們要在 <code>.eslintrc.json</code> 中主動告知有哪些是屬於全域性的變數：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">"globals"</span>: &#123;</span><br><span class="line">    <span class="string">"describe"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"it"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"expect"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"vi"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若專案中有使用到 TypeScript 的話，則需在 <code>tsconfig.json</code> 中補上 <code>types</code>，如此一來就能抓到透過全域變數的型別：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"types"</span>: [<span class="string">"vitest/globals"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在設定完這些後，我們就可以來看看 Vitest Mocking API 有哪些方法。</p>
<h2 id="Vitest-Mocking-API"><a href="#Vitest-Mocking-API" class="headerlink" title="Vitest Mocking API"></a>Vitest Mocking API</h2><p>Vitest 本身內建的 Mocking API 主要有以下幾種分類：</p>
<ul>
<li>Dates：用於模擬日期</li>
<li>Timers：用於模擬計時器（<code>setTimeout</code>、<code>setInterval</code>）</li>
<li>Functions：用於模擬函式</li>
<li>Globals：用於模擬全域變數</li>
<li>Modules：用於模擬模組引入</li>
</ul>
<h3 id="Dates"><a href="#Dates" class="headerlink" title="Dates"></a>Dates</h3><p>在開發的過程中，有時候我們可能會遇到功能實作與系統時間有關的實作，這時候我們就可以使用這些 API 來協助我們進行測試：</p>
<ul>
<li><code>vi.useFakeTimers</code></li>
<li><code>vi.setSystemTime</code></li>
<li><code>vi.useRealTimers</code></li>
<li><code>vi.getMockedSystemTime</code></li>
<li><code>vi.getRealSystemTime</code></li>
<li><code>vi.restoreCurrentDate</code></li>
</ul>
<p>在測試案例中模擬日期時，我們可以透過 <code>vi.useFakeTimers</code> 來模擬系統時間，接著就可以透過 <code>vi.setSystemTime</code> 設定模擬系統時間：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should mock system time'</span>, () =&gt; &#123;</span><br><span class="line">    vi.useFakeTimers()</span><br><span class="line">    vi.setSystemTime(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2022-10-13'</span>))</span><br><span class="line"></span><br><span class="line">    expect(<span class="keyword">new</span> <span class="built_in">Date</span>()).toEqual(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2022-10-13'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若要恢復模擬系統時間，可以透過 <code>vi.useRealTimers</code> 來恢復系統時間：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">it(<span class="string">'should restore system time'</span>, () =&gt; &#123;</span><br><span class="line">    vi.useFakeTimers()</span><br><span class="line">    vi.setSystemTime(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2022-10-13'</span>))</span><br><span class="line">    vi.useRealTimers()</span><br><span class="line"></span><br><span class="line">    expect(<span class="keyword">new</span> <span class="built_in">Date</span>()).not.toEqual(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2022-10-13'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也可以結合先前 Setup &amp; Teardown API 的概念，快速設定各個測試案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> formatDateTime = <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> year = date.getFullYear()</span><br><span class="line">  <span class="keyword">const</span> month = date.getMonth() + <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> day = date.getDate()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;year&#125;</span>-<span class="subst">$&#123;month&#125;</span>-<span class="subst">$&#123;day&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'mock system time'</span>, () =&gt; &#123;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    vi.useFakeTimers()</span><br><span class="line">  &#125;)</span><br><span class="line">  afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    vi.useRealTimers()</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'should mock system time'</span>, () =&gt; &#123;</span><br><span class="line">    vi.setSystemTime(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2022-10-13'</span>))</span><br><span class="line">    expect(<span class="keyword">new</span> <span class="built_in">Date</span>()).toEqual(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2022-10-13'</span>))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should restore system time'</span>, () =&gt; &#123;</span><br><span class="line">    expect(formatDateTime(<span class="keyword">new</span> <span class="built_in">Date</span>())).toEqual(formatDateTime(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2022-10-13'</span>)))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若要取得目前模擬的系統時間，可以透過 <code>vi.getMockedSystemTime</code> 來取得：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should get mocked system time'</span>, () =&gt; &#123;</span><br><span class="line">    vi.useFakeTimers()</span><br><span class="line">    vi.setSystemTime(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2022-10-13'</span>))</span><br><span class="line"></span><br><span class="line">    expect(vi.getMockedSystemTime()).toEqual(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2022-10-13'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若要取得目前真實系統的時間，則可以透過 <code>vi.getRealSystemTime</code> 來取得：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should get real system time'</span>, () =&gt; &#123;</span><br><span class="line">    vi.useFakeTimers()</span><br><span class="line">    vi.setSystemTime(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2022-10-13'</span>))</span><br><span class="line"></span><br><span class="line">    expect(vi.getRealSystemTime()).not.toEqual(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2022-10-13'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後，想要將從模擬系統時間恢復成真實系統的時間，可以透過 <code>vi.restoreCurrentDate</code> 來恢復：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should restore current date'</span>, () =&gt; &#123;</span><br><span class="line">    vi.useFakeTimers()</span><br><span class="line">    vi.setSystemTime(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2022-10-13'</span>))</span><br><span class="line">    vi.restoreCurrentDate()</span><br><span class="line"></span><br><span class="line">    expect(<span class="keyword">new</span> <span class="built_in">Date</span>()).not.toEqual(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2022-10-13'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a>Timers</h3><p>Vitest 也提供了與計時器相關的 API，讓我們可以模擬 <code>setTimeout</code>、<code>setInterval</code> 的行為：</p>
<ul>
<li><code>vi.useFakeTimers</code></li>
<li><code>vi.runAllTimers</code></li>
<li><code>vi.runOnlyPendingTimers</code></li>
<li><code>vi.advanceTimersByTime</code></li>
<li><code>vi.advanceTimersToNextTimer</code></li>
<li><code>vi.restoreAllMocks</code></li>
</ul>
<p>與日期相關的 API 類似，在模擬計時器之前，我們要透過 <code>vi.useFakeTimers</code> 讓當下環境中的計時器指定為模擬的計時器，接著就可以使用 <code>runAllTimers</code> 讓模擬計時器開始執行計時的功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should mock timers'</span>, () =&gt; &#123;</span><br><span class="line">    vi.useFakeTimers()</span><br><span class="line">    <span class="keyword">const</span> mockFn = vi.fn()</span><br><span class="line"></span><br><span class="line">    setTimeout(mockFn, <span class="number">1000</span>)</span><br><span class="line">    vi.runAllTimers()</span><br><span class="line"></span><br><span class="line">    expect(mockFn).toHaveBeenCalled()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>有時候我們計時器可能會有遞迴的情況，這時候可以透過 <code>vi.runOnlyPendingTimers</code> 來執行下一個應該要執行的計時器，從而捕捉各個計時器之間發生過程的相關內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should run only pending timers'</span>, () =&gt; &#123;</span><br><span class="line">  vi.useFakeTimers()</span><br><span class="line">  <span class="keyword">const</span> cache = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    cache.count++</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      mockFn()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  mockFn() <span class="comment">// 此時 cache.count === 1</span></span><br><span class="line"></span><br><span class="line">  expect(cache.count).toEqual(<span class="number">1</span>)</span><br><span class="line">  vi.runOnlyPendingTimers() <span class="comment">// 執行下一個 setTimeout</span></span><br><span class="line">  expect(cache.count).toEqual(<span class="number">2</span>)</span><br><span class="line">  vi.runOnlyPendingTimers() <span class="comment">// 執行下一個 setTimeout</span></span><br><span class="line">  expect(cache.count).toEqual(<span class="number">3</span>)</span><br><span class="line">  vi.runOnlyPendingTimers() <span class="comment">// 執行下一個 setTimeout</span></span><br><span class="line">  expect(cache.count).toEqual(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>除了階段性的執行計時器，若想直接讓計時器被提前到指定的時間，可以透過 <code>vi.advanceTimersByTime</code> 來達成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should advance timers by time'</span>, () =&gt; &#123;</span><br><span class="line">  vi.useFakeTimers()</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn()</span><br><span class="line"></span><br><span class="line">  setTimeout(mockFn, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">  vi.advanceTimersByTime(<span class="number">999</span>) <span class="comment">// 計時器被提前 999 毫秒執行</span></span><br><span class="line">  expect(mockFn).not.toHaveBeenCalled()</span><br><span class="line">  vi.advanceTimersByTime(<span class="number">1</span>) <span class="comment">// 計時器被提前 1000 毫秒執行</span></span><br><span class="line">  expect(mockFn).toHaveBeenCalled()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若想直接讓計時器被提前到下一個計時器的時間，可以透過 <code>vi.advanceTimersToNextTimer</code> 來達成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should advance timers to next timer'</span>, () =&gt; &#123;</span><br><span class="line">  vi.useFakeTimers()</span><br><span class="line">  <span class="keyword">const</span> mockFn = vi.fn()</span><br><span class="line"></span><br><span class="line">  setTimeout(mockFn, <span class="number">1000</span>)</span><br><span class="line">  setTimeout(mockFn, <span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">  vi.advanceTimersToNextTimer() <span class="comment">// 所有計時器提前了 1000 毫秒</span></span><br><span class="line">  expect(mockFn).toHaveBeenCalled()</span><br><span class="line">  vi.advanceTimersToNextTimer() <span class="comment">// 所有計時器被提前了 3000 毫秒</span></span><br><span class="line">  expect(mockFn).toHaveBeenCalled()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後，如果想要將從模擬計時器恢復成真實計時器的時候，可以透過 <code>vi.restoreAllMocks</code> 方法達成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should restore all mocks'</span>, () =&gt; &#123;</span><br><span class="line">    vi.useFakeTimers()</span><br><span class="line">    <span class="keyword">const</span> mockFn = vi.fn()</span><br><span class="line"></span><br><span class="line">    setTimeout(mockFn, <span class="number">1000</span>)</span><br><span class="line">    vi.restoreAllMocks()</span><br><span class="line"></span><br><span class="line">    expect(mockFn).not.toHaveBeenCalled()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>今日 Vitest Mocking API 先介紹到這邊，相信光是模擬日期與計時器的 API，就足夠讓你驚訝於 Vitest Mocking API 的威力，在瀏覽器環境囂張的計時器，在測試環境中，竟然可以如此任由我們所擺佈。</p>
<p>但最重要的是由於我們可以細微的控制日期與計時器的執行時機，因此可以讓我們的測試案例能夠模擬各種不同的狀況，讓我們的測試案例能更加完整與彈性。</p>
<p>而明天我們將會繼續介紹 Vitest Mocking API 的其他功能，學習完這些內容之後，我們就可以開始來寫有關 Vue 周邊工具的測試案例了！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】Vue Ecosystem 篇：Pinia 測試</title>
    <url>/testing/ithelp-2022-vitest-31/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="Pinia-測試"><a href="#Pinia-測試" class="headerlink" title="Pinia 測試"></a>Pinia 測試</h1><ul>
<li>Pinia 簡介</li>
<li>Pinia 測試關注點</li>
<li>Pinia 測試實作<ul>
<li>測試 Store 本身行為</li>
<li>測試 Store 與 Vue 元件之間的互動</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="Pinia-簡介"><a href="#Pinia-簡介" class="headerlink" title="Pinia 簡介"></a>Pinia 簡介</h2><p>隨著專案規模越大，在管理共用狀態上就越不容易，這時後就會需要一個狀態管理工具來協助我們處理這些問題。</p>
<p>而 Pinia 便是一個以 Vuex 的概念為基礎的狀態管理工具，它除了沿用了部分 Vuex 概念之外，還兼容了 Vue 3 中的 Composition API 的語法，讓我們在專案中可以更方便的管理狀態之外，還能讓專案中的程式碼風格統一。</p>
<h2 id="Pinia-測試關注點"><a href="#Pinia-測試關注點" class="headerlink" title="Pinia 測試關注點"></a>Pinia 測試關注點</h2><p>根據不同專案中的設計與應用，測試 Pinia 的難度與複雜度也會有所不同，而依據受測物的不同我們大概能分為兩類：</p>
<ul>
<li>以 Pinia 作為受測物，測試本身行為所影響的狀態結果是否正確</li>
<li>以 Vue 元件作為受測物，測試與 Pinia 互動的行為是否正確</li>
</ul>
<p>接著底下實作的部分就以這兩個關注點為主，來介紹如何測試 Pinia。</p>
<h2 id="Pinia-測試實作"><a href="#Pinia-測試實作" class="headerlink" title="Pinia 測試實作"></a>Pinia 測試實作</h2><h3 id="測試-Store-本身行為"><a href="#測試-Store-本身行為" class="headerlink" title="測試 Store 本身行為"></a>測試 Store 本身行為</h3><p>在測試 Pinia 本身行為時，由於我們會使用到真實的 Store 來進行操作，因此在測試案例前我們必須先透過 <code>setActivePinia</code> 來活化（active）Pinia 實體：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setActivePinia, createPinia &#125; <span class="keyword">from</span> <span class="string">'pinia'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store</span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setActivePinia(createPinia())</span><br><span class="line">  store = useStore()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接著就可以根據我們 Store 的設計來撰寫測試案例：</p>
<p>Store</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">'pinia'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = defineStore(<span class="string">'counter'</span>, &#123;</span><br><span class="line">  state: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.count * <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      <span class="keyword">this</span>.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement() &#123;</span><br><span class="line">      <span class="keyword">this</span>.count--</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在撰寫測試案例時，要注意到我們只關注在 state 的預期變化，也就是說：</p>
<ul>
<li>操作 action 後 state 最後的變化是否正確</li>
<li>使用 getter 取值時，最後預期的結果是否正確</li>
</ul>
<p>Counter.spec.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setActivePinia, createPinia &#125; <span class="keyword">from</span> <span class="string">'pinia'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useCounterStore &#125; <span class="keyword">from</span> <span class="string">'@/stores/counter'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Counter Store'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> store</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setActivePinia(createPinia())</span><br><span class="line">    store = useCounterStore()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should increment count'</span>, () =&gt; &#123;</span><br><span class="line">    store.increment()</span><br><span class="line">    expect(store.count).toBe(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should decrement count'</span>, () =&gt; &#123;</span><br><span class="line">    store.decrement()</span><br><span class="line">    expect(store.count).toBe(<span class="number">-1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'should return double count'</span>, () =&gt; &#123;</span><br><span class="line">    expect(store.doubleCount).toBe(<span class="number">0</span>)</span><br><span class="line">    store.increment() <span class="comment">// count = 1</span></span><br><span class="line">    expect(store.doubleCount).toBe(<span class="number">2</span>)</span><br><span class="line">    store.increment() <span class="comment">// count = 2</span></span><br><span class="line">    store.increment() <span class="comment">// count = 3</span></span><br><span class="line">    expect(store.doubleCount).toBe(<span class="number">6</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="測試-Store-與-Vue-元件之間的互動"><a href="#測試-Store-與-Vue-元件之間的互動" class="headerlink" title="測試 Store 與 Vue 元件之間的互動"></a>測試 Store 與 Vue 元件之間的互動</h3><p>在進行 Pinia 與 Vue 元件互動時，由於我們受測物主要為 Vue 元件，因此我們要使用到 <code>@pinia/testing</code> 提供的 <code>createTestingPinia</code> 方法來幫助我們建立模擬 Pinia 實體，方便我們從中得到有關 store 的呼叫紀錄與參數等。</p>
<p>因此，首先我們要先下載 <code>@pinia/testing</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D @pinia/testing</span><br></pre></td></tr></table></figure>

<p>接著在撰寫測試案例時，由於現在我們是使用模擬的 Pinia 實體，因此我們不需要再使用 <code>setActivePinia</code> 來活化 Pinia，而是直接使用 <code>createTestingPinia</code> 來建立模擬實體，所以在測試案例建立容器時，我們可以透過 <code>globals.plugins</code> 來載入它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">    globals: &#123;</span><br><span class="line">        plugins: [createTestingPinia()],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>createTestingPinia</code> 本身除了回傳 Pinia 實體讓我們不需要在測試案例中活化 Pinia 之外，還有提供了參數讓我們操作與改變 Store 的行為：</p>
<ul>
<li>initialState</li>
<li>stubActions</li>
<li>createSpy</li>
<li>plugins</li>
</ul>
<h4 id="initialState"><a href="#initialState" class="headerlink" title="initialState"></a>initialState</h4><p><code>initialState</code> 可以讓我們在測試案例中，將 Store 的 state 初始化為我們指定的值。</p>
<p>而在使用 <code>initialState</code> 時，要帶入欲初始化 Store 的名稱，再傳入要模擬的 State 值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        createTestingPinia(&#123;</span><br><span class="line">            initialState: &#123;</span><br><span class="line">                <span class="comment">// 將 counter store 的 state 初始化為 10</span></span><br><span class="line">                counter: &#123;</span><br><span class="line">                    count: <span class="number">0</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="stubActions"><a href="#stubActions" class="headerlink" title="stubActions"></a>stubActions</h4><p>在孤立型的測試風格中，由於 Vue 元件與 Pinia 互動之間，我們比較在意的會是操作 Vue 元件時，有無呼叫到 Store 中的 Action，而不會在意 Action 內部的邏輯是否正確。</p>
<p>因此使用 <code>createTestingPinia</code> 作為測試案例的 Pinia 實體時，<strong>「預設」</strong> 會將所有的 Action 都以模擬替身（stub）的型態替換掉，改為回傳預設值。</p>
<p>所以在測試案例中無論怎麼操作 Store，都不會影響到 Store 本身的 State 值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        createTestingPinia(),</span><br><span class="line">    ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = useCounterStore() <span class="comment">// state: &#123; count: 0 &#125;</span></span><br><span class="line">store.increment() <span class="comment">// add 1 to count</span></span><br><span class="line">expect(store.count).toBe(<span class="number">0</span>) <span class="comment">// state: &#123; count: 0 &#125;</span></span><br></pre></td></tr></table></figure>

<p>倘若你希望能在測試案例中能真實交互 Store 的行為，可以透過 <code>stubActions: false</code> 來關閉對 Store Action 的隔離：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        createTestingPinia(&#123;</span><br><span class="line">            stubActions: <span class="literal">false</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = useCounterStore() <span class="comment">// state: &#123; count: 0 &#125;</span></span><br><span class="line">store.increment() <span class="comment">// add 1 to count</span></span><br><span class="line">expect(store.count).toBe(<span class="number">1</span>) <span class="comment">// state: &#123; count: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="createSpy"><a href="#createSpy" class="headerlink" title="createSpy"></a>createSpy</h4><p>在使用 Vitest 或 Jest 作為測試環境時，根據設定 <code>createTestingPinia</code> 會自動透過 <code>vi.fn</code> 或 <code>jest.fn</code> 來建立 Action 的模擬替身。</p>
<p>假如你有想要使用其他隔離庫（e.g. Sinon.js）中的測試替身函數就可以透過 <code>createSpy</code> 帶入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sinon <span class="keyword">from</span> <span class="string">'sinon'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">            createTestingPinia(&#123;</span><br><span class="line">                createSpy: sinon.spy,</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p>若在使用 Pinia 時有使用到插件（plugins）來擴充 Pinia 的功能，由於活化 Pinia 機制不同，因此我們需要透過 <code>plugins</code> 參數來顯性的將插件加入到 <code>createTestingPinia</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; myPlugin &#125; <span class="keyword">from</span> <span class="string">'./stores/plugins'</span></span><br><span class="line"><span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        createTestingPinia(&#123;</span><br><span class="line">            plugins: [myPlugin],</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而綜合以上 <code>createTestingPinia</code> 的參數，最後若我們想要撰寫孤立型測試風格的測試案例，就會像是這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should increment'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">    global: &#123;</span><br><span class="line">      plugins: [</span><br><span class="line">        createTestingPinia(&#123;</span><br><span class="line">          initialState: &#123;</span><br><span class="line">            counter: &#123;</span><br><span class="line">              count: <span class="number">0</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> store = useCounterStore()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_increment"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line">  <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_increment"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">  expect(store.increment).toHaveBeenCalledTimes(<span class="number">2</span>)</span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="content_count"]'</span>).text()).toBe(<span class="string">'1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若想要撰寫社交型風格的測試，則會像這樣撰寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should increment'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(component, &#123;</span><br><span class="line">      global: &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">          createTestingPinia(&#123;</span><br><span class="line">            initialState: &#123;</span><br><span class="line">              counter: &#123;</span><br><span class="line">                count: <span class="number">0</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            stubActions: <span class="literal">false</span>,</span><br><span class="line">          &#125;),</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button_increment"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    expect(wrapper.find(<span class="string">'[data-test="content_count"]'</span>).text()).toBe(<span class="string">'1'</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>但要注意到的是，如此一來將來在 Store 發生變更時，元件中的測試案例也會因此發生錯誤，因此在撰寫測試案例時，要適度的取捨與規劃。</p>
<p>以上就是有關於在 Vue 3 中，若使用 Pinia 作為狀態管理工具時，要如何撰寫有關於 Pinia 的測試案例！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【語法ノ章】Vue Ecosystem 篇：Vue Router 測試</title>
    <url>/testing/ithelp-2022-vitest-30/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="本文序"><a href="#本文序" class="headerlink" title="本文序"></a>本文序</h1><p>前幾天測試替身相關章節最主要的強項主要都是在當我們專案實作過程中有依賴外部模組或工具時，我們可以透過替身的方式來測試我們的邏輯，而不需要真的去執行外部模組或工具，這樣可以減少測試時間，也可以避免測試時因為外部模組或工具的問題而造成測試失敗。</p>
<p>因此測試替身我們必須先走過一次概念，才能更好的理解替身本身要做的事情；接著語法的部分則要瞭解到 Vue Test Utils 與 Vitest 提供了哪些語法可以供我們選擇使用；最後，在測試的部分我們才能透過洽當的概念和語法來撰寫出更好的測試案例。</p>
<p>所以今天我們就要來看看當我們在使用 Vue 周邊工具時，我們要如何利用測試替身來撰寫測試案例！</p>
<a id="more"></a>

<h1 id="Vue-Router-測試"><a href="#Vue-Router-測試" class="headerlink" title="Vue Router 測試"></a>Vue Router 測試</h1><ul>
<li>Vue Router 簡介</li>
<li>Vue Router 測試關注點</li>
<li>Vue Router 測試實作<ul>
<li>孤立型測試：以 Mocked Router 作為受測物</li>
<li>社交型測試：以專案中的 Router 作為受測物</li>
</ul>
</li>
</ul>
<h2 id="Vue-Router-簡介"><a href="#Vue-Router-簡介" class="headerlink" title="Vue Router 簡介"></a>Vue Router 簡介</h2><p>Vue Router 提供了 SPA 類型專案一個良好管理路由的工具，並與 Vue 有良好的整合，讓我們在開發以 Vue 為基底的專案，處理路由時能更加的輕鬆愜意。</p>
<p>而在使用 Vue Router 時，我們主要會一個基本的路由設定：</p>
<p>router.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'../views/Home.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    name: <span class="string">'Home'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ... more routes</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(process.env.BASE_URL),</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<p>接著再將設定引入到我們的 Vue 專案中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line">createApp(App).use(router).mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>如此一來，在元件開發的過程中就能透過 Vue Router APIs 來做路由上的處理：</p>
<p>App.vue:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"goToContactPage"</span>&gt;</span>Contact Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> $router = useRouter()</span><br><span class="line">    <span class="keyword">const</span> goToContactPage = <span class="function"><span class="params">()</span> =&gt;</span> $router.push(<span class="string">'/contact'</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; goToContactPage &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue-Router-測試關注點"><a href="#Vue-Router-測試關注點" class="headerlink" title="Vue Router 測試關注點"></a>Vue Router 測試關注點</h2><p>在撰寫有關 Vue Router 的測試時，我們主要會關注在模擬 End User 操作過程中，是否有正確的觸發 Vue Router 的 API，比方像是：</p>
<ul>
<li>使用者點擊 <code>&lt;router-link&gt;</code> 時，是否有正確的觸發 <code>router.push()</code> 等 API？</li>
<li>根據行為在觸發 Router APIs 時所帶的參數是否正確？</li>
<li>根據我們所設定的「潛在規則」最後所導向的路由是否正確？</li>
</ul>
<p>而我們只要確保這部分能正確的被測試到，基本上就能確保我們大部分的 Vue Router 相關內容。</p>
<h2 id="Vue-Router-測試實作"><a href="#Vue-Router-測試實作" class="headerlink" title="Vue Router 測試實作"></a>Vue Router 測試實作</h2><p>在撰寫 Vue Router 測試時，我們主要可以分為兩種類型：</p>
<ul>
<li>孤立型測試：以 Mocked Router 作為受測物</li>
<li>社交型測試：以專案中的 Router 作為受測物</li>
</ul>
<p>這兩種類型的差異純屬於測試的觀察角度不同，對應實作上的差異則在於測試案例中我們要如何取得 Router 實例。</p>
<p>而接下來我們以部落格當中常見的編輯文章按鈕為例，並以 options API 與 composition API 版本來分別撰寫兩種類型的測試。</p>
<h3 id="Options-API"><a href="#Options-API" class="headerlink" title="Options API"></a>Options API</h3><p>在 options API 風格中，我們主要是透過 <code>this.$router</code> &amp; <code>this.$route</code> 來取得 Router 相關資訊與控制方法：</p>
<p>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 元件某處 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"goToEditPage"</span>&gt;</span>編輯文章<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        isUserLogin: <span class="literal">false</span> <span class="comment">// 這裡為了理解方便單純模擬判斷使用者是否登入，並非最佳實踐</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        goToEditPage() &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isUserLogin)&#123;</span><br><span class="line">                <span class="keyword">this</span>.$router.push(<span class="string">`/articles/<span class="subst">$&#123;<span class="keyword">this</span>.$route.params.id&#125;</span>/edit`</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.$router.push(<span class="string">`/login`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在-Options-API-中以孤立型測試撰寫-Vue-Router-測試"><a href="#在-Options-API-中以孤立型測試撰寫-Vue-Router-測試" class="headerlink" title="在 Options API 中以孤立型測試撰寫 Vue Router 測試"></a>在 Options API 中以孤立型測試撰寫 Vue Router 測試</h4><p>在孤立型測試中，我們可以透過 Vue Test Utils 中的容器（Wrapper）中的選項 <code>global.mocks</code> 來模擬 <code>vue-router</code> 中的 <code>$route</code> &amp; <code>$routes</code> 操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = mount(App, &#123;</span><br><span class="line">  global: &#123;</span><br><span class="line">    mocks: &#123;</span><br><span class="line">      $route: &#123;</span><br><span class="line">        params: &#123;</span><br><span class="line">          id: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      $router: &#123;</span><br><span class="line">        push: vi.fn()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而在 <code>$router</code> 中的 <code>push</code> 方法，我們可以透過 <code>vi.fn()</code> 來模擬呼叫行為，如此一來我們就可以捕捉到相關資訊。</p>
<p>最後，我們就可以根據 <code>isUserLogin</code> 選項，產生 Happy Path 與 Sad Path 的測試案例：</p>
<ul>
<li>若使用者登錄狀況下點擊編輯文章按鈕，則應該要導向 <code>/articles/{根據路由取得文章的 id}/edit</code> 的路由</li>
<li>若使用者未登錄狀況下點擊編輯文章按鈕，則應該要導向 <code>/login</code> 的路由<br>App.spec.js:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'@/App.vue'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'App.vue'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'should go to edit page when click button if user is Login'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        <span class="keyword">const</span> mockRoute = &#123;</span><br><span class="line">            params: &#123;</span><br><span class="line">                id: <span class="number">10308907</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> mockRouter = &#123;</span><br><span class="line">            push: vi.fn(),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> wrapper = mount(App, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                isUserLogin: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            global: &#123;</span><br><span class="line">                mocks: &#123;</span><br><span class="line">                    $route: mockRoute,</span><br><span class="line">                    $router: mockRouter,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// Act</span></span><br><span class="line">        <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button"]'</span>).trigger(<span class="string">'click'</span>) <span class="comment">// 點擊後應觸發 router.push() 事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert</span></span><br><span class="line">        expect(mockRouter.push).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">        expect(mockRouter.push).toHaveBeenCalledWith(<span class="string">'/articles/10308907/edit'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'should go to login page when click button if user is not Login'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> mockRoute = &#123;</span><br><span class="line">            params: &#123;</span><br><span class="line">                id: <span class="number">10308907</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> mockRouter = &#123;</span><br><span class="line">            push: vi.fn(),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> wrapper = mount(App, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                isUserLogin: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            global: &#123;</span><br><span class="line">                mocks: &#123;</span><br><span class="line">                    $route: mockRoute,</span><br><span class="line">                    $router: mockRouter,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">        expect(mockRouter.push).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">        expect(mockRouter.push).toHaveBeenCalledWith(<span class="string">'/login'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="在-Options-API-中以社交型測試撰寫-Vue-Router-測試"><a href="#在-Options-API-中以社交型測試撰寫-Vue-Router-測試" class="headerlink" title="在 Options API 中以社交型測試撰寫 Vue Router 測試"></a>在 Options API 中以社交型測試撰寫 Vue Router 測試</h4><p>在社交型測試中，我們會直接在測試案例中引入 Route 設定，並真實透過 Vue Router 創造一個 Router 來進行測試：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; routes &#125; <span class="keyword">from</span> <span class="string">"@/router"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">    history: createWebHistory(),</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而在測試案例中，我們則要改由用容器選項中的 <code>global.plugins</code> 來注入 <code>router</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = mount(App, &#123;</span><br><span class="line">  global: &#123;</span><br><span class="line">    plugins: [router]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>另外，撰寫測試案例中若有透過 <code>router.push()</code> 來導向路由，則需要透過 <code>router.isReady()</code> 來確保路由已經準備好：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.push(<span class="string">'/articles/10308907/edit'</span>)</span><br><span class="line"><span class="keyword">await</span> router.isReady()</span><br></pre></td></tr></table></figure>

<p>除此之外，若有需要斷言網頁內容的資訊時，則需要透過 Vue Test Utils 所提供的 <code>flushPromises</code> 來確保所有非同步的行為都已經完成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> flushPromises()</span><br><span class="line">expect(wrapper.html()).toContain(<span class="string">'After async action'</span>)</span><br></pre></td></tr></table></figure>

<p>最後我們將上述內容組裝起來，完整的社交型 options API 的測試案例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; routes &#125; <span class="keyword">from</span> <span class="string">"@/router"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">    history: createWebHistory(),</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'App.vue'</span>, () =&gt; &#123;</span><br><span class="line">    beforeEach( <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在每個測試案例執行前，都會先將路由準備好</span></span><br><span class="line">        router.push(<span class="string">'/'</span>)</span><br><span class="line">        <span class="keyword">await</span> router.isReady()</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'should go to edit page when click button if user is Login'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        <span class="keyword">const</span> wrapper = mount(App, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                isUserLogin: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            global: &#123;</span><br><span class="line">                plugins: [router]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act</span></span><br><span class="line">        <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button"]'</span>).trigger(<span class="string">'click'</span>) <span class="comment">// 點擊後應觸發 router.push() 事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert</span></span><br><span class="line">        expect(router.push).toHaveBeenCalledWith(<span class="string">'/articles/10308907/edit'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'should go to login page when click button if user is not Login'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> wrapper = mount(App, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                isUserLogin: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            global: &#123;</span><br><span class="line">                plugins: [router]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">        expect(mockRouter.push).toHaveBeenCalledWith(<span class="string">'/login'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h3><p>在 Composition API 風格中，我們主要是在 <code>setup</code> 函式，透過 <code>useRouter</code>、<code>useRoute</code> 來取得 Vue Router 的相關資訊與操作方法：</p>
<p>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 元件某處 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-test</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"goToEditPage"</span>&gt;</span>編輯文章<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        isUserLogin: <span class="literal">false</span> <span class="comment">// 這裡為了理解方便單純模擬判斷使用者是否登入，並非最佳實踐</span></span><br><span class="line">    &#125;,</span><br><span class="line">    setup(props)&#123;</span><br><span class="line">        <span class="keyword">const</span> $router = useRouter()</span><br><span class="line">        goToEditPage() &#123;</span><br><span class="line">            <span class="keyword">if</span>(props.isUserLogin)&#123;</span><br><span class="line">                $router.push(<span class="string">`/articles/<span class="subst">$&#123;<span class="keyword">this</span>.$route.params.id&#125;</span>/edit`</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $router.push(<span class="string">`/login`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            goToEditPage</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在-Composition-API-中以社交型測試撰寫-Vue-Router-測試"><a href="#在-Composition-API-中以社交型測試撰寫-Vue-Router-測試" class="headerlink" title="在 Composition API 中以社交型測試撰寫 Vue Router 測試"></a>在 Composition API 中以社交型測試撰寫 Vue Router 測試</h4><p>與 options API 相同，在社交型測試中我們一樣需要在測試案例準備好 Router 的相關設定，並且引入 <code>createRouter</code>、<code>createWebHistory</code> 來建立 Router 實體：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; vi &#125; <span class="keyword">from</span> <span class="string">'vitest'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; routes &#125; <span class="keyword">from</span> <span class="string">'@/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">    history: createWebHistory(),</span><br><span class="line">    routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但由於這次我們是使用了真實的 Router 來當作測試對象，因此這時後我們若想要捕捉 Push 的行為，就必須透過 <code>vi.spyOn</code> 來替身出 <code>router.push</code> 方法，最後我們才能透過這個替身斷言結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> spyPush = vi.spyOn(router, <span class="string">'push'</span>)</span><br></pre></td></tr></table></figure>

<p>完整的測試案例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; vi &#125; <span class="keyword">from</span> <span class="string">'vitest'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; routes &#125; <span class="keyword">from</span> <span class="string">'@/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">    history: createWebHistory(),</span><br><span class="line">    routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'App.vue'</span>, () =&gt; &#123;</span><br><span class="line">    beforeEach( <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        router.push(<span class="string">'/'</span>)</span><br><span class="line">        <span class="keyword">await</span> router.isReady()</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'should go to edit page when click button if user is Login'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        <span class="keyword">const</span> wrapper = mount(App, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                isUserLogin: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            global: &#123;</span><br><span class="line">                plugins: [router],</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act</span></span><br><span class="line">        <span class="keyword">const</span> spyPush = vi.spyOn(router, <span class="string">'push'</span>)</span><br><span class="line">        <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button"]'</span>).trigger(<span class="string">'click'</span>) <span class="comment">// 點擊後應觸發 router.push() 事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert</span></span><br><span class="line">        expect(spyPush).toHaveBeenCalledWith(<span class="string">'/articles/10308907/edit'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'should go to login page when click button if user is not Login'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> wrapper = mount(App, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                isUserLogin: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            global: &#123;</span><br><span class="line">                plugins: [router],</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> spyPush = vi.spyOn(router, <span class="string">'push'</span>)</span><br><span class="line">        <span class="keyword">await</span> wrapper.find(<span class="string">'[data-test="button"]'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">        expect(spyPush).toHaveBeenCalledWith(<span class="string">'/login'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上便是我們在進行 Vue Router 測試中，針對不同風格時的撰寫測試案例與技巧，相信看到這邊你應該會對於測試替身的應用有更深層的認知了，往後遇到其他第三方套件的測試時就可以應用這些技巧來撰寫測試案例。</p>
<p>而雖然以天數來說今天系列文已經完賽了，但我們還有一些東西可以繼續來看看哩，而明天我們將會來看看要如何撰寫新一代的 Vue Store 工具 Pinia 要如何來進行測試，敬請期待！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>【進階ノ章】Vitest UI</title>
    <url>/testing/ithelp-2022-vitest-32/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="Vitest-UI"><a href="#Vitest-UI" class="headerlink" title="Vitest UI"></a>Vitest UI</h1><p>經過了一個月多，我們也從測試基礎概念一路講到實際上的語法和簡單的應用，而有關於測試的部分，還有許多值得我們去探討的地方，因此從今天開始要來談談一些有關於測試的相關輔助工具與議題，看看這些東西要怎麼協助我們更好的撰寫測試。</p>
<a id="more"></a>

<p>而第一個要談到的是基於 Vitest 工具底下的 <a href="https://vitest.dev/guide/ui.html" target="_blank" rel="noopener">Vitest UI</a>：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062L5WYsaaOLO.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062L5WYsaaOLO.png"></p>
<p>Vitest UI 簡單來說，是另一種供我們查看測試與編寫測試的方式，它的特色在於基於 Vite 的 dev server 環境，讓我們可以直接在瀏覽器上直接觀看測試案例的測試結果，甚至支援直接在瀏覽器中編寫測試案例後同步更新測試檔案。</p>
<p>而在使用這項酷酷的功能之前，我們需要另外安裝 <code>@vitest/ui</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D @vitest/ui</span><br></pre></td></tr></table></figure>

<p>接著就可以在 <code>package.json</code> 中新增一個 <code>vitest</code> 指令，並帶上參數 <code>--ui</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"vitest:ui"</span>: <span class="string">"vitest --ui"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一來後們只要執行 <code>npm run vitest:ui</code>，就可以在啟動這項功能，並看到下列畫面：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062L5WYsaaOLO.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062L5WYsaaOLO.png"></p>
<h2 id="介面"><a href="#介面" class="headerlink" title="介面"></a>介面</h2><p>在 Vitest UI 中，左側是所有測試案例的測試結果（Pass / Fail / Skip），我們可以透過上方的搜尋欄輸入檔名或路徑找到我們要觀察的測試。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062E2AiqzFYsB.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062E2AiqzFYsB.png"></p>
<p>點擊左側的測試路徑後，右側會出現測試情境與測試案例的描述讓我們更好觀察當下檔案中的所有案例</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062DFHiTCaobG.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062DFHiTCaobG.png"></p>
<p>除此之外，再往右側會看到四項資訊，分別為：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062FLznwhW8On.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062FLznwhW8On.png"></p>
<ul>
<li>Report（預設顯示項目）</li>
<li>Module Graph</li>
<li>Console</li>
<li>Code</li>
</ul>
<h3 id="Report"><a href="#Report" class="headerlink" title="Report"></a>Report</h3><p>點擊 Report 頁籤時，會在右側顯示該測試檔案中的所有測試案例結果。</p>
<p>若為全通過的情況會顯示 <code>All tests passed in this file</code>：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062TbwjYrMuoW.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062TbwjYrMuoW.png"></p>
<p>若有錯誤會顯示是哪一條測試案例發生錯誤：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062TQhdnfzOZf.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062TQhdnfzOZf.png"></p>
<p>我們甚至能點擊錯誤訊息右方的開啟視窗 Icon，Vitest UI 將會直接啟動系統預設的程式碼編輯器，開啟測試檔案後將輸入游標聚焦在錯誤的行數與位置。（e.g. 圖中的 <code>toEqual</code> Assertion Matcher）</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062GPtp0Nw6Ub.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062GPtp0Nw6Ub.png"></p>
<h3 id="Module-Graph"><a href="#Module-Graph" class="headerlink" title="Module Graph"></a>Module Graph</h3><p>接著是第二個頁籤的 <code>Module Graph</code>，這頁的內容主要是透過檢測行內引入模組，呈現檔案之間依賴關係。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062eUcp66kBCu.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062eUcp66kBCu.png"></p>
<p>點擊圖中的節點可以看到該模組的 Source 檔與經由 Transformed 後的程式碼。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062rinDQ1r5LZ.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062rinDQ1r5LZ.png"></p>
<p>而這個圖表最大的用處在於，透過可視化的方式呈現出測試程式碼中受測物（SUT）與依賴物（DOC）的依賴狀況。</p>
<h3 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h3><p>Console 頁籤主要是顯示在測試程式碼中的 <code>console.log</code> 資訊，由於與測試結果分離的情況下，相較於在終端機中觀察 Console，這裡會顯示得更加清楚。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062XMfRj5tUxM.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062XMfRj5tUxM.png"></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>最後壓軸介紹的部分，則是 Code 頁籤，你可能會覺得這有什麼特別的，不就是顯示測試檔案程式碼嗎？</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062YNU4uepQdC.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062YNU4uepQdC.png"></p>
<p>然而，這裡的測試程式碼除了預覽之外，還能夠直接在瀏覽器中直接編寫並執行測試查看結果，更重要的是寫完的當下按下儲存它還能夠同步調整到實際的程式碼中！</p>
<p>比方在瀏覽器中的測試程式碼中加個註解，並儲存：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062pXtIRD6DYz.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062pXtIRD6DYz.png"></p>
<p>實際測試程式碼檔案也加上了註解！</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/20119062iJAN6r7pjK.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/20119062iJAN6r7pjK.png"></p>
<p>如此一來，我們就可以直接在這個視窗內撰寫我們的測試案例，並且在瀏覽器中即時看到測試結果。</p>
<p>不過這裡有個小小缺點是，若在專案中有設定 eslint + prettier 的話，在程式編輯器撰寫測試時可以設定儲存當下的自動做格式化，但是瀏覽器中的編輯器環境不同，所以寫測試時會收到格式錯誤的警告，但在不考慮這點的情況下，這個工具是個用來檢視測試結果與依賴關係的好工具。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221017/201190625fQBVzwGJn.png" alt="https://ithelp.ithome.com.tw/upload/images/20221017/201190625fQBVzwGJn.png"></p>
<p>以上就是 Vitest UI 工具的介紹，若有興趣的話可以親自下去 try try！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 為何需要框架與 Vue.js ？</title>
    <url>/vue.js/Vue-001-why-do-I-need-vue/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h1 id="為什麼要學框架？"><a href="#為什麼要學框架？" class="headerlink" title="為什麼要學框架？"></a>為什麼要學框架？</h1><p>HTML、CSS 以及 JavaScript 是身為前端不可或缺的技能組合，然而要投履歷時會發現許多公司都會要求至少要有一個框架的經驗，再加上一些工具才會達到應徵門檻，不求甚解的話很容易認為框架只是個公司需求，但可以反問的是，<strong>為什麼公司會有框架的需求呢？</strong></p>
<p>在不同類型的公司可能會遇到不同的問題，團隊開發專案會需要配合互相的 code，翻修、維護舊專案則是要看前人寫的 code，就連自己想要在自己 side project 上加功能，都得看自己以前寫的 code。在哪都要看 code 的情況下，看 code 顯然就變成了一門值得探討的技術，並且延伸到<strong>命名規則</strong>、<strong>編寫風格規定</strong>等等，而框架就我認為在某種程度上是<strong>提升</strong>了看 code 這門技術的<strong>優雅性</strong>。</p>
<p>隨著時代的演進，網路開發已從一人包辦變成前後端分離，而分離出來的前端要實作的功能也越趨複雜，以致於程式碼的維護與管理越來越困難，如果公司沒有固定設計模式的情況下，不同專案的開發人員依自己喜好編寫開發架構，甚至維護他人專案時又採用自己的喜好，未來維護專案時將會需要花相對更長的時間在看 code，除了基本的 review code 似乎可以稍微防止這類的事情發生，若能依照各個框架本身提供的 <strong>API</strong> 、<strong>風格</strong>、<strong>邏輯</strong>與<strong>架構</strong>開發，下一個人要接手維護時只要懂得該框架的邏輯與用法就能繼續延續前人的程式碼，至於選用哪個框架則會依據<strong>公司專案的需求不同而有不同</strong>，另外也會因為<strong>時代的不同</strong>，而有<strong>不同的選擇可以考量</strong>。</p>
<a id="more"></a>

<h1 id="jQuery-不好嗎，為什麼要用-Vue-js？"><a href="#jQuery-不好嗎，為什麼要用-Vue-js？" class="headerlink" title="jQuery 不好嗎，為什麼要用 Vue.js？"></a>jQuery 不好嗎，為什麼要用 Vue.js？</h1><p>上個段落提到了不同的時代會有不同的選擇，作為前輩的 jQuery ，當時出現的歷史原因是 JavaScript 在<strong>早期的一些原生功能較為薄弱</strong>，並且當時<strong>瀏覽器不一致</strong>的問題使得同樣一段程式碼在不同瀏覽器會產生不同結果，<br>舉例來說，在操作 <code>DOM</code> 的時候，原生 JavaScript 可以使用 <code>document.getElementById(&#39;test&#39;)</code> 這種寫法去捕捉，再透過方法來將值輸入進節點。但使用 jQuery 的作法可以透過更簡單的方法如 <code>$(&#39;#text&#39;).html()</code> 就可以輕鬆達成，除此之外還有像是對於 <strong>AJAX 的發送</strong>、<strong>建立新的 DOM 元素</strong>、<strong>各種事件</strong>與<strong>動畫</strong>等等，jQuery 都提供更完善與簡潔的方法來解決他們。</p>
<p>至於 Vue.js 解決的主要問題在於 <strong>UI 與狀態同步的難處</strong>，假設有一個代辦清單的專案需求，不論原生 JavaScript 或是使用 jQuery，都得<strong>相對頻繁地的操作 DOM</strong> ，也因此使得網頁性能下降，而且在同步與非同步的難題中，容易漏了一個環節後就漸漸與 UI 脫離，並且這樣的做法也相對<strong>難以知道</strong>最後是由誰去更動了目標。而 Vue.js 則是以<strong>監聽</strong>特定節點中的值來觸發需要改動的狀態，透過<strong>綁定 HTML 元素</strong>，使用<strong>模板語法</strong>來將我們想要顯示的資料輸出。範例如下：<br>HTML 部分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; myData &#125;&#125;</span><br><span class="line">    <span class="comment">&lt;!-- 使用花括弧可直接取得 Vue.js 實體中的資料 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        myData: <span class="string">'我的資料'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>這樣的做法除了在 HTML 部分可以更清楚的掌握整個元件的樣貌，往後也能透過 Vue 實體來控管整個狀態的運作。</p>
<p>由此可知 jQuery 解決的問題與 Vue.js 其實不太一樣，並且當時關注點分離著重的地方也不太相同（以前強調 HTML、CSS、JavaScript 要盡量分開，現在則是偏好以單一個元件為一個單位），所以我認為並非 jQuery 不好用，只是 Vue.js 更貼近目前前端的趨勢。但也並非完全就不用 jQuery，以往專案有用到 jQuery 的話，仍需要瞭解 jQuery 的用法，才能符合舊專案的<del>形狀</del>思維。</p>
<h1 id="我還能靠-Vue-js-做到什麼？"><a href="#我還能靠-Vue-js-做到什麼？" class="headerlink" title="我還能靠 Vue.js 做到什麼？"></a>我還能靠 Vue.js 做到什麼？</h1><p>除了以上 UI與狀態同步 的優點之外，Vue.js 身為一款靈活的<strong>漸進式框架</strong>，你可以<strong>決定在不同的專案中引入不同程度的 Vue.js</strong>，小至只使用他提供的<strong>資料綁定（Data Binding）</strong>功能；大則到可以藉由 Vue-cli 建立一個較為完整的單頁式應用程式(SPA, Single Page Application)，讓你<strong>殺雞焉用牛刀</strong>。</p>
<p>擁有<strong>相對平緩的學習曲線</strong>，不如 React.js 要求較高的 JavaScript 能力（需要使用大量的 es6 以及 JSX），不如 Angular 要學習許多內建的函式庫以及 TypeScript、Rx.js，並且擁有<strong>簡單易讀的文件</strong>，需要特定功能（router、vuex、nust）時再去使用也沒問題。</p>
<p>若是更加深度比較框架間的差異與優勢也可以參考下列文章：</p>
<ul>
<li><a href="https://kknews.cc/zh-tw/code/r33n9vn.html" target="_blank" rel="noopener">全面的 React、Angular 和 Vue.js 比較指南</a></li>
<li><a href="https://buzzorange.com/techorange/2017/07/31/all-about-javascript-framework/" target="_blank" rel="noopener">JavaScript 框架大比拼</a></li>
</ul>
<p>看完本篇文章不知道大家是否心中有個底要追 Vue.js 呢？而下一篇文章將會開始建立基礎環境，若還在猶豫不彷繼續走走，或許到後面你會愛上 Vue.js！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>【進階ノ章】覆蓋率（Coverage）</title>
    <url>/testing/ithelp-2022-vitest-33/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="程式碼覆蓋率（Code-Coverage）"><a href="#程式碼覆蓋率（Code-Coverage）" class="headerlink" title="程式碼覆蓋率（Code Coverage）"></a>程式碼覆蓋率（Code Coverage）</h1><p>在測試領域中，覆蓋率（Coverage）一詞泛指的是以百分比表示測試程式碼能夠涵蓋多少產品程式碼的範圍，而依據不同的覆蓋率種類，其細微的定義也會有所不同。</p>
<p>接下來我們以覆蓋率工具庫 c8 來說明覆蓋率的概念與如何透過 c8 在 Vitest 測試環境中檢視當下的測試覆蓋率，最後再來談談有關於覆蓋率的相關議題。</p>
<a id="more"></a>

<h2 id="c8"><a href="#c8" class="headerlink" title="c8"></a>c8</h2><p>要在 Vitest 測試環境中使用 c8 產生覆蓋率報告，我們首先需要安裝 <code>@vitest/coverage-c8</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D @vitest/coverage-c8</span><br></pre></td></tr></table></figure>

<p>接著就可以在 <code>package.json</code> 中新增指令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test:coverage"</span>: <span class="string">"vitest --environment jsdom --coverage"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行 <code>npm run test:coverage</code> 後，預設會在終端機產生出覆蓋率報告：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221018/20119062lKkr6nTtkH.png" alt="https://ithelp.ithome.com.tw/upload/images/20221018/20119062lKkr6nTtkH.png"></p>
<p>而 c8 覆蓋率報告總共有四種類型：</p>
<ul>
<li>行數覆蓋率（line coverage）：以行數為單位來計算。</li>
<li>函式覆蓋率（function coverage）：以內部的函式為單位來計算。</li>
<li>分枝覆蓋率（branch coverage）：以每個判斷式為單位來計算。</li>
<li>語句覆蓋率（statement coverage）：以每個語句（statement）為單位計算。</li>
</ul>
<p>測試程式碼涵蓋多少範圍的產品程式碼，甚至於每行程式碼個被執行了幾次</p>
<p>並且若有未覆蓋行數的情況， c8 則會在 Uncovered Line 中顯示未涵蓋的行數範圍，如下圖中的 <code>13-17,19-28</code></p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221018/20119062H4yYnGfHBS.png" alt="https://ithelp.ithome.com.tw/upload/images/20221018/20119062H4yYnGfHBS.png"></p>
<p>躺若你覺得這種報告形式不方便觀看，或是希望將它製作成文件，則可以在 config.js 檔中設定 <code>coverage.reporter</code> 的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vite.config.js or vitest.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  test: &#123;</span><br><span class="line">    coverage: &#123;</span><br><span class="line">      reporter: [<span class="string">'text'</span>, <span class="string">'json'</span>, <span class="string">'html'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其中 c8 提供的報告（reporter）選項有以下三種：</p>
<ul>
<li><code>text</code>： 在終端機中呈現覆蓋率報告。</li>
</ul>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221018/201190627GKM0l78fQ.png" alt="https://ithelp.ithome.com.tw/upload/images/20221018/201190627GKM0l78fQ.png"></p>
<ul>
<li><code>json</code>： 以 JSON 格式產生覆蓋率報告。</li>
</ul>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221018/20119062Kt7ISm9g3h.png" alt="https://ithelp.ithome.com.tw/upload/images/20221018/20119062Kt7ISm9g3h.png"></p>
<ul>
<li><code>html</code>： 產生一個可互動的 HTML 覆蓋率報告。</li>
</ul>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221018/2011906268egcXCSuM.png" alt="https://ithelp.ithome.com.tw/upload/images/20221018/2011906268egcXCSuM.png"></p>
<p>其中 HTML 的版本中，我們還可以點擊測試檔案來查看未覆蓋的行數有哪些，相較終端機的版本，我們就不必再拿著行數去對程式碼了：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221018/20119062lC3REV70h1.png" alt="https://ithelp.ithome.com.tw/upload/images/20221018/20119062lC3REV70h1.png"></p>
<h2 id="覆蓋率目標"><a href="#覆蓋率目標" class="headerlink" title="覆蓋率目標"></a>覆蓋率目標</h2><p>而在瞭解怎麼查看覆蓋率報告後，那麼究竟覆蓋率目標要達到多少才是合理呢？</p>
<p>以 《可測試的 JavaScript》一書作者 Mark Ethan Trostler 提供的答案是單元測試大約要介於 80 % 左右。</p>
<p>以 Martin Fowler 於 <a href="https://martinfowler.com/bliki/TestCoverage.html" target="_blank" rel="noopener">Test Coverage</a> 一文中，則是指出大約會在於 80 至 90 % 附近。</p>
<p>至於為什麼不是達到百分之百呢？接下來我們來探討有關於覆蓋率相關的議題。</p>
<h2 id="覆蓋率議題"><a href="#覆蓋率議題" class="headerlink" title="覆蓋率議題"></a>覆蓋率議題</h2><h3 id="覆蓋率與付出的心力"><a href="#覆蓋率與付出的心力" class="headerlink" title="覆蓋率與付出的心力"></a>覆蓋率與付出的心力</h3><p>雖然以理論上來說盡可能得達到高覆蓋率，測試程式碼將涵蓋的越完全，然而為了追求 100 % 的覆蓋率所要付出的心理將會截然不同。</p>
<p>Jeroen Mols 在 <a href="https://jeroenmols.com/blog/2017/11/28/coveragproblem/" target="_blank" rel="noopener">The 100% code coverage problem</a> 一文中的提到了心力付出與覆蓋率的關係表。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221018/20119062DxhbP4mmbR.png" alt="https://ithelp.ithome.com.tw/upload/images/20221018/20119062DxhbP4mmbR.png"></p>
<blockquote>
<p>引用自 Jeroen Mols 《The 100% code coverage problem》一文中的圖</p>
</blockquote>
<p>從上圖中可以看見，在覆蓋率從 0 提升至 80% 我們僅需要付出一些心力就可以輕易達成，然而要將 90% 提升至接近 100% 我們則幾乎要投入兩到三倍以上的心力才能完成。</p>
<p>因此，有些人雖然會認為 100% 的覆蓋率是一個不錯的目標，但是在實際上，我們可能會因為追求 100% 的覆蓋率而付出過多的心力，而導致測試程式碼的品質反而變差。</p>
<h3 id="覆蓋率-100-的誤區"><a href="#覆蓋率-100-的誤區" class="headerlink" title="覆蓋率 100% 的誤區"></a>覆蓋率 100% 的誤區</h3><p>在費盡千辛萬苦後，我們終於達到了 100% 覆蓋率的情況了。</p>
<p>然而，100 % 的覆蓋率僅能代表測試程式碼完整（Complete）的覆蓋了產品程式碼，並非代表測試程式碼的品質達到完美（Perfect），接下來我們用個簡單的例子來說明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">test(<span class="string">'max'</span>, () =&gt; &#123;</span><br><span class="line">  expect(max(<span class="number">2</span>, <span class="number">1</span>)).toBe(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在上方案例中，我們可以看見 <code>max</code> 測試案例基本上已經完全覆蓋了 <code>max</code> 函式的實作情況，而我們可以從這個案例中看出兩個問題：</p>
<ul>
<li>產品程式碼本身有問題，即便測試程式碼覆蓋了 100% 的情況下，產品程式碼本身仍然是有問題的。</li>
<li>測試程式碼案例與路徑不足，導致覆蓋率為 100% 的情況下，並沒有測出產品程式碼中的問題與邊際案例（edge case）。</li>
</ul>
<p>因此覆蓋率 100% 充其量只是一個指標，用來告訴我們測試程式碼是否完整的覆蓋了產品程式碼，而非「完全沒有問題」。</p>
<p>倘若我們想要盡可能避免這種情況的發生，這時我們就可以透過突變測試（Mutation Testing）來協助我們。</p>
<h2 id="突變測試（mutation-testing）"><a href="#突變測試（mutation-testing）" class="headerlink" title="突變測試（mutation testing）"></a>突變測試（mutation testing）</h2><p>突變測試（Mutation Testing）是一種驗證與改善測試程式碼的測試方法，概念上來說，他會盡可能的抽換產品程式碼中的每個角落，接著依照抽換規則來預期測試程式碼的檢測結果。</p>
<p>假設我們有個比較函式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greaterThan = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x &gt; y</span><br></pre></td></tr></table></figure>

<p>而這時我們測試程式碼可能會這麼處理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should return true if x is greater than y'</span>, () =&gt; &#123;</span><br><span class="line">  expect(greaterThan(<span class="number">2</span>, <span class="number">1</span>)).toBe(<span class="literal">true</span>)</span><br><span class="line">  expect(greaterThan(<span class="number">0</span>, <span class="number">-1</span>)).toBe(<span class="literal">true</span>)</span><br><span class="line">  expect(greaterThan(<span class="number">100</span>, <span class="number">0</span>)).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">'should return false if x is less than y'</span>, () =&gt; &#123;</span><br><span class="line">  expect(greaterThan(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="literal">false</span>)</span><br><span class="line">  expect(greaterThan(<span class="number">-1</span>, <span class="number">0</span>)).toBe(<span class="literal">false</span>)</span><br><span class="line">  expect(greaterThan(<span class="number">0</span>, <span class="number">100</span>)).toBe(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接著突變測試可能會將 <code>greaterThan</code> 函式中的 <code>&gt;</code> 符號替換成 <code>&gt;=</code> 符號，此時理論上來說應該會有測試案例失敗，但是實際上測試程式碼卻沒有檢測到這個問題，那就表示我們的測試程式碼並沒有覆蓋到這個案例。</p>
<p>此時我們就可以針對這種情況，再補上對應的測試案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should return true if x is greater than y'</span>, () =&gt; &#123;</span><br><span class="line">  expect(greaterThan(<span class="number">2</span>, <span class="number">1</span>)).toBe(<span class="literal">true</span>)</span><br><span class="line">  expect(greaterThan(<span class="number">0</span>, <span class="number">-1</span>)).toBe(<span class="literal">true</span>)</span><br><span class="line">  expect(greaterThan(<span class="number">100</span>, <span class="number">0</span>)).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line">it(<span class="string">'should return false if x is less than y'</span>, () =&gt; &#123;</span><br><span class="line">  expect(greaterThan(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="literal">false</span>)</span><br><span class="line">  expect(greaterThan(<span class="number">-1</span>, <span class="number">0</span>)).toBe(<span class="literal">false</span>)</span><br><span class="line">  expect(greaterThan(<span class="number">0</span>, <span class="number">100</span>)).toBe(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 新增案例</span></span><br><span class="line">it(<span class="string">'should return false if x is equal y'</span>, () =&gt; &#123;</span><br><span class="line">  expect(greaterThan(<span class="number">1</span>, <span class="number">1</span>)).toBe(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接著突變測試再度將 <code>&gt;</code> 符號替換成各種符號（e.g. <code>&lt;=</code>），甚至是將 <code>{}</code> 語句（statement）清空，而諸如此類的手法，就是突變測試的核心概念。</p>
<blockquote>
<p>若想手動置換產品程式碼中的符號，可以從這些方法下手</p>
<ul>
<li>operator: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
<li>condition: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code></li>
<li>statement: <code>{}</code>, <code>if</code>, <code>else</code>, <code>for</code>, <code>return</code>, <code>throw</code>, <code>try</code>, <code>catch</code></li>
<li>expression: <code>&amp;&amp;</code>, <code>||</code>, <code>!</code><br>…, etc.</li>
</ul>
</blockquote>
<h3 id="突變測試的工具"><a href="#突變測試的工具" class="headerlink" title="突變測試的工具"></a>突變測試的工具</h3><p>雖然說我們可以手動置換產品程式碼中的各種符號，但是這樣的作法會讓我們的工作量變得非常龐大，因此我們可以透過工具來協助我們完成這些工作。</p>
<p>以前端領域來說，我們可以透過 <a href="https://stryker-mutator.io/" target="_blank" rel="noopener">Stryker Mutator</a> 底下的 <a href="https://github.com/stryker-mutator/stryker-js" target="_blank" rel="noopener"><code>stryker-js</code></a> 工具來完成這些工作。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20221018/20119062cbZHth4wOw.png" alt="https://ithelp.ithome.com.tw/upload/images/20221018/20119062cbZHth4wOw.png"></p>
<p>Stryker Mutator 的概念就是透過替換不同的符號產生出突變的內容，而我們的測試程式碼應該要捕捉到那些不合理的情況，藉此來保證我們的測試案例有一定的穩固性。</p>
<p>然而，可惜的是 <code>stryker-js</code> 目前僅支援到 Jest 環境，尚未支援 Vitest 的環境，因此我這邊就暫不做介紹了，有興趣者可以追蹤該 <a href="https://github.com/stryker-mutator/stryker-js/issues/3465" target="_blank" rel="noopener">issue</a> 目前的最新進度。</p>
<hr>
<p>以上便是有關於覆蓋率的基本概念與如何在 Vitest 中透過 c8 查看目前覆蓋率的介紹，雖然突變測試工具目前尚未支援 Vitest，因此暫時只能透過手動替換來增加穩固度，但是確實是個能夠增強我們測試案例的好方法，若你有更好提升測試案例的穩定性的方法與工具，歡迎在下方留言分享與討論！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 基礎環境建置</title>
    <url>/vue.js/Vue-002-basic-build/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>
# 環境搭建

<p>一般來說建置 Vue.js 的完整專案會使用 Vue-cli 工具來產生專案目錄，但如果只是想要快速學習 Vue.js 不必安裝過多的環境，Vue.js 的官網提供了 CDN 的作為引入方式，讓有興趣的人可以更快參與其中，而目前提供的版本分別為：</p>
<ul>
<li><strong>開發版本：</strong>這個版本包含了<strong>完整的開發人員工具</strong>以及<strong>提示報錯</strong>等等的協助，適合<strong>開發</strong>時使用。</li>
<li><strong>生產版本：</strong>這個版本則是將上述開發工具都拔除，盡量縮小它的體積，適合<strong>正式發布</strong>時使用。</li>
</ul>
<p>而我們目的是體驗 Vue.js 的開發，因此選擇<strong>開發版本</strong>，並將其導入 HTML 的 head 中即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接著在 HTML 的部分我們需要建立一個元素並選擇性使用 <code>class</code> 或 <code>id</code>，讓待會 Vue.js 知道它要渲染的範圍。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 待會用來初始化 Vue 的地方</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>在 JavaScript 部分，我們需要初始化 Vue.js 的實體，就好像飲料販賣機一樣，投個硬幣拿到這個商品後我們就可以開始使用它。透過 <code>new</code> 初始化 Vue 的物件之後，傳入一些基本的設定，其中 <code>el</code> 的值需要放入綁定的元素好比上方範例中的（<code>app</code>）；而 <code>data</code> 的值則是傳入一個物件，這裡主要是用來存放資料的部分，而 <code>key</code>（<code>message</code>）的部分將會用在<strong>樣板語法</strong>中供 Vue.js 去找到對應的 <code>value</code>（<code>&#39;Hello, Vue.js!&#39;</code>）最後將它顯示出來。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    message:<span class="string">'Hello, Vue.js!'</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後，我們在剛才的 HTML 部分中使用<strong>樣板語法（兩對花括弧）</strong>，裡面塞入剛才的 <code>key</code>（<code>message</code>），就可以將其對應的 <code>&#39;Hello, Vue.js!&#39;</code> 渲染出來：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">     var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">      el:'#app',</span></span><br><span class="line"><span class="xml">      data:&#123;</span></span><br><span class="line"><span class="xml">        message:'Hello, Vue.js!'</span></span><br><span class="line"><span class="xml">      &#125; </span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>如此一來，將頁面打開來時就能看到 Hello, Vue.js!了。<del>找回最初的感動（？</del></p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190904/20119062w0tUzpaNA2.png" alt="https://ithelp.ithome.com.tw/upload/images/20190904/20119062w0tUzpaNA2.png"></p>
<h1 id="BONUS：平時開發常用設定"><a href="#BONUS：平時開發常用設定" class="headerlink" title="BONUS：平時開發常用設定"></a>BONUS：平時開發常用設定</h1><ul>
<li>作業系統： 目前主要是在 Windows、以前則是用 macOS (雙棲動物)</li>
<li>程式碼編輯器： Visual Studio Code (free)</li>
</ul>
<p>編輯器推薦套件</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag" target="_blank" rel="noopener">Auto Rename Tag</a>：更改標籤時，想一次更改開始標籤與結尾標籤可以考慮安裝這個！</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer" target="_blank" rel="noopener">Bracket Pair Colorize</a>：將程式碼區塊前後顏色配對，可以快速找到該區塊範圍在哪。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.live-sass" target="_blank" rel="noopener">Live Sass Compiler</a>：可以自動編譯 SASS（SCSS）並同步輸出成未壓縮版與壓縮版的 CSS 檔。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer" target="_blank" rel="noopener">Live Server</a>：模擬一個 Local Web 環境，具有熱更新的功能，也就是一更改程式碼就會即時顯示變化在頁面上。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=octref.vetur" target="_blank" rel="noopener">Vetur</a>：由 Vue.js 作者<strong>尤雨溪</strong>與微軟開發者<strong>Pine Wu</strong>官方合作的套件，支援了<strong>語法高亮</strong>、<strong>語法快捷</strong>等等強大的功能。</li>
</ul>
<p>Chrome 瀏覽器推薦套件</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/dimensions/baocaagndhipibgklemoalmkljaimfdj" target="_blank" rel="noopener">Dimensions</a>：可以快速量網頁上元素之間的距離。</li>
<li><a href="https://chrome.google.com/webstore/detail/colorpick-eyedropper/ohcpnigalekghcmgcdcenkpelffpdolg" target="_blank" rel="noopener">ColorPick Eyedropper</a>：可以快速捕捉網頁上的色彩顏色（RGB、HEX 等等應有盡有）。</li>
<li><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd" target="_blank" rel="noopener">Vue.js devtools</a>：開發必備，可以即時監測 Vue 實體中的資料狀態等等資料，你想一邊 Debug 一邊觀看 Data 的狀況嗎？安裝他吧！</li>
</ul>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190904/20119062BP5oyN0ahL.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190904/20119062BP5oyN0ahL.jpg"></p>
<p>如果還有其他好用的工具也歡迎讀者投稿囉！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 指令 Directives</title>
    <url>/vue.js/Vue-003-directives/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h1 id="指令（Directives）"><a href="#指令（Directives）" class="headerlink" title="指令（Directives）"></a>指令（Directives）</h1><p>在 Vue.js 中有提供一些帶有前綴<code>v-</code>的指令，指令主要放在 HTML 標籤當中，如同 HTML 屬性一樣，而我們可以透過指令去<strong>命令那些元素做事情</strong>，只要指令<strong>條件符合</strong>時，就會執行該指令的動作。而透過這些指令與上一回的樣板語法，我們可以直接在 HTML 上去綁定我們需要做的事情，以下列出幾個常用到的指令與用法：</p>
<a id="more"></a>

<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>透過<code>v-if</code>指令，當<code>v-if</code>後的條件為<code>true</code>時，該元素就會<strong>顯示</strong>在 DOM 上，若<code>false</code>則該元素<strong>不會顯示</strong>在 DOM 的結構上。</p>
<p>範例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">'text1'</span>&gt;</span>最後這段文字會顯示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">'text2'</span>&gt;</span>最後這段文字不會顯示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">  el:<span class="string">'#app'</span>,</span></span><br><span class="line">  data:&#123;</span><br><span class="line"><span class="actionscript">    text1:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">    text2:<span class="literal">false</span></span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>和上面的<code>v-if</code>很像，但<code>v-show</code>在<code>false</code>時的消失，實際觀察 DOM 會發現該元素只是被加上了行內樣式 <code>style=&quot;display:none&quot;</code>而已，並<strong>沒有從DOM上消失</strong>。</p>
<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>接下來介紹的這個指令非常的好用，透過<code>v-for</code>，我們可以將<code>data</code>中的某筆資料遍歷輸出，用法就有如原生 JavaScript 中的 <code>for...of</code>迴圈一樣，取一個變數名稱去拿到<strong>資料物件裡面的值</strong>，可以用來快速製作一個<strong>樣板</strong>。</p>
<p>範例：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(person,index) in class001"</span> <span class="attr">:key</span>=<span class="string">"person.id"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      第</span><span class="xquery">&#123;&#123; index &#125;</span><span class="xml">&#125;筆資料，姓名：</span><span class="xquery">&#123;&#123; person<span class="built_in">.name</span> &#125;</span><span class="xml">&#125;，年齡：</span><span class="xquery">&#123;&#123; person.age &#125;</span><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">let vm = new Vue(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">  el:<span class="string">'#app'</span>,</span></span><br><span class="line"><span class="xquery">  data:&#123;</span></span><br><span class="line"><span class="xquery">    class001:[</span></span><br><span class="line"><span class="xquery">      &#123;</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> id</span>:<span class="string">'001'</span>,</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> name</span>:<span class="string">'小明'</span>,</span></span><br><span class="line"><span class="xquery">        age:<span class="number">12</span></span></span><br><span class="line"><span class="xquery">      &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> id</span>:<span class="string">'002'</span>,</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> name</span>:<span class="string">'小美'</span>,</span></span><br><span class="line"><span class="xquery">        age:<span class="number">10</span></span></span><br><span class="line"><span class="xquery">      &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> id</span>:<span class="string">'003'</span>,</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> name</span>:<span class="string">'小華'</span>,</span></span><br><span class="line"><span class="xquery">        age:<span class="number">11</span></span></span><br><span class="line"><span class="xquery">      &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    ]</span></span><br><span class="line"><span class="xml">  &#125; </span></span><br><span class="line"><span class="xml">&#125;)</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>需要注意的地方</strong>，在使用<code>v-for</code>指令輸出時，<a href="https://cn.vuejs.org/v2/style-guide/#%E4%B8%BA-v-for-%E8%AE%BE%E7%BD%AE%E9%94%AE%E5%80%BC-%E5%BF%85%E8%A6%81" target="_blank" rel="noopener">官網強烈建議</a>需要給予一個 <code>key</code> 來作為可識別的資料，有點類似於身分證的概念；而當我們需要對資料操作時，Vue.js 也才能依靠身分證去找到對的人，如果我們是使用門牌（如<code>index</code>）來檢驗的話，哪天裡面的租客搬走換人了就會找錯人了！</p>
<p><strong>另外一個須注意的地方是</strong>，需要避免<code>v-for</code>與<code>v-if</code>在同一個地方上使用，因為有可能會渲染到本來應該會隱藏的欄位，而官方也做了<a href="https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7-%E5%BF%85%E8%A6%81" target="_blank" rel="noopener">詳細解釋</a>，簡單來說你叫貓咪要趴下，又要他站起來，那牠到底是要趴下還是站起來呢？</p>
<p>橘橘：我選擇趴下好了<br><img src="https://ithelp.ithome.com.tw/upload/images/20190906/20119062JZFpwznF0E.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190906/20119062JZFpwznF0E.jpg"></p>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>透過<code>v-model</code>指令綁定在元素上，可以創造一個雙向綁定資料的概念，例如我們讓資料雙向綁定在一個<code>input</code>元素上，<code>input</code>的值就會顯示出他對應的<code>&#39;我會顯示在input中&#39;</code>，如果我們更改<code>input</code>的值，最後 <code>data</code> 裡面的值也會被我們更改。</p>
<p>範例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">  el:<span class="string">'#app'</span>,</span></span><br><span class="line">  data:&#123;</span><br><span class="line"><span class="actionscript">    message:<span class="string">'我會顯示在input中'</span></span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p><code>v-on</code>指令使用方法類似於使用 HTML 原生屬性<code>on</code>一樣。例如要使用點擊觸發的行為，我們只要在元素上寫上<code>v-on:click=&quot;yourFunction&quot;</code>即可，而寫函式的位置則是在 Vue.js 實體中的 <code>methods</code> 裡頭。範例如下：</p>
<p>HTML部分</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;button type=<span class="string">"button"</span> v-<span class="keyword">on</span>:click=<span class="string">"handleOnClick"</span>&gt;Click Me!&lt;/button&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>JavaScript部分</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  method<span class="variable">s:</span>&#123;</span><br><span class="line">    handleOnClick : <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">      alert(<span class="string">'Hello Vue!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>除此之外，<code>v-on</code>也可以縮寫為<code>@</code>，將上面的範例改寫後會變成：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"handleOnClick"</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>這樣的效果會跟上方一模一樣。</p>
<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p><code>v-bind</code>主要可以用來綁定元素中的屬性，並且將屬性的值交由 Vue.js 中的 <code>data</code> 來控管，達到<strong>動態控制</strong>，使該元素變成是<strong>可控制的元素</strong>，這個觀念在 React.js 中也常常用到，例如常用到的一個做法就是控制元素的<code>class</code>屬性。下方範例將示範一個由按鈕去<strong>驅動資料</strong>讓元素的 <code>class</code> 能動態變化：</p>
<p>CSS部分，這裡簡單定義了box與rotate的樣式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.rotate</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HTML部分，這裡透過<code>v-on</code>的點擊事件讓<code>isRotate</code>的值可以反轉布林值，而 <code>v-bind:class</code> 的意思則是當<code>isRotate</code>為<code>true</code>該元素加上<code>rotate</code>的 <code>class</code>名稱，若<code>false</code>則不添加。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span> v-bind:<span class="built_in">class</span>=<span class="string">"&#123;'rotate':isRotate&#125;"</span>&gt;&lt;<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;button type=<span class="string">"button"</span> v-<span class="keyword">on</span>:click=<span class="string">"isRotate = !isRotate"</span>&gt; Rotate <span class="keyword">the</span> box&lt;/button&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>JavaScript部分</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    isRotate: false,</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如此一來我們便可以使用按鈕來驅動元素樣式。而這個指令也有縮寫的寫法，用法省略<code>v-bind</code>只留下<code>:</code>的部分，範例修改上面後的如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span> :<span class="built_in">class</span>=<span class="string">"&#123;'rotate':isRotate&#125;"</span>&gt;&lt;<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;button type=<span class="string">"button"</span> @click=<span class="string">"isRotate = !isRotate"</span>&gt; Rotate <span class="keyword">the</span> box&lt;/button&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>以上是一些常用到的指令與用法，關於其他更多深入的用法，可到官網上有更多詳細範例說明可以<a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">參考</a>，而下一段章節將會介紹到<strong>修飾符</strong>的內容，我們將會知道怎麼用簡單的<strong>修飾符</strong>讓指令的變化更加豐富！我們下個章節見！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>【進階ノ章】寫測試的最佳實踐（Testing Best Practice）</title>
    <url>/testing/ithelp-2022-vitest-34/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="最佳實踐（Best-Practice）"><a href="#最佳實踐（Best-Practice）" class="headerlink" title="最佳實踐（Best Practice）"></a>最佳實踐（Best Practice）</h1><p>程式語言本身可分為語法（Syntax）與語意（Semantics）兩部分：語法的部分主要受限於語言中的設計以及工具基於這些設計打造了什麼功能供我們使用，而語意的部分則是我們如何透過這些語法，來設計、歸納好我們想表達的邏輯。</p>
<p>同樣地，測試程式碼也是程式碼的一環，在撰寫測試程式碼的時候，我們除了語法上的學習之外，也應當考量測試程式碼的可讀性與維護性等等。</p>
<p>而今天的主題，我們要來一起欣賞開源專案 <a href="https://github.com/goldbergyoni/javascript-testing-best-practices" target="_blank" rel="noopener">《JavaScript 測試的最佳實踐》</a>，在這份指南中集結了大量的文章與書籍所給予撰寫測試程式碼上的建議！</p>
<p>由於這份指南說真的沒有很長，個人非常推薦把這個項目的內容完整閱讀一遍，因此本文主要傾向補充說明我個人的看法；並將本系列文提過的概念條列出來，讓讀者可快速回想。</p>
<p>若是英文苦手的開發者朋友們，也可以參考由<br><a href="https://github.com/yubinTW" target="_blank" rel="noopener">YuBin</a> 所翻譯的 <a href="https://github.com/goldbergyoni/javascript-testing-best-practices/blob/master/readme-zh-TW.md" target="_blank" rel="noopener">中文版本</a>！</p>
<a id="more"></a>

<h2 id="已經提及過的部分"><a href="#已經提及過的部分" class="headerlink" title="已經提及過的部分"></a>已經提及過的部分</h2><ul>
<li>1.2 3A 模式（Arrange, Act, Assert）</li>
<li>1.4 只測試公開方法 =&gt; 只驗證介面上的操作而非私有的方法。</li>
<li>3.2 使用不易改變的屬性來查詢 =&gt; 使用 data-* 屬性作為測試選取標準</li>
<li>3.6 基於 FIRST 原則中的 F（Fast） =&gt; 遇到會花費時間的測試，應盡可能的縮短時間，比方 request 非同步的資料應考慮使用回傳模擬資料。</li>
<li>4.1 藉由足夠的覆蓋率來獲得信心 =&gt; 以 80-90% 的覆蓋率為目標之一。</li>
<li>4.3 使用「變異測試」測量邏輯覆蓋率</li>
</ul>
<h2 id="補充說明"><a href="#補充說明" class="headerlink" title="補充說明"></a>補充說明</h2><h3 id="1-3-BDD-風格斷言"><a href="#1-3-BDD-風格斷言" class="headerlink" title="1.3 BDD 風格斷言"></a>1.3 BDD 風格斷言</h3><p>斷言風格主要在 <a href="https://ithelp.ithome.com.tw/articles/10300787" target="_blank" rel="noopener">斷言語法</a> 章節中有稍微提到不同風格的問題，筆者個人認為風格問題應回歸到團隊上的使用習慣。</p>
<p>而文中所舉的反例，個人認為比較像是因邏輯上的複雜度導致斷言上的困難，那麼透過拆分測試案例也是一種方式。</p>
<p>e.g.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'...情況下，應該為 A 且不為 B'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 不論哪種斷言風格</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可考慮拆解成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'...情況下，應該為 A'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 不論哪種斷言風格</span></span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'...情況下，不能為 B'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 不論哪種斷言風格</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此外，Vitest 兼容 Jest 斷言語法，也可以透過 <code>expect().not</code> Matchers 來反轉邏輯，所以解方也有很多種。</p>
</blockquote>
<h3 id="1-5-使用正確的測試替身-Test-Double"><a href="#1-5-使用正確的測試替身-Test-Double" class="headerlink" title="1.5 使用正確的測試替身 (Test Double)"></a>1.5 使用正確的測試替身 (Test Double)</h3><p>測試替身一直是測試中比較困難的部分，因為不同測試替身的使用時機和關注點不太一樣，筆者主要是建議使用測試替身的相關語法前，一定要先思考的一件事情就是<a href="https://ithelp.ithome.com.tw/articles/10307288" target="_blank" rel="noopener">斷言目標在誰身上</a>：</p>
<blockquote>
<p>以下簡稱 Vue Test Utils 為 VTU</p>
</blockquote>
<ul>
<li>Stub 類型：單純想避免依賴物回傳的干擾，並斷言受測物反映的結果：VTU =&gt; stub, Vitest =&gt; <code>vi.stubGlobal</code>, <code>vi.fn</code></li>
<li>Spy 類型：監聽受測物使用這個依賴時做了什麼（呼叫次數、帶的參數）：Vitest =&gt; <code>vi.fn</code>, <code>vi.spyOn</code></li>
<li>Mock 類型：控制依賴物的一切，連同能用什麼方法（method）都被控制：Vitest =&gt; <code>vi.mock</code></li>
</ul>
<h3 id="1-8-簡短的行內快照-inline-snapshots"><a href="#1-8-簡短的行內快照-inline-snapshots" class="headerlink" title="1.8 簡短的行內快照 (inline snapshots)"></a>1.8 簡短的行內快照 (inline snapshots)</h3><p>在先前快照測試中我們有提到 Vitest 中有個 <code>toMatchInlineSnapshot()</code> 語法，會在測試案例中直接生成快照檔，從而避免管理快照檔案上的負擔，但同時也讓測試檔案行數快速膨脹，所以建議用在小範圍的測試，或是使用 data-test 屬性選取到特定的目標範圍後再進行快照。</p>
<blockquote>
<p>反串註明：如果公司 KPI 是以產生程式碼行數的話或許可以大幅增加你的績效。</p>
</blockquote>
<h3 id="1-11-為測試案例打上標籤"><a href="#1-11-為測試案例打上標籤" class="headerlink" title="1.11 為測試案例打上標籤"></a>1.11 為測試案例打上標籤</h3><p>這個做法主要是依賴於測試運行環境時主要有提供 filter 測試案例的功能，筆者覺得有趣但要思考的一點是：設計中有分類設計，就會免不了遇到分類時要如何管理的議題。</p>
<p>如果真的要使用就必須先考量好分類的標準，先例可以參考比方 Github 開源專案中對於 Issue 所做的 Tag 分類，或是 Git 中 Commit 時會用到的 Message 標籤。</p>
<h3 id="1-12-把測試案例進行至少兩個層次的分類"><a href="#1-12-把測試案例進行至少兩個層次的分類" class="headerlink" title="1.12 把測試案例進行至少兩個層次的分類"></a>1.12 把測試案例進行至少兩個層次的分類</h3><p>這部分主要是警惕避免將案例描述全合併成一個案例，使其名稱過長，而規模越大的專案就越容易受其影響。</p>
<h3 id="3-3-如果可以，使用真實且完全渲染的組件來進行測試"><a href="#3-3-如果可以，使用真實且完全渲染的組件來進行測試" class="headerlink" title="3.3 如果可以，使用真實且完全渲染的組件來進行測試"></a>3.3 如果可以，使用真實且完全渲染的組件來進行測試</h3><p>這一部分筆者認為應考慮進行元件測試時要使用社交型測試風格還是孤立型測試風格。</p>
<p>以孤立型風格來說，目標的關注點將會在於每個元件本身在各種案例下應該會呈現的樣貌，其中用到 Vue Test Utils 中的 <code>shallowMount</code> 不失為一種合理的用法，因為當我們在透過 <code>&lt;-stub&gt;</code> 隔絕底下子元件時，我們主要是希望先關注在受測物（元件本身）所發生的事情。而若想確保與依賴物之間的關係，孤立型測試可再以 <code>mount</code> 來快照子元件的樣貌來保證子元件更改時會通知。</p>
<h3 id="4-4-使用-Test-linter-來避免測試程式的問題"><a href="#4-4-使用-Test-linter-來避免測試程式的問題" class="headerlink" title="4.4 使用 Test linter 來避免測試程式的問題"></a>4.4 使用 Test linter 來避免測試程式的問題</h3><p>基本上主要是有關於設置 ESLint 或 ESLint + Prettier 時有沒有好好設置規則，如<a href="https://ithelp.ithome.com.tw/articles/10308153" target="_blank" rel="noopener">先前所提</a> 到 Vitest 也有提供 Config 設定 <code>test.globals</code> 的功能，那麼我們也需要在 <code>.eslintrc.json</code> 通知 ESLint 這個全域變數的存在。</p>
<p>而文中更加強的部分是，要加入有關於給測試時用的 Lint！主要有時可能為了開發上的方便會用到 <code>.skip</code> 語法來跳過某些測試情境或案例，甚至是訂定撰寫案例上的規則，這時候這些給測試專用的 Lint 就非常方便。</p>
<p>但免不了的是，在使用跨開發環境時的功能還是有機會被影響到，比方前面<a href="https://ithelp.ithome.com.tw/articles/10309162" target="_blank" rel="noopener">提到</a> 在 Vitest UI 內寫測試時，相關工具會沒辦法引入設定而導致錯誤發生。</p>
<hr>
<p>以上便是有關於一些撰寫測試案例上有關於最佳實踐的補充說明，再次說到，指南的部分真的沒有很長，非常推薦大家可以花時間閱讀。而隨著大家測試撰寫的越多，你可能也會找到大家未發現過的優良實踐，也歡迎大家踴躍分享自己的經驗！</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 修飾符 modifier</title>
    <url>/vue.js/Vue-004-modifier/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="修飾符"><a href="#修飾符" class="headerlink" title="修飾符"></a>修飾符</h2><p>上一章節介紹到指令的部分，還蠻多的東西需要一點時間消化，而今天要來介紹一點相對簡單的東西，那就是修飾符(modifier)啦！在 Vue.js中，修飾符以半形句號(<code>.</code>)<strong>後綴</strong>在指令上來表示<strong>觸發事件時會另外使用什麼方法</strong>，而修飾符的種類分別有：</p>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">事件修飾符</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">按鍵修飾符</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/events.html#%E7%B3%BB%E7%BB%9F%E4%BF%AE%E9%A5%B0%E9%94%AE" target="_blank" rel="noopener">系統修飾鍵</a></li>
</ul>
<a id="more"></a>

<h2 id="事件修飾符"><a href="#事件修飾符" class="headerlink" title="事件修飾符"></a>事件修飾符</h2><p>事件修飾符是將常用的一些事件處理事件綁定在我們所觸發的指令上，例如我們常會在實作上遇見的<strong>點擊冒泡</strong>觸發事件，以往我們會透過<code>event.preventDefault()</code>來處理這一類事件，而在 Vue.js 中我們可以在<code>@click</code>後面加上<code>.prevent</code>就能夠在觸發<code>handleOnClick</code>後觸發<code>event.preventDefault()</code>：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">&lt;button <span class="class"><span class="keyword">type</span></span>=<span class="string">"button"</span> <span class="meta">@click</span>.prevent=<span class="string">"handleOnClick"</span>&gt;<span class="type">Click</span> <span class="type">Me</span>!&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>除此之外的事件修飾符還有：</p>
<ul>
<li><code>.stop</code>：可以阻止原先綁定的指令繼續傳播回其他元素。</li>
<li><code>.once</code>：該指令所綁定的事件只會執行一次。</li>
<li><code>.passive</code>：被修飾的指令若條件符合將會立即觸發，例如在監聽捲軸滾動時<code>v-on:scroll.passive</code>，只要捲軸一滾動就會立即觸發，並不需要等到完成捲軸滾動的行為。</li>
<li><code>.prevent</code>：有如在方法上使用 <code>event.preventDefault()</code> 來阻止冒泡事件。</li>
<li><code>.capture</code>：在冒泡事件中，原本會先到<strong>目標元素</strong>才執行，並往回觸發而被此修飾符修飾的元素將會優先執行。</li>
</ul>
<p>舉例來說，下方例子原本會因為<strong>冒泡事件</strong>的關係，點擊<code>#div2</code>的元素後會先觸發<code>handleOnClickTwo</code>，在冒泡觸發<code>handleOnClickOne</code>，但因為現在有在<code>#div1</code>的點擊事件增加<code>.capture</code>修飾符，所以反而會先觸發<code>handleOnClickOne</code>，在到達目標元素<code>#div2</code>，並觸發<code>handleOnClickTwo</code>。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"div1"</span> @click.capture=<span class="string">"handleOnClickOne"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"div2"</span> @click=<span class="string">"handleOnClickTwo"</span>&gt;</span><br><span class="line">        &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.self</code>：類似上面的範例概念，但這個修飾符是當指令是觸發在自己元素身上的時候才會去執行，例如下面範例點擊元素<code>#div2</code>，原先一樣原本會依序觸發<code>handleOnClickTwo</code>、<code>handleOnClickOne</code>，但因為元素<code>#div1</code>的指令增加了<code>.self</code>修飾符所以不會觸發<code>handleOnClickOne</code>。</li>
</ul>
<p>只有在是點擊元素<code>#div1</code>的情況下，才會觸發<code>handleOnClickOne</code>。</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="symbol">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="symbol">id</span>=<span class="string">"div1"</span> @click.<span class="literal">self</span>=<span class="string">"handleOnClickOne"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="symbol">id</span>=<span class="string">"div2"</span> @click=<span class="string">"handleOnClickTwo"</span>&gt;</span><br><span class="line">        &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>冒泡事件相關的修飾符概念比較難懂一些，大家可以多練習看看，順便跟黑黑一起複習<a href="https://javascript.info/bubbling-and-capturing" target="_blank" rel="noopener">冒泡事件</a>！<br><img src="https://ithelp.ithome.com.tw/upload/images/20190907/20119062ODC8RZPq34.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190907/20119062ODC8RZPq34.jpg"></p>
<h2 id="按鍵修飾符"><a href="#按鍵修飾符" class="headerlink" title="按鍵修飾符"></a>按鍵修飾符</h2><p>第二個要介紹的按鍵修飾符則是提供<strong>偵測鍵盤按鍵</strong>觸發方法(<code>methods</code>)的功能，例如當我們要使用按下<code>enter</code>鍵時啟用方法可以這麼做：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> @keyup.<span class="attribute">enter</span>=<span class="string">"sumbitValid"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>這樣一來如果有一些 input 欄位想要讓使用者快速 keyin 就可以使用這個修飾符增加使用者良好體驗。</p>
<p>另外，按鍵修飾符在更早的版本也支援<code>keycode</code>的用法，只可惜目前已經廢除了。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> @keyup.<span class="attribute">13</span>=<span class="string">"sumbitValid"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>其他官方提供的按鍵修飾符：</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code></li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<h2 id="系統修飾鍵"><a href="#系統修飾鍵" class="headerlink" title="系統修飾鍵"></a>系統修飾鍵</h2><p>系統修飾鍵則是將事件綁定在要按下相對應的按鍵才能觸發方法的功能，假如上方範例還要多一個同時按下<code>shift</code>才能觸發的情境，就會變成：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> @keyup.enter.<span class="attribute">shift</span>=<span class="string">"sumbitValid"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>其他也可以使用的系統修飾鍵：</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<p>透過本篇 Vue.js 所介紹的修飾符，搭配昨天的指令，已經可以組合出許多花樣！而下一章節將會介紹 Vue.js 實體一些常用 api(<code>data</code>、<code>computed</code>、<code>methods</code>以及<code>watch</code>)。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>【雜談ノ章】那些沒說到的內容、完賽感言、TOC 與參考資料們</title>
    <url>/testing/ithelp-2022-vitest-35/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' />
</div>

<h1 id="那些沒說到的部分"><a href="#那些沒說到的部分" class="headerlink" title="那些沒說到的部分"></a>那些沒說到的部分</h1><p>在開賽時，起初寫了個預期的 TOC 來規劃要講哪些內容，然而隨著每天撰文下來，覺得有部分內容比較偏向額外的學習，因此在評估後，決定調整原先 TOC 的內容，定義一下我認為至少先學到哪個部分就已足夠開始在實際專案中應用，而這一段落主要是來小談一下這些異動的章節有哪些，以及為什麼會有這些異動與將來是否會再陸續補充。</p>
<a id="more"></a>

<ul>
<li><p>訪問實際導入測試的團隊心路歷程：會想擷取其他團隊經驗最主要是擔心導入後的成效問題，但訪問到不少人大部分都是支持充分研究後先寫再來調整，剩下都是怎麼把它運作得更好的後談，後來筆者自己想想學習與導入其實也不衝突，但有些內容真的要試過了才知道，因此想把這部分挪到後續有空時再來補充。</p>
</li>
<li><p>測試驅動開發（Test-Driven Development, TDD）：TDD 本身是個值得深入討論的主題，只用一篇短文提及其實有些可惜，但要深入又會模糊了學習測試的焦點，因此後來想想乾脆透過測驗章節中的 Demo 環節稍微展現一下 TDD 精神下的紅燈綠燈要如何開發，若讀者有興趣了自然會對 TDD 感到好奇，這一部分賽後應該會考慮與下方的重構一起討論。</p>
</li>
<li><p>測試與重構（Refactor with Testing）：在重構的領域中，其實還能夠再細分為針對測試程式碼的重構與產品程式碼的重構，而測試程式碼的重構主要是基於具有更高的可讀性與可維護性，甚至提升測試程式碼的執行效率等等，這其實很仰賴大量的實作後才能有所體會，而本系列文定位希望是以入門測試為主，所以同樣保留至賽後再來考慮；至於產品程式碼的重構，則已經偏向了 Vue 中的最佳實踐等等議題，雖說測試程式碼與產品程式碼是相生的概念，但這部分建議以測試作為保護的方向去調整產品程式碼即可，後續主要還是會以測試程式碼中的內容為主。</p>
</li>
<li><p>漏網之魚：原先是要談談測試中失敗的議題，但同樣這部分需要大量實作才會比較有感，而前面的變異測試（Mutation Testing）也是降低漏網之魚的手段之一，因此先有變異測試的概念我覺得剩下就是在慢慢補足案例已經，重新與團隊思考測試案例路徑的規劃即可。</p>
</li>
</ul>
<hr>
<h1 id="完賽感言"><a href="#完賽感言" class="headerlink" title="完賽感言"></a>完賽感言</h1><p>屏除了上述部分，這邊首先要恭喜的是一起閱讀本系列文的讀者，對於基本的測試概念來說你們也完賽了！你可能會訝異於感覺還有不少東西沒提及，但是其餘的東西都是從基本的概念延伸而來的。就像開發產品程式碼一樣，我們也需要透過實際的測試經驗來慢慢磨練我們的測試技巧，並從中體會更多的心得與不斷精進測試相關的內容。</p>
<p>再來也要恭喜我自己（？），今年參賽其實也是挺突然的，一直到了開賽最後一天才打算來發文 XD，最主要的原因是有些部分希望能準備得更充分一點，但這種東西其實也沒有準備完的一天⋯⋯，因為測試程式碼的工具也不斷在進步，剩下的東西只能靠時間來驗證了。所以最後乾脆一不做二不休，直接給他報名下去，雖然報名後每天都在懷疑人生，好幾天寫到晚上十一點差點超時，不然就是一寫完直接累癱睡爆的那種，可是，我撐過來惹！！！感謝賽期間女友的支持與家中貓貓們的陪伴，另外也感謝同事把我鐵人賽當作在追番一樣閱讀，給了我不少回饋與靈感。</p>
<p>最後想要一起恭喜其他鐵人們，不論完賽與否，我覺得有繁中文件可以閱讀是一件很幸福的事情，更別提如果是追最新技術的鐵人們，在國內文獻上的參考很少的情況下還能夠寫出很多優質的文章，真的非常不簡單。由其每當我沒靈感時我都會邊看看其他鐵人寫了什麼 XD 時常一不注意差點忘記自己也在參賽，現在終於能好好來拜讀了！</p>
<hr>
<h1 id="TOC"><a href="#TOC" class="headerlink" title="TOC"></a>TOC</h1><blockquote>
<p>寫完文章要列 TOC 簡單多了（？）</p>
</blockquote>
<p>此 TOC 是透過 JavaScript 語法直接在<a href="https://ithelp.ithome.com.tw/users/20119062/ironman/5554?page=1" target="_blank" rel="noopener">鐵人賽目錄</a> 頁面上 Console 取得系列文目錄標題與連結，歡迎各位鐵人自行取用下列語法。（迷：等一下，大家應該都寫完 TOC 了吧！！！！）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> titleEl = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.qa-list .qa-list__title'</span>)</span><br><span class="line"><span class="keyword">const</span> linkEl = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.qa-list .qa-list__title a'</span>)</span><br><span class="line"><span class="keyword">const</span> tocList = [<span class="string">'\n'</span>]</span><br><span class="line"></span><br><span class="line">titleEl.forEach(<span class="function">(<span class="params">el, idx</span>) =&gt;</span> tocList.push(<span class="string">`- [<span class="subst">$&#123;el.innerText&#125;</span>](<span class="subst">$&#123;linkEl[idx].href&#125;</span>)\n`</span>)) <span class="comment">// 直接產出 Markdown 格式</span></span><br><span class="line"><span class="built_in">console</span>.log(tocList.join(<span class="string">''</span>)) <span class="comment">// 顯示於 Console 控制台中自行複製即可</span></span><br></pre></td></tr></table></figure>

<p>測試案例⋯⋯ （誒</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'it should return markdown list'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 不知道為什麼寫完當下連這個都想測試一下</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>產出結果：</p>
<ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10287432" target="_blank" rel="noopener">【初始ノ章】前言與 TOC</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10292537" target="_blank" rel="noopener">【初始ノ章】測試建置：跟著系列文一起學測試</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10293368" target="_blank" rel="noopener">【初始ノ章】測試建置：在自己的專案加入單元測試來學測試</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10294024" target="_blank" rel="noopener">【初始ノ章】測試建置：Vitest Config Setting</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10294706" target="_blank" rel="noopener">【概念ノ章】測試價值：為什麼我需要測試</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10295380" target="_blank" rel="noopener">【概念ノ章】測試價值：加入測試的時機</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10296174" target="_blank" rel="noopener">【概念ノ章】測試脈絡－1. 決定測試類型</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10296779" target="_blank" rel="noopener">【概念ノ章】測試脈絡－2. 決定測試工具</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10297571" target="_blank" rel="noopener">【概念ノ章】測試脈絡－3. 決定測試情境與測試案例</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10298229" target="_blank" rel="noopener">【概念ノ章】測試脈絡－4. 測試案例中的 3A 模式</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10298760" target="_blank" rel="noopener">【概念ノ章】測試脈絡－5. 撰寫測試碼 FIRST 法則與學習步驟</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10299474" target="_blank" rel="noopener">【語法ノ章】案例與情境：describe &amp; it 與輔助 API</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10300210" target="_blank" rel="noopener">【語法ノ章】Setup &amp; Teardown：beforeAll, beforeEach, AfterAll &amp; AfterEach</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10300787" target="_blank" rel="noopener">【語法ノ章】斷言（Assertion）上篇：斷言語法與 Matchers</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10301430" target="_blank" rel="noopener">【語法ノ章】斷言（Assertion）下篇： 替身、快照（Snapshot）與拋出錯誤</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10302202" target="_blank" rel="noopener">【試験ノ章】第一個測驗：測試情境案例、Setup &amp; Teardown 與 Matchers</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10302568" target="_blank" rel="noopener">【概念ノ章】測試工具： Vue Test Utils 與元件測試</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10303238" target="_blank" rel="noopener">【語法ノ章】元件測試：容器（Wrapper）</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10303784" target="_blank" rel="noopener">【語法ノ章】元件測試：容器方法（Wrapper methods）－選擇器與陷阱</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10304396" target="_blank" rel="noopener">【語法ノ章】元件測試：容器方法（Wrapper methods）－取得目標資訊</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10304881" target="_blank" rel="noopener">【語法ノ章】元件測試：容器方法（Wrapper methods）－模擬事件</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10305460" target="_blank" rel="noopener">【語法ノ章】元件測試：模擬 Vue APIs（data, props）</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10305821" target="_blank" rel="noopener">【語法ノ章】元件測試：模擬 Vue APIs（emit, provide/inject）</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10306500" target="_blank" rel="noopener">【語法ノ章】元件測試：模擬 Vue APIs（slots, custom directives）</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10306965" target="_blank" rel="noopener">【試験ノ章】第二個測驗：容器（Wrapper）與容器方法（Wrapper methods）</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10307288" target="_blank" rel="noopener">【概念ノ章】測試替身（Test Double）：Dummy, Stub, Spy, Fake &amp; Mock</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10307790" target="_blank" rel="noopener">【語法ノ章】測試替身（Test Double）feat. Vue Test Utils</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10308153" target="_blank" rel="noopener">【語法ノ章】測試替身（Test Double）feat. Vitest Mocking API（Date, Timer）</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10308508" target="_blank" rel="noopener">【語法ノ章】測試替身（Test Double）feat. Vitest Mocking API（Function, Globals &amp; Modules）</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10308907" target="_blank" rel="noopener">【語法ノ章】Vue Ecosystem 篇：Vue Router 測試</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10309064" target="_blank" rel="noopener">【語法ノ章】Vue Ecosystem 篇：Pinia 測試</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10309162" target="_blank" rel="noopener">【進階ノ章】Vitest UI</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10309187" target="_blank" rel="noopener">【進階ノ章】覆蓋率（Coverage）</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10309245" target="_blank" rel="noopener">【進階ノ章】寫測試的最佳實踐（Testing Best Practice）</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10309267" target="_blank" rel="noopener">【雜談ノ章】那些沒說到的內容、完賽感言、TOC 與參考資料們</a></li>
</ul>
<hr>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p>不想看我的系列文也沒關係（嗚），但這些文章你絕對不能錯過。</p>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><h3 id="環境設置"><a href="#環境設置" class="headerlink" title="環境設置"></a>環境設置</h3><ul>
<li><a href="https://www.thisdot.co/blog/testing-with-vitest" target="_blank" rel="noopener">Ignacio Falk - Testing with Vitest</a></li>
</ul>
<h3 id="測試金字塔"><a href="#測試金字塔" class="headerlink" title="測試金字塔"></a>測試金字塔</h3><ul>
<li><a href="https://martinfowler.com/bliki/TestPyramid.html" target="_blank" rel="noopener">Martin Fowler - TestPyramid</a></li>
<li><a href="https://martinfowler.com/articles/practical-test-pyramid.html" target="_blank" rel="noopener">Martin Fowler - The Practical Test Pyramid</a></li>
</ul>
<h3 id="單元測試"><a href="#單元測試" class="headerlink" title="單元測試"></a>單元測試</h3><ul>
<li><a href="https://martinfowler.com/bliki/UnitTest.html" target="_blank" rel="noopener">Martin - UnitTest</a></li>
<li><a href="https://otischou.tw/2019/08/02/unit-test.html" target="_blank" rel="noopener">otischou - 暸解單元測試</a></li>
</ul>
<h3 id="測試斷言庫"><a href="#測試斷言庫" class="headerlink" title="測試斷言庫"></a>測試斷言庫</h3><ul>
<li><a href="https://dwatow.github.io/2020/04-18-jest/jest-doc-2/" target="_blank" rel="noopener">Chris - 讀 Jest Doc - 斷言庫</a></li>
</ul>
<h3 id="測試替身"><a href="#測試替身" class="headerlink" title="測試替身"></a>測試替身</h3><ul>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/09/test-double1.html" target="_blank" rel="noopener">Teddy Chen - Test Double（1）：什麼是測試替身？</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/09/test-double2.html" target="_blank" rel="noopener">Teddy Chen - Test Double（2）：五種替身簡介</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/09/test-double3dummy-object.html" target="_blank" rel="noopener">Teddy Chen - Test Double（3）：Dummy Object</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/09/test-double4test-stub.html" target="_blank" rel="noopener">Teddy Chen - Test Double（4）：Test Stub</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/10/test-double5test-spy.html" target="_blank" rel="noopener">Teddy Chen - Test Double（5）：Test Spy</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/10/test-double6fake-object.html" target="_blank" rel="noopener">Teddy Chen - Test Double（6）：Fake Object</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2014/10/test-double7mock-object.html" target="_blank" rel="noopener">Teddy Chen - Test Double（7）：Mock Object</a></li>
<li><a href="https://martinfowler.com/bliki/TestDouble.html" target="_blank" rel="noopener">Martin Fowler - TestDouble</a></li>
<li><a href="https://medium.com/starbugs/unit-test-%E4%B8%AD%E7%9A%84%E6%9B%BF%E8%BA%AB-%E6%90%9E%E4%B8%8D%E6%B8%85%E6%A5%9A%E7%9A%84dummy-stub-spy-mock-fake-94be192d5c46" target="_blank" rel="noopener">被蛇咬到的魯卡 - Unit Test 中的替身：搞不清楚的Dummy 、Stub、Spy、Mock、Fake</a></li>
<li><a href="https://jchu.cc/2018/08/16-test.html" target="_blank" rel="noopener">Julian Chu - 測試中常見的名詞：Stub, Dummy, Mock..等等</a></li>
</ul>
<h3 id="覆蓋率"><a href="#覆蓋率" class="headerlink" title="覆蓋率"></a>覆蓋率</h3><ul>
<li><a href="http://teddy-chen-tw.blogspot.com/2019/02/blog-post.html" target="_blank" rel="noopener">Teddy Chen - 透過測試涵蓋率讓重構更有信心（上）：分支涵蓋率</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2019/02/blog-post_19.html" target="_blank" rel="noopener">Teddy Chen - 透過測試涵蓋率讓重構更有信心（中）：突變測試</a></li>
<li><a href="http://teddy-chen-tw.blogspot.com/2019/02/blog-post_20.html" target="_blank" rel="noopener">Teddy Chen - 透過測試涵蓋率讓重構更有信心（下）：特徵測試</a></li>
<li><a href="https://martinfowler.com/bliki/TestCoverage.html" target="_blank" rel="noopener">Martin Fowler - TestCoverage</a></li>
</ul>
<h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><ul>
<li><a href="https://ithelp.ithome.com.tw/users/20010292/ironman/462" target="_blank" rel="noopener">就是91 - 30天快速上手TDD</a></li>
</ul>
<h3 id="突變測試"><a href="#突變測試" class="headerlink" title="突變測試"></a>突變測試</h3><ul>
<li><a href="https://juejin.cn/post/6926476489345122317" target="_blank" rel="noopener">wwwzbwcomlv - 测试你的测试：Stryker Mutator + Jest 实现 JS / TS 变异测试</a></li>
</ul>
<h3 id="最佳實踐"><a href="#最佳實踐" class="headerlink" title="最佳實踐"></a>最佳實踐</h3><ul>
<li><a href="https://github.com/goldbergyoni/javascript-testing-best-practices" target="_blank" rel="noopener">goldbergyoni/javascript-testing-best-practices</a></li>
</ul>
<h2 id="書籍"><a href="#書籍" class="headerlink" title="書籍"></a>書籍</h2><ul>
<li><a href="http://xunitpatterns.com/index.html" target="_blank" rel="noopener">XUnit Test Patterns</a></li>
<li><a href="https://www.tenlong.com.tw/products/9789862017050" target="_blank" rel="noopener">Robert C. Martin - 無瑕的程式碼－敏捷軟體開發技巧守則</a></li>
<li><a href="https://www.tenlong.com.tw/products/9789865021832" target="_blank" rel="noopener">Martin Fowler - 重構｜改善既有程式的設計, 2/e</a></li>
<li><a href="https://www.tenlong.com.tw/products/9789864342471" target="_blank" rel="noopener">Roy Osherove - 單元測試的藝術</a></li>
<li><a href="https://www.tenlong.com.tw/products/9789864345618" target="_blank" rel="noopener">Kent Beck 的測試驅動開發：案例導向的逐步解決之道</a></li>
<li><a href="https://www.tenlong.com.tw/products/9789863470090" target="_blank" rel="noopener">Mark Ethan Trostler - 可測試的 JavaScript</a></li>
<li><a href="https://www.tenlong.com.tw/products/9787111646709" target="_blank" rel="noopener">Edd Yerburgh - Vue.js 應用測試</a></li>
<li><a href="https://www.tenlong.com.tw/products/9789864341313" target="_blank" rel="noopener">CODE COMPLETE：軟體開發實務指南, 2/e</a></li>
</ul>
<h2 id="Facebook-追蹤"><a href="#Facebook-追蹤" class="headerlink" title="Facebook 追蹤"></a>Facebook 追蹤</h2><ul>
<li><a href="https://www.facebook.com/91agile/" target="_blank" rel="noopener">91 敏捷開發之路</a></li>
<li><a href="https://www.facebook.com/groups/2430262353914136" target="_blank" rel="noopener">F2EUnit.tw-單元測試在前端</a></li>
</ul>
<h2 id="相關工具"><a href="#相關工具" class="headerlink" title="相關工具"></a>相關工具</h2><ul>
<li><a href="https://vuejs.org/guide/scaling-up/testing.html#testing" target="_blank" rel="noopener">Vue3 - Testing</a></li>
<li><a href="https://vitest.dev/" target="_blank" rel="noopener">Vitest</a></li>
<li><a href="https://test-utils.vuejs.org/" target="_blank" rel="noopener">Vue Test Utils</a></li>
<li><a href="https://stryker-mutator.io/" target="_blank" rel="noopener">Stryker Mutator</a></li>
<li><a href="https://jestjs.io/" target="_blank" rel="noopener">Jest</a></li>
<li><a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a></li>
<li><a href="https://www.chaijs.com/" target="_blank" rel="noopener">Chai</a></li>
<li><a href="https://sinonjs.org/" target="_blank" rel="noopener">Sinon</a></li>
</ul>
<p>– 希望將來還有機會與各位鐵人一起共襄盛舉！–</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Vue.js</tag>
        <tag>Vitest</tag>
        <tag>Vue Test Utils</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 資料選項 Options</title>
    <url>/vue.js/Vue-005-options/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h1 id="data-資料"><a href="#data-資料" class="headerlink" title="data 資料"></a>data 資料</h1><p>data 是用來儲存資料的地方，而 Vue.js 會透過前面介紹的樣板語法，將其對應的值輸出顯示到 DOM 上，並且最重要的是，只要一更動 data 裡面的資料，Vue.js 將會透過內部已經幫我們處理好的邏輯，去比對 HTML 哪邊需要更改，實現部分渲染，達成資料驅動畫面的概念。範例：</p>
<p>HTML 部分：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">    &#123;&#123; a &#125;&#125;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>JavaScript部分：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">let</span> <span class="string">vm = new Vue(&#123;</span></span><br><span class="line">  <span class="attr">el</span>: <span class="string">'#app',</span></span><br><span class="line">  <span class="attr">data</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">a</span>: <span class="string">1,</span></span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">b1</span>: <span class="string">'something',</span></span><br><span class="line">        <span class="attr">b2</span>: <span class="string">'another</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;)</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>首先如同前面介紹，使用 <code>new</code> 關鍵字去創建一個實體，並使用花括弧傳入我們所需要的參數，例如在 <code>el</code> 中去填入我們要渲染的元素範圍 <code>#app</code> ，在 data 中則一樣是透過物件再把我們要的資料配對給他，我們就可以在 HTML 部分以樣板語法取得對應的值。</p>
<h1 id="computed-計算屬性"><a href="#computed-計算屬性" class="headerlink" title="computed 計算屬性"></a>computed 計算屬性</h1><p>前面提到的 data 主要是用來存放一些資料，如果我們今天在顯示資料前需要<strong>先計算</strong> data 的內容<strong>再顯示</strong>到畫面上時，就可以使用 computed 來幫助我們，例如以匯率計算來說：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  目前擁有台幣：</span><span class="template-variable">&#123;&#123; money &#125;&#125;</span><span class="xml">元。</span></span><br><span class="line"><span class="xml">  轉換為日幣後：</span><span class="template-variable">&#123;&#123; money / 0.3&#125;&#125;</span><span class="xml">日圓。</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    money:<span class="number">1000</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>原先我們可能在樣板語法中直接去計算內容，但是如果要重複使用的話將會大量的複製貼上，此時便可以使用<code>computed</code>來計算，修改後如下：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  目前擁有台幣：</span><span class="template-variable">&#123;&#123; money &#125;&#125;</span><span class="xml">元。</span></span><br><span class="line"><span class="xml">  轉換為日幣後：</span><span class="template-variable">&#123;&#123; JPY &#125;&#125;</span><span class="xml">日圓。</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    money:<span class="number">1000</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">    JPY : <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">      <span class="keyword">return</span> this.money / <span class="number">0.3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>這樣改變後，在 HTML 的部分將更加的直觀，而將計算的方法寫在實體當中，需要取得的時候如同在 data 的資料，將對應的 key（<code>JPY</code>）寫在樣板語法鐘即可。</p>
<p><strong>而使用這個方法要注意的地方在於</strong>，若其計算的途中沒有使用到 <code>data</code> 中的任何一筆資料時，<strong>資料將會無法更新！</strong>，因此若確定每次使用都會更新到的部分建議還是使用 <code>methods</code> 的方法來驅動。</p>
<h1 id="methods-方法"><a href="#methods-方法" class="headerlink" title="methods 方法"></a>methods 方法</h1><p>與<code>computed</code>不一樣的是，<code>methods</code>可以直接供 Vue.js 的實體來使用，也可以藉由指令中的表達式使用，更重要的是還能將參數帶入其函式中( <code>computed</code> 是無法傳入參數的)。</p>
<p>範例如下：</p>
<p>在這個完整範例中，原先按鈕會顯示 <code>data</code> 中的 <code>text</code>資料，按下按鈕後透過指令 <code>v-on:click</code> 縮寫（<code>@click</code>）去執行  <code>methods</code> 裡面的 <code>handleOnClick</code>，並將參數 ‘Shawn’傳到函式中，最後透過 <code>this.text</code> 方法取得 data 裡面的 <code>text</code> 並且更改為我們需要的內容。</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleOnClick('Shawn')"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span></span><span class="template-variable">&#123;&#123;text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    tex<span class="variable">t:</span><span class="string">'Hello Vue!'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  method<span class="variable">s:</span>&#123;</span><br><span class="line">    handleOnClick : <span class="function"><span class="keyword">function</span><span class="params">(name)</span>&#123;</span></span><br><span class="line">      <span class="keyword">return</span> this.text = `Hello $&#123;name&#125;!`</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>而<code>methods</code>要注意的地方是</strong>，函式的部分不能使用 ES6 中的箭頭函式<code>arrow function</code>，否則<code>this</code>指向 window 最後拋出<code>undefined</code>。</p>
<h1 id="watcher-監聽器"><a href="#watcher-監聽器" class="headerlink" title="watcher 監聽器"></a>watcher 監聽器</h1><p><code>watch</code>的用法如同監聽器一樣，在與其綁定的資料有更動時會執行對應的函式，需要異步執行資料變化時便可以使用，而參考官網的範例如下：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    今晚晚餐吃這個：</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"question"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; answer &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    question:<span class="string">''</span>,</span><br><span class="line">    answer:<span class="string">'讓我來幫你決定要吃什麼吧！'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  watch:&#123;</span><br><span class="line">    question : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.getAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    getAnswer:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">      fetch(<span class="string">'https://yesno.wtf/api'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span>=&gt;</span>res.json())</span><br><span class="line">      .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        self.answer = res.answer</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>這個範例是透過 yesno 網站所提供的 API 去實作一個決定晚餐要不要吃這個的簡單應用程式，使用者在 <code>input</code> 輸入問題後，透過上篇提過的 <code>v-model</code> 雙向綁定資料到<code>data</code>中的<code>question</code>，接著資料內容被改變後去驅動監聽器去啟動對應的方法並啟動 <code>methods</code> 裡面的 <code>getAnswer</code> ，接著 <code>getAnswer</code> 發送了一個<code>request</code>到<a href="https://yesno.wtf/api" target="_blank" rel="noopener">https://yesno.wtf/api</a>並得到一個回應後，我們再將回應的資料傳回去 data 中的 <code>answer</code>。</p>
<p>以上這幾個用法是屬於 Vue.js 實體的一些相關用法，結合樣板語法、指令與修飾符後我們已經可以完成一個簡單的小應用了，而下個章節我們將繼續介紹 Vue.js 的生命週期！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 生命週期 lifecycle</title>
    <url>/vue.js/Vue-006-lifecycle/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p><img src="https://ithelp.ithome.com.tw/upload/images/20190909/20119062ONbDHOY5Nq.png" alt="https://ithelp.ithome.com.tw/upload/images/20190909/20119062ONbDHOY5Nq.png"></p>
<h2 id="生命週期"><a href="#生命週期" class="headerlink" title="生命週期"></a>生命週期</h2><p>生命週期（如上圖）主要是在說明一個元件從生(初始化)到死(註銷)的過程，對於生命週期有良好的理解，可以更有效的運用他，譬如要在哪個階段載入 AJAX 的資料？哪個階段之後才能開始撈 <code>data</code> 裡的資料？為了解決這一類時機的問題，Vue.js 提供了這些<strong>時機</strong>的呼叫方式，稱之為 <strong>hook</strong>。而為了要好好地瞭解 Vue.js 的生命週期，下面透過一個簡單的範例，來捕捉各種生命週期的狀態：</p>
<a id="more"></a>

<p>HTML部分</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>JavaScript部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message:<span class="string">'get Data!'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        handleOnClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeCreate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'beforeCreate'</span>)</span><br><span class="line">        alert(<span class="string">"el屬性： "</span>+<span class="keyword">this</span>.$el)</span><br><span class="line">        alert(<span class="string">"data資料： "</span>+<span class="keyword">this</span>.$data.message)</span><br><span class="line">    &#125;,</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(<span class="string">'created'</span>)</span><br><span class="line">      alert(<span class="string">"el屬性： "</span>+<span class="keyword">this</span>.$el)</span><br><span class="line">      alert(<span class="string">"data資料： "</span>+<span class="keyword">this</span>.$data.message)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(<span class="string">'beforeMount'</span>)</span><br><span class="line">      alert(<span class="string">"el屬性： "</span>+<span class="keyword">this</span>.$el)</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'mounted'</span>)</span><br><span class="line">        alert(<span class="string">"el屬性： "</span>+<span class="keyword">this</span>.$el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>設定好一個 Vue.js 的實體之後，接著一步一步對照生命週期的圖來說明：</p>
<h2 id="new-Vue"><a href="#new-Vue" class="headerlink" title="new Vue"></a>new Vue</h2><p>初始化 Vue.js 實體。</p>
<h2 id="init-events-lifecycle"><a href="#init-events-lifecycle" class="headerlink" title="init events $ lifecycle"></a>init events $ lifecycle</h2><p>開始初始化 Vue.js 的生命週期。</p>
<h2 id="beforeCreate-hooks"><a href="#beforeCreate-hooks" class="headerlink" title="beforeCreate (hooks)"></a>beforeCreate (hooks)</h2><p>在此週期下， <code>$el</code> 尚未被建立，且 <code>data</code> 此時也尚未被定義出來，說明在這個階段中我們可以做的基本上是在於資料尚未被讀取進來的事情。而深入查看 Vue.js 檔案 <code>init.js</code> 中，會發現此階段尚未初始化 <code>props</code>、<code>data</code>、<code>methods</code>、<code>watch</code>、<code>computed</code>等 <code>options</code> 所以顯然上述的功能基本上是都不能夠使用的。</p>
<h2 id="init-injection-amp-reactivity"><a href="#init-injection-amp-reactivity" class="headerlink" title="init injection &amp; reactivity"></a>init injection &amp; reactivity</h2><p><del>9/9前原文：開始注入依賴項目。</del></p>
<p>比較好理解的話應該是<strong>此階段會開始將父元件所提供的資料傳遞給子元件做接收</strong>。也就是說在 <code>created</code> hook 執行前要將「提供/拿取 <code>data</code>值」這件事情給初始化完畢，以供使用。</p>
<p>在官方文件 <a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener">provide / inject</a> 一文中提到，父元件可以透過 <code>provide</code> 傳遞一個物件或是讓函式回傳一個物件的方法，供給子元件利用 <code>inject</code> 來得到該物件。</p>
<p>程式碼的部分則可以透過 Vue.js 官方 github 庫的檔案 <a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/inject.js" target="_blank" rel="noopener">inject.js</a> 中可以瞭解到底層的運作方式。</p>
<h2 id="created-hooks"><a href="#created-hooks" class="headerlink" title="created (hooks)"></a>created (hooks)</h2><p>由 <code>alert</code> 取得 <code>$el</code> 結果為 <code>undefined</code> ， <code>data</code> 的結果為 <code>get Data!</code> 的結論得出：</p>
<p>在此週期下， <code>$el</code> 尚未被建立，但 <code>data</code> 此時已經可以讀取的到了，說明在這個階段中我們可以做的基本上在於讀取資料相關的事情。深入研究，查看 Vue.js 中裡的檔案 <code>init.js</code> ，會發現已經初始化<code>props</code>、<code>data</code>、<code>methods</code>、<code>watch</code>、<code>computed</code>，因此也說明了若想要使用<code>data</code>等等的資料的話，至少得等到<code>created</code>這個階段才可以使用。</p>
<h2 id="el檢查"><a href="#el檢查" class="headerlink" title="el檢查"></a>el檢查</h2><p>這個階段會檢查Vue實體中是否含有 <code>$el</code> 的項目，有的話就繼續檢查是否含有 <code>template</code>，沒有的話則是等到手動調用 <code>vm.$mount()</code> 的時候才繼續。</p>
<h2 id="template檢查"><a href="#template檢查" class="headerlink" title="template檢查"></a>template檢查</h2><p>這個階段會檢查 Vue.js 實體中是否含有 <code>template</code> 的項目，沒有的話會將被 <code>$el</code> 綁定的 <code>outerHTML</code> 區域作為樣板替換，若有的話則是將 <code>template</code> 編譯進 <code>render function</code>。</p>
<h2 id="beforeMount-hooks"><a href="#beforeMount-hooks" class="headerlink" title="beforeMount (hooks)"></a>beforeMount (hooks)</h2><p>由 <code>alert</code> 取得 <code>$el</code> 結果顯示此時已經抓的到 <code>$el</code>：</p>
<p>在此週期下 DOM 已經被 Vue.js 載入了一個新的元素。但此時的差異在於， <code>$el</code> 裡面樣板語法尚未被賦予值進去，所以顯示的仍然是兩個花括號的部分<code></code>。</p>
<h2 id="mounted-hooks"><a href="#mounted-hooks" class="headerlink" title="mounted (hooks)"></a>mounted (hooks)</h2><p>由 <code>alert</code> 取得 <code>$el</code> 結果顯示此時已經抓的到 <code>$el</code>，並且此時樣板語法也確實的將資料傳遞進去，因此最後看到的是顯示<code>get Data!</code>的字串而非 <code></code> 了。而一般初始化的 Vue.js 元件的必經之路到此階段就結束了 (<strong>除了使用<code>keep-alive</code>的元件，<code>keep-alive</code>元件再次渲染時並不會觸發<code>created</code>、<code>mounted</code>等hooks</strong>)，因此我們可以再次看向官網的說明圖中，此階段後的線條是虛線的部分。</p>
<h2 id="beforeUpdate-hooks"><a href="#beforeUpdate-hooks" class="headerlink" title="beforeUpdate (hooks)"></a>beforeUpdate (hooks)</h2><p>此生命週期發生在資料即將被更新前，這個階段主要可以用在得知哪個元件即將發生資料改動，並且可以移除對其綁定的事件監聽器。</p>
<h2 id="updated-hooks"><a href="#updated-hooks" class="headerlink" title="updated (hooks)"></a>updated (hooks)</h2><p>此階段已經重新渲染完成資料更新後的狀態，並且要注意在此期間更改狀態，如果要更改官方建議使用<code>computed</code>或<code>watch</code>來進行資料更改。</p>
<h2 id="beforeDestroy-hooks"><a href="#beforeDestroy-hooks" class="headerlink" title="beforeDestroy (hooks)"></a>beforeDestroy (hooks)</h2><p>當一個實體要被銷毀前會觸發此生命週期(譬如透過主動調用<code>vm.$destroy()</code>或是當該元素所綁定的<code>v-if</code>條件為<code>false</code>時)。而這個階段我們可以做一些提醒的動作，例如<code>alert</code>來確認使用者的意圖。</p>
<h2 id="destroyed-hooks"><a href="#destroyed-hooks" class="headerlink" title="destroyed (hooks)"></a>destroyed (hooks)</h2><p>當一個實體已經被銷毀時會觸發此生命週期，這個階段的銷毀意味著所綁定的<code>watcher</code>、<code>child components</code>以及<code>event listeners</code>等等已經與原本元素毫無關聯了，但要注意的事情是父元件已經渲染在DOM上的視圖仍然會保留在頁面上，只有子元件會完全消失。</p>
<h3 id="補充：觸發渲染-Render-時機"><a href="#補充：觸發渲染-Render-時機" class="headerlink" title="補充：觸發渲染 Render 時機"></a>補充：觸發渲染 Render 時機</h3><p>透過以上生命週期，大致上已經可以瞭解每個周期 Vue.js 正在做什麼事情、我們能做什麼事情了，而觸發渲染的關鍵時刻是<code>beforeMount</code>到<code>mounted</code>時以及<code>beforeUpdate</code>至<code>updated</code>的這兩個階段。</p>
<p>最後如果在編寫 Vue.js 時有遇到哪邊渲染有問題，或是資料讀取不到的時候，不彷查看一下是不是做了生命週期所不能及的事情喔！</p>
<p>黑黑：沒有我所不能及的事情！（翻滾）<br><img src="https://ithelp.ithome.com.tw/upload/images/20190909/20119062gSCDaeWfkk.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190909/20119062gSCDaeWfkk.jpg"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 子元件 child component</title>
    <url>/vue.js/Vue-008-component-child/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="父子元件"><a href="#父子元件" class="headerlink" title="父子元件"></a>父子元件</h2><p>在某些情境下我們可能會在元件內使用大量重複的元素標籤以及內容，這個時候我們就可以把元件中的重複的內容再次元件化，並且作法同樣可以分為<strong>區域性</strong>與<strong>全域性</strong>。假設目前需求是把一個頁面拆分成 wrapper-header、wrapper-body 以及 wrapper-footer 元件並且在 wrapper-body 中還要再塞入其他元件：</p>
<p>在 HTML 部分要注意的地方是，HTML 在編譯的時候是<strong>不區分大小寫</strong>的，而在 JavaScript 中是<strong>無法使用<code>-</code>連字號來編寫</strong>，因此在格式上<a href="https://cn.vuejs.org/v2/style-guide/#%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99-%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90" target="_blank" rel="noopener">官方建議</a> HTML 部分採用 <code>kebab-case</code> 連字號命名法，而在 Vue.js 裡面採用<code>PascalCase</code>駝峰式命名法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wrapper-header</span>&gt;</span><span class="tag">&lt;/<span class="name">wrapper-header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wrapper-body</span>&gt;</span><span class="tag">&lt;/<span class="name">wrapper-body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wrapper-footer</span>&gt;</span><span class="tag">&lt;/<span class="name">wrapper-footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>在 JavaScript部分，區域性的作法是在 Vue.js 實體的 <code>components</code> 中使用 <code>Vue.extend</code> 去擴充元件，使得元件中物件除了可以回傳 <code>template</code> 之外，可以在裡面繼續使用 <code>components</code> 註冊一個新的元件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        WrapperHeader: Vue.extend(&#123;</span><br><span class="line">            template:<span class="string">'&lt;div&gt;Header&lt;/div&gt;'</span></span><br><span class="line">        &#125;),</span><br><span class="line">        WrapperBody: Vue.extend(&#123;</span><br><span class="line">            template:</span><br><span class="line">            <span class="string">'&lt;div&gt;'</span>+</span><br><span class="line">              <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">              <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">              <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">            <span class="string">'&lt;/div&gt;'</span>,</span><br><span class="line">            components:&#123;</span><br><span class="line">                wrapperInnerBody: Vue.extend(&#123;</span><br><span class="line">                    template: <span class="string">' &lt;div&gt;Body&lt;/div&gt; '</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">        WrapperFooter: Vue.extend(&#123;</span><br><span class="line">            template:<span class="string">'&lt;div&gt;Footer&lt;/div&gt;'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面這個作法是將元件以<strong>區域性</strong>的方法註冊，而這個方式會使得初始 Vue.js 的程式碼段落過長，如果每個元件都寫在裡頭，可能將來會不易管理，因此透過 ECMAScript 6 的物件縮寫（物件名稱與值相同時可省略值），將元件的部分挪到外頭，可使得程式碼更加的簡潔：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapperHeader = Vue.extend(&#123;</span><br><span class="line">    template:<span class="string">'&lt;div&gt;Header&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapperBody = Vue.extend(&#123;</span><br><span class="line">    template:</span><br><span class="line">    <span class="string">'&lt;div&gt;'</span>+</span><br><span class="line">        <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">        <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">        <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">    <span class="string">'&lt;/div&gt;'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        wrapperInnerBody: Vue.extend(&#123;</span><br><span class="line">            template: <span class="string">' &lt;div&gt;Body&lt;/div&gt; '</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapperFooter = Vue.extend(&#123;</span><br><span class="line">    template:<span class="string">'&lt;div&gt;Footer&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        wrapperHeader,</span><br><span class="line">        wrapperBody,</span><br><span class="line">        wrapperFooter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但這樣的作法依然是屬於<strong>區域性</strong>的，也就是只有在初始化 Vue.js 的變數 <code>vm</code> 中才能使用，而如果要讓元件變成是全域性的話，同樣可以使用 <code>Vue.component</code> 進行封裝：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapperHeader = Vue.extend(&#123;</span><br><span class="line">    template:<span class="string">'&lt;div&gt;Header&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapperBody = Vue.extend(&#123;</span><br><span class="line">    template:</span><br><span class="line">    <span class="string">'&lt;div&gt;'</span>+</span><br><span class="line">        <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">        <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">        <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">    <span class="string">'&lt;/div&gt;'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        wrapperInnerBody: Vue.extend(&#123;</span><br><span class="line">            template: <span class="string">' &lt;div&gt;Body&lt;/div&gt; '</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapperFooter = Vue.extend(&#123;</span><br><span class="line">    template:<span class="string">'&lt;div&gt;Footer&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'wrapper-header'</span>,wrapperHeader)</span><br><span class="line">Vue.component(<span class="string">'wrapper-body'</span>,wrapperBody)</span><br><span class="line">Vue.component(<span class="string">'wrapper-footer'</span>,wrapperFooter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app1'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app2'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如此一來不論是 <code>vm1</code> 或是 <code>vm2</code> 的 Vue.js 實體都可以使用這些元件之外，被註冊的元件中還能再使用其他的元件。</p>
<p>今天這個章節除了複習元件註冊方式並製作多個元件之外，還將子元件擴充進去元件當中，也示範了子元件區域性與全域性的作法，而下個章節，我們將會學習到如何把元件中 <code>template</code> 部分抽取成一個 script 成為樣板，來大大地增加程式碼可重複利用性。</p>
<p>隨文附上一直想出門溜溜的阿橘一枚：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190911/20119062TWW83vTNvO.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190911/20119062TWW83vTNvO.jpg"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 元件樣板 template</title>
    <url>/vue.js/Vue-009-template/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>前幾章花了一點時間在介紹元件的註冊方式與用法，除了能夠建立一個元件並使用對應的 <code>&lt;tag&gt;</code> 標籤建立在網頁上，也能將元件塞入其他元件當中成為他的子元件。</p>
<p>然而，對於真正顯示的內容，最主要還是得依靠 <code>template</code> 所產生，回顧一下之前<a href="https://ithelp.ithome.com.tw/articles/10214359" target="_blank" rel="noopener">生命週期</a>的章節會發現到，Vue.js 的生命週期中，會有一段過程檢查實體中是否有包含 <code>template</code> 的選項：</p>
<ul>
<li>若有 <code>template</code> 的情況：最後會使用 <code>render function</code>去編譯裡面的內容到網頁上。</li>
<li>若沒有 <code>template</code> 的情況：則是會使用綁定 <code>el</code> 元素的 <code>outerHTML</code>來做為編譯範圍。</li>
</ul>
<p>其中 <code>template</code> 指的就是元件樣板的部分，我們可以透過不同的封裝方式來管理內容，例如使用 <code>HTML</code> 標籤來進行封裝：</p>
<a id="more"></a>

<h2 id="HTML標籤封裝"><a href="#HTML標籤封裝" class="headerlink" title="HTML標籤封裝"></a>HTML標籤封裝</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">    template:<span class="string">'&lt;div&gt;HTML封裝方式&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>作法是直接在 <code>template</code> 中以 <code>HTML</code> 字串方式直接編寫，但是內容一多的時候將會變成非常長一條，不易於閱讀，而所幸在 JavaScript ES6 中我們可以透過<strong>模版字符串（template literal）</strong>的方式去書寫，透過<strong>反引號</strong>快速解決這個難處：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">    template:`</span><br><span class="line">    <span class="symbol">&lt;div&gt;</span></span><br><span class="line">        <span class="symbol">&lt;h1&gt;</span>HTML封裝方式&lt;/h1&gt;</span><br><span class="line">        <span class="symbol">&lt;div&gt;</span>ES6 讓這種方式變得更容易閱讀了！&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;`</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="inline-template"><a href="#inline-template" class="headerlink" title="inline-template"></a>inline-template</h2><p>這種封裝方式，則是在編寫樣板的時候直接在元件上加上 <code>inline-template</code> 屬性，它的效果是能夠讓 Vue.js 認為其元件標籤內的內容是元件的樣板（原先預設元件標籤內的值都不會渲染出來）：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;thumb-slider inline-template&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"thumb-wrapper"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"title"</span>&gt; ... &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/thumb-slider&gt;</span><br></pre></td></tr></table></figure>

<p>使用這種封裝方式的好處是在渲染時由於是直接寫在 HTML 當中，因此在頁面載入的過程中就會出現在頁面上，而不用等到 JavaScript 執行到才編譯元件內容。</p>
<h2 id="x-template"><a href="#x-template" class="headerlink" title="x-template"></a>x-template</h2><p><code>x-template</code>的封裝方式，則是可以將整段樣板抽取出來，以另一個 <code>script</code> 標籤作為樣板來管理，使用方法僅需要另外加入一個<code>script</code>標籤，並且將其 <code>type</code> 屬性定義為 <code>x-template</code> ， id 的部分則對應到 Vue.js 實體中的 <code>template</code> 即可：</p>
<p>x-template 部分</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/x-template"</span> <span class="symbol">id</span>=<span class="string">"my-component"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt; <span class="comment">// 最外層只能由單個元素包裝</span></span><br><span class="line">        &lt;<span class="keyword">div</span>&gt;<span class="symbol">x</span>-template封裝法&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span>&gt;<span class="symbol">x</span>-template封裝法&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>Vue.js 實體部分</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line"><span class="actionscript">        template:<span class="string">'#my-component'</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是在使用 <code>x-template</code> 方法封裝時，最外層必須只能使用單個元素來做包裝，否則最後將會只渲染出第一個元素，這一點跟 React.js 的 JSX 概念是一樣的。</strong></p>
<h2 id="Render-function"><a href="#Render-function" class="headerlink" title="Render function"></a>Render function</h2><p>最後這一種方式則是原先 Vue.js 在編譯所做的事情，意思就如同我們平常在使用<code>template</code>時，主要是依靠 Vue.js 去幫我們做編譯，但今天如果我們想要自己寫更多 JavaScript 的內容去管理時，就可以透過這種封裝方式來編寫樣板，而範例程式碼如下：</p>
<p>Render function 作法：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">(createElement)</span>&#123;</span></span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">'div'</span>,<span class="string">'內容'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>原本 template 作法：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">    template:<span class="string">'&lt;div&gt;內容&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>透過 Render function 的作法，我們可以藉由返回一個樣板物件來建立一個樣板，而樣板物件寫法好處是可以寫更加詳細的內容去編譯，而不是只是透過 Vue.js 幫我們包裝好的方法去開發，但相對難處便是在於實在太過抽象，元件內容一多，編寫 render function 將會十分困難。</p>
<hr>
<p>以上便是 template 的一些常見封裝方式，而除了以上這幾種方式之外，還有一種常見的是單一文件檔（.vue檔），而這種封裝方式到時候會在 Vue-cli 的章節一併解說。至於封裝方式的選用到底用哪種，最後決定權還是要看專案上實際上的需求來選用可能會好一點！</p>
<p>明天的部分將會看到 Vue.js 對於元件溝通的核心概念，以及 Vue.js 元件之間到底要怎麼溝通，就讓我們一起繼續努力撐到最後吧！</p>
<p>附上一起陪我撐到很晚的黑黑一枚<br><img src="https://ithelp.ithome.com.tw/upload/images/20190912/20119062DGAD832DiF.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190912/20119062DGAD832DiF.jpg"><br>黑黑：我幫你暖好被了，快來睡吧~</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 元件傳遞 event bus</title>
    <url>/vue.js/Vue-012-event-bus/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>前面兩天提到的元件間的資料傳遞，主要是父元件對子元件的 <code>props</code> 以及子元件對於父元件的 <code>event</code> 發送，而最後留下一個問題是假如今天我們要子元件與子元件溝通，要怎麼做呢？</p>
<p>第一個最快想到的方法，可能是按照前面兩天提到的方法，不斷的往上傳遞到共同的父元件，再往下傳遞到想溝通的子元件當中，但這樣的做法會耗費太多心力，並且作了很多重複的動作、難以維護等等，而這些行為也是工程師不喜歡的<strong>壞味道</strong>，要知道未卜先知跟通靈以後要維護的東西可說是工程師的另一個價值 （？</p>
<p>而雖然第一個方法可以達成，但實在太搞剛（台）了，因此官方也直接列了第二個方法作為標準，那就是……</p>
<a id="more"></a>

<h2 id="event"><a href="#event" class="headerlink" title="event"></a>event</h2><p>而 <code>event</code> 實際上的用法如同公車一樣，當我們今天元件之間不是父子關係，而是多層元件關係時，都可以使用 <code>event</code> ，而 <code>event</code> 搭乘的乘客便是我們昨天提到的 <code>event</code>，只是今天我們<strong>發送與監聽的對象改 <code>event</code> 身上</strong>，而我們接下來以兩個平行的子元件之間的溝通來當作實作範例：</p>
<p>HTML 部分是兩個平行的元件<code>element-city1</code>與<code>element-city2</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element-city1</span>&gt;</span><span class="tag">&lt;/<span class="name">element-city1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element-city2</span>&gt;</span><span class="tag">&lt;/<span class="name">element-city2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript部分，<code>event</code> 既然要乘載我們 Vue.js 的功能，首先我們自然得先使用 <code>new</code> 去初始化一個 Vue 物件，使我們要乘載 <code>event</code> 的變數擁有 Vue 物件的屬性與功能：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bus = <span class="keyword">new</span> <span class="constructor">Vue()</span>;</span><br></pre></td></tr></table></figure>

<p>接著子元件 <code>element-city1</code> 以 <code>$emit</code> 發送事件而發送事件對象改為 <code>bus</code>：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'element-city1'</span>, &#123;</span><br><span class="line">  template:</span><br><span class="line">  `</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"submit"</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  `,</span></span><br><span class="line"><span class="xml">  methods:</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    submit()&#123;</span></span><br><span class="line"><span class="xquery">      bus.<span class="variable">$emit</span>(<span class="string">'receive'</span>, this.message)</span></span><br><span class="line"><span class="xquery">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  data()</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="xquery">      message : <span class="string">"this is city1's message"</span></span></span><br><span class="line"><span class="xquery">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>要接受資料的 <code>element-city2</code>，監聽對象也同樣改為<code>bus</code>：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'element-city2'</span>, &#123;</span><br><span class="line">  <span class="attribute">template</span>:<span class="string">`&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  created()&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">    bus.$<span class="keyword">on</span>(<span class="string">'receive'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">newMessage</span>)</span>&#123;</span><br><span class="line">      self.message = newMessage</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      <span class="attribute">message</span>: <span class="string">"this is city2's message"</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後同樣的要初始化一個最基本的根元件來當作 Vue.js 要渲染的範圍。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    tex<span class="variable">t:</span><span class="string">'Hello Vue!'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  method<span class="variable">s:</span>&#123;</span><br><span class="line">    handleOnClick : <span class="function"><span class="keyword">function</span><span class="params">(name)</span>&#123;</span></span><br><span class="line">      <span class="keyword">return</span> this.text = `Hello $&#123;name&#125;!`</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/ShawnLin0201/pen/OJLwpap" target="_blank" rel="noopener">點我看範例</a></p>
<p>如此一來，子元件 <code>element-city1</code> 便能將資料藉由發送給 <code>bus</code>，讓監聽著 <code>bus</code> 的子元件 <code>element-city2</code> 拿到他想要的資料，藉此達成子元件與子元件的溝通技術。</p>
<p><strong>而往後開發要注意的是</strong>，由於註冊與監聽事件都是在 <code>bus</code> 上，不同元件間註冊與監聽可能事件名稱會有<strong>撞名的問題</strong>，可以透過初始化另一台<code>bus</code>來稍微緩解這個問題。</p>
<p>今天介紹了子元件如何與子元件的做資料傳遞的溝通，接下來隨著 Vue.js 即將進入尾聲，因此要來介紹幾個 Vue.js 幾個也蠻重要的功能補充，祝大家周末愉快囉！</p>
<blockquote>
<p>今天依然是由黑黑擔任每日一貓的工作，因為弟弟阿橘正在梳毛中不開心哈哈哈。而最近剛好是換毛季，感覺梳下來的毛都可以拿去做貓毛氈了……<br><img src="https://ithelp.ithome.com.tw/upload/images/20190915/20119062QkffxkBKJg.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190915/20119062QkffxkBKJg.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 元件 component</title>
    <url>/vue.js/Vue-007-component/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>元件的概念可以把它看作成一個<strong>重複利用性高</strong>的程式，好比只要輸入資料進去，就能夠輸出得到對應的需求，至於其他相關的外觀樣式等等都會相應產生。而要將 Vue.js 的程式元件化之前，首先一起來瞭解它的核心觀念：</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="https://ithelp.ithome.com.tw/upload/images/20190910/20119062r5BJ41crhr.png" alt="https://ithelp.ithome.com.tw/upload/images/20190910/20119062r5BJ41crhr.png"></p>
<p>Vue.js 的架構深受 <a href="https://zh.wikipedia.org/wiki/MVVM" target="_blank" rel="noopener">MVVM</a> 的影響，而 MVVM 講的也就是，M(model)、V(view)以及 VM(view-model)，官網範例中常用到的 <code>vm</code> 也是因此而來的。</p>
<p>三者之間的關係也非常簡單，前端可能會透過像是 API 取得一些後端的資料（Model），接著會撰寫 Vue.js 的部分來讓 API 資料更有邏輯或整理成更加容易讓視覺可以顯示的資料（View-Model），接著就可以使用 Vue.js 的樣板語法來讓整理好的資料顯示在畫面上（View）。</p>
<p>反過來則是今天當按鈕（View）的部分被使用者點擊，因此觸發向 View-Model 獲取一些資訊，而作為 View-Model 可能會直接提供自己本身就有的資料，亦或是最後再向 Model 拿取更多的資訊回來整理。</p>
<p>而 Vue.js 最主要是幫我們把<strong>連結 View 與 Model 的部分</strong>給處理掉了（<strong>View-Model</strong>），因此我們接下來要做的元件，最主要是要透過 Vue.js 提供的 API 等功能（也就是前面所說的指令、修飾符等等），來打造元件，並且搭配 View 與 CSS（SCSS）來塑造他的外觀。</p>
<a id="more"></a>

<h2 id="元件註冊"><a href="#元件註冊" class="headerlink" title="元件註冊"></a>元件註冊</h2><p>在 Vue.js 中要使用 <code>components</code> 時，可以選擇在初始化 Vue.js 時將其資訊帶進去，或是使用 <code>Vue.component</code> 的方式來註冊，並且依據使用方法不同分為區域性的註冊方式(<code>scope</code>)以及全域性的註冊方式(<code>global</code>)，以下介紹兩種註冊方式的差異：</p>
<h3 id="區域註冊"><a href="#區域註冊" class="headerlink" title="區域註冊"></a>區域註冊</h3><p>使用區域性的元件時，可以選擇在初始化 Vue.js 的時候將元件的資訊帶進去：</p>
<p>HTML部分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS部分</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.myComponent</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        <span class="string">'my-component'</span>:&#123;</span><br><span class="line">            template:<span class="string">'&lt;div class="myComponent"&gt;Hello Vue&lt;/div&gt;'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>範例註冊了一個名稱為<code>my-component</code>的元件，並且該元件有一個<code>template</code>，使得 Vue.js 會將其渲染出來，最後在 DOM 產生三個<code>&lt;div class=&quot;myComponent&quot;&gt;Hello Vue&lt;/div&gt;</code>，並且將CSS的style渲染上去，而這種註冊方式是會僅限於原先的區域，假使有另一個 Vue.js 應用程式 <code>app2</code> <code>(如下），在裡面同樣使用</code>my-component<code>，最終結果將會是</code>app2`不認得這個元件，也沒辦法將結果渲染在畫面上。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="全域註冊"><a href="#全域註冊" class="headerlink" title="全域註冊"></a>全域註冊</h2><p>而在某些情境下，專案可能要在兩個或多個應用程式間共享元件。我們可以透過 <code>Vue.component</code> 進行註冊，如此一來不管在哪個程式中都可以使用<code>my-component</code>元件，這種註冊方式會稱他為全域的<code>global</code>的註冊方式，範例程式碼如下：</p>
<p>JavaScript部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>,&#123;</span><br><span class="line">    data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            message:<span class="string">''</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template:<span class="string">'&lt;div class="myComponent"&gt;Hello Vue&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>而這裡有一點要注意的是</strong>，若不將 <code>data</code> 以函式返回物件的方式封裝起來的話，資料物件將會混淆，並且被各個元件共享（原因是物件是屬於複雜類型，複雜類型的參考方式是<code>call by reference</code>），也就是說元件對 <code>data</code> 操作時將會連帶影響到其他元件的數值。而解決辦法就是利用 Javascript 切割 scope 最小單位<code>function</code>來做封裝（如上面範例程式碼所示）。</p>
<p>以上章節是透過基本的<strong>元件註冊</strong>，將<strong>重複的程式碼</strong>包裝成元件，來達成<strong>可重複利用性更高</strong>的程式，而明天要介紹的部分則是在元件中設置元件的作法。</p>
<p>附上今日的黑黑元件以及橘橘元件<br><img src="https://ithelp.ithome.com.tw/upload/images/20190910/20119062caNJOFKmnT.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190910/20119062caNJOFKmnT.jpg"></p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190911/20119062t3y8rmF2D3.png" alt="https://ithelp.ithome.com.tw/upload/images/20190911/20119062t3y8rmF2D3.png"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 元件傳遞 props</title>
    <url>/vue.js/Vue-010-props/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="單向資料流"><a href="#單向資料流" class="headerlink" title="單向資料流"></a>單向資料流</h2><p>前面章節大部分的範例都是取用元件自己本身的 data 來操作的，而實際開發時的元件最主要是用來當作一個可重複利用的樣板，裡面即使有 data 的存在，可能大部分也是用於預設值的初始化，更多時候子元件所接收到的資料，會來自於父元件所傳遞的。</p>
<p>而在傳遞資料時要遵守單向資料流的規定，意思是我們只能透過<strong>父元件傳遞資料給子元件</strong>，子元件並不能<strong>直接傳遞資料給父元件</strong>，這樣做的原因是當今天很有多子元件依賴父元件某項資料物件時，如果每個子元件都可以任意更改父元件的資料時，就容易造成牽一髮而動全身的行為，因此這種行為是被禁止。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190913/20119062xmubDbCYt5.png" alt="https://ithelp.ithome.com.tw/upload/images/20190913/20119062xmubDbCYt5.png"></p>
<a id="more"></a>

<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>在傳遞資料時，我們可以使用元件內的 <code>props</code> 選項來指定傳遞的資料名稱，如下面範例中，我們在子元件 <code>props</code> 中指定了元件外面可以傳遞給他的資料為 <code>childmsg</code> ，並在 <code>template</code> 中將傳遞進來的資料當作數值，分別放入樣板語法與 v-model 中以供顯示。</p>
<p>子元件 的部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">"child-component"</span>, &#123;</span><br><span class="line">    template:</span><br><span class="line">        <span class="string">'&lt;div&gt;&#123;&#123; childmsg &#125;&#125; &lt;br&gt;&lt;input type="text" v-model="childmsg"&gt;&lt;/div&gt;'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        childmsg: <span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>父元件 Vue.js 實體的部分：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">let vm = new Vue(&#123;</span><br><span class="line"><span class="symbol">    el:</span> <span class="string">"#app"</span>,</span><br><span class="line"><span class="symbol">    data:</span> &#123;</span><br><span class="line"><span class="symbol">        parentmsg:</span> <span class="string">"父元件資料"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>而在 HTML 部分中，我們跟之前章節一樣，使用已經註冊好的子元件標籤 <code>child-component</code>，並且在子元件的屬性中透過 <code>v-bind</code> (縮寫<code>:</code>)綁定來自於父元件本身的資料 <code>parentmsg</code>，接著子元件就能透過這種方法來得到傳遞的對象來源，假如今天是要傳入不同的資料，我們只要將 <code>:childmsg-message=&quot;parentmsg&quot;</code> 中的 <code>parentmsg</code> 更改為其他資料來源即可。</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>父元件：<span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="template-variable">&#123;&#123; parentmsg &#125;&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"parentmsg"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>子元件：</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">child-component</span> <span class="attr">:childmsg</span>=<span class="string">"parentmsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/ShawnLin0201/pen/WNeyZqV" target="_blank" rel="noopener">點我看線上範例</a></p>
<h1 id="props-型別檢查"><a href="#props-型別檢查" class="headerlink" title="props 型別檢查"></a>props 型別檢查</h1><p>而在實際在工作上實作時，我們有可能會遇到<code>components</code>的部分是由 teammate 所撰寫的，因此在接手專案時，對於 <code>components</code> 的 <code>props</code> 型別檢查就特別重要，我們可以在 <code>props</code> 設定傳送資料時一起寫入一些設定，範例如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.component</span>(<span class="string">'my-component'</span>,&#123;</span><br><span class="line">    <span class="attribute">props</span>: &#123;</span><br><span class="line">        <span class="attribute">parentMsg</span>: null,  <span class="comment">// 表示傳遞進來的類別沒有限制</span></span><br><span class="line">        <span class="attribute">parentMsgA</span>: Number,<span class="comment">// 表示傳遞進來的類別須為數字類型</span></span><br><span class="line">        <span class="attribute">parentMsgB</span>: [String, Number], <span class="comment">// 表示傳遞進來的類別可以是字串或數字</span></span><br><span class="line">        <span class="attribute">parentMsgC</span>: &#123;</span><br><span class="line">            <span class="attribute">type</span>: String, </span><br><span class="line">            <span class="attribute">required</span>: true, <span class="comment">// 表示使用這個元件時一定要有 `parentMsgC` 參數，否則會報錯</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attribute">parentMsgD</span>: &#123;</span><br><span class="line">            <span class="attribute">type</span>: Number, </span><br><span class="line">            <span class="attribute">default</span>: <span class="number">100</span> <span class="comment">// 表示如果沒有給予這個參數，則預設會顯示的資料為 100</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attribute">parentMsgE</span>: &#123;</span><br><span class="line">            <span class="attribute">type</span>: Object,</span><br><span class="line">            <span class="attribute">default</span>: function()&#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    <span class="attribute">message </span>: <span class="string">'Hello Vue!'</span> <span class="comment">// 我們也可以透過傳送參數來返回一個資料物件</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attribute">parentMsgF</span>: &#123;</span><br><span class="line">            <span class="attribute">validator</span>: function(value)&#123;</span><br><span class="line">                return value &gt; <span class="number">100</span> <span class="comment">// 我們也可以自己撰寫一個驗證器，來看傳進來的資料是否有符合條件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上是介紹父元件傳遞給子元件資料的方法，以及如何透過 <code>props</code> 的型別檢查來限制我們傳進去的資料，有效提升子元件不會被濫用的情況。而明天的章節，我們將會說明子元件如果真的想要傳遞資料給父元件時，我們可以透過什麼方式來執行？</p>
<p>阿橘在這裡也祝大家中秋佳節愉快<br><img src="https://ithelp.ithome.com.tw/upload/images/20190913/20119062H4W48vp757.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190913/20119062H4W48vp757.jpg"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 動態元件 Dynamic component</title>
    <url>/vue.js/Vue-013-dynamic-component/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="Dynamic-component-動態元件"><a href="#Dynamic-component-動態元件" class="headerlink" title="Dynamic component 動態元件"></a>Dynamic component 動態元件</h2><p>在某些情境下的專案中可能會需要透過標籤來切換頁面，可能第一個想到的會是使用 <code>v-if</code> 或是 <code>v-show</code> 的方式去顯示，並且透過在標籤上綁定資料物件來顯示內容：</p>
<p>在 HTML 部分，我們可能會使用<code>v-on</code>（縮寫<code>@</code>）去綁定 <code>click</code> 事件，透過點擊事件來更動 <code>data</code> 裡的資料（<code>pagename</code>）：</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'mainpage'"</span>&gt;</span>switch to Main page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接著在要顯示頁面的元件中掛上<code>v-if</code>來限定顯示的條件，如 <code>pagename</code> 的值是 <code>mainpage</code> 時就會顯示該元素，藉此來達到如切換分頁的效果，並且重複以上動作將各個顯示頁面用的元件加入如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'mainpage'"</span>&gt;</span>switch to Main page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'aboutpage'"</span>&gt;</span>switch to About page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'contactpage'"</span>&gt;</span>switch to Contact page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mainpage</span> <span class="attr">v-if</span>=<span class="string">"pagename === 'mainpage'"</span>&gt;</span><span class="tag">&lt;/<span class="name">mainpage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aboutpage</span> <span class="attr">v-if</span>=<span class="string">"pagename === 'aboutpage'"</span>&gt;</span><span class="tag">&lt;/<span class="name">aboutpage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contactpage</span> <span class="attr">v-if</span>=<span class="string">"pagename === 'contactpage'"</span>&gt;</span><span class="tag">&lt;/<span class="name">contactpage</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而 JavaScript部分除了基本的頁面內容樣板之外， 在 Vue.js 初始化的實體中則是在 <code>data</code> 中先放入一開始預設頁面值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'mainpage'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;This page is mainpage&lt;/div&gt;`</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'created mainpage'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed mainpage'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">'aboutpage'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;This page is aboutpage&lt;/div&gt;`</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'created aboutpage'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed aboutpage'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">'contactpage'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;This page is contactpage&lt;/div&gt;`</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'created contactpage'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed contactpage'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    pagename : <span class="string">'mainpage'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如此一來就能達成進入後顯示主要頁面，接著透過按鈕切換數值來驅動顯示不同的畫面。這樣的做法確實可以達到切換分頁的效果，但缺點在於一開始進入根目錄頁面時，DOM 就已經載入該元素了。</p>
<p>解決辦法是透過 Vue.js 所提供的 API (<code>:is</code>) 來達成同樣的效果，我們只需要放入一個名為<code>component</code>的標籤（ Vue.js 的內建元素 <code>Built-In Components</code>），並且透過 <code>:is</code> 來對應元件名稱，最後 Vue.js 就會依照<code>:is</code>的數值來決定被渲染的元件，HTML部分改寫後如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'mainpage'"</span>&gt;</span>switch to Main page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'aboutpage'"</span>&gt;</span>switch to About page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'contactpage'"</span>&gt;</span>switch to Contact page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"pagename"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>往後新增頁面時，只要將觸發更改頁面的按鈕、方法寫好，並且新增對應名稱的元件，即可快速做到更動頁面的效果，而同樣的方法也適用於快速切換小區域的元件內中（如表單等等），大家不彷一起嘗試看看這個 API 吧。</p>
<blockquote>
<p>橘橘也有周一病，一到周末晚上就各種厭世臉哈哈哈<br><img src="https://ithelp.ithome.com.tw/upload/images/20190916/20119062aZXueKQpKU.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20119062aZXueKQpKU.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 狀態保留 keep-alive</title>
    <url>/vue.js/Vue-014-keep-alive/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>上一章節介紹到動態元件的使用方法，我們可以使用 <code>is</code> 來快速切換元件中的內容，藉著省下不少程式碼上的複製貼上，並且在 DOM 結構上也不會渲染出不必要的內容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'mainpage'"</span>&gt;</span>switch to Main page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'aboutpage'"</span>&gt;</span>switch to About page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'contactpage'"</span>&gt;</span>switch to Contact page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"pagename"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但假如使用者在這些頁面中進行如<strong>表單輸入</strong>等等的操作，接著切換到另一個元件中，原本的元件頁面就會消失，並且觸發 <code>destroyed</code>的生命週期鉤子，而當使用者在切換回原先的頁面時，就會發現已經輸入過的資料<strong>已經遺失</strong>了。</p>
<a id="more"></a>

<p>而這並不是什麼奇怪的 BUG ，我們可以透過 <strong><code>created</code> 生命週期鉤子被觸發</strong>的現象觀察證實，此時載入的已經是另一個<strong>全新的元件</strong>，而如果這時我們想要能夠自在的切換元件間，又想要保留元件原先的資料內容，則可以使用 <code>keep-alive</code> 這個標籤。</p>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>這個標籤最主要的功能，就是保留如上述一樣的情境時，因為切換而遺失的資料內容，原先消失的原因是因為 Vue.js 在虛擬 DOM 上的計算，導致渲染時會以該元件作為一個重新渲染的節點，最後刷新整個元件內部的資訊，而要藉由 <code>keep-alive</code> 保留內部資訊的使用方法也很簡單，我們只要在外層包覆一層 <code>keep-alive</code> 標籤即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'mainpage'"</span>&gt;</span>switch to Main page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'aboutpage'"</span>&gt;</span>switch to About page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'contactpage'"</span>&gt;</span>switch to Contact page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"pagename"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'mainpage'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;This page is mainpage. Enter this page : &#123;&#123; count &#125;&#125; &lt;/div&gt;`</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">'aboutpage'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;This page is aboutpage. Enter this page : &#123;&#123; count &#125;&#125; &lt;/div&gt;`</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">'contactpage'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;This page is contactpage. Enter this page : &#123;&#123; count &#125;&#125; &lt;/div&gt;`</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    pagename : <span class="string">'mainpage'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我們在上面範例中加入了一些觸發生命週期的鉤子，透過開發者工具列可以看到的是，原先當元件切換時，理應當觸發 <code>destroyed</code> 的生命週期鉤子，並且顯示 <code>destroyed</code>，然而最後結果卻沒有顯示，表示元件在切換到不同元件時，該元件<strong>並沒有被銷毀</strong>。</p>
<p>此時切換回原先的元件時，可以發現觸發了生命週期鉤子中的 <code>activated</code>，表示元件並<strong>不是走原先 <code>created</code> 等初始化元件的過程</strong>，而 <code>activated</code> 在官方生命週期中則是表示元件<strong>重新被啟用</strong>的意思，並且可以發現先前的資料內容也同時被保存下來，如此一來將來有如表單輸入等等需要暫時保留資料的元件，可以透過 <code>keep-alive</code> 的這個標籤來達到保存的功能。</p>
<p>以上就是今天狀態保存 <code>keep-alive</code> 的說明與用法，明天將會介紹 Vue.js 的最後的一個好用功能 <code>slot</code>。</p>
<blockquote>
<p>明天就是 Vue.js 的最後一張啦，<del>橘橘表示興奮到模糊</del>。<br><img src="https://ithelp.ithome.com.tw/upload/images/20190917/20119062yrB2Z2gY2w.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190917/20119062yrB2Z2gY2w.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 插槽 slot</title>
    <url>/vue.js/Vue-015-slot/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="渲染範圍"><a href="#渲染範圍" class="headerlink" title="渲染範圍"></a>渲染範圍</h2><p>使用樣本語法時，我們可以在 HTML 中使用<strong>兩對花括號</strong>來表示要顯示的資料，並且透過 Vue.js 實體中的 <code>el</code> 來指定 Vue.js 渲染的範圍，並且在子元件的 <code>template</code> 中同樣也可以使用，然而如果是在 HTML 中的子元件標籤裡<strong>直接使用則會導致失效</strong>，如下面範例：</p>
<a id="more"></a>

<p>HTML部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span>&#123;&#123; childMessage &#125;&#125;<span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;&lt;/div&gt;`</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    message : <span class="string">'parent component'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後樣板語法將不會顯示任何資料。（這並非是什麼 BUG，而是 Vue.js 預設的渲染。）</p>
<h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><p>假使想要在子元件標籤中放些自定義的文字或內容，可以透過 <code>&lt;slot&gt;</code> 標籤來達成，我們試著將上面的元件稍微改寫一下：</p>
<p>JavaScript 部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:</span><br><span class="line">  <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;slot&gt;&lt;/slot&gt; // 加入 slot 標籤</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>HTML 部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span><br><span class="line">        &#123;&#123; message &#125;&#125; //這裡的message 將會傳入父元件的資料物件</span><br><span class="line">    <span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>這樣將會使得在 <code>&lt;child-element&gt;&lt;/child-element&gt;</code> 標籤中的資料，傳入到子元件裡的<code>&lt;slot&gt;&lt;/slot&gt;</code>的位置，將其替換掉。並且我們可以也可以傳入 HTML 元素、甚至是其他的元件以及父元件的資料物件：</p>
<p><strong>注意</strong>當使用這樣的方法在子元件內使用樣板語法傳入資料，此時傳入的資料將會是<strong>父元件的資料物件</strong>，若要使用子元件的資料物件，仍然只能在子元件的<code>template</code>中去呼叫。</p>
<p>而當我們使用 <code>&lt;slot&gt;</code> 後，若沒有 HTML 部分中所綁定的元件中傳入資訊，則預設將會顯示<code>&lt;slot&gt;&lt;/slot&gt;</code>所包含的資料：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:</span><br><span class="line">  <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;slot&gt;Hello Vue!&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    message : <span class="string">'parent component'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後顯示的結果會是 <code>&lt;div&gt;Hello Vue!&lt;/div&gt;</code>。</p>
<h2 id="指定slot"><a href="#指定slot" class="headerlink" title="指定slot"></a>指定slot</h2><p>當今天 <code>slot</code> 所要傳入的對象越來越多時，可以透過指定插入的方式去分配 <code>slot</code> 要怎麼對應資料，方法是在子元件中使用 <code>template</code> 標籤並加上<code>v-slot</code>屬性，<code>v-slot</code>的值會對應到的是 <code>slot</code> 標籤的 <code>name</code> 屬性，這樣一來當我們有需要放多個 <code>slot</code> 時就不必擔心對應位置的問題，範例如下：</p>
<p>HTML部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:first</span>&gt;</span>First<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:second</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:third</span>&gt;</span>Third<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:</span><br><span class="line">  <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;slot name="first"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;slot name="second"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;slot name="third"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    message : <span class="string">'parent component'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後 HTML 部分子元件的內容將會對應的傳入子元件中，並顯示出來。而這個 API 好用的地方在於今天有個元件我們純粹只是想要更換部分的顯示內容，就可以在父元件引入該子元件，並且透過 <code>v-slot</code> 直接傳入子元件中，而不用資料整筆 props 進去再接出來。</p>
<p>以上是目前 Vue.js 的最後一章節，而實作的部分將會等到我們以 Vue-cli 創建環境時，再搭配 D3.js 一起介紹！</p>
<blockquote>
<p>隨文附上今日的黑黑，據家人說他今天在同個地方躺了連續八小時 ( XD???<br><img src="https://ithelp.ithome.com.tw/upload/images/20190917/20119062Gz4i7Zt1Ic.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190917/20119062Gz4i7Zt1Ic.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 元件傳遞 event</title>
    <url>/vue.js/Vue-011-event/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>上一章節中，我們介紹了父元件如何透過 <code>props</code> 傳遞資料給子元件，並且使用<strong>型別設定</strong>來規範傳進元件中的值，而今天要來介紹<strong>子元件要如何傳遞資料給父元件</strong>。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190913/20119062xmubDbCYt5.png" alt="https://ithelp.ithome.com.tw/upload/images/20190913/20119062xmubDbCYt5.png"></p>
<p>昨天在解說這張圖的時候，有提到了一個單向資料流的概念，Vue.js 只允許我們透過 <code>props</code> 來傳遞資料給 子元件，為了避免一些不可預期更改導致最後不知道是哪個子元件去更改了父元件的資料，那麼如果子元件真的有需求，想要傳遞資料給父元件的話，官方給了一個作法是 <code>emit event</code> 發送事件。</p>
<p>透過子元件發送事件給父元件，父元件的部分可以藉由<strong>監聽</strong>這個任務事件，去觸發相對應的行為，而藉由這個做法，就可以達成類似於<strong>子元件傳遞資料給父元件</strong>的行為，並且<strong>仍然是單向資料流的行為</strong>，而實際上要怎麼來發送事件以及監聽事件就一起來看看下面的範例：</p>
<blockquote>
<p>這個範例中我們將會跟上一章節一樣，做一個父元件可以將資料傳遞給子元件的表單，但不一樣的事情是我們將會在子元件中新增一個按鈕，藉由<strong>點擊按鈕</strong>來觸發<strong>將我們輸入在子元件的內容資料傳遞給父元件</strong>。</p>
</blockquote>
<a id="more"></a>

<p>在 HTML 的部分，我們一樣先建立一個基礎的版型，：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>父元件：<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        &#123;&#123; message &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>子元件：</span><br><span class="line">        <span class="tag">&lt;<span class="name">child-component</span> <span class="attr">:parent-message</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 也是一樣建立一個基本的實體：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">    dat<span class="variable">a:</span>&#123;</span><br><span class="line">        message : <span class="string">'父元件資料'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'child-component'</span>,&#123;</span><br><span class="line">    template:`</span><br><span class="line"><span class="symbol">&lt;div&gt;</span> &#123;&#123; parentMessage &#125;&#125; <span class="symbol">&lt;br&gt;</span></span><br><span class="line">  &lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"parentMessage"</span>&gt;</span><br><span class="line">  &lt;button <span class="built_in">type</span>=<span class="string">"button"</span>&gt;Update&lt;/button&gt;&lt;/div&gt;`,</span><br><span class="line">    prop<span class="variable">s:</span>&#123;</span><br><span class="line">        parentMessage: String</span><br><span class="line">    &#125;,</span><br><span class="line">    dat<span class="variable">a:</span> <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            message : this.parentMessage</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>現在我們已經擁有了父元件可以傳資料給子元件，並且子元件同樣只能更改屬於自己資料的表單，接下來我們要撰寫的部分是在按鈕點擊的時候要發送事件，而發送事件的行為我們同樣是將函式寫在 <code>methods</code> 當中，只是我要註冊的對象我們可以透過 <code>this.$parent</code> 來捕捉，並藉由 <code>$emit</code> 來發送行為。</p>
<p>而 <code>$emit</code> 函式使用方法是在第一個傳送參數中，填入要觸發方法的名稱，就像是告訴對方說我要做什麼事情：而第二個傳送參數則是傳入想要給予對方什麼樣的內容。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-component'</span>,&#123;</span><br><span class="line">    template:`</span><br><span class="line"><span class="symbol">&lt;div&gt;</span> &#123;&#123; parentMessage &#125;&#125; <span class="symbol">&lt;br&gt;</span></span><br><span class="line">  &lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"parentMessage"</span>&gt;</span><br><span class="line">  &lt;button <span class="built_in">type</span>=<span class="string">"button"</span> @click=<span class="string">"updateText"</span>&gt;Update&lt;/button&gt;&lt;/div&gt;`,</span><br><span class="line">    prop<span class="variable">s:</span>&#123;</span><br><span class="line">        parentMessage: String</span><br><span class="line">    &#125;,</span><br><span class="line">    dat<span class="variable">a:</span> <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            message : this.parentMessage</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    method<span class="variable">s:</span>&#123;</span><br><span class="line">      updateTex<span class="variable">t:</span> <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        this.$parent.$emit(<span class="string">'update'</span>,this.parentMessage)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>將上方的範例更改之後，現在的子元件 <code>child-component</code> 已經可以發送給父元件一個 <code>update</code> 事件，並且將要傳遞的資料 <code>this.parentMessage</code> 傳送給父元件。</p>
<p>接著在父元件的部分，我們則是要註冊一個監聽事件，用來監聽其他人發送給他的事件，而本次監聽的方法，我們寫在父元件實體中的 <code>mounted</code> 生命週期鉤子中，透過 <code>$on</code>這個方法來監聽目標的事件，同樣的第一個傳送參數是<strong>我們要監聽的事件名稱</strong>，第二個則是監聽到這個事件的時候，元件要選擇做什麼事情；而這裡我們是選擇監聽到這個事件之後，我們要去觸發 <code>selfUpdate</code> 的這個函式，這個函式將會將元件自己的資料，賦與傳遞進來的值。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message : <span class="string">'父元件資料'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      selfUpdate(<span class="keyword">value</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = <span class="keyword">value</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$<span class="keyword">on</span>(<span class="string">'update'</span>, <span class="keyword">this</span>.selfUpdate)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/ShawnLin0201/pen/MWgBWpe" target="_blank" rel="noopener">範例連結請點我！</a></p>
<p>透過這個方式大家可以很明顯地看到，<strong>子元件其實並沒有真正直接傳遞資料給父元件</strong>，而是雙方<strong>各自註冊了事件去溝通要傳遞什麼資料</strong>，如此一來父元件最後更新的掌握權利還是<strong>保留在自己</strong>身上，若是子元件自己單獨想要發送資料給父元件的話，是同樣無法使父元件觸發行為的，且最後要不要將傳遞資料更動到自己本身的資料上也是由父元件自己所掌握，這樣能使得傳遞的資料來源流向更加的清晰，也解決子元件想要傳遞給父元件資料的這個問題。</p>
<p>而到目前為止，我們已經學會了父元件傳遞資料給子元件的方法，也學會了子元件傳遞給父元件的正確知識<del>姿勢</del>，但事情總不會這麼簡單就結束！假如今天我們是要將子元件傳遞給另外一個子元件的時候，我們可以怎麼做呢？這邊就留個謎底給大家想想，明天我們將會公布解答！</p>
<blockquote>
<p>隨文小故事<br>最近發現黑黑好像對於自己是黑色的貓這件事情感到很無奈，時常發現他有的時候會照著鏡子發呆，難道他想要變成白貓嗎？<br>黑黑：我很黑我也很無奈好嗎<br><img src="https://ithelp.ithome.com.tw/upload/images/20190914/20119062vxXds9RVWs.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190914/20119062vxXds9RVWs.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 單一元件檔 （.vue 檔）</title>
    <url>/vue.js/Vue-cli-002-vue-file/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="單一元件檔"><a href="#單一元件檔" class="headerlink" title="單一元件檔"></a>單一元件檔</h2><p>今天要來介紹的是<strong>單一元件檔</strong>，單一元件檔在 Vue-cli 中被大量地使用，算是寫 Vue-cli 不可不知的一環，而在昨天我們安裝好 Vue-cli 環境後，可以看見 src 資料夾底下充滿著大量 .vue 結尾的檔案，大家或許會滿臉疑惑，因為前一兩周寫 Vue.js 根本沒有提到這個東西啊？那他到底是什麼呢？</p>
<a id="more"></a>

<p><img src="https://ithelp.ithome.com.tw/upload/images/20191004/20119062Z2qnzMoZH6.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191004/20119062Z2qnzMoZH6.jpg"></p>
<p>其實顧名思義，單一元件檔（single-file-component）就是一個元件專屬的檔案，還記得我們當時使用  <code>Vue.component</code> 建立了一個全域環境的元件嗎？單一元件檔就好比把該元件所需的資訊封裝成一種檔案格式，透過 <code>import</code> 註冊到其他的檔案當中，最後以工具解析後，產生網頁能夠讀懂的相關靜態檔案（如 HTML、CSS、JavaScript 等等。）那他跟我們寫得全域性註冊元件差在哪呢？</p>
<p>當我們以 Vue.component 註冊元件會遇到的問題：</p>
<ul>
<li>以全域性註冊的元件，<strong>元件名稱不能重複使用</strong>。</li>
<li>樣板字面值在文字編輯器中一般情況都是<strong>沒有語法顏色提醒輔助</strong>，需要自行下載額外工具。</li>
<li>在元件當中通常<strong>沒有區塊能夠讓元件單獨使用 CSS 的地方</strong>。</li>
<li>沒有建立環境的步驟，因此需要預處理器的協助時通常會有一定難度。</li>
</ul>
<p>而在使用了單一元件檔之後：</p>
<ul>
<li>即使在不同資料夾中元件名稱一樣，仍可<strong>透過 import 時指定元件名稱</strong>來引入。</li>
<li>單一元件檔<strong>提供各種語法顏色輔助提醒</strong>，在編寫程式時可以容易分辨樣板字面值的區塊（template）。</li>
<li>單一元件檔提供撰寫 CSS 的地方，並且<strong>支援 SCSS 等預處理器</strong>，讓你可以<strong>直接在檔案中撰寫 SCSS</strong>，經由熱處理直接在運行的網頁上立刻看到更改後的結果，另外還能封裝成限定該元件區域使用，不會汙染全域環境。</li>
<li>Vue-cli <strong>基於 webpack</strong>，要引入各種工具都十分方便。</li>
</ul>
<p>除了以上使用單一元件檔後的差別，最重要是更能體現<strong>關注點分離</strong>的部分：</p>
<h2 id="關注點分離"><a href="#關注點分離" class="headerlink" title="關注點分離"></a>關注點分離</h2><p>在之前程式開發時，關注點分離可能指的像是 HTML、CSS 以及 JavaScript 的檔案類型要分離的很乾淨，各司其職彼此井水不犯河水，不要在 HTML 裡面看到 inline 版本的 CSS 或是 JavaScript，而在 JavaScript 裡面可能不要去寫到 HTML 或是去定義樣式等等，然而近代前端開發的思維已逐漸邁向另一種<strong>元件化</strong>的思維。</p>
<p>元件化的思維，最主要的想法是在於要盡可能的<strong>把重複性高的程式碼，包裝成一個可重複利用的元件</strong>，並且裡面的樣式與功能可能都大同小異，差異在於帶進去的數值不同，因此返回不同的結果。以前端開發為例，可能就像是將每頁都會固定用到的 Navbar 區塊寫成一個可重複利用的檔案，以 HTML 定義好結構，用 CSS 替元件修飾一下外觀，最後用 JavaScirpt 提供更多元的功能等等；因此 HTML、CSS 與 JavaSciprt 基本上都會混和在一起。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>而說了這麼多，單一元件檔到底要怎麼用呢？我們點開 Vue-cli 中的範例檔案 Hello.vue，可以看見該檔案中分成三個區塊，分別為 <code>template</code>、<code>script</code> 和 <code>style</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>template</strong> 區塊，如同之前我們寫元件時的 template 一樣，這裡主要是放置 HTML 結構與 Vue 指令、樣板指令的地點。</p>
<p><strong>script</strong> 區塊，則是以往我們寫 JavaScript 的地方，而單一元件檔則是透過 export 指令匯出，使我們可以在其他元件檔中以 import 方式引入該元件。</p>
<p><strong>style</strong> 區塊，這個地方是最令我開心的地方，因為我們將可以在這邊直接編寫如 SCSS 等 CSS 預處理器等工具，只要我們在安裝 Vue-cli 時有指定要選用這個選項即可無痛快速使用！</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191004/20119062l0e3DH9v5z.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191004/20119062l0e3DH9v5z.jpg"></p>
<blockquote>
<p>而實務上要怎麼應運這些區塊呢，明天我們將直接開發一個專案來當作範例！<br><img src="https://ithelp.ithome.com.tw/upload/images/20191004/20119062Pcn7QO96UM.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191004/20119062Pcn7QO96UM.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 介紹與環境建置</title>
    <url>/vue.js/Vue-cli-001-build/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h2><p>當我們終於熟悉 Vue.js 的一些基本用法後，專案上可能會要使用 webpack 來建立專案，而今天要來介紹的 Vue-cli ，主要是提供開發者一個快速建置 Vue.js 架構的工具，並基於 webpack，提供了許多相關的功能、套件安裝協助。而這裡建議使用 Vue-cli 前可以稍微瞭解 Vue.js 一些基本的指令以及元件概念基礎，並且要有不怕操作基本終端機指令的一顆心。</p>
<a id="more"></a>

<h2 id="環境建置"><a href="#環境建置" class="headerlink" title="環境建置"></a>環境建置</h2><p>要下載 Vue-cli 之前，我們會需要透過 NPM 套件管理工具來下載，而 NPM 在下載 Node.js 時就會一併包進去了，雖然安裝 Node.js 比較好的方式是依靠 NVM 來管理 Node.js 版本，但如此一來我們就要使用 NVM 來下載 Node.js，再來檢查有沒有一併安裝好 NPM 後，最後才能用 NPM 來下載 Vue-cli。（好饒口）</p>
<p>但如果大家真的只是在家體驗玩看看的話，其實也不彷直接載 Node.js 就是了。</p>
<p>首先，我們到 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> 官方網站下載 Node.js，接著打開這個黑色的視窗，window 系統叫他<strong>命令提示字元（cmd）</strong>，而 Mac 電腦要找到他則可搜尋<strong>終端機（Terminal）</strong>。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191003/20119062P4LfYSn7rD.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191003/20119062P4LfYSn7rD.jpg"></p>
<p>打開它之後會看到全黑的視窗，以 Windows 系統的為例會看到這個：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191003/20119062KSvKqPCe8s.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191003/20119062KSvKqPCe8s.jpg"></p>
<p>接著在裡面輸入<code>node -v</code>，如果有出現 Node.js 版本號表示有下載到 Node.js：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> node <span class="literal">-v</span></span><br></pre></td></tr></table></figure>

<p>NPM 的部分同樣可以輸入 <code>npm -v</code> 來查詢：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npm <span class="literal">-v</span></span><br></pre></td></tr></table></figure>

<p>確認同樣有跳出版本號後，我們就可以來使用 NPM 來下載 Vue-cli 啦！而這裡 Windows 系統與 Mac 會略有一點差別：</p>
<p>Windows 在 cmd 中直接輸入 <code>npm install -g @vue/cli</code> 來下載，<code>npm install @vue/cli</code> 表示藉由 npm 來下載 <code>@vue/cli</code>，而 <code>-g</code> 則表示此套件將會下載到全域環境之中，也就是說接下來你在任何資料夾路徑中都可以使用這個套件。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npm install <span class="literal">-g</span> @vue/cli</span><br></pre></td></tr></table></figure>


<p>Mac 用戶下載全域(<code>global</code>)套件的部分會受到一些限制，第一個是需要在指令前面多加 <code>sudo</code> 來執行，並且會要求你提供 Mac 帳戶密碼，如果帳戶沒設置密碼的話會沒辦法使用，因此得替帳戶設定一組密碼：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> sudo npm install <span class="literal">-g</span> @vue/cli</span><br></pre></td></tr></table></figure>

<p>安裝完畢之後，可以輸入指令來確認 Vue-cli 是否有安裝成功：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> vue -<span class="literal">-version</span></span><br></pre></td></tr></table></figure>

<p>下載完成後，若是熟悉終端機指令的朋友可以下面方案一的方式創建，若不熟悉終端機操作的人，Vue-cli 也很貼心地推出介面的管理方式，可以參考底下方案二的方式管理（但我還是推薦大家可以多熟悉終端機指令啦 XD）。</p>
<h2 id="方案一-終端機"><a href="#方案一-終端機" class="headerlink" title="方案一 終端機"></a>方案一 終端機</h2><p>將終端機切換到存放管理的資料夾執行指令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> vue create *你的專案名稱*</span><br></pre></td></tr></table></figure>

<p>接著他會顯示要安裝哪種預設套裝，默認 <code>default</code> 設定可以快速建立一個基本原型，而實際專案較常會使用下方的手動設定 <code>Manually</code> 來調整想要使用的內容，如官網圖所示：</p>
<blockquote>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191003/20119062NIJtU0zTOl.png" alt="https://ithelp.ithome.com.tw/upload/images/20191003/20119062NIJtU0zTOl.png"></p>
</blockquote>
<p>而手動設定的部分我一般是選用 Router、Vuex、CSS Pre-processors 以及 Linter。</p>
<h2 id="方案二-介面安裝法"><a href="#方案二-介面安裝法" class="headerlink" title="方案二 介面安裝法"></a>方案二 介面安裝法</h2><p>雖然 Vue-cli 幫大家做了一個介面來管理，但第一行還是要請大家到終端機去輸入指令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> vue ui</span><br></pre></td></tr></table></figure>

<p>這樣一來他就會開啟一個瀏覽器頁面來幫助建立專案的流程，最後一樣會建立一個以你專案名稱為名字的資料夾。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191003/201190621ygmc1dhMd.png" alt="https://ithelp.ithome.com.tw/upload/images/20191003/201190621ygmc1dhMd.png"></p>
<p>設定完畢啟動後，我們透過終端機 <code>cd</code> 指令切換到我們的專案資料夾中，再使用 <code>npm run serve</code> 來啟用本地伺服器：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cd <span class="string">'你的專案夾名稱'</span></span><br><span class="line"><span class="variable">$</span> npm run serve</span><br></pre></td></tr></table></figure>

<p>最後啟動後將可以看到 Vue.js 大大的 LOGO 以及 <code>Welcome to Your Vue.js App</code> 字樣出現在網頁上了。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191003/20119062AgkG8fqvm2.png" alt="https://ithelp.ithome.com.tw/upload/images/20191003/20119062AgkG8fqvm2.png"></p>
<h2 id="結構目錄"><a href="#結構目錄" class="headerlink" title="結構目錄"></a>結構目錄</h2><p>在專案資料夾被創立之後，Vue-cli 會在裡面建立一些預設檔案，而產生的目錄如下，可以先稍微了解大概檔案的目的是什麼：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">├── dist/               // 使用 npm run build 會在此處建立一個靜態檔案</span><br><span class="line">├── node_modules/       // 使用 npm 下載管理的模組會集中在此</span><br><span class="line">├── public/             // 放在此處的公共檔案可以使用絕對路徑取得，並且不會經過編譯壓縮處理</span><br><span class="line">│   ├── favicon.ico     // 範例用的圖片檔</span><br><span class="line">│   └── index.html      // 網站入口</span><br><span class="line">├── src/                // 前端開發的原始檔案，基本上要寫的程式都是放在此處</span><br><span class="line">│   ├── assets/         // 放在此處的公共檔案可以使用相對路徑取得，並且會經過編譯壓縮處理</span><br><span class="line">│   ├── components/     // Vue 元件檔案</span><br><span class="line">│   ├── views/          // Vue rounter 頁面檔案</span><br><span class="line">│   ├── App.vue         // Vue 專案的進入點</span><br><span class="line">│   ├── main.js         // Vue 專案的設定檔</span><br><span class="line">│   ├── router.js       // Vue rounter設定</span><br><span class="line">│   └── store.js        // Vuex設定</span><br><span class="line">├── .gitignore          // git 設定檔案</span><br><span class="line">├── package.json        // npm 產生的專案文件</span><br><span class="line">└── vue.config.js       // Vue 設定文件 ( 需手動建立 )</span><br></pre></td></tr></table></figure>

<blockquote>
<p>環境建置的章節就到這裡結束囉，下一章會來介紹一下 Vue-cli 裡面的 .vue 檔案究竟是什麼東西？<br><img src="https://ithelp.ithome.com.tw/upload/images/20191003/20119062S6FmV59sIA.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191003/20119062S6FmV59sIA.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 單一元件檔（ 以 iT 邦幫忙鐵人賽檔案當作開發範例）</title>
    <url>/vue.js/Vue-cli-003-vue-file-sample-1/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>今天要來以 iT 邦幫忙的鐵人賽檔案當作開發範例啦！</p>
<p>首先我們先來看看<strong>正版</strong>的鐵人賽檔案長什麼樣子：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/201190626f3Cl5S3qh.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/201190626f3Cl5S3qh.jpg"></p>
<p>忽略左上角之後，我們可以看到下方的這個區塊非常適合來開發成一個元件，而這個元件要考慮到哪些地方呢？假如今天大雄有參與<strong>不同年度的鐵人賽</strong>，並且又報名<strong>不同組別</strong>等等，加上文章本身就會有<strong>標題</strong>、<strong>鐵人是否練成</strong>、<strong>發了幾篇文章</strong>、<strong>有多少人訂閱</strong>等等，有許多控制項目可以玩，我們挑選其中幾個項目之後，在這裡發揮我們工程師的技能</p>
<a id="more"></a>

<h3 id="通靈"><a href="#通靈" class="headerlink" title="通靈!!!!!!"></a>通靈!!!!!!</h3><p>於是經過通靈之後，我們拿到了鐵人賽的 json 檔案格式：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/201190628yNCgj9k6B.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/201190628yNCgj9k6B.jpg"></p>
<p>好吧，其實是經過通靈之後，按我認為可能會拿到的 json 檔案格式（？</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    irontitle: "第 11 屆 iT 邦幫忙鐵人賽",</span><br><span class="line">    articles: [</span><br><span class="line">      &#123;</span><br><span class="line">        type: "Modern Web",</span><br><span class="line">        title:</span><br><span class="line">          "「小孩才做選擇，我全都要。」小白也能輕鬆瞭解的 Vue.js 與 D3.js 。",</span><br><span class="line">        href:</span><br><span class="line">          "https://ithelp.ithome.com.tw/users/20119062/ironman/2242",</span><br><span class="line">        info: &#123;</span><br><span class="line">          success: true,</span><br><span class="line">          count: 32,</span><br><span class="line">          subscribe: 39</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>接下來我們就可以拿著這份檔案，把他塞進我們的 .vue 檔之中，假裝他是 AJAX 下來的資料：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">"articleBoard"</span>,</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      json: &#123;</span><br><span class="line"><span class="actionscript">          <span class="comment">// 把上面的檔案直接放進來，</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 或是寫一個 methods 做 AJAX 把這個檔案拿進來。</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如此一來該單一元件檔就擁有了這份通靈的資料了。</p>
<p>而接著在塞資料進去之前，我們可以先刻好一個寫死的元件畫面：</p>
<p>在 template 的部分中，先把元件該要有的結構劃分清楚，否則後面透過 <code>v-for</code> 塞資料進去時，會容易跑版：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"board-wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"board-header"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-title"</span>&gt;</span>鐵人檔案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-deco"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"board-body"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"article-wrapper"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-year"</span>&gt;</span>第 11 屆 iT 邦幫忙鐵人賽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-body"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"article-type"</span>&gt;</span>Modern Web<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"article-title"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">href</span>=<span class="string">"https://ithelp.ithome.com.tw/users/20119062/ironman/2242"</span></span></span><br><span class="line"><span class="tag">            &gt;</span>「小孩才做選擇，我全都要。」小白也能輕鬆瞭解的 Vue.js 與 D3.js 。 系列<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"article-info"</span>&gt;</span>鐵人鍊成 ｜ 共 32 篇文章 ｜ 39 人訂閱<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"board-footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>樣式的部分直接以 SCSS 寫好寫滿，命名的話我自己是比較喜歡 SMACSS 與 OOCSS 的味道，而當許多元件都會用到共用的 CSS 時，可以自己建立共用的 SCSS，放在 <code>/src/assets/scss/</code> 中，透過主要 SCSS 檔案 style.scss 引入其他設定的 SCSS：</p>
<p><code>style.scss</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">'./basic'</span>;</span><br></pre></td></tr></table></figure>

<p><code>_basic.scss</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"Noto Sans TC"</span>, sans-serif;</span><br><span class="line">  <span class="attribute">background</span>:<span class="number">#F2F2F2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: inherit;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1140px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">48px</span> auto <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最後在單一元件檔要使用共用 SCSS 檔案時就可以透過 import 直接引入主要的 SCSS 檔案：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;style</span> <span class="string">scoped</span> <span class="string">lang="scss"&gt;</span></span><br><span class="line"><span class="string">@import</span> <span class="string">"@/assets/scss/style.scss"</span><span class="string">;</span></span><br><span class="line"><span class="string">.board-wrapper</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">margin:</span> <span class="string">20px</span> <span class="string">auto;</span></span><br><span class="line">  <span class="attr">max-width:</span> <span class="string">1140px;</span></span><br><span class="line">  <span class="attr">border:</span> <span class="string">1px</span> <span class="string">solid</span> <span class="comment">#e5e5e5;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="comment">#fff;</span></span><br><span class="line">  <span class="string">.board-header</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">padding:</span> <span class="string">14px</span> <span class="string">30px;</span></span><br><span class="line">    <span class="attr">z-index:</span> <span class="number">1</span><span class="string">;</span></span><br><span class="line">    <span class="string">.header-title</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">font-size:</span> <span class="string">24px;</span></span><br><span class="line">      <span class="attr">padding-left:</span> <span class="string">24px;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="string">.header-deco</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">background:</span> <span class="comment">#ffe8cc;</span></span><br><span class="line">      <span class="attr">width:</span> <span class="number">100</span><span class="string">%;</span></span><br><span class="line">      <span class="attr">height:</span> <span class="string">30px;</span></span><br><span class="line">      <span class="attr">margin-top:</span> <span class="string">-19px;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">.board-body</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">padding:</span> <span class="number">0</span> <span class="string">30px</span> <span class="string">14px;</span></span><br><span class="line">    <span class="string">.article-wrapper</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">.article-year</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">relative;</span></span><br><span class="line">        <span class="attr">padding:</span> <span class="string">8px</span> <span class="string">24px;</span></span><br><span class="line">        <span class="attr">border-bottom:</span> <span class="string">1px</span> <span class="string">solid</span> <span class="comment">#dddddd;</span></span><br><span class="line">        <span class="attr">color:</span> <span class="comment">#495057;</span></span><br><span class="line">        <span class="attr">font-size:</span> <span class="string">18px;</span></span><br><span class="line">        <span class="string">&amp;::before</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">position:</span> <span class="string">absolute;</span></span><br><span class="line">          <span class="attr">top:</span> <span class="string">18px;</span></span><br><span class="line">          <span class="attr">left:</span> <span class="string">10px;</span></span><br><span class="line">          <span class="attr">content:</span> <span class="string">""</span><span class="string">;</span></span><br><span class="line">          <span class="attr">width:</span> <span class="string">8px;</span></span><br><span class="line">          <span class="attr">height:</span> <span class="string">8px;</span></span><br><span class="line">          <span class="attr">background:</span> <span class="comment">#495057;</span></span><br><span class="line">          <span class="attr">border-radius:</span> <span class="string">50px;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">      <span class="string">.article-body</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">padding:</span> <span class="string">12px</span> <span class="string">4px;</span></span><br><span class="line">        <span class="attr">border-bottom:</span> <span class="string">1px</span> <span class="string">solid</span> <span class="comment">#dddddd;</span></span><br><span class="line">        <span class="string">.article-type</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">margin-bottom:</span> <span class="string">6px;</span></span><br><span class="line">          <span class="attr">padding:</span> <span class="string">2px</span> <span class="string">8px;</span></span><br><span class="line">          <span class="attr">border-radius:</span> <span class="string">20px;</span></span><br><span class="line">          <span class="attr">background:</span> <span class="comment">#4a89dc;</span></span><br><span class="line">          <span class="attr">font-weight:</span> <span class="string">lighter;</span></span><br><span class="line">          <span class="attr">font-size:</span> <span class="string">14px;</span></span><br><span class="line">          <span class="attr">color:</span> <span class="comment">#fff;</span></span><br><span class="line">          <span class="attr">cursor:</span> <span class="string">pointer;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">        <span class="string">.article-title</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">display:</span> <span class="string">block;</span></span><br><span class="line">          <span class="attr">margin:</span> <span class="string">6px</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">          <span class="attr">color:</span> <span class="comment">#303233;</span></span><br><span class="line">          <span class="attr">font-size:</span> <span class="string">18px;</span></span><br><span class="line">          <span class="attr">font-weight:</span> <span class="string">bold;</span></span><br><span class="line">          <span class="attr">transition:</span> <span class="number">0.</span><span class="string">3s;</span></span><br><span class="line">          <span class="attr">cursor:</span> <span class="string">pointer;</span></span><br><span class="line">          <span class="string">&amp;:hover</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="attr">color:</span> <span class="comment">#007db6;</span></span><br><span class="line">          <span class="string">&#125;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">        <span class="string">.article-info</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">color:</span> <span class="comment">#e8590c;</span></span><br><span class="line">          <span class="attr">font-size:</span> <span class="string">14px;</span></span><br><span class="line">          <span class="attr">font-weight:</span> <span class="string">lighter;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/20119062sG6tnlDDqx.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/20119062sG6tnlDDqx.jpg"></p>
<p>最後結果顯示，我自己是覺得刻的還可以啦：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/20119062RSW6VEwg7C.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/20119062RSW6VEwg7C.jpg"></p>
<p>接下來呢我們就要將這個已經刻好的版面來挖洞塞值進去 <code>template</code> 裡面！</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"board-wrapper"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"board-header"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-title"</span>&gt;</span>鐵人檔案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-deco"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"board-body"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(year,index) in this.json"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"article-wrapper"</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-year"</span>&gt;</span></span><span class="template-variable">&#123;&#123; year.irontitle &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-body"</span> <span class="attr">v-for</span>=<span class="string">"(articles,index) in year.articles"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"article-type"</span>&gt;</span></span><span class="template-variable">&#123;&#123; articles.type &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"article-title"</span> <span class="attr">:href</span>=<span class="string">"articles.href"</span>&gt;</span></span><span class="template-variable">&#123;&#123; articles.title &#125;&#125;</span><span class="xml"> 系列<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span></span></span></span><br><span class="line"><span class="xml">              class="article-info"</span></span><br><span class="line"><span class="xml">            &gt;</span><span class="template-variable">&#123;&#123; articles.info.success ? '鐵人練成' : '鐵人未練成' &#125;&#125;</span><span class="xml"> ｜ 共 </span><span class="template-variable">&#123;&#123; articles.info.count &#125;&#125;</span><span class="xml"> 篇文章 ｜ </span><span class="template-variable">&#123;&#123; articles.info.subscribe &#125;&#125;</span><span class="xml"> 人訂閱<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"board-footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>完成之後就會看到畫面……</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/20119062QDVJMZZUP8.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/20119062QDVJMZZUP8.jpg"></p>
<p>還是一樣！</p>
<p>但不一樣的事情是裡面的數值是由資料所供應的，因此面板上的東西會隨著資料而有所變動！</p>
<p>現在來模擬一下假如大雄去年也有參加鐵人賽，因此資料庫回傳的 JSON 檔案變成下面這樣：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">[</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">irontitle:</span> <span class="string">"第 11 屆 iT 邦幫忙鐵人賽"</span><span class="string">,</span></span><br><span class="line">    <span class="attr">articles:</span> <span class="string">[</span></span><br><span class="line">      <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">"Modern Web"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">title:</span></span><br><span class="line">          <span class="string">"「小孩才做選擇，我全都要。」小白也能輕鬆瞭解的 Vue.js 與 D3.js 。"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span></span><br><span class="line">          <span class="string">"https://ithelp.ithome.com.tw/users/20119062/ironman/2242"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">info:</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">success:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">          <span class="attr">count:</span> <span class="number">32</span><span class="string">,</span></span><br><span class="line">          <span class="attr">subscribe:</span> <span class="number">39</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">]</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">irontitle:</span> <span class="string">"2019 邦幫忙鐵人賽"</span><span class="string">,</span></span><br><span class="line">    <span class="attr">articles:</span> <span class="string">[</span></span><br><span class="line">      <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">"自我挑戰"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"挑戰連續三十天喝不同家手搖飲。"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">""</span><span class="string">,</span></span><br><span class="line">        <span class="attr">info:</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">success:</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line">          <span class="attr">count:</span> <span class="number">29</span><span class="string">,</span></span><br><span class="line">          <span class="attr">subscribe:</span> <span class="number">512</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">"自我挑戰"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"連續三十天發廢文。"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">""</span><span class="string">,</span></span><br><span class="line">        <span class="attr">info:</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">success:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">          <span class="attr">count:</span> <span class="number">999</span><span class="string">,</span></span><br><span class="line">          <span class="attr">subscribe:</span> <span class="number">87</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;,</span></span><br><span class="line">    <span class="string">]</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure>

<p>而依照 Vue.js 核心概念以資料驅動視覺，最後元件就會依其資料產生對應的視覺出來：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/20119062r7NDCP4e1b.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/20119062r7NDCP4e1b.jpg"></p>
<p>這樣就完成半個元件啦！</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/20119062rljfyj8Vxe.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/20119062rljfyj8Vxe.jpg"></p>
<p>還記得我們元件最初的資料傳遞概念嗎？明天我們將會以 props 的方式傳遞資料進去，讓這個元件成為真正可以復用的元件！</p>
<blockquote>
<p>最近翻著阿橘一年前的照片發現阿橘變胖好多，那時候大概才現在的一半大小吧…(?<br><img src="https://ithelp.ithome.com.tw/upload/images/20191005/20119062DYd3umJBXN.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/20119062DYd3umJBXN.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli What is Vuex? Why do we need Vuex?</title>
    <url>/vue.js/Vue-cli-005-vuex/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>這幾天陸陸續續講解了 Vue.js 在 Vue-cli 裡偏向實作的說明，而目前我們也已經完成了一個簡單的元件，可以透過父層引用這個元件時，將需要的資料傳遞給元件，使子元件可以在不同頁面、區塊重複使用。</p>
<p>然而昨天有提出了一個問題，<strong>「假設今天不同頁面（不同 .vue 檔案），都要使用共同的狀態時，我們應該如何處理？」</strong></p>
<a id="more"></a>

<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20119062j4oXCz4l8w.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20119062j4oXCz4l8w.png"></p>
<p>如果大家還有印象，我們之前曾經在 Vue.js 章節中講過類似的 <a href="https://ithelp.ithome.com.tw/articles/10215277" target="_blank" rel="noopener">傳遞</a> ，在當時我們提到了子元件可以透過 <code>$emit</code> 去發送事件給另一個 Vue 實體（例如當時命名的 <code>bus</code>），而父元件就可以藉由監聽 <code>bus</code> 上的事件，等待其他元件去觸發他，從而達到<strong>事件的集中管理</strong>。</p>
<p>而<strong>資料狀態</strong>的集中管理，在 Vue.js 則是藉由一個簡單的 <code>store</code> 來達成：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/201190623CyZpsmxn6.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/201190623CyZpsmxn6.png"></p>
<p>建立一個 store 物件，而各個 Vue 實體引入該 store 來做為狀態的集中管理：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> store = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vmA = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  <span class="built_in">data</span>: store</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vmB = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  <span class="built_in">data</span>: store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>只要 <code>vmA</code> 或 <code>vmB</code> 任一方更動了 store 裡的資料都會觸發雙方因<strong>資料改變而驅動視覺改變</strong>的過程。</p>
<p>而這個過程必須遵循著之前所提的單向資料流的部分，我們應該由視覺（view）的部分去觸發事件（action），而讓事件去更改狀態（state），最後狀態（state）會更新視覺（view）：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20119062llpUTj8JUN.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20119062llpUTj8JUN.png"></p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>今天要介紹的 Vuex 其實就是綜合了以上的概念，將<strong>資料狀態與事件操作集中管理的一項工具</strong>。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20119062FSAgtZHqGQ.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20119062FSAgtZHqGQ.png"></p>
<p>在 Vuex 中，主要負責的是上圖綠色框中的部分，左邊 Vue.component 則是元件本身自己的部分，而元件本身最主要的工作就是藉由發送（dispatch）給 Vuex，Vuex 幫我們處理了後續的內容之後，藉由更改狀態（state）來觸發元件本身重新渲染。</p>
<p>因此單看元件本身的話，<strong>元件本身</strong>會需要的是：</p>
<ul>
<li><strong>寫下發送（dispatch）的事件</strong></li>
<li><strong>接收 Vuex（store） 裡的狀態（state）</strong></li>
</ul>
<p>而在 Vuex 中的<strong>狀態管理倉庫（store）中則會提供</strong>：</p>
<ul>
<li><strong>Actions</strong> ：接收來自元件發送（dispatch）的事件，並且提交（commit）事件給 Mutations 去執行他該做的事情。</li>
<li><strong>Mutations</strong> ：接收來自 Actions 的事件，並且發送變更（Mutate）給 store 裡本身的 State。</li>
<li><strong>State</strong> ：接收來自 Mutations 發送的變更，更改 State 自己本身的狀態。</li>
</ul>
<p>以昨天更改好的 Home.vue 為例子，原先在 data 中的資料改成放置在 store 中的 action 去跟後端呼叫，取而代之的是以 computed 去抓取 store 中的值，並且在 created 生命週期中發送 <code>getIronmanData</code> 事件給 store：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">import infoBoard from "@/components/board/articleBoard";</span></span><br><span class="line"></span><br><span class="line"><span class="xml">export default </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery"> <span class="built_in"> name</span>: <span class="string">"home"</span>,</span></span><br><span class="line"><span class="xquery">  components: &#123;</span></span><br><span class="line"><span class="xquery">    infoBoard</span></span><br><span class="line"><span class="xquery">  &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">  created()</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    this.<span class="variable">$store</span>.dispatch(<span class="string">'getIronmanData'</span>)</span></span><br><span class="line"><span class="xquery">  &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">  computed:</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    ironmanData()&#123;</span></span><br><span class="line"><span class="xquery">      <span class="keyword">return</span> this.<span class="variable">$store</span>.state.ironmanData</span></span><br><span class="line"><span class="xquery">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>而在 /src/store.js 中，我們在 actions 區塊放入監聽事件名稱對應的函式 <code>getIronmanData</code> 並將 <code>context</code> 參數傳入，透過 <code>context.commit</code> 將發送的事件提交給 Mutations 來做變更：</p>
<figure class="highlight roboconf"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">    <span class="attribute">getIronmanData (context) &#123;</span></span><br><span class="line"><span class="attribute">      fetch('https</span>://raw<span class="variable">.githubusercontent</span><span class="variable">.com</span>/shawnlin0201/ironmanData/master/ironman<span class="variable">.json</span>')</span><br><span class="line">        <span class="variable">.then</span>(res =&gt; res<span class="variable">.json</span>())</span><br><span class="line">        <span class="variable">.then</span>(res =&gt; &#123;</span><br><span class="line">          context<span class="variable">.commit</span>('setItonmanData', res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mutations 區塊則是放入 actions 所提交的事件名稱 <code>setItonmanData</code> 並將 <code>state</code> 與 <code>payload</code> 傳入函式當中，這裡的 state 指向的是 store.state，而 payload 則是前面 actions 函式所帶進來的數值：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    <span class="built_in">set</span>ItonmanData (<span class="keyword">state</span>, json) &#123;</span><br><span class="line">      <span class="keyword">state</span>.ironmanData = json</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>最後在 state 中放入初始值即完成一個簡單的狀態集中管理。</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">import Vue <span class="keyword">from</span> 'vue'</span><br><span class="line">import Vuex <span class="keyword">from</span> 'vuex'</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> new Vuex.Store(&#123;</span><br><span class="line">  <span class="keyword">state</span>: &#123;</span><br><span class="line">    ironmanData: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="built_in">set</span>ItonmanData (<span class="keyword">state</span>, json) &#123;</span><br><span class="line">      <span class="keyword">state</span>.ironmanData = json</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    getIronmanData (context) &#123;</span><br><span class="line">      fetch('https://raw.githubusercontent.com/shawnlin0201/ironmanData/master/ironman.json')</span><br><span class="line">        .then(res =&gt; res.json())</span><br><span class="line">        .then(res =&gt; &#123;</span><br><span class="line">          context.commit('<span class="built_in">set</span>ItonmanData', res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>現在的程式碼概念如下：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20119062DELL7jQX63.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20119062DELL7jQX63.png"></p>
<p>而最後顯示的畫面理所當然的是……還是一樣</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20119062E0sXO8pBst.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20119062E0sXO8pBst.jpg"></p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/2011906215bC8QVWPG.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191007/2011906215bC8QVWPG.jpg"></p>
<p>正如梗圖所示，Vuex 最終在做的事情是方便各個元件要取得、修改同筆資料來源時，能夠有個<strong>狀態集中管理</strong>的地方，協助我們處理不同元件間最後<strong>視覺層上的一致性</strong>，但假如項目只是個單純一頁網站、沒有太多元件引用同隻資料來源，則 Vuex 確實是不一定加入項目當中的，所以工具選用上還是要自己權衡一下是否真的需要，否則會有點殺雞用牛刀的感覺！</p>
<p>當然，Vuex 的部分其實還不僅止於此，假設項目真的大到 store 塞滿滿的話，我們還有 <a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener">Module</a> 的方式去管理 store 的部分，並且如果 store 中的 state 狀態需要很多計算的話，其實可以利用 <a href="https://vuex.vuejs.org/zh/guide/getters.html" target="_blank" rel="noopener">getter</a> （有如元件中的 computed）來先計算好數值再傳給元件去重新渲染等等，但這麼一說下去可能這系列會寫不完吧（？，所以明天我們會先回頭來介紹 Vue.router 要如何使用再做打算吧！</p>
<blockquote>
<p>今天就以阿橘的肉球跟大家說再見！<br><img src="https://ithelp.ithome.com.tw/upload/images/20191007/201190629y4SXlpmsv.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191007/201190629y4SXlpmsv.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli Router</title>
    <url>/vue.js/Vue-cli-006-vue-router/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>今天要介紹的是對<strong>單頁式應用網站（SPA，Single Page Application）</strong> 非常重要的 Router， SPA 為何會需要 Router 來處理網頁路徑呢？這裡簡單介紹一下他們之間的關係：</p>
<p>在 SPA 技術被大肆使用之前，以前的網站多是採用<strong>多頁式網頁（MPA，Multiple Page Application）</strong>，而兩者差異最大的地方在於<strong>向伺服器請求的東西不同</strong>。</p>
<p>一開始不論 SPA 還是 MPA 網站都需要使用者輸入網址，透過一個叫做 DNS 的服務器找到該網站伺服器，接著經過一連串回應後，伺服器回應給使用者一個 HTML 網頁檔案。</p>
<p>而 MPA 在後續轉換頁面上，則是<strong>藉由輸入的網址不同，重複以上動作向網站伺服器拿取每頁的網頁檔案</strong>，並且重新渲染每頁的內容，因此會造成網頁整個畫面都被刷新。</p>
<p>SPA 則是進入入口網頁（SPA 進入點）後透過 AJAX 技術，跟伺服器拿取部分資料替換內容進去；而替換的區域，小至更新收藏狀態的按鈕，大至整個頁面都被刷新，此時網址列的路徑卻仍是我們一開始進去的那個 SPA 進入點網址。</p>
<p>因此，SPA 網頁需要<strong>藉由 History API</strong> 來操控網址列，並且藉由<strong>前端辨識使用者輸入的網頁路徑</strong>不同，而透過前端給予使用者不同的頁面內容，這也代表著原先由後端伺服器所負責的路徑管理，將交由前端來負責辨識與處理，也使得前端的複雜度上升了一個檔次。</p>
<p>為了使用者的品質體驗，身為前端工程師的我們當然不會因為這種小事而被擊倒，但管理路徑上確實是不容易的事情，因此工程師們逐漸發展出一系列管理路徑的方法。而在 Vue 框架中，我們可以藉由 Vue Router 來協助處理這一類的問題，這也就是今天所要提到的內容。</p>
<a id="more"></a>

<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>在 Vue.js 中，可以單獨在頁面中引入 script 檔使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">https:<span class="comment">//unpkg.com/vue-router@2.0.0/dist/vue-router.js</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而在 Vue-cli 中，我們可以在一開始建立檔案時，將 Router 模組安裝進去，安裝完畢後會在 <code>/src</code> 路徑底下看到一隻 router.js 設定檔案，這也就是我們今天主要會操作到的檔案。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">├── dist/               </span><br><span class="line">├── node_modules/       </span><br><span class="line">├── public/             </span><br><span class="line">│   ├── favicon.ico     </span><br><span class="line">│   └── index.html      </span><br><span class="line">├── src/                </span><br><span class="line">│   ├── assets/         </span><br><span class="line">│   ├── components/     </span><br><span class="line">│   ├── views/          </span><br><span class="line">│   ├── App.vue         </span><br><span class="line">│   ├── main.js         </span><br><span class="line">│   ├── router.js       // 在這裡</span><br><span class="line">│   └── store.js        </span><br><span class="line">├── .gitignore          </span><br><span class="line">├── package.json        </span><br><span class="line">└── vue.config.js</span><br></pre></td></tr></table></figure>

<p>而打開 router.js 後我們可以看到下列檔案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./views/Home.vue'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  base: process.env.BASE_URL,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'home'</span>,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/about'</span>,</span><br><span class="line">      name: <span class="string">'about'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./views/About.vue'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>首先我們先來關注放在 Router 裡面所回傳的物件可放入的屬性，第一個屬性 <code>mode</code> 模式可以切換為：</p>
<ul>
<li><code>hash</code> ：默認值，在這種模式下路徑會以 hash 來模擬路徑，藉由 hash 特性使切換路徑時頁面不會刷新。</li>
<li><code>history</code> ：history 模式，則是利用前面提到的 history API 來達成切換路徑的效果。</li>
</ul>
<p>以本機伺服器為例子切換到 /about 的話兩者差異如下：</p>
<ul>
<li>hash<ul>
<li><a href="http://localhost:8080/#/" target="_blank" rel="noopener">http://localhost:8080/#/</a></li>
<li><a href="http://localhost:8080/#/about" target="_blank" rel="noopener">http://localhost:8080/#/about</a></li>
</ul>
</li>
<li>history<ul>
<li><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></li>
<li><a href="http://localhost:8080/about" target="_blank" rel="noopener">http://localhost:8080/about</a></li>
</ul>
</li>
</ul>
<p>第二個屬性 <code>base</code> 則是決定好根目錄的名稱，建立環境如果在特定路徑下需要更改。</p>
<p>第三個屬性 <code>routes</code> 則可以設定頁面路徑等相關設定，以下列出幾個較常用的項目：</p>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>用來核對網址路徑使用，若符合該路徑則會渲染出對應的元件（component），並且支援多種比對的方法。<br>路徑          | 涵義<br>————- | ————-<br>/             | 根目錄網址<br>/*             | 所有網址都符合此路徑，會攔截所有網址，要謹慎使用。<br>/member       | 網址剛好為 /member 才符合<br>/member-*       | 開頭為 /member 皆符合條件<br>/member/*       |  /member/ 底下網址都符合此條件<br>/member/:id       | 網址為 <code>/member/9527</code> 的話，可在該頁面透過 this.$route.params 取到 <code>{id:9527}</code><br>/member?       | 網址為 <code>/member?from=ithome</code> 的話，可在該頁面透過 this.$route.query 取到 <code>{from:ithome}</code> </p>
<h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><p>path 條件符合時，渲染該頁面對應的單一元件檔（.vue）。</p>
<p>透過 import 方式我們可以在使用者開啟網站時就先導入該頁面的資源，而透過放在 component 裡的 callback function 則可以達到 lazy loading 載入元件的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./views/About.vue'</span>)</span><br></pre></td></tr></table></figure>

<p>另外在執行 <code>npm run build</code> 建置靜態檔案準備上傳伺服器前，可在 import 內放入 webpackChunkName 來設定包裝元件檔的模組名稱，而該模組名稱主要是用來執行異步載入用，避免元件檔數量太多而造成載入時受影響。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'./views/About.vue'</span>)</span><br></pre></td></tr></table></figure>


<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>識別該頁面的名稱，如在元件中可透過方法切換到指定的頁面名稱：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123;<span class="attr">name</span>: <span class="string">'about'</span>&#125;) <span class="comment">// 使用 Vue router 切換到 about 頁面</span></span><br></pre></td></tr></table></figure>

<h3 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h3><p>將進入到符合到 path 路徑條件的網址，重新轉向 redirect 所指定的網址：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">redirect</span>: <span class="string">'/b'</span> &#125; <span class="comment">// 此設定將會使進入 /a 網址的使用者，被導向到 /b 網址並使用符合 /b path 路徑的元件</span></span><br></pre></td></tr></table></figure>

<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>將進入到符合到 path 路徑條件的網址，改成 alias 所指定的網址：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">alias</span>: <span class="string">'/b'</span>, <span class="attr">component</span>:A &#125;    <span class="comment">// 此設定將會使進入 /a 並使用符合 /a 路徑的元件，但網址會轉換成 /b</span></span><br></pre></td></tr></table></figure>

<h2 id="切換頁面"><a href="#切換頁面" class="headerlink" title="切換頁面"></a>切換頁面</h2><p>在設定完頁面相關資訊之後，我們現在已經擁有了一個網址路徑比對的工具了，現在我們要在頁面中執行切換頁面的效果。</p>
<p>最簡單的方式，是透過 Vue router 所提供的 <code>&lt;router-link&gt;</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最後會轉譯成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而特地要使用 <code>&lt;router-link&gt;</code> 而不是 <code>&lt;a&gt;</code> 的原因在於，他在有設定 base 路徑的情況下，可以直接使用 <code>to</code> 來導向網域底下的頁面，並且防止頁面重新載入以及遇到不支援 history 模式的瀏覽器時會自動降級成 hash 模式的路徑。</p>
<p><strong>此外也可以傳入一個 router 物件：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"&#123; path: 'about'&#125;"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 9527 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">以上等同於</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/user?userId=9527"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>以 JavaScript 轉頁：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">'about'</span>&#125;&#125;)  <span class="comment">// 網址 /about</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">9527</span> &#125;)  <span class="comment">// 網址 /user?userId=9527</span></span><br></pre></td></tr></table></figure>

<p><strong>針對歷史紀錄切換頁：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.go(<span class="number">1</span>)    <span class="comment">// 下一頁</span></span><br><span class="line"><span class="keyword">this</span>.$router.go(<span class="number">-1</span>)   <span class="comment">// 上一頁</span></span><br><span class="line"><span class="keyword">this</span>.$router.go(<span class="number">9527</span>) <span class="comment">// 若跳轉頁面數量不構，會發生錯誤，需自行處理</span></span><br></pre></td></tr></table></figure>

<h2 id="顯示頁面"><a href="#顯示頁面" class="headerlink" title="顯示頁面"></a>顯示頁面</h2><p>Vue router 提供了 <code>&lt;router-view&gt;</code> 標籤供我們使用，只要符合路徑，而在標籤使用區塊須注意 router 中所設定的 route 層級，以下方為例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">App.vue </span><br><span class="line">├── Home.vue</span><br><span class="line">└── About.vue</span><br><span class="line">    ├── Info.vue</span><br><span class="line">    └── Contact.vue</span><br></pre></td></tr></table></figure>

<p>若在 App.vue 中所使用的話，路徑可比對到 <code>Home.vue</code> 以及 <code>About.vue</code>。</p>
<p>但若想要在 About.vue 中嵌套顯示底下的 <code>Info.vue</code> 或 <code>Contact.vue</code> 則需在 About.vue 裡面也放置 <code>&lt;router-view&gt;</code>標籤，並在 router 中設定 children 路徑配對：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">path</span>: <span class="string">'/about'</span>,</span><br><span class="line">  name: <span class="string">'AboutPage'</span>,</span><br><span class="line">  component: () =&gt; <span class="built_in">import</span>(/* webpackChunkName: <span class="string">"About"</span> */ <span class="string">'./views/About.vue'</span>),</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/about/info'</span>,</span><br><span class="line">      component: () =&gt; <span class="built_in">import</span>(/* webpackChunkName: <span class="string">"About"</span> */ <span class="string">'./views/Info.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attribute">path</span>: <span class="string">'/about/contact'</span>,</span><br><span class="line">      component: () =&gt; <span class="built_in">import</span>(/* webpackChunkName: <span class="string">"About"</span> */ <span class="string">'./views/Contact.vue'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一來首先會從 <code>App.vue</code> 的 <code>&lt;router-view&gt;</code> 配對到 about 頁面並載入 <code>About.vue</code> 後，在透過連結配對到 info 頁面或 contact 頁面，切換 About.vue 頁面當中的 <code>&lt;router-view&gt;</code> ，載入 <code>Info.vue</code> 或 <code>Contact.vue</code>。</p>
<p>以上就是 Vue-cli Router 中一些最基礎的用法！基本上依靠這幾個 API 切換加上之前所介紹到的 Vue.js 指令與 Vue-cli .vue 檔案，已經能做出完整的應用程式了，而其中還有少數幾個 API 沒有講到的，不過這都可以待需要使用時再繼續深入研究，希望大家會喜歡這個系列！</p>
<blockquote>
<p>接下來我們就有緣再相見啦！<br><img src="https://ithelp.ithome.com.tw/upload/images/20191008/20119062b1DjmDGged.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191008/20119062b1DjmDGged.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 單一元件檔（ 以 iT 邦幫忙鐵人賽檔案當作開發範例）續</title>
    <url>/vue.js/Vue-cli-004-vue-file-sample-2/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="單一元件檔-props"><a href="#單一元件檔-props" class="headerlink" title="單一元件檔 props"></a>單一元件檔 props</h2><p>今天要來把昨天製作好的元件檔案拆分的更乾淨一點，昨天我們的資料都還放在<strong>元件自己本身中的 data 裡面</strong>，這樣子在 View 頁面使用時套用該元件都只會讀到元件自己本身中的資料，而我們今天要來將元件中的 data 清除乾淨，透過父層在決定要使用這個元件時，才將要輸入的資料傳遞進去。</p>
<a id="more"></a>

<p>首先，我們將元件自己本身中的 data 給清除，因為我們之後將會由父層去決定塞什麼資料給子元件，並且在裡面塞入 props 欄位，指定這個子元件能夠接收父層傳遞哪個欄位給他：</p>
<p>子元件的 script 區塊：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">"articleBoard"</span>,</span></span><br><span class="line"><span class="actionscript">  props: &#123; json: <span class="literal">null</span> &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接著，template 區域，改動的地方最主要是在於 li 標籤元素中，原本我們是透過 <code>this.json.iron</code> 去抓取子元件自己本身的資料，而現在要改成 <code>json</code> 去對應到 script 中 props 所給予的資料（也就是父層傳遞進來的欄位）！</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"board-wrapper"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"board-header"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-title"</span>&gt;</span>鐵人檔案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-deco"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"board-body"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(year,index) in json"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"article-wrapper"</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-year"</span>&gt;</span></span><span class="template-variable">&#123;&#123; year.irontitle &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-body"</span> <span class="attr">v-for</span>=<span class="string">"(articles,index) in year.articles"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"article-type"</span>&gt;</span></span><span class="template-variable">&#123;&#123; articles.type &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"article-title"</span> <span class="attr">:href</span>=<span class="string">"articles.href"</span>&gt;</span></span><span class="template-variable">&#123;&#123; articles.title &#125;&#125;</span><span class="xml"> 系列<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span></span></span></span><br><span class="line"><span class="xml">              class="article-info"</span></span><br><span class="line"><span class="xml">            &gt;</span><span class="template-variable">&#123;&#123; articles.info.success ? '鐵人練成' : '鐵人未練成' &#125;&#125;</span><span class="xml"> ｜ 共 </span><span class="template-variable">&#123;&#123; articles.info.count &#125;&#125;</span><span class="xml"> 篇文章 ｜ </span><span class="template-variable">&#123;&#123; articles.info.subscribe &#125;&#125;</span><span class="xml"> 人訂閱<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"board-footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>調整完畢後，現在該元件已經可以接受來自父層所傳遞的資料了。現在我們把該元件檔命名為 <code>articleBoard.vue</code> 並把它放入 <code>/src/components/board/</code> 的路徑底下，並且在 <code>/src/view</code> 路徑中的元件檔中透過 import 引入這個元件，並取名為 <code>infoBoard</code>（可自由命名），然後把資料 data 放在這個父層中模擬由父層給予子元件資料的過程：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;script&gt;</span></span><br><span class="line">import infoBoard from <span class="string">"@/components/board/articleBoard"</span>;</span><br><span class="line"></span><br><span class="line">export <span class="class">default </span>&#123;</span><br><span class="line"><span class="symbol">  name:</span> <span class="string">"home"</span>,</span><br><span class="line"><span class="symbol">  components:</span> &#123;</span><br><span class="line">    infoBoard</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="class">return </span>&#123;</span><br><span class="line"><span class="symbol">      json:</span> [</span><br><span class="line">        &#123;</span><br><span class="line"><span class="symbol">          irontitle:</span> <span class="string">"第 11 屆 iT 邦幫忙鐵人賽"</span>,</span><br><span class="line"><span class="symbol">          articles:</span> [</span><br><span class="line">            &#123;</span><br><span class="line"><span class="symbol">              type:</span> <span class="string">"Modern Web"</span>,</span><br><span class="line"><span class="symbol">              title:</span></span><br><span class="line">                <span class="string">"「小孩才做選擇，我全都要。」小白也能輕鬆瞭解的 Vue.js 與 D3.js 。"</span>,</span><br><span class="line"><span class="symbol">              href:</span> <span class="string">"https://ithelp.ithome.com.tw/users/20119062/ironman/2242"</span>,</span><br><span class="line"><span class="symbol">              info:</span> &#123;</span><br><span class="line"><span class="symbol">                success:</span> true,</span><br><span class="line"><span class="symbol">                count:</span> <span class="number">32</span>,</span><br><span class="line"><span class="symbol">                subscribe:</span> <span class="number">39</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="symbol">          irontitle:</span> <span class="string">"2019 邦幫忙鐵人賽"</span>,</span><br><span class="line"><span class="symbol">          articles:</span> [</span><br><span class="line">            &#123;</span><br><span class="line"><span class="symbol">              type:</span> <span class="string">"自我挑戰"</span>,</span><br><span class="line"><span class="symbol">              title:</span> <span class="string">"挑戰連續三十天喝不同家手搖飲。"</span>,</span><br><span class="line"><span class="symbol">              href:</span> <span class="string">""</span>,</span><br><span class="line"><span class="symbol">              info:</span> &#123;</span><br><span class="line"><span class="symbol">                success:</span> false,</span><br><span class="line"><span class="symbol">                count:</span> <span class="number">29</span>,</span><br><span class="line"><span class="symbol">                subscribe:</span> <span class="number">512</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line"><span class="symbol">              type:</span> <span class="string">"自我挑戰"</span>,</span><br><span class="line"><span class="symbol">              title:</span> <span class="string">"連續三十天發廢文。"</span>,</span><br><span class="line"><span class="symbol">              href:</span> <span class="string">""</span>,</span><br><span class="line"><span class="symbol">              info:</span> &#123;</span><br><span class="line"><span class="symbol">                success:</span> true,</span><br><span class="line"><span class="symbol">                count:</span> <span class="number">999</span>,</span><br><span class="line"><span class="symbol">                subscribe:</span> <span class="number">87</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="params">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 Home.vue 的 template 中，我們使用剛剛命名的 <code>infoBoard</code> 來當作標籤使用，接著使用 <code>json</code> 欄位來引入資料，然後這樣只會將後面的值 <code>&quot;this.json.iron&quot;</code> 當作資料寫進去，要與 Vue.js 元件本身檔案有關係的話我們仍必須透過 <code>v-bind</code> 去引用，因此最後是使用 <code>:json</code> 來引入 <code>this.json.iron</code> 而非 <code>json</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page page-home"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">infoBoard</span> <span class="attr">:json</span>=<span class="string">"this.json.iron"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>完成之後我們就得到了一個由 Home.vue 父元件所引入的 articleBoard.vue 子元件，並且透過父層傳遞資料進去給他，而最後顯示的畫面應該還是要跟之前一模一樣才對：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20119062Hl3TkzMIgb.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20119062Hl3TkzMIgb.jpg"></p>
<p>差異在於今天可以由父層的 data 去給予這個元件不同的資料，而非寫死在子元件裡面的，所以現在每個頁面都可以使用這個元件了！</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20119062tW3oLgXAz3.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20119062tW3oLgXAz3.jpg"></p>
<p>然而問題馬上就出現了，現在我們已經可以自由引入這個元件，並透過 data 去引入他的資料，但是萬一這個資料哪天要更動，不就每個引用這個 data 的元件都要改變嗎？因此有個東西叫做 Vuex 他替我們解決了這個問題…</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20119062BvFnfN60P6.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20119062BvFnfN60P6.jpg"></p>
<blockquote>
<p>補班的隔天一整個睡死，起來就看到兩姊弟不知道在討論什麼秘密……？<br><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20119062nlEYZZB7Dw.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20119062nlEYZZB7Dw.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 2.x 升級 Vue 3.0 紀錄</title>
    <url>/vue.js/Vue-cli-007-update-3-0/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>Vue.js 底層還沒來得及摸透，在 2020 年 6 月 30 號 Vue 作者尤雨溪又發布<a href="https://github.com/vuejs/rfcs/issues/183" target="_blank" rel="noopener">聲明</a>：</p>
<p>大致上是在說明即將在 2020 年七月中 Vue 3.0 將進入 RC 階段並且八月初官方就會釋出正式版。</p>
<p>心想該來的還是要來，不如趁現在 branch 開下去馬上升級一波。</p>
<a id="more"></a>

<h1 id="起始式-vue-add-vue-next"><a href="#起始式-vue-add-vue-next" class="headerlink" title="起始式 vue add vue-next"></a>起始式 vue add vue-next</h1><p>要升級最快的方式便是直接在 <code>vue-cli</code> 專案中使用 <code>vue add vue-next</code> 指令來升級。</p>
<p>但不愧是升級之路，一開始馬上就來噴個錯誤給你看…</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue add vue-next</span><br><span class="line"></span><br><span class="line">📦  Installing vue-cli-plugin-vue-next...</span><br><span class="line">✔  Successfully installed plugin: vue-cli-plugin-vue-next</span><br><span class="line"></span><br><span class="line">🚀  Invoking generator <span class="keyword">for</span> vue-cli-plugin-vue-next...</span><br><span class="line">ERROR  TypeError: Received an unexpected value [object Undefined]</span><br></pre></td></tr></table></figure>

<p>這個問題不難，主要是因為 <code>vue-cli</code> 版本不支援的關係，所以透過 <code>npm install -g @vue/cli @latest</code> 將 <code>vue-cli</code> 升級到最新版即可，接著再跑一次  <code>vue add vue-next</code> 指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue add vue-next</span><br><span class="line"></span><br><span class="line">📦  Installing vue-cli-plugin-vue-next...</span><br><span class="line">✔  Successfully installed plugin: vue-cli-plugin-vue-next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">🚀  Invoking generator <span class="keyword">for</span> vue-cli-plugin-vue-next...</span><br><span class="line">ERROR  Cannot find file src/main.js</span><br><span class="line">📦  Installing additional dependencies...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">✔  Successfully invoked generator <span class="keyword">for</span> plugin: vue-cli-plugin-vue-next</span><br><span class="line"> vue-next  Installed vuex 4.0.</span><br><span class="line"> vue-next  Documentation available at https://github.com/vuejs/vuex/tree/4.0</span><br><span class="line"></span><br><span class="line">This dependency was not found:</span><br><span class="line"></span><br><span class="line">* vue <span class="keyword">in</span> ./node_modules/vuex/dist/vuex.esm-browser.js, ./src/index.js and 17 others</span><br></pre></td></tr></table></figure>

<h1 id="修復"><a href="#修復" class="headerlink" title="修復"></a>修復</h1><p>從上述報告中可以看出，安裝升級的套件有做了簡易的 migration，並且依據不同工具來做自動轉換。</p>
<p>但有舊專案總是有一些設定不如預期就沒辦法靠工具自動解決了，比如說專案使用了 <code>index.js</code> 來做為進入點的 js 檔案名稱，就會因為工具沒偵測到而拋出了 <code>ERROR  Cannot find file src/main.js</code>，</p>
<p>因此即便升級完畢，最後執行 <code>npm run serve</code> 時，仍會 log 出這樣的訊息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">This dependency was not found:</span><br><span class="line"></span><br><span class="line">* vue <span class="keyword">in</span> ./node_modules/vuex/dist/vuex.esm-browser.js, ./src/index.js and 17 others</span><br></pre></td></tr></table></figure>

<p>甚至我在同事電腦中看到的版本還會叫你去安裝 <code>Vue.js</code> …（別傻傻地又 install 回 2.X 版本阿 XD</p>
<p>而各套件中修復的方向不同，以下針對這個專案所遇到的問題來改改：</p>
<ul>
<li>進入點</li>
<li>Vuex</li>
<li>vue.config.js</li>
</ul>
<h2 id="進入點"><a href="#進入點" class="headerlink" title="進入點"></a>進入點</h2><p>進入點主要就是用來綁定渲染元素的地方，基本上 Vue 2.x 的寫法 3.0 都有支援，所以主要是引入的地方要改，而原本進入點檔案可能長得像這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而在 Vue 3.0 的做法是透過 createApp 引入 Vue，並且需透過 <code>mount</code> 來綁定的元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">'#app'</span>) <span class="comment">// 注意不是用 $mount，$mount 是 Vue 2.x 的寫法</span></span><br></pre></td></tr></table></figure>

<p>這樣就完成進入點的設定了。</p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vuex 更動則是包含了進入點的引入與本身檔案的設定。</p>
<p>Vuex 檔案（store.js）本身，原本引入與使用都在這個檔案中設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Vue 3.0 後，我們需要將 <code>createStore</code> 引入，並透過它創建好一個 <code>store</code> 後 <code>export</code> 出去，怎麼使用完全交由引入的檔案設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store =  createStore(&#123;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>接著原本進入點的地方原本是透過這樣載入，我們拿上方進入點章節修改好的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">  store, <span class="comment">// 原本是引入到裡面</span></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>修改一下 <code>@/store</code> 所引入的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">'@/store'</span> <span class="comment">// 這裡要注意引入的方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(store) <span class="comment">// 改成透過 `use` 使用</span></span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>Vuex 到這裡就可以繼續使用啦！</p>
<h2 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h2><p>config 檔案多數偏向客製的設定，而這裡主要原先需求是要能透過靜態的 html 檔案使用 vue.js 功能，也就是讓 SSR 渲染完能接回 Vue.js SPA 的概念，所以原本大概會有這些設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pages: &#123;  <span class="comment">// multiple page SSR contect with SPA</span></span><br><span class="line">    index: &#123;</span><br><span class="line">      entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      chunks: [<span class="string">'chunk-vendors'</span>, <span class="string">'chunk-common'</span>, <span class="string">'index'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'about'</span>: &#123;</span><br><span class="line">      entry: <span class="string">'./src/page/about.js'</span>,</span><br><span class="line">      template: <span class="string">'public/about.html'</span>,</span><br><span class="line">      filename: <span class="string">'about.html'</span>,</span><br><span class="line">      chunks: [<span class="string">'chunk-vendors'</span>, <span class="string">'chunk-common'</span>, <span class="string">'about'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'contact'</span>: &#123;</span><br><span class="line">      entry: <span class="string">'./src/contact.js'</span>,</span><br><span class="line">      template: <span class="string">'public/contact.html'</span>,</span><br><span class="line">      filename: <span class="string">'contact.html'</span>,</span><br><span class="line">      chunks: [<span class="string">'chunk-vendors'</span>, <span class="string">'chunk-common'</span>, <span class="string">'contact'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  filenameHashing: <span class="literal">false</span>,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>, <span class="string">'.css'</span>],</span><br><span class="line">      alias: &#123;</span><br><span class="line">        vue$: <span class="string">'vue/dist/vue.esm.js'</span>, <span class="comment">// 對應的解析方式</span></span><br><span class="line">        <span class="string">'@'</span>: resolve(<span class="string">'src'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而裡面最主要會拋出錯誤的地方在於透過 <code>configureWebpack</code> 設定 <code>webpack</code> 的 <code>resolve</code> 時，這是因為原先用來定義引入 <code>vue</code> 的 <code>vue/dist/vue.esm.js</code> 在 Vue 3.0 的 module 中消失了。</p>
<p>因此我們將其改為 Vue 3.0 對應 ES module 的檔案 <code>vue/dist/vue.esm-bundler.js</code> 引回即可。</p>
<p>修復完畢後執行 <code>npm run serve</code> 應該就能看到頁面長回來了，接下來就可以使用 <code>composition API</code> 的寫法將原本的 <code>lifecycle</code>、<code>methods</code> 或其他 API 改寫完畢！</p>
<p><del>寫文當下還沒有出 Vue 3.0 的 devtool，升級投資有賺有賠申購前請記得先開 branch 改</del></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>人月神話</title>
    <url>/book/the-mythical-man-month/01/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <!-- <img style="object-fit:cover;" alt="vitest-logo" src='/images/vitest-logo.svg' width='200px' height='200px' /> -->
</div>

<h1 id="焦油坑"><a href="#焦油坑" class="headerlink" title="焦油坑"></a>焦油坑</h1><p>史前動物 焦油坑</p>
<p>程式, 軟體系統, 軟體產品, 軟體系統產品 差異與成本</p>
<p>樂趣：</p>
<ul>
<li>趣味與獨特</li>
<li>對他人有用</li>
<li>推理解謎</li>
<li>持續學習</li>
</ul>
<p>苦難：</p>
<ul>
<li>須完美，因為一有缺失看得出來</li>
<li>別人設定目標 提供資訊</li>
<li>仰賴他人</li>
<li>臭蟲</li>
<li>產品上市時已過時</li>
</ul>
<p>如果解決這焦油坑便是這本書要處理的事情</p>
<h1 id="人月神話"><a href="#人月神話" class="headerlink" title="人月神話"></a>人月神話</h1><p>紐奧良 Antoine 餐廳</p>
<blockquote>
<p>好菜都得多花時間準備</p>
</blockquote>
<p>軟體專案不順 =&gt; 多半是缺乏良好時程規劃</p>
<p>原因：</p>
<ul>
<li>預估時間技術不成熟</li>
<li>誤把工作量當成專案進度 =&gt; 反應以為人力跟工時是可以互換的</li>
<li>RD 無法篤定時程 =&gt; PM 無法堅持 Antoine 餐廳美學</li>
<li>軟體工程時程缺法監控 =&gt; 卻用其他工程領域被證明或可行的技術拿來套用並改革</li>
<li>以為延遲增加人手就可以更快</li>
</ul>
<p><strong>本書不講工程時程監控這件事情！</strong></p>
]]></content>
  </entry>
</search>
