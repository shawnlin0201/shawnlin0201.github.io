<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript 深入淺出 Arrow Function 箭頭函式</title>
    <url>/JavaScript/JavaScript-Arrow-function/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>箭頭函式算是 ECMAScript 中常見的用法之一，但他與一般的函式差別在哪？就讓我們一起來瞭解箭頭函式到底是什麼吧。</p>
<a id="more"></a>

<h1 id="基礎用法"><a href="#基礎用法" class="headerlink" title="基礎用法"></a>基礎用法</h1><p>一般我們在使用函式我們可能會這麼做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般函式宣告（function declaration）的用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或定義在變數當中的函式運算式（function expression）</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而箭頭函式最主要是將函式運算式或函式陳述式轉化成這種撰寫方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="進階用法"><a href="#進階用法" class="headerlink" title="進階用法"></a>進階用法</h1><h2 id="省略"><a href="#省略" class="headerlink" title="省略"></a>省略</h2><p>當函式語句內部只有運算式的時候還可以省略大括號與宣告返回值的部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br></pre></td></tr></table></figure>

<p>如果只有一個參數還可以省略中間小括號的部分（如果沒有或有兩個以上的參數就需要小括號）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greaterThanOne = <span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br></pre></td></tr></table></figure>

<h2 id="預設參數（Default-parameters）與剩餘函數（Rest-parameter）"><a href="#預設參數（Default-parameters）與剩餘函數（Rest-parameter）" class="headerlink" title="預設參數（Default parameters）與剩餘函數（Rest parameter）"></a>預設參數（Default parameters）與剩餘函數（Rest parameter）</h2><p>在箭頭函式中一樣可以使用預設函數與剩餘函數：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x = <span class="number">0</span>, ...y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (y.length === <span class="number">0</span> ) &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line">  <span class="keyword">let</span> sumOtherNum = y.reduce(<span class="function">(<span class="params">total, value</span>) =&gt;</span> total + value)</span><br><span class="line">  <span class="keyword">return</span> x + sumOtherNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum()          <span class="comment">// 0</span></span><br><span class="line">sum(<span class="number">1</span>)         <span class="comment">// 1</span></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><p>我們都知道 JavaScript 是採用靜態作用域，而箭頭函式沒有 this 屬性，因此在箭頭函式中的 this 會指向的是父層定義箭頭函式當下的 this：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ShawnL = &#123;</span><br><span class="line">  name: <span class="string">'ShawnL'</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hi, My name is '</span> + <span class="keyword">this</span>.name +<span class="string">'.'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShawnL.sayHi() <span class="comment">// Hi, My name is ShawnL .</span></span><br></pre></td></tr></table></figure>

<p>若使用箭頭函式的情況：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'anonymous'</span></span><br><span class="line"><span class="keyword">const</span> ShawnL = &#123;</span><br><span class="line">  name: <span class="string">'ShawnL'</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Hi, My name is '</span> + <span class="keyword">this</span>.name +<span class="string">'.'</span> <span class="comment">// this 指向定義 ShawnL 的 this （也就是 window）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShawnL.sayHi() <span class="comment">// "Hi, My name is anonymous."  .</span></span><br></pre></td></tr></table></figure>

<p>箭頭函式對於 this 的影響不小，像是在 Vue.js 框架中的 computed 若使用箭頭函式就會因為 this 指向問題而產生錯誤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      number: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    addNumber: <span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">this</span>.number + x <span class="comment">// this 指向 window 了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而 React.js 則是利用了這個特性，在撰寫 class component 簡化寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CardWrapper</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      cardTitle: <span class="string">'Title'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="comment">// 用原先函式宣告寫法會受到呼叫者的指向而有所不同，現在箭頭函式統一指向了這個元件</span></span><br><span class="line">      cardTitle: event.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;<span class="keyword">this</span>.state.cardTitle&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="text" onChange=&#123;this.handleChange&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是箭頭函式的用法，我自己是還蠻常用到的，使用時要注意的就是瀏覽器支援度與 this 指向問題，確認沒問題後箭頭函式將會大幅提升程式碼可閱讀性與開發速度。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://wiki.developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">MDN - Arrow functions</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 陣列處理迴圈的方法（forEach、map、filter、reduce）</title>
    <url>/JavaScript/JavaScript-Array-methods/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>今天要來介紹四個陣列中處理迴圈的常見方法，還在用 <code>for</code> 迴圈打天下嗎？來看看這些 cool 東西吧 (?)</p>
<a id="more"></a>

<p>下面要介紹的方法目的都在於可以使程式碼更加的簡潔易懂：</p>
<h1 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h1><p><code>forEach</code> 方法簡單說就是將陣列整個遍歷一次，並且不回傳值。</p>
<p>例如原本 <code>for</code> 迴圈中我們要把 <code>arr</code> 陣列中的每個值加到 <code>acc</code> 當中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> acc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  acc += arr[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(acc) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>用 <code>forEach</code> 的寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> acc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  acc += val</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(acc) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>如果你想額外拿到遍歷時陣列的索引值或原先的陣列可以透過第二、第三參數拿到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> acc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val)  <span class="comment">// 分三次印出 1, 5, 9</span></span><br><span class="line">  <span class="built_in">console</span>.log(idx)  <span class="comment">// 分三次印出 0, 1, 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(array) <span class="comment">// 分三次印出 [1, 5, 9], [1, 5, 9], [1, 5, 9]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h1><p><code>map</code> 方法與 <code>forEach</code> 類似，但他可以回傳一個運算完的陣列：</p>
<p>例如原先我們要取得另一個運算完的陣列可能會這麼做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> newNumber = arr[i] * <span class="number">2</span></span><br><span class="line">  newArr.push(newNumber)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<p>但用了 <code>map</code> 後：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">val, idx, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val * <span class="number">2</span> <span class="comment">//  建立一個新的陣列，並將 1, 2, 3 分別乘 2 後依序傳入到陣列當中</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<h1 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h1><p><code>filter</code> 作用最主要是用來篩檢內容，例如原先我們會這麼處理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]) <span class="comment">// 1, 2, 3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (arr[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    newArr.push(arr[i]) <span class="comment">// 只有 2, 3 符合</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<p>用了 <code>filter</code> 後：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val &gt; <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<h1 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h1><p>最後一個則是累加器 <code>reduce</code>，他最主要的作用就是依序取出與整理。</p>
<p>原先我們需要整理陣列可能會這樣寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> sumArrAddTwo = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  sumArrAddTwo += (arr[i] + <span class="number">2</span>) <span class="comment">// 依序取出 1, 5, 9 並加上 2，也就是將 3, 7, 11 累加給 sumArrAddTwo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumArrAddTwo) <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>

<p>用了 <code>reduce</code> 後：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> sumArrAddTwo = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total, val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> total + val + <span class="number">10</span></span><br><span class="line">&#125;, <span class="number">0</span>) <span class="comment">// 這裡的 0 代表累加器初始值為 0，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分解開來就像是</span></span><br><span class="line"><span class="comment">第一次：0 + 1 + 10 = 11</span></span><br><span class="line"><span class="comment">第二次：11 + 5 + 10 = 26</span></span><br><span class="line"><span class="comment">第三次：26 + 9 + 10 = 45</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumArrAddTwo) <span class="comment">// 45</span></span><br></pre></td></tr></table></figure>

<p>但要注意的是，若你沒有給予 <code>reduce</code> 第二個參數的話，他預設會將第一個陣列值當作初始值，因此會變成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> sumArrAddTwo = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total, val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> total + val + <span class="number">10</span></span><br><span class="line">&#125;) <span class="comment">// 這裡沒有給予初始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分解開來就像是</span></span><br><span class="line"><span class="comment">第一次：1 + 5 + 10 = 16      // 陣列中的第一個值被當作初始值來看待</span></span><br><span class="line"><span class="comment">第二次：11 + 9 + 10 = 26</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumArrAddTwo) <span class="comment">// 36</span></span><br></pre></td></tr></table></figure>

<p>但這種累加我自己是偏好使用 forEach 另外存一個變數會相對直覺一點。</p>
<p>不過若是要用來整理資料結構跟扁平化的時候 <code>reduce</code> 的優勢會比較明顯：</p>
<h2 id="reduce-整理資料結構"><a href="#reduce-整理資料結構" class="headerlink" title="reduce 整理資料結構"></a>reduce 整理資料結構</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    firstname: <span class="string">'Audy'</span>,</span><br><span class="line">    lastname: <span class="string">'Lin'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    firstname: <span class="string">'Berry'</span>,</span><br><span class="line">    lastname: <span class="string">'Chen'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">3</span>,</span><br><span class="line">    firstname: <span class="string">'Cath'</span>,</span><br><span class="line">    lastname: <span class="string">'Chang'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> member = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total, val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> total.concat(&#123;</span><br><span class="line">    memberID: val.id,</span><br><span class="line">    fullname: val.firstname + <span class="string">' '</span> + val.lastname</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(member)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    "memberID": 1,</span></span><br><span class="line"><span class="comment">    "fullname": "Audy Lin"</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    "memberID": 2,</span></span><br><span class="line"><span class="comment">    "fullname": "Berry Chen"</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    "memberID": 3,</span></span><br><span class="line"><span class="comment">    "fullname": "Cath Chang"</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><del>雖然如果是 API 打下來的資料通常我都會叫後端直接整理好</del></p>
<p>但自己有需要的時候還是可以用這種方式快速整理好資料喔！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">MDN - Array.prototype.reduce</a></li>
<li><a href="https://www.ucamc.com/e-learning/javascript/261-javascript-reduce%E3%80%81foreach%E3%80%81filter%E3%80%81map" target="_blank" rel="noopener">Javascript迴圈函式Reduce、ForEach、Filter、Map 應用範例</a></li>
<li><a href="https://fred-zone.blogspot.com/2017/01/javascript-mapreduce.html" target="_blank" rel="noopener">上手使用 JavaScript 的 Map、Reduce 吧！</a></li>
<li><a href="https://wcc723.github.io/javascript/2017/06/29/es6-native-array/" target="_blank" rel="noopener">JavaScript 陣列處理方法 [filter(), find(), forEach(), map(), every(), some(), reduce()]</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Automatic Semicolon Insertion 自動插入分號機制</title>
    <url>/JavaScript/JavaScript-Automatic-Semicolon-Insertion/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>在 JavaScript 當中 <code>;</code> 被用來作為分隔表達式語句（statement）符號；然而，你知道在 2000 年時的 ECMAScript（ES3）中，有自動插入分號機制（Automatic Semicolon Insertion）會幫你自動插入分號嗎？</p>
<a id="more"></a>

<h1 id="結尾是否一定得分號？"><a href="#結尾是否一定得分號？" class="headerlink" title="結尾是否一定得分號？"></a>結尾是否一定得分號？</h1><p>如序文所述，在 JavaScript 當中主要是用來分隔表達式語句（statement）符號，而在 ES3 中新增的自動插入分號機制（Automatic Semicolon Insertion）則是基於當你一段程式碼後按下 <code>Enter</code> （也就是實際上寫入一個換行符號（<code>\n</code>））時，JavaScript parser 就有一定規則的幫你補分號進去程式。</p>
<p>瀏覽器基於 ECMAS-262 spec Automatic Semicolon Insertion 規則而實作的結果就是，有些地方就算你不寫他也會幫你補、有些則是你不寫他也不會幫你補；但另一群例外則是你一定得補分號跟不能補分號的情況。</p>
<p>所以情境大致上可分為：</p>
<ul>
<li>不會 ASI 的情境</li>
<li>會 ASI 的情境</li>
<li>一定要補分號的情境</li>
<li>一定不能補分號的情境</li>
<li>不需要補分號的情境</li>
</ul>
<h1 id="不會-ASI-的情境"><a href="#不會-ASI-的情境" class="headerlink" title="不會 ASI 的情境"></a>不會 ASI 的情境</h1><ul>
<li>該行沒有結束程式碼區塊時</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> frult = [</span><br><span class="line">  <span class="string">'apple'</span>,</span><br><span class="line">  <span class="string">'banana'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lyrics = <span class="string">`    </span></span><br><span class="line"><span class="string">  你看這碗又大又圓</span></span><br><span class="line"><span class="string">  你看這麵又長又寬</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<ul>
<li>下一行開頭是運算子的時候</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">+<span class="number">1</span></span><br><span class="line">++</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>條件陳述句沒有用花括號 <code>{}</code> 包起來時。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(a)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'false'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用空白分隔程式碼時</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'false'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="一定要補分號的情境"><a href="#一定要補分號的情境" class="headerlink" title="一定要補分號的情境"></a>一定要補分號的情境</h1><ul>
<li>表達式與表達式之間</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="keyword">var</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a); <span class="keyword">if</span> (b)</span><br></pre></td></tr></table></figure>

<ul>
<li>下行開頭為 <code>[</code> 、 <code>(</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'log'</span>) <span class="comment">// SyntaxError: console.log(...) is not a function</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'IIFE'</span>)</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>

<p>防禦手段可以透過前置分號來幫忙：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'IIFE'</span>)</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">;[<span class="string">'array'</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="一定不能多補分號的情境"><a href="#一定不能多補分號的情境" class="headerlink" title="一定不能多補分號的情境"></a>一定不能多補分號的情境</h1><ul>
<li><p>for 迴圈小括號中的兩個分號是固定值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;)&#123; &#125; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++;) &#123;&#125; <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>條件、迴圈等陳述式中小括號的後方</p>
</li>
</ul>
<h1 id="不需要補分號的情境"><a href="#不需要補分號的情境" class="headerlink" title="不需要補分號的情境"></a>不需要補分號的情境</h1><ul>
<li>陳述式花括號的後方</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> () &#123;&#125; <span class="comment">// 不需要補</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (); &#123;&#125; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="keyword">for</span> (;;); &#123;&#125; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>


<h1 id="懂了-ASI-之後"><a href="#懂了-ASI-之後" class="headerlink" title="懂了 ASI 之後"></a>懂了 ASI 之後</h1><p>在知道 Automatic Semicolon Insertion 後應該要瞭解到結尾分號是一種<strong>選項</strong>，因此團隊風格可以決定要不要採用；另外一定要的情況是採用了不支援沒分號的壓縮工具，但現在大部分的工具應該都有支援沒分號的寫法。更重要的是絕對不會是為了減少程式碼的大小而不寫，因為最後壓縮工具都會幫你補上去。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Async &amp; Await</title>
    <url>/JavaScript/JavaScript-Async-Await/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>上次看完 Promise 如何快速解決 callback hell 之後這次要來介紹 ES7 的兄弟檔 <code>Async</code> &amp; <code>Await</code>。</p>
<a id="more"></a>

<h1 id="Async-amp-Await"><a href="#Async-amp-Await" class="headerlink" title="Async &amp; Await"></a><code>Async</code> &amp; <code>Await</code></h1><p>在 ES 7 橫空出世的 <code>Async</code> 與 <code>Await</code>，最主要的功能就是協助 Promise 的操作，還記得之前基本的 Promise 用法嗎？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> res(<span class="string">'funcA done!'</span>), (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> res(<span class="string">'funcB done!'</span>), (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcC</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> res(<span class="string">'funcC done!'</span>), (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA()</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">return</span> funcB()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">return</span> funcC()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>而 <code>async</code> 功用就是包裹一個函式，使其最後會返回 Promise 物件，而 <code>await</code> 就是用來等待每個非同步的完成，才往下執行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> res(<span class="string">'funcA done!'</span>), (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> res(<span class="string">'funcB done!'</span>), (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcC</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> res(<span class="string">'funcC done!'</span>), (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> funcA()</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">await</span> funcB()</span><br><span class="line">  <span class="keyword">let</span> c = <span class="keyword">await</span> funcC()</span><br><span class="line">  <span class="built_in">console</span>.log( a + b + c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result() <span class="comment">// 'funcA done!funcB done!funcC done!'</span></span><br></pre></td></tr></table></figure>

<p>每當執行到 <code>await</code>，它都會等待 <code>Promise</code> 回應，因此若要寫出非同步合併的效果就會更加方便了！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Execution Context Stack（Call Stack）呼叫堆疊</title>
    <url>/JavaScript/JavaScript-Call-Stack/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>
延續上篇執行環境（Execution Context）的內容，接下來要介紹整個 JavaScript 在執行期間（runtime）的運作，也就是 JavaScript 在瀏覽器中是怎麼被執行的。

<a id="more"></a>

<p>在瀏覽器當中執行 JavaScript 最主要關鍵在於瞭解上次提到的執行環境，以及接下來提到<strong>執行環境的堆疊（Execution Context Stack 或稱 Call Stack）</strong>與<strong>任務循環（Event Loop）機制</strong>。</p>
<h1 id="Execution-Context-Stack"><a href="#Execution-Context-Stack" class="headerlink" title="Execution Context Stack"></a>Execution Context Stack</h1><p>每呼叫一次函式就會創立一個執行環境（Execution Context），並且在執行完畢前又有新的執行環境時就會堆疊起來，而這種執行環境中的堆疊又稱呼叫堆疊（Call Stack）顧名思義，其資料結構是一個堆疊（Stack），而這種資料結構處理方式就是後入先出（LIFO，Last in First out）：</p>
<p>例如當我們執行下面程式碼時：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  func2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'func1'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'func2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'func start'</span>)</span><br><span class="line">func1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'func end'</span>)</span><br></pre></td></tr></table></figure>

<p>在呼叫堆疊中看起來就像這樣：</p>
<p><img src="/images/JavaScript/Execution-Context-Stack.png" alt="Execution-Context-Stack.png"></p>
<p>一進入 JavaScript 前會執行一個主程式函式來包裹。</p>
<p>接著執行 <code>func1()</code> 函式，進入 <code>func1()</code> 函式後執行 <code>func2()</code> 函式。</p>
<p>在執行 <code>console.log(&#39;func2&#39;)</code> 完後，<code>func2()</code> 函式會從 stack 中移除。</p>
<p>執行 <code>console.log(&#39;func1&#39;)</code>，<code>func1()</code> 函式會從 stack 中移除。</p>
<p>最後整段程式碼都執行完畢時，便把 <code>main</code> 也拋出 stack。</p>
<p>這就是 Execution Context Stack（Call Stack）呼叫堆疊的運作方式，也就是為何大家會說 JavaScript 是 <strong>單執行緒（single thread）</strong> 的原因。</p>
<p>但以上的例子都只有同步（synchronous）的情況，如果遇到像是 setTimeout() 等 Web APIs 與需要藉由 Ajax 取得資料的非同步（Asynchronous）情況時，這時候就輪到 Event Loop 與 Job Queue 上場了。</p>
<h1 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h1><ul>
<li><a href="https://darjun.github.io/2018/11/23/javascript-callstack-eventloop/" target="_blank" rel="noopener">深入理解Javascript之CallStack&amp;EventLoop</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Call Stack</tag>
        <tag>Synchronous</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Event Loop、Job Queue</title>
    <url>/JavaScript/JavaScript-Event-Loop-and-Job-Queue/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>要知道 JavaScript 執行期（runtime）究竟在做什麼事情？絕對不能不知呼叫堆疊（Call Stack）、事件循環（Event Loop）及任務隊列（Job Queue）。</p>
<p>前陣子介紹了 JavaScript 執行期間如果只有同步（Synchronous）的程式碼時是非常容易理解的，因為我們只需要理解呼叫堆疊（Call stack）中的執行環境（Execution Context），就能夠透過變數物件（Variable）、執行物件（Activation Object）、作用域鍊（Scope Chain）來理解作用域（Scope）與以及閉包（Closure）等等概念。</p>
<p>那麼非同步要以什麼方式來理解呢？那就是靠任務循環（Event Loop）以及任務序列（Job Queue）的機制啦！</p>
<a id="more"></a>

<h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><p>任務循環（Event Loop）嚴格說起來並不是 JavaScript 本身的機制，而是 JavaScript 運行環境（runtime）裡的機制（也就是瀏覽器）。</p>
<p>在瀏覽器當中的主執行緒（Main Thread）會透過 JavaScript 引擎去即時編譯 JavaScript 程式碼，而辨識到<strong>非同步的程式碼區塊</strong>時，就會指派給各個監視器（watcher）。</p>
<p>接著主執行緒會在不斷的輪詢（polling）各個監視器（watcher）來確認是否產生事件，例如 <code>setTimeout</code> 會經由瀏覽器的 <code>Timer</code> 檢查是否到特定的時間，如果達到特定的時間就會將其事件移到任務隊列（Job Queue）上。</p>
<p>而在輪詢的過程中，也會去查看 JavaScript 中的呼叫堆疊（Call Stack）是否為空的，如果是的話就將任務隊列（task queue）裡的任務放入呼叫堆疊當中。</p>
<p>也因此我們可以說任務循環算是實作 JavaScript 非同步機制的一種作法，如果沒有任務循環那麼 JavaScript 就無法做到非同步這件事情。</p>
<p>那麼，我們現在瞭解任務循環了，但什麼是任務隊列？</p>
<h1 id="Job-Queue"><a href="#Job-Queue" class="headerlink" title="Job Queue"></a>Job Queue</h1><p>任務隊列（Job Queue）又稱 Event Queue 或 Callback Queue，簡單來說就是各種非同步事件用來排隊的地方；也就意味著，在非同步的概念當中並不是誰比較早寫誰先被執行，而是透過上述所說的各個監視器產生事件後才排入任務隊列的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'first'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'second'</span>)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'third'</span>)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<p>像上面的順序就是依序將第一個、第二個與第三個 <code>setTimeout</code> 分別交由 <code>Timer</code> 去確認時間，而 <code>Timer</code> 首先確認到第二個與第三個時間到，這時候分別把第二個與第三個排入任務隊列，最後才是第一個。</p>
<p>因此結果會顯示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'second'</span> <span class="comment">// 與 'third' 幾乎同時顯示</span></span><br><span class="line"><span class="string">'third'</span>  <span class="comment">// 與 'second' 幾乎同時顯示，但稍微晚一點（如果不清楚為什麼的話推薦閱讀執行環境 Execution Context 一文</span></span><br><span class="line"></span><br><span class="line"><span class="string">'first'</span> <span class="comment">// 與前兩者相較晚一些才顯示</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>而延伸其概念我們可以說 <code>setTimeout</code> 只能做到確認至少幾秒後才會被執行，我們並沒有辦法精確的定義他們什麼時候被執行。</p>
</blockquote>
<p>那麼有什麼事件是會被放入任務隊列的：</p>
<ul>
<li><code>XMLHttpRequest</code>：預設採用非同步方式取得資料，它另外也提供同步的方式給需要的開發者。</li>
<li><code>fetch</code>：使用非同步的做法取得資料。</li>
<li><code>setTimeout</code>、<code>setInterval</code>：由於 JavaScript 本身沒有計時器，因此執行後會交由瀏覽器的計時器倒數，時間到了才回傳至任務序列（Task Queue）等待任務循環（Event Loop）機制將其傳入主線程。<br>以上等等</li>
</ul>
<p>然而非同步程式區塊如果是 <code>promise</code> 的話則又有另一種隊列，我們稱其為 <code>Mircotask</code>…</p>
<p>詳見 <code>Mircotask</code> 一文</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Closure 閉包</title>
    <url>/JavaScript/JavaScript-Closure/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>常常聽到閉包卻不知道是指什麼？看看文章又覺得是在講作用域（Scope）？就算知道他是什麼也不知道用他能做什麼？</p>
<p>如果你有以上的問題，那就讓我們一起來看看閉包吧！</p>
<a id="more"></a>

<h1 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h1><p>閉包（Closure）其實算是 JavaScript 的種種特性所集合起來的概念，裡面牽扯到了作用域鏈（Scope Chain）、高階函式（Higher-order function）與自由變數（free variable）等等概念。</p>
<blockquote>
<p>推薦先閱讀 Scope 與 Higher-order function 一文</p>
</blockquote>
<h1 id="Free-Variable"><a href="#Free-Variable" class="headerlink" title="Free Variable"></a>Free Variable</h1><p>自由變數（free variable）的意思則是指使用不在自己的作用域中的變數：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 這裡的 x 就是自由變數</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA()</span><br></pre></td></tr></table></figure>

<p>而要瞭解自由變數的原因在於通常談論閉包的特性時，通常會指有用到自由變數的情況：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">num = <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">    result = result + num</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = acc()</span><br><span class="line"></span><br><span class="line">counter.add(<span class="number">3</span>) <span class="comment">// 3</span></span><br><span class="line">counter.add(<span class="number">5</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>在上面程式碼中，使用 <code>counter</code> 覆值 <code>acc</code> 會是一個重點，因為函式的執行環境（Execution Context）在函式執行完畢時，就會被移出呼叫堆疊（Call Stack），也因此照理來說裡面的變數物件（Variable Object）及作用域鏈（Scope Chain）會消失。</p>
<p>但因為使用了 <code>counter</code> 覆值 <code>acc</code>，因此執行完畢時，會將此參照記錄到 <code>counter</code> 當中。</p>
<p>最後我們就能藉由操作 <code>counter</code> 來達到看似控制 <code>acc</code> 內部的變數的效果。</p>
<h1 id="why-we-need-closure"><a href="#why-we-need-closure" class="headerlink" title="why we need closure?"></a>why we need closure?</h1><p>聰明的讀者一定想到了一點，既然執行函式時都會創立一個執行環境，那麼用不同變數去承接這些環境，不就能達到類似獨立的效果嗎？</p>
<p>沒錯！我們再來看一次剛剛的程式碼，只是我們用不同的變數去接取：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">num = <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">    result = result + num</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter1 = acc()</span><br><span class="line"><span class="keyword">let</span> counter2 = acc()</span><br><span class="line"></span><br><span class="line">counter1.add(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">counter1.add(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">counter2.add(<span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line">counter2.add(<span class="number">20</span>) <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">counter1.add(<span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">counter2.add(<span class="number">30</span>) <span class="comment">// 60</span></span><br></pre></td></tr></table></figure>

<p>我們可以看到 <code>counter1</code>、<code>counter2</code> 各自擁有其執行環境，</p>
<p>除此之外在函式執行完畢時，原先執行環境移除後，該環境中的變數物件應該會消失，但由於作用域鏈的綁定，使其被重新<br>變相延長了他的生命週期，也就是說只要 <code>counter1</code>、<code>counter2</code> 再沒有被重新賦值（reassign）的情況下，<code>acc</code> 中的 <code>result</code> 就會一直存在裡面。</p>
<p>現在我們大致上已經瞭解閉包是什麼以及可以如何善用它了，最後我們再回頭來較準確地重新看一次閉包的解釋：</p>
<p>根據參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">MDN</a> 對於閉包的解釋：</p>
<blockquote>
<p>閉包（Closure）是函式以及該函式被宣告時所在的作用域環境（lexical environment）的組合。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Execution Content 執行環境</title>
    <url>/JavaScript/JavaScript-Execution-Context/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>常聽見有人說作用域（Scope）但是不知道它是什麼，又或者查了作用域瞭解了之後卻不知道它是怎麼形成的？</p>
<p>那麼你可能需要知道一下什麼叫做執行環境（Execution Context）</p>
<a id="more"></a>

<h1 id="Execution-Context"><a href="#Execution-Context" class="headerlink" title="Execution Context"></a>Execution Context</h1><p>執行環境（execution context）是指 JavaScript 引擎模組化直譯程式碼時的區塊環境。簡單來說，就像是在整個 JavaScript 執行時，引擎將程式碼拆解成許多區塊，將這些區塊一塊一塊疊起來，運算完結果就移除當前的區塊，然後繼續運算下一部分的區塊。</p>
<p>這些區塊內存放著變數物件（Variable Object）、範圍鍊（Scope Chain）等等內容，使 JavaScript 引擎（V8）可以更方便的管理。</p>
<p>不過我們寫 JavaScript 程式碼時，從來就沒有主動宣告過執行環境這件事情阿。那麼到底什麼時會創建執行環境呢？</p>
<p>答案就是呼叫一個函式的時候。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  funcB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA()</span><br></pre></td></tr></table></figure>

<p>當我們執行了上面的程式時，整個執行環境的堆疊 stack 看起來就像是這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[main, funcA, funcB]</span><br></pre></td></tr></table></figure>

<p>接著計算完 <code>funcB</code> 後拋出 <code>Hello</code> 後就變成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[main, funcA]</span><br></pre></td></tr></table></figure>

<p>然後 <code>funcA</code> 執行完後就剩下主程式本身：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[main]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果想更加深入的瞭解上面整個運作請見執行環境堆疊一文。</p>
</blockquote>
<h1 id="Execution-Context-Types"><a href="#Execution-Context-Types" class="headerlink" title="Execution Context Types"></a>Execution Context Types</h1><p>現在我們大略知道執行環境是由一個堆疊負責運作管理的，而執行環境總共可分為：</p>
<ul>
<li>全域執行環境（Global Execution Context）</li>
<li>函式執行環境（Function Execution Context）</li>
</ul>
<h2 id="Global-Execution-Context"><a href="#Global-Execution-Context" class="headerlink" title="Global Execution Context"></a>Global Execution Context</h2><p>全域執行環境指的是一開始執行 JavaScript 程式時所創立的執行環境，裡面包含了：</p>
<ul>
<li>階段（Phase）</li>
<li>全域物件（Global Object）</li>
<li>this</li>
<li>變數物件（Variable Object）</li>
<li>範圍鏈（Scope Chain）</li>
</ul>
<p>在瀏覽器中，<code>this</code> 所指向的便是瀏覽器物件 <code>window</code>，<br>在 Node.js 中，<code>this</code> 則是指向 <code>global</code>。</p>
<p>以程式碼為例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>整段程式碼運行完畢時，在全域執行環境可以看作是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalExecutionContext = &#123;</span><br><span class="line">  Phase: <span class="string">'Execution'</span>,    <span class="comment">// 運行階段</span></span><br><span class="line">  <span class="built_in">window</span>: GlobalObject,  <span class="comment">// 在瀏覽器中全域物件便是指 Web API</span></span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>,          <span class="comment">// 指向 window</span></span><br><span class="line">  variableObject: &#123;      <span class="comment">// 變數物件（Variable）</span></span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  scopeChain: variableObject       <span class="comment">// 因為已經是最外層</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中變數物件（Variable）就是在形容 a 與 b 。</p>
<h2 id="Function-Execution-Context"><a href="#Function-Execution-Context" class="headerlink" title="Function Execution Context"></a>Function Execution Context</h2><p>函式執行環境指的是執行函式時所創立執行環境，裡面包含了：</p>
<ul>
<li>階段（Phase）</li>
<li>this</li>
<li>執行物件（Activation Object，其實也就只是多了一些東西的變數物件）</li>
<li>範圍鏈（Scope Chain） </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>整段程式碼運行完畢時，在函式執行環境可以看作是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addExecutionContext = &#123;</span><br><span class="line">  Phase: <span class="string">'Execution'</span>,    <span class="comment">// 運行階段</span></span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>,          <span class="comment">// 指向呼叫的地方 =&gt; window</span></span><br><span class="line">  activationObject: &#123;    <span class="comment">// 執行物件</span></span><br><span class="line">    <span class="built_in">arguments</span>: &#123; <span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: (activation object + [[Scope]])     <span class="comment">// 簡單來說該值就是視覺上宣告程式時的外層範圍加上自己的執行物件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中執行物件（Variable）就是形容 <code>arguments</code> 、 <code>a</code> 與 <code>b</code>， 所以在函式執行環境中變數物件與執行物件的概念其實是差不多的，但由於全域執行環境沒有 <code>arguments</code>，所以才又多了個執行物件的概念。</p>
<blockquote>
<p>其中個別的議題涉及廣泛，我將依底下分類各開一篇文章再深度解釋：</p>
<ul>
<li>Variable Object &amp; Activation Object</li>
<li>this</li>
<li>Scope Chain</li>
</ul>
</blockquote>
<p>而在瞭解執行環境的種類後，接著要來瞭解執行環境是怎麼運作的：</p>
<h1 id="Execution-Context-Phase"><a href="#Execution-Context-Phase" class="headerlink" title="Execution Context Phase"></a>Execution Context Phase</h1><p>在執行環境中總共可分為兩個階段：</p>
<ul>
<li>創造階段（creation phase）</li>
<li>執行階段（execution phase）</li>
</ul>
<h2 id="Creation-Phase"><a href="#Creation-Phase" class="headerlink" title="Creation Phase"></a>Creation Phase</h2><p>在全域執行環境的創造階段中會：</p>
<ul>
<li>建立全域物件（Global Object）</li>
<li>建立變數物件（Variable Object）</li>
<li>建立 <code>this</code>，並將它指向全域物件（在瀏覽器中是 <code>window</code>，在 Node.js 則是 <code>global</code>）</li>
<li>建立範圍鏈，並設為 null。（因為他自己就是最頂層）</li>
</ul>
<p>在函式執行環境的創造階段中會：</p>
<ul>
<li>建立執行物件（Activation Object）</li>
<li>建立 <code>this</code>，並把它指向呼叫此函式的 caller。</li>
<li>建立範圍鏈（Scope chain），並把它指向此函式的外層（程式編寫時視覺上的）。</li>
</ul>
<h2 id="Excuting-Phase"><a href="#Excuting-Phase" class="headerlink" title="Excuting Phase"></a>Excuting Phase</h2><p>當創造階段結束時，執行環境就會將裡面的階段（Phase）從 <code>Creation</code> 更改為 <code>Execution</code> 來表示進入到執行階段。</p>
<p>而執行階段最主要就是一行一行（line by line）的執行該執行環境的程式碼，如果有遇到宣告就對宣告進行處理等等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在所有程式碼執行前，首先執行環境會先進入創造階段，此時會將所有變數初始化一個 <code>undefined</code> 的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  <span class="built_in">window</span>: globleObject,</span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>,</span><br><span class="line">  variableObject : &#123;</span><br><span class="line">    a: <span class="literal">undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以等到運行階段時，第一個 <code>console.log</code> 輸出的值會是 <code>undefined</code>。</p>
<p>接著一行一行的看到第二行程式碼，我們這時才將 <code>1</code> 賦值給變數 <code>a</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Execution'</span>,</span><br><span class="line">  <span class="built_in">window</span>: globleObject,</span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>,</span><br><span class="line">  variableObject : &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這時候第三行 <code>console.log</code> 在當下的執行環境找到變數 <code>a</code> 現在的值為 <code>1</code>，這時才真正的將 <code>1</code> 呈現出來。</p>
<p>而所謂的提升（Hoisting）、<code>let</code> 的 TDZ 等等概念也是因為這樣而來的。</p>
<p>以上大概是執行環境（Execution Context）的介紹，其中還有許多概念我將另闢新文來做更深入的介紹。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts" target="_blank" rel="noopener">ECMA 262 8.3Execution Contexts</a></li>
<li><a href="http://notepad.yehyeh.net/Content/WebDesign/Javascript/ECMA/Core/JavaScriptCore.php#section8" target="_blank" rel="noopener">ECMA-262 Javascript核心 譯文</a></li>
<li><a href="https://blog.techbridge.cc/2018/12/08/javascript-closure/#scope" target="_blank" rel="noopener">所有的函式都是閉包：談 JS 中的作用域與 Closure</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10203387" target="_blank" rel="noopener">你不可不知的 JavaScript 二三事#Day5：湯姆克魯斯與唐家霸王槍——變數的作用域(Scope) (1)</a></li>
<li><a href="https://dev.to/gemhar/execution-context-the-secret-life-of-functions-1bl1" target="_blank" rel="noopener">Execution Context &amp; the Secret Life of Functions</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Error &amp; Exception-Handling 錯誤與例外處理</title>
    <url>/JavaScript/JavaScript-Exception-Handling/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>在程式開發中不免會遇到一些錯誤以及例外的狀況，而在 JavaScript 中又是要如何處理錯誤與例外呢？</p>
<a id="more"></a>

<h1 id="錯誤與例外處理"><a href="#錯誤與例外處理" class="headerlink" title="錯誤與例外處理"></a>錯誤與例外處理</h1><p>不少的文章其實都指出錯誤（Error）處理與例外（Exception）處理其實雖然都是 <code>Exception Handling</code>，但它們的本意上其實不大相同。</p>
<p>第一類的錯誤主要發生的是在程式碼方面的錯誤，比如拼寫錯誤（typo）、語法錯誤（Syntax Error）等等，這一類的錯誤應該是在開發階段中我們可以透過程式編輯器的檢查，甚至是使用 <code>console.log</code>、<code>debugger</code> 之類的語法，透過瀏覽器提供的開發者工具列（如 Chrome 的 Chrome DevTools）來尋找錯誤並解決。</p>
<p>第二類的錯誤主要則是系統上的錯誤，好比前端的例外處理要關心的是使用者在操作瀏覽器過程中的行為異常，例如網路突然斷掉了，使用者無法正常向伺服器端取得資料時，這時處在客戶端的 JavaScript 程式應該要如何應對？</p>
<p>所以在 JavaScript 中撇除掉錯誤中的型別議題，大部分說明例外處理的時候通常會聚焦偏向後者的討論。</p>
<p>而接下來我們將從第一類的錯誤開始延伸至第二類的錯誤：</p>
<h1 id="錯誤-Error"><a href="#錯誤-Error" class="headerlink" title="錯誤 Error"></a>錯誤 Error</h1><p>在 JavaScript 中有一個 <code>Error</code> 物件專門產生錯誤訊息的實體，我們可以透過傳入字串來顯示出錯誤訊息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Hello, Error?'</span>)</span><br><span class="line">error <span class="comment">// Error: Hello, Error?</span></span><br></pre></td></tr></table></figure>

<h2 id="錯誤類型"><a href="#錯誤類型" class="headerlink" title="錯誤類型"></a>錯誤類型</h2><p>而除了 <code>Error</code> 物件之外，在 JavaScript 中還有另外七種錯誤子類型，它們會透過 <code>Error</code> 物件所創建與拋出：</p>
<ul>
<li>EvalError（被遺棄）</li>
<li>InternetError（未標準化）</li>
<li>RangeRrror</li>
<li>ReferenceError</li>
<li>SyntaxError</li>
<li>TypeError</li>
<li>URIError</li>
</ul>
<h3 id="EvalError"><a href="#EvalError" class="headerlink" title="EvalError"></a>EvalError</h3><p><code>EvalError</code> 主要發生在全域函數發生錯誤時會產生，就 MDN 文件看來目前好像已經遺棄這種錯誤訊息。</p>
<h3 id="InternetError"><a href="#InternetError" class="headerlink" title="InternetError"></a>InternetError</h3><p><code>InternetError</code> 主要發生在 JavaScript Engine 在 Runtime 有異常時會警告，而這個錯誤也尚未標準化，畢竟每家的引擎還是會有自己想定義的內容（簡單來講就是你的錯不一定是我的錯，我的錯也不一定你的錯。）</p>
<h3 id="RangeRrror"><a href="#RangeRrror" class="headerlink" title="RangeRrror"></a>RangeRrror</h3><p>範圍錯誤（<code>RangeRrror</code>）主要發生在傳入方法參數超出有效範圍就會發生錯誤，最常出現在 <code>Number</code> 中的 <code>toFixed</code>、<code>toExponential</code> 等等方法中，當然我們也可以在函式中自訂錯誤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPositive</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x === <span class="number">0</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">"Zero is not Positive &amp; Nagative number."</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &gt; <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isPositive(<span class="number">1</span>)  <span class="comment">// true</span></span><br><span class="line">isPositive(<span class="number">-1</span>) <span class="comment">// false</span></span><br><span class="line">isPositive(<span class="number">0</span>)  <span class="comment">// RangeError: Zero is not Positive &amp; Nagative number.</span></span><br></pre></td></tr></table></figure>

<h3 id="ReferenceError"><a href="#ReferenceError" class="headerlink" title="ReferenceError"></a>ReferenceError</h3><p>引用錯誤（<code>ReferenceError</code>）主要發生在試圖存取一個尚未宣告過的變數，最常出現在打錯字、大小寫錯誤而找不到變數的情況：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415926</span></span><br><span class="line"><span class="built_in">console</span>.log(pi) <span class="comment">// ReferenceError: pi is not defined</span></span><br></pre></td></tr></table></figure>

<p>這種錯誤通常在開發階段時，程式編輯器就會透過高亮、深淺來提示是否有輸入錯誤造成無法解析以及宣告變數未使用，此時你就可以檢查是否有引用錯誤的情況。</p>
<h3 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h3><p>語法錯誤（<code>SyntaxError</code>）主要發生在 JavaScript 語法錯誤的情況，同樣的這種錯誤得在開發階段就得排除，否則會造成程式無法執行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI <span class="number">3.1415926</span> <span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello'</span>) <span class="comment">// 被上方錯誤中斷了</span></span><br></pre></td></tr></table></figure>

<h3 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h3><p>型別錯誤（<code>TypeError</code> ）主要發生在資料型別（Data Type）的操作上與 JavaScript Engine 預期不同時就會產生，通常會發生在函式傳參數時，內部行為與引用參數型別有誤所造成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">murmur</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> text.split(<span class="string">''</span>).join(<span class="string">'murmur'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">murmur(<span class="string">'Hello, JavaScript.'</span>) <span class="comment">// "Hmurmuremurmurlmurmurlmurmuromurmur,murmur murmurJmurmuramurmurvmurmuramurmurSmurmurcmurmurrmurmurimurmurpmurmurtmurmur."</span></span><br><span class="line">murmur([ <span class="comment">// TypeError: text.split is not a function</span></span><br><span class="line">  <span class="string">'Hello, HTML.'</span>,</span><br><span class="line">  <span class="string">'Hello, CSS.'</span>,</span><br><span class="line">  <span class="string">'Hello, JavaScript.'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>這是 JavaScript 中最容易出現的錯誤，由於 JavaScript 宣告時並不需要定義型別，並且 JavaScript 還擁有自動強制轉型（Coercion）的議題在，因此這個問題除了工程師要自律的使用函式之外，若真的有需要也可以藉由使用 TypeScript 來強化檢查型別這件事情。</p>
<h3 id="URIError"><a href="#URIError" class="headerlink" title="URIError"></a>URIError</h3><p><code>URIError</code> 主要發生在使用 <code>encodeURI()</code> 或 <code>decodeURI()</code> 傳入不正常的參數所導致：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">decodeURIComponent</span>(<span class="string">'%'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err <span class="keyword">instanceof</span> <span class="built_in">URIError</span>)  <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(err.message)              <span class="comment">// malformed URI sequence</span></span><br><span class="line">  <span class="built_in">console</span>.log(err.name)                 <span class="comment">// URIError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例外處理"><a href="#例外處理" class="headerlink" title="例外處理"></a>例外處理</h1><p>以上那些錯誤盡量都應該是在撰寫程式時就應該要解決的，然而還有一些使用者在操作時才遇到情況我們通常可以使用 <code>try</code>、<code>catch</code>、<code>throw</code>以及 <code>finally</code> 來解決。</p>
<ul>
<li>try：放入主要的程式碼</li>
<li>throw：拋出錯誤訊息</li>
<li>catch：如果有錯誤，則錯誤訊息會被傳到這個區塊，並且執行這個區塊的行為</li>
<li>finally：不論有無錯誤最後這個區塊都會被執行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">guessNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()* <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (random) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Number is Positive!'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'Number is Zero.'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Do something!'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Stopping guess number.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guessNumber()</span><br><span class="line"><span class="comment">/* 情況 1：random 為 1</span></span><br><span class="line"><span class="comment">* Number is Positive!</span></span><br><span class="line"><span class="comment">* Do something!</span></span><br><span class="line"><span class="comment">* Stopping guess number.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情況 2：random 為 0</span></span><br><span class="line"><span class="comment">* Number is Zero.</span></span><br><span class="line"><span class="comment">* Stopping guess number.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>從上面範例中可以看到若當 JavaScript Runtime 執行到 <code>throw</code> 並拋出錯誤時， <code>try</code> 區塊原本執行的內容就會中止，並且接著執行 <code>catch</code> 區塊內的內容；若沒有的話則是繼續執行 <code>try</code> 原先區塊的行為，但無論如何最後 <code>finally</code> 區塊都是會被執行的地方。</p>
<h1 id="客製化錯誤"><a href="#客製化錯誤" class="headerlink" title="客製化錯誤"></a>客製化錯誤</h1><p>如果要客製化錯誤的話我們可以藉由繼承 <code>Error</code> 物件本身的 <code>name</code> 以及 <code>message</code> 來定義錯誤名稱與內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Status:'</span>,</span><br><span class="line">  <span class="keyword">this</span>.message = message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>() <span class="comment">// 繼承 Error 類別</span></span><br><span class="line">CustomError.prototype.constructor = CustomError <span class="comment">// 將建構子從 Error 轉回 CustomEror</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> CustomError(<span class="string">'[A1] Permission is denied.'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.name, err.message) <span class="comment">// Status: [A1] Permission is denied.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AJAX-中的錯誤"><a href="#AJAX-中的錯誤" class="headerlink" title="AJAX 中的錯誤"></a>AJAX 中的錯誤</h1><p>既然最主要是使用者在汲取資料時容易會遇到斷線等等問題而導致操作失敗，所以採用了 Promise 所設計的 AJAX API 本身都有支援 <code>catch</code> 的選項來協助除錯，即便沒有也通常會提供相對應的例外處理 API 來協助開發：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fetch</span></span><br><span class="line">fetch(<span class="string">'url'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(res) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// axios</span></span><br><span class="line">axios.get(<span class="string">'url'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res.data))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery ajax</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  type: <span class="string">"GET"</span>,</span><br><span class="line">  url: <span class="string">"url"</span>,</span><br><span class="line">  success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function">(<span class="params">XMLHttpRequest, textStatus, errorThrown</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.error(textStatus)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="錯誤事件處理器"><a href="#錯誤事件處理器" class="headerlink" title="錯誤事件處理器"></a>錯誤事件處理器</h1><p>瀏覽器有提供一個綁定在全域下的錯誤事件處理器，只要觸發下列條件就會啟動 <code>window.onerror</code>：</p>
<ul>
<li>JavaScript Runtime 的各種 Error。</li>
<li>透過元素屬性的 <code>src</code> 引入資源時發生異常。</li>
</ul>
<p>而針對上面兩種不同的情況 callback function 的傳送參數也有不同：</p>
<p>針對 Runtime Error：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">windon.onerorr = <span class="function"><span class="keyword">function</span> (<span class="params">message, filename, lineNumber, columnNumber, errorObject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>針對 Element source Error：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如載入圖片如果發生異常時我們便可以透過這個 <code>onerror</code> 來執行替換預設圖片的程式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">onerror</span>=<span class="string">"replaceToDefaultImage(this)"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceToDefaultImage</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> defaultImage = <span class="string">'xxx.png'</span></span><br><span class="line">  target.src = defaultImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上便是幾種常見的錯誤類型、例外處理與錯誤事件處理器。</p>
<p>最後，錯誤處理就開發上算是一種行為的脈絡，也並非所有情境都會需要這種脈絡，前端應就整體行為流程去斟酌。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://pjchender.blogspot.com/2017/12/js-error-handling.html" target="_blank" rel="noopener">PJChen - [JS] 談談 JavaScript 中的錯誤處理 Error Handling</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noopener">MDN - Error</a></li>
<li><a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part3/error.html" target="_blank" rel="noopener">Eddy Chang - 錯誤與例外處理</a></li>
<li><a href="https://www.ithome.com.tw/voice/131812" target="_blank" rel="noopener">林信良 - JavaScript錯誤處理</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Garbage Collection 垃圾回收機制</title>
    <url>/JavaScript/JavaScript-Garbage-Collection/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>垃圾回收機制（Garbage Collection）主要是在協助執行於電腦上的應用程式，保留、清除一些儲存於記憶體中一些用不到的資料。</p>
<p>那麼在 JavaScript 中的垃圾回收機制又是如何處理呢？</p>
<a id="more"></a>

<h1 id="瀏覽器中的記憶體存取"><a href="#瀏覽器中的記憶體存取" class="headerlink" title="瀏覽器中的記憶體存取"></a>瀏覽器中的記憶體存取</h1><p>要知道垃圾回收機制前，要先稍微瞭解一下記憶體存取的概念，對於瀏覽器來說，由於各家廠商對於記憶體管理（Memory Management）的實作不同，存取的抽象概念可能也會有所差距，但大致上來說都會擁有 <code>stack</code> 與 <code>heap</code> 的儲存機制：</p>
<p>其中 stack 存放著一些較為簡單的資料，如一些原始數值（如：Number、String 等等），另外還有儲存一些指向 <code>heap</code> 的地址（address）。</p>
<p>而相對的 <code>heap</code> 就是用來儲存一些比較複雜的物件類型（或說非原始類型、複雜類型）。</p>
<p>所以每次操作資料時都會去 <code>stack</code> 設定相關的資料，如果是處理物件類型的資料，那就得在 <code>stack</code> 設定一個找到 <code>heap</code> 的地址，再儲存值到 <code>heap</code> 裡面；如果只是原始數值，就指向到 <code>stack</code> 就完成了。</p>
<blockquote>
<p>想知道瀏覽器實作時遵循的文件可參考 <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-memory-model" target="_blank" rel="noopener">ECMA 262 - 10.0</a></p>
</blockquote>
<h1 id="Memory-leak-記憶體遺失"><a href="#Memory-leak-記憶體遺失" class="headerlink" title="Memory leak 記憶體遺失"></a>Memory leak 記憶體遺失</h1><p>上面介紹到簡略的存取概念後，我們可以知道：</p>
<ul>
<li>每次操作時都會申請分配（allocate） <code>stack</code> 的記憶體。</li>
<li>物件類型不僅會分配到 <code>stack</code>，還會再深入到 <code>heap</code> 當中。</li>
</ul>
<p>所以當我們對於變數重新賦值（reassign）一個物件類型時，意味著我們需要重新分配一個 <code>stack</code> 地址後，再連結到新的一個 <code>heap</code> 當中。</p>
<p>而一個較為經典的記憶體遺失案例就發生在這個過程中當中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">'大家掰掰，這是我們最後一次見面了。'</span>]</span><br><span class="line">a = [<span class="string">'大家好，我其實是另一個陣列'</span>] <span class="comment">// Memory leak</span></span><br></pre></td></tr></table></figure>

<p>僅僅兩行，就能造成一個簡單的記憶體遺失案例，這中間發生什麼事情了？</p>
<p>首先，第一行我們對於 <code>a</code> 賦值，由於是物件類型，我們必須分配到 <code>stack</code> 記憶體後，儲存一個指向 <code>heap</code> 的地址，並在 <code>heap</code> 中存下 <code>[&#39;大家掰掰，這是我們最後一次見面了。&#39;]</code>。</p>
<p>接著第二行，我們對於 <code>a</code> 重新賦值，由於是物件類型，我們必須再次重新分配到 <code>stack</code> 記憶體後，儲存另一個指向 <code>heap</code> 的地址，原本在 <code>heap</code> 中存下 <code>[&#39;大家掰掰，這是我們最後一次見面了。&#39;]</code> 資料，它仍然還在那邊，不過我們再也無法去取得它了。</p>
<blockquote>
<p>想看更多的垃圾（？）可以參考這篇<a href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec" target="_blank" rel="noopener">文章</a></p>
</blockquote>
<h1 id="垃圾回收機制"><a href="#垃圾回收機制" class="headerlink" title="垃圾回收機制"></a>垃圾回收機制</h1><p>身為人類，我們都知道哪些東西要拿去丟垃圾車，但瀏覽器其實並沒有提供你手動丟記憶體垃圾的權利，因為瀏覽器會幫我們丟掉這些垃圾。</p>
<p>簡單的來說，記憶體垃圾要怎麼丟、丟什麼完全不是我們網頁工程師所能控制的，我們唯一能做的就是減少垃圾的產生<del>或繼續製造垃圾。</del></p>
<p>那麼瀏覽器要怎麼辨識哪些是記憶體垃圾呢？一般在辨識記憶體垃圾上有比較常見的兩種方法：</p>
<ul>
<li>計算參考（Reference counting）演算法</li>
<li>標記掃除（Mark-and-Sweep）演算法</li>
</ul>
<h2 id="記憶體回收演算法：Reference-counting"><a href="#記憶體回收演算法：Reference-counting" class="headerlink" title="記憶體回收演算法：Reference counting"></a>記憶體回收演算法：Reference counting</h2><p>簡單來說就是該記憶體有沒有被參考到，而這理論上確實很合理，因為沒有被參考到的就是垃圾。</p>
<p>但有一種明明有被參考到但卻還是垃圾的情況：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line">  obj.a = obj2;   <span class="comment">// obj 參考 obj2</span></span><br><span class="line">  obj2.a = obj;    <span class="comment">// obj2 參考 obj</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<p>這種例子就叫做循環參考。</p>
<h2 id="標記掃除演算法：Mark-and-Sweep"><a href="#標記掃除演算法：Mark-and-Sweep" class="headerlink" title="標記掃除演算法：Mark-and-Sweep"></a>標記掃除演算法：Mark-and-Sweep</h2><p>標記掃除演算法是大部分垃圾回收機制的處理方式。</p>
<p>原因在於這種演算法則是將記憶體垃圾定義為「從根（roots）開始，不可到達的物件」。</p>
<p>對於 JavaScript 來說，根即為全局物件（詳見變數物件 Variable Object），因此這種算法會遍歷所有被全局物件所參考的物件與所參考的物件底下所有被參考的物件，還有其被參考的物件所參考的物件（好饒舌），一直到最後為止，沒有被這個颱風尾掃到的，就是垃圾。</p>
<p>這個演算法好處解決了上面循環的問題：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line">  obj.a = obj2;   <span class="comment">// obj 參考 obj2</span></span><br><span class="line">  obj2.a = obj;    <span class="comment">// obj2 參考 obj</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>垃圾回收機制最終控制權是在瀏覽器身上而非網頁開發工程師本身，儘管完美的垃圾回收應該要使記憶體垃圾不會對使用者造成負擔，但我們仍可以試著理解垃圾回收機制儘量避免這些會成為記憶體垃圾的寫法。</p>
<h1 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)" target="_blank" rel="noopener">Garbage Collection wiki</a></li>
<li><a href="https://zh.wikipedia.org/zh-tw/%E9%9B%BB%E8%85%A6%E8%A8%98%E6%86%B6%E9%AB%94" target="_blank" rel="noopener">Memory wiki</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Memory_Management" target="_blank" rel="noopener">Memory Management MDN</a></li>
<li><a href="https://liujiacai.net/blog/2018/06/15/garbage-collection-intro/#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-mark-and-sweep" target="_blank" rel="noopener">基本算法 mark-and-sweep</a></li>
<li><a href="https://zh.javascript.info/garbage-collection" target="_blank" rel="noopener">garbage-collection</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">JavaScript 内存泄漏教程</a></li>
<li><a href="https://juejin.im/post/5b10ba336fb9a01e66164346" target="_blank" rel="noopener">JavaScript 内存机制</a></li>
<li><a href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec" target="_blank" rel="noopener">How JavaScript works: memory management + how to handle 4 common memory leaks</a></li>
<li><a href="https://medium.com/@ethannam/javascripts-memory-model-7c972cd2c239" target="_blank" rel="noopener">JavaScript’s Memory Model</a></li>
<li><a href="https://codeburst.io/js-demystified-04-execution-context-97dea52c8ac6" target="_blank" rel="noopener">JS Demystified 04 — Execution Context</a></li>
<li><a href="https://www.coderbridge.com/@aszx87410/a5279d9298ab4e75bf75c75a4f391e78" target="_blank" rel="noopener">Day00：V8 bytecode 系列文介紹</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Microtasks &amp; Marcotask</title>
    <url>/JavaScript/JavaScript-Microtasks-Marcotask/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>
前陣子我們介紹到事件循環（Event Loop）以及任務隊列（Job Queue），使我們更加瞭解 JavaScript 中非同步（Asynchronous）的運作知識，然而並非所有的非同步事件都是排在同一個隊伍裡……

<a id="more"></a>

<h1 id="Microtasks-amp-Marcotask"><a href="#Microtasks-amp-Marcotask" class="headerlink" title="Microtasks &amp; Marcotask"></a>Microtasks &amp; Marcotask</h1><p>之前我們理解到非同步事件會經由 Web API 依照各自的做法（如： <code>setTimeoue</code> 需靠 <code>Timer</code> 檢查），之後才排入任務隊列（Job Queue）中，然而任務隊列實際上還可以分為 <code>Marcotask</code> 與 <code>Mircotask</code> 兩個隊伍。</p>
<p>而各自會排入的事件大概可以分為：</p>
<ul>
<li>Marcotasks：<code>setTimeout</code>、<code>setInterval</code>、I/O、UI 渲染</li>
<li>Mircotasks：<code>Promises</code>、<code>MutationObserver</code></li>
</ul>
<p>在執行順序上 <code>Mircotasks</code> 是優於 <code>Marcotasks</code> 且會等到 <code>Mircotasks</code> 都執行完了才會回來檢查 <code>Marcotasks</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>

<p>執行完畢會顯示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'start'</span></span><br><span class="line"><span class="string">'end'</span></span><br><span class="line"><span class="string">'Promise1'</span></span><br><span class="line"><span class="string">'Promise2'</span></span><br><span class="line"><span class="string">'setTimeout1'</span></span><br><span class="line"><span class="string">'setTimeout2'</span></span><br></pre></td></tr></table></figure>

<p>一步一步來看的話，程式應當會先執行同步的程式碼，因此依序直譯到最後一行時，會依序將 <code>start</code> 以及 <code>end</code> 拋出。</p>
<p>接著其他非同步的程式則會分派到不同的 <code>watcher</code> 待任務循環的輪詢。</p>
<p>其中 <code>Promise1</code>、<code>Promise2</code> 分到 <code>Mircotasks</code>， <code>setTimeout1</code>、<code>setTimeout2</code> 分到 <code>Marcotasks</code>。</p>
<p>等到主線程（main thread）執行完畢時，任務循環首先會去查看 <code>Mircotasks</code> 還有沒有事件，如果有就將之移入呼叫堆疊（Call Stack）中執行，直到 <code>Mircotasks</code> 沒有事件才去檢查 <code>Marcotasks</code>。</p>
<p>由此可知如果想要非同步事件盡早被解決的話可以使用會被分派於 <code>Mircotasks</code> 的寫法，如果想要避免非同步事件受到 <code>Mircotasks</code> 隊伍影響到其餘非同步事件則應盡量都使用 <code>Marcotasks</code> 方法。</p>
<h1 id="強迫寫成-Mircotasks-事件或-Marcotasks-事件的方法"><a href="#強迫寫成-Mircotasks-事件或-Marcotasks-事件的方法" class="headerlink" title="強迫寫成 Mircotasks 事件或 Marcotasks 事件的方法"></a>強迫寫成 Mircotasks 事件或 Marcotasks 事件的方法</h1><p>強迫寫成 Marcotasks 技巧其實很多人可能都有使用過了，那就是 <code>setTimeout(fn, 0)</code>。</p>
<p>透過 <code>setTimeout</code> 的特性讓內部的程式區塊可以拖延至主線程都執行完畢時再來執行內部的程式碼，例如需要龐大的計算時就可以以此來包裹。</p>
<p>而強迫寫成 Mircotask 這個可能就比較少人知道了，我們可以透過 <code>queueMicrotask(callback)</code> 來執行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">queueMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'這個回呼回被拋到 Mircotasks 隊列中'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'這個回呼回被拋到 Marcotasks 隊列中'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>以上就是 Microtasks &amp; Marcotask 在瀏覽器上的概念，基本上事件循環（Event Loop）整體的概念到這裡已經算是一個尾端了，每個部份當然可以更加的深究，不過與產出的結果可以說是以達到相近不遠的程度了，若有興趣的可以再深究下去，一起來討論！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Promise</title>
    <url>/JavaScript/JavaScript-Promise/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>繼回呼地獄（Callback Hell）之後，ES 6 推了一個令人振奮的功能，那就是 <code>Promise</code>！</p>
<p>Promise 解決了使用回呼時會產生的回呼地獄，讓整個程式平坦化之外，更多了一些 <code>Promise.all</code> 、 <code>Promise.race</code> 使許多非同步處理能更加的簡潔，</p>
<p>今天就讓我們一起來看看 <code>Promise</code> 要怎麼使用吧！</p>
<a id="more"></a>

<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>沒有經歷過糟糕的怎麼會懂另一邊的好，所以第一節當然要先看看相對醜醜的寫法。</p>
<p>而在之前 <code>Promise</code> 還未出現時，如果我們需要讓不同非同步方法能夠等待可以這麼做：</p>
<p>情境一，有序地等待，直接回呼下一個函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcA done!'</span>)</span><br><span class="line">    callback()</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcB done!'</span>)</span><br><span class="line">    callback()</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcC</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcC done!'</span>)</span><br><span class="line">    callback()</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  funcB(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    funcC(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'All Done'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但這樣會造成回呼地獄。</p>
<p>情境二，互相等待，做一個控管函式，由控管函式確認最後合併結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcA done!'</span>)</span><br><span class="line">    callback(<span class="string">'A'</span>)</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcB done!'</span>)</span><br><span class="line">    callback(<span class="string">'B'</span>)</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combineResult</span>(<span class="params">func1, func2, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> box = []</span><br><span class="line">  funcA(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    box.push(val)   <span class="comment">// A</span></span><br><span class="line">    <span class="keyword">if</span>(box.length === <span class="number">2</span>) &#123;</span><br><span class="line">      callback(<span class="string">'All done!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  funcB(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    box.push(val)   <span class="comment">// B</span></span><br><span class="line">    <span class="keyword">if</span>(box.length === <span class="number">2</span>) &#123;</span><br><span class="line">      callback(<span class="string">'All done!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">combineResult(funcA, funcB, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// All done!</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>情境三，互相競爭，做一個控管函式，由控管函式來阻止另一個函式回呼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcA done!'</span>)</span><br><span class="line">    callback(<span class="string">'A'</span>)</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'funcB done!'</span>)</span><br><span class="line">    callback(<span class="string">'B'</span>)</span><br><span class="line">  &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">raceResult</span>(<span class="params">func1, func2, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> box = []</span><br><span class="line">  funcA(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    box.push(val)   <span class="comment">// A</span></span><br><span class="line">    <span class="keyword">if</span>(box.length === <span class="number">1</span>) &#123;</span><br><span class="line">      callback(val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  funcB(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    box.push(val)   <span class="comment">// B</span></span><br><span class="line">    <span class="keyword">if</span>(box.length === <span class="number">1</span>) &#123;</span><br><span class="line">      callback(val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raceResult(funcA, funcB, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result + <span class="string">' is first!'</span>) <span class="comment">// ? is first!</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面兩種做法雖然已經可以解決一些基礎的等待與競爭情境，但顯然看起來還是不夠乾淨，於似乎我們在 ES6 終於盼到了這一刻，</p>
<p>那就是 <code>Promise</code>！</p>
<h1 id="Promise-基本使用"><a href="#Promise-基本使用" class="headerlink" title="Promise 基本使用"></a>Promise 基本使用</h1><p>Promise 顧名思義它主要是用來承諾一些非同步上的行為要如何處理。</p>
<p>而一個基本的 Promise 會有三種狀態：</p>
<ul>
<li>pending：等待執行回應。</li>
<li>resolve（fulfilled）：執行完畢，並且回應完成。</li>
<li>reject：執行完畢，並且回應失敗。</li>
</ul>
<p>最基本的用法就是在函式中初始化一個 Promise 物件，並把相關處理放在裡面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcA done!'</span>)        <span class="comment">// 回應表示執行完畢，結果成功，並送出成功結果。</span></span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;                  <span class="comment">// 捕捉到錯誤時</span></span><br><span class="line">      reject(err)                   <span class="comment">// 回應表示執行完畢，結果失敗，並送出失敗結果。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著當 Promise 執行成功時，我們可以藉由 <code>then</code> 去取得 <code>resolve</code> 所回應的成功結果，執行失敗則可以藉由 <code>catch</code> 去取得 <code>reject</code> 所回應的失敗結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">funcA()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 在這裡執行成功的後續處理</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">rej</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(rej) <span class="comment">// 在這裡執行失敗的後續處理</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>而其中由 <code>then</code> 所返回的值也是 <code>Promise</code> 物件，因此你還可以接著做其他後續處理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">funcA()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> res <span class="comment">// 第一波處理後將值回傳，使得接下來能可以繼續使用 Promise 中的 then 方法處理</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 第二波處理</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>釐清怎麼使用後，接著我們回到第一個情境改寫一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcA done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcB done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcC done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    funcB()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    funcC()</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>有沒有看到改寫後整個平坦化了許多！</p>
<p>現在來看看合併與競爭下的 Promise 要怎麼使用：</p>
<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h1><p>在 Promise 之中我們只要將會返回 Promise 物件的函式包裹在一起即可透過 <code>Promise.all</code> 等待所有結果後，再發出最後結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcA done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcB done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([funcA(), funcB()])</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// ["funcA done!", "funcB done!"]</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>如此一來它就會等待所有函式都返回結果時，於下一個 <code>then</code> 中回傳一個陣列，裡面分別為所有 Promise <code>resolve</code> 的結果。</p>
<h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h1><p>若是要競爭非同步行為的話，則透過 <code>Promise.race</code> 就可以取得第一個執行完畢的結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcA done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">'funcB done!'</span>)</span><br><span class="line">    &#125;, (<span class="built_in">Math</span>.random() + <span class="number">1</span>) * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([funcA(), funcB()])</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// 'func? done'</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>如此一來它就會等待第一個回應的結果，並只回傳第一個結果。</p>
<h1 id="Promise-其餘狀況"><a href="#Promise-其餘狀況" class="headerlink" title="Promise 其餘狀況"></a>Promise 其餘狀況</h1><p>除了基本的合併與競爭之外，Promise 還有下列情境可以使用：</p>
<ul>
<li>first()：只要第一個 Promise 回應了就執行。</li>
<li>last()：最後一個 Promise 回應了才執行。</li>
<li>none()：如果所有 Promise 都失敗了才執行。</li>
<li>any()：任何一個 Promise 成功了就執行。</li>
</ul>
<p>以上就是 Promise 基本用法，其餘之外還有一些雷點跟狀況就等待大家來挖掘吧（？</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://blog.huli.tw/2015/08/26/javascript-promise-generator-async-es6/" target="_blank" rel="noopener">[Javascript] Promise, generator, async與ES6</a></li>
<li><a href="https://wcc723.github.io/development/2020/02/16/all-new-promise/" target="_blank" rel="noopener">JavaScript Promise 全介紹</a></li>
<li><a href="https://pjchender.github.io/2017/09/26/js-promise-%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">[JS] Promise 的使用</a></li>
<li><a href="https://cythilya.github.io/2018/10/31/promise/" target="_blank" rel="noopener">你懂 JavaScript 嗎？#24 Promise</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10194569?sc=iThelpR" target="_blank" rel="noopener">重新認識 JavaScript: Day 26 同步與非同步</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Pure Function &amp; Side Effect 純函數與副作用</title>
    <url>/JavaScript/JavaScript-Pure-Function/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>來點純一點的貨吧！</p>
<p>為什麼函式還有分純不純的呢？有副作用的函式又是怎麼一回事？</p>
<p>讓我們一起來瞭解純函數與副作用到底是什麼吧！</p>
<a id="more"></a>

<h1 id="Pure-Function"><a href="#Pure-Function" class="headerlink" title="Pure Function"></a>Pure Function</h1><p>純函式（pure function）主要的概念是不會改變函式外面與函式傳進來的數值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">// 4</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>而我們會需要純函式的原因：</p>
<ul>
<li>具可快取性（cachable），可建立快取方法加速運算。</li>
<li>具有移植性（portable），由於純函式具有一致性，因此函式可輕鬆移到別的程式中。</li>
<li>引用具有透明性（referntial transparency），引用資料從何而來一清二楚，</li>
<li>函式本身即為文件（self-documenting），不必再另外撰寫一份說明文件，相對容易理解好維護。</li>
<li>具可測試性（testable），</li>
<li>好理解，因為沒有競爭狀態（race condition）。（雖然在 JavaScript Runtime 中本身是屬於單執行緒，本來就沒競爭狀態的問題）。</li>
</ul>
<h2 id="可快取性"><a href="#可快取性" class="headerlink" title="可快取性"></a>可快取性</h2><p>我們可以透過閉包的機制封裝結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cacheFunc = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = &#123;&#125; <span class="comment">// 參數與回傳值將會被快取在這裡</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arg = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>)</span><br><span class="line">    cache[arg] = cache[arg] || func.apply(func, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> cache[arg]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著就可以透過這個 <code>cacheFunc</code> 來快取運算值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = cacheFunc(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">5</span>) <span class="comment">// 6</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">5</span>) <span class="comment">// 從快取得到 6</span></span><br></pre></td></tr></table></figure>

<h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><p>可移植性簡單來說就是因為純函式到哪裡運算邏輯都不受影響，因此別的程式需要時可以直接引用，甚至是複製到其他專案中。</p>
<h2 id="引用透明性"><a href="#引用透明性" class="headerlink" title="引用透明性"></a>引用透明性</h2><p>引用透明性是指撰寫時視覺上我們可以很清楚的知道函式的輸入輸出總是能輸出相同的值。</p>
<h2 id="本身為文件"><a href="#本身為文件" class="headerlink" title="本身為文件"></a>本身為文件</h2><p>純函數本身可以被看作是一種文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> renderH1 = <span class="function"><span class="keyword">function</span>(<span class="params">content</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;'</span> + content + <span class="string">'&lt;/h1&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.title'</span>).innerHTML = renderH1(<span class="string">'標題'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="可測試性"><a href="#可測試性" class="headerlink" title="可測試性"></a>可測試性</h2><p>純函數由於在內部不直接引用外部值，而須透過參數給定，因此在測試上只需要針對傳送參數即可，並且必定會回傳相同值也讓測試案例（test case）更好撰寫。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'add func test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  test(<span class="string">'add 1 &amp; 2 should equal 3'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>) <span class="comment">// 不論使用多少次 add(1, 2) 最後都一定會返回 3。</span></span><br><span class="line">  &#125;)</span><br><span class="line">  test(<span class="string">'add 2 &amp; 4 should equal 6'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    expect(add(<span class="number">2</span>, <span class="number">4</span>)).toBe(<span class="number">6</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="可並行性"><a href="#可並行性" class="headerlink" title="可並行性"></a>可並行性</h2><p>在別的程式語言中要考量存取記憶體的先後順序定義的問題，然而 JavaScript 在 Runtime 時本身就是單執行緒，所以 JavaScript 不會進入競爭狀態（race condition）。但如果是在別的程式語言中使用純函數，就可以透過純函數不依靠記憶體而得到避免進入競爭狀態的窘境。</p>
<p>以上便是使用純函數的好處與理由。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10185780" target="_blank" rel="noopener">Day 12: ES6篇: Side Effects(副作用)與Pure Functions(純粹函式)</a></li>
<li><a href="https://medium.com/frochu/%E7%B4%94%E7%B2%B9%E7%9A%84%E5%A5%BD-pure-function-%E7%9F%A5%E9%81%93-574d5c0d7819" target="_blank" rel="noopener">純粹的好，Pure Function 知道</a></li>
<li><a href="https://jigsawye.gitbooks.io/mostly-adequate-guide/ch3.html" target="_blank" rel="noopener">第 3 章：Pure Function－單純的幸福</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Statement &amp; Expression 陳述式與表達式</title>
    <url>/JavaScript/JavaScript-Statement-Expression/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>你有想過為什麼變數可以儲存 <code>3</code> 卻沒有辦法儲存 <code>if/else</code> 語句，可是卻又能儲存整個 <code>function</code> 嗎？</p>
<p>一起來看看陳述式與表達式的概念就能馬上瞭解！</p>
<a id="more"></a>

<p>在談談兩者之前要先請你看下方程式，請問最後會秀出甚麼呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span>(a = <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a = <span class="number">4</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>

<p>如果無法一眼看出是 <code>4</code>、<code>4</code> 或不知道為什麼會這樣的話歡迎繼續看下去！</p>
<h1 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h1><p>在 JavaScript 中，語句主要可分為陳述式（statement）與表達式（expression）。</p>
<p>而陳述式簡單的來說就像是指令一樣，它的目的主要是去執行一些事情，並且不會返回運算結果，例如 <code>if/else</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> () &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>陳述式最主要是用來描述它將做什麼事，並且它也不會回傳一個運算結果給你。</p>
<h1 id="Expression"><a href="#Expression" class="headerlink" title="Expression"></a>Expression</h1><p>除了陳述式之外，JavaScript 另一種語句我們稱為表達式（Expression），</p>
<p>而表達式又稱為運算式，顧名思義就是在計算一些東西，因此在 JavaScript 執行期他會回傳一個運算結果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span> + <span class="number">1</span>) <span class="comment">// 回傳 2</span></span><br></pre></td></tr></table></figure>

<p>而我們可以藉由將表達式所運算的結果藉由變數指派記憶體的路徑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="number">1</span> + <span class="number">1</span>) <span class="comment">// a 存下回傳的 2</span></span><br><span class="line"></span><br><span class="line">a <span class="comment">// 現在 a 儲存的路徑指向 2</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span> * <span class="number">2</span> <span class="comment">// a 存下回傳的 10</span></span><br><span class="line"></span><br><span class="line">a <span class="comment">// 現在 a 儲存的路徑指向 10</span></span><br></pre></td></tr></table></figure>

<p>一些其他的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">2</span> <span class="comment">// 回傳 false</span></span><br><span class="line">(<span class="number">2</span> &gt; <span class="number">1</span> ? <span class="string">'yes'</span> : <span class="string">'no'</span>) <span class="comment">// 回傳 yes</span></span><br><span class="line">a = <span class="number">3</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>有注意到嗎？賦值運算子 <code>=</code> 其實也是表達式，而 <code>=</code> 所回傳的結果是右方運算完的內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">var</span> y;</span><br><span class="line"><span class="keyword">var</span> z = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">x = y = z + <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">// ?</span></span><br><span class="line"><span class="built_in">console</span>.log(y) <span class="comment">// ?</span></span><br><span class="line"><span class="built_in">console</span>.log(z) <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>在執行的過程中， <code>x = y = z + 5</code> 這句會先被拆解成 <code>y = z + 5</code>，接著再把 <code>y = z + 5</code> 所返回的值 <code>5</code> 賦值給 <code>x</code>，所以最後結果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(y) <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(z) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>現在再回頭看最上面的那道題目，你應該可以解釋為什麼最後印出的結果會是 <code>4</code>、<code>4</code> 了！</p>
<h1 id="常見誤區"><a href="#常見誤區" class="headerlink" title="常見誤區"></a>常見誤區</h1><p>至於為什麼要區辨表達式跟陳述式的原因很多，其中一個例子是當你原本 <code>if</code> 中是要透過全等運算 <code>===</code> 但錯打成 <code>=</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if(a === 3) &#123;&#125; 原本要做全等比較</span></span><br><span class="line"><span class="keyword">if</span> (a = <span class="number">3</span>) &#123;&#125; <span class="comment">// 不小心打成這樣，但由於裡面返回的運算值是 3 ，為真值，所以最後仍然能通過 if 執行內部的東西。</span></span><br></pre></td></tr></table></figure>

<p>而這種錯誤在 typo 當中也算是一種比較麻煩的類型，原因是因為它是合法且能執行的，所以要特別小心。</p>
<h1 id="函式"><a href="#函式" class="headerlink" title="函式"></a>函式</h1><p>函式（function）在 JavaScript 算是物件的一種，所以自然而然可以把它當作值來操作，比方說把函式透過變數來儲存，或是單純呼叫函式，因此自然而然它也擁有表達式與陳述式兩種形式。</p>
<h2 id="函式陳述式-Function-Statement"><a href="#函式陳述式-Function-Statement" class="headerlink" title="函式陳述式 Function Statement"></a>函式陳述式 Function Statement</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">something</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(something)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say <span class="comment">// function say(something)&#123; console.log(something) &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="函式表達式-Function-Expression"><a href="#函式表達式-Function-Expression" class="headerlink" title="函式表達式 Function Expression"></a>函式表達式 Function Expression</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(something)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say <span class="comment">// function (something) &#123; console.log(something) &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="比較-函式陳述式-amp-函式表達式"><a href="#比較-函式陳述式-amp-函式表達式" class="headerlink" title="比較 函式陳述式 &amp; 函式表達式"></a>比較 函式陳述式 &amp; 函式表達式</h2><p>這兩個最大的差異點在於 JavaScript 執行時（Runtime）當下的執行環境（Execution Context）中。</p>
<p>所以若是以下這段程式碼為例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">statementFunction()</span><br><span class="line">expressionFunction()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">statementFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expressionFunction = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">statementFunction()</span><br><span class="line">expressionFunction()</span><br></pre></td></tr></table></figure>

<p>在全域環境執行時期的創造階段中，會有一個叫做 <code>Variable Object</code> 紀錄所有的值（若不清楚的請詳見 <code>Varaible Object</code> 與 <code>Activation Object</code> 一章），函式陳述式在這裡會被視為需要被初始化的目標，而透過變數宣告的則是會先預設一個<br> <code>undefined</code> 的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GlobalExecutionContext = &#123; <span class="comment">// 全域執行環境</span></span><br><span class="line">  phase: <span class="string">'Creation'</span>, <span class="comment">// 創造階段</span></span><br><span class="line">  variableObject: &#123; <span class="comment">// 紀錄當下環境的值</span></span><br><span class="line">    statementFunction: <span class="function"><span class="keyword">function</span> <span class="title">statementFunction</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'Hi'</span>) &#125;,</span><br><span class="line">    expressionFunction: <span class="literal">undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等創造模式結束所有的行為後，進入執行階段才會開始一行一行的檢查有沒有要運算的內容，因此第一行我們可以很輕易的在 <code>variable object</code> 中找到 <code>statementFunction</code> 這個辨識字（identity）所儲存的是一個函式，因此要它執行函式很合理。</p>
<p>但就在第二行時，我們知道 <code>variable object</code> 中 <code>expressionFunction</code> 這個識別字所表示的值還是初始化的 <code>undefined</code>，因此要去執行一個 <code>undefined</code> 時引擎就會拋出一個錯誤提醒你。</p>
<p>所以他們之間的差異最主要還是在於 <code>scope</code> 這件事情上，如果已經瞭解 <code>Execution Context</code> 的創造階段與執行階段到底做了什麼事情的話，其實你也大概知道這兩者背後的運作原理了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Scope</title>
    <url>/JavaScript/JavaScript-Scope/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>為什麼 <code>console.log</code> 出來的結果跟你想的不一樣？</p>
<p>瞭解 <code>Scope</code> 後，你將會大幅提升閱 code 能力！</p>
<a id="more"></a>

<blockquote>
<p>要瞭解作用域（Scope）前，建議要先有執行環境（Execution Context）的概念就可以很快理解本篇內容！</p>
</blockquote>
<h1 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h1><p>作用域（Scope）簡單的來說就像是變數的生存環境，最主要牽扯的是有關於執行環境（Execution Context）的概念，而簡單來說，只要執行函式就會創造一個新的執行環境。</p>
<blockquote>
<p>想深入請詳見執行環境一文。</p>
</blockquote>
<h2 id="全域執行環境"><a href="#全域執行環境" class="headerlink" title="全域執行環境"></a>全域執行環境</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上列程式在執行前（Creation Phase），會先初始化變數物件（Variable Object）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GlobalExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  variableObject: &#123;</span><br><span class="line">    a: <span class="literal">undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這也是為什麼 <strong>執行時</strong> 一行一行直譯時第一行秀出該行 <code>console.log(a)</code> 為 <code>undefined</code> ，而第三行則是秀出 <code>1</code> 的原因（也是 <code>提升 Hoisting</code> 概念的由來）。</p>
<h2 id="函式執行環境"><a href="#函式執行環境" class="headerlink" title="函式執行環境"></a>函式執行環境</h2><p>接著或許你會說，那麼我如果執行了一個函式，裡面不是也會形成新的執行環境，那他如果找不到裡面的變數怎麼辦？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>我們一樣來看看在初始化時函式執行環境做了什麼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FunctionExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  activationObject: &#123;</span><br><span class="line">    argument: []</span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: activationObject + [[scope]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>執行物件（Actication Object）與變數物件（Variable Object）其實只差在多了個 <code>argument</code> 參數。</p>
</blockquote>
<p>我們可以從執行物件（Actication Object）中看到他並沒有 <code>a</code> 這個變數，那麼它要去哪裡找呢？</p>
<h1 id="Scope-Chain"><a href="#Scope-Chain" class="headerlink" title="Scope Chain"></a>Scope Chain</h1><p>範圍鏈、或稱作用鏈（Scope Chain），主要的目的在於當我們在該執行環境中的物件找不到變數時，就會透過作用鏈的機制來尋找。</p>
<p>而一般作用鏈初始化的內容會是自己本身的變數物件加上 <code>[[scope]]</code>，所以我們可以理解成一開始理所當然的會先去找當前的變數環境，找不到再來看有沒有在 <code>[[scope]]</code> 當中。</p>
<p>那麼 <code>[[scope]]</code> 又是什麼東西？</p>
<p>根據 ECMA 262 三版中的解釋是，當一開始建立此函式時，<code>[[scope]]</code> 所設定的值會是當下環境中的 <code>scope chain</code>，回到剛剛的程式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) </span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>所以<code>[[scope]]</code> 其實就是宣告 <code>function</code> 的環境，更白話一點的方式就是，<br><strong>找不到變數就往宣告函式的外層找就行！</strong></p>
<p>接著來驗證此想法：</p>
<h2 id="Scope-Chain，範例一"><a href="#Scope-Chain，範例一" class="headerlink" title="Scope Chain，範例一"></a>Scope Chain，範例一</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  y()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br><span class="line">x();</span><br></pre></td></tr></table></figure>

<p>在上面程式碼中，函式 <code>y</code> 是在全域執行環境下被初始化的，因此函式 <code>y</code> 的 scope chain 除了自己本身之外，另一個就是找到全域執行環境當中，因此輸出 <code>1</code>。</p>
<h2 id="Scope-Chain，範例二"><a href="#Scope-Chain，範例二" class="headerlink" title="Scope Chain，範例二"></a>Scope Chain，範例二</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)  <span class="comment">// ?</span></span><br><span class="line">  &#125;</span><br><span class="line">  y()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x();</span><br></pre></td></tr></table></figure>

<p>在上面程式碼中，函式 <code>y</code> 是在函式執行環境 <code>x</code> 下被初始化的，因此函式 <code>y</code> 的 scope chain 除了自己本身之外，另一個就是找到函式執行環境 <code>x</code> 當中，而在 <code>x</code> 環境當中有宣告 <code>a</code> 變數，因此輸出 <code>2</code>。</p>
<h2 id="Scope-Chain，範例三"><a href="#Scope-Chain，範例三" class="headerlink" title="Scope Chain，範例三"></a>Scope Chain，範例三</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  y()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)  <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x();</span><br></pre></td></tr></table></figure>

<p>在上面程式碼中，函式 <code>y</code> 是在全域執行環境下被初始化的，因此函式 <code>y</code> 的 scope chain 除了自己本身之外，另一個就是找到全域執行環境當中的 <code>x</code>，但與範例一不同的地方在於，執行 <code>x()</code> 時，內部的 <code>a</code> 去更動了全域環境的 <code>a</code> 值，因此輸出 <code>2</code>。</p>
<h1 id="Scope-type-作用域類型"><a href="#Scope-type-作用域類型" class="headerlink" title="Scope type 作用域類型"></a>Scope type 作用域類型</h1><p>作用域的類型其實分有兩種：</p>
<ul>
<li>動態作用域（dynamic scope）</li>
<li>靜態作用域（static scope），又稱為詞法作用域（lexical scope）。</li>
</ul>
<p>動態作用域的意思是以<strong>呼叫</strong>函式的地方當作作用域鏈。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  y()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 若是動態的話這邊會以呼叫的地方，也就是 x 的環境當作作用域，最後輸出 2。</span></span><br><span class="line">&#125;</span><br><span class="line">x();</span><br></pre></td></tr></table></figure>

<p>靜態作用域的意思則是以<strong>宣告</strong>函式的地方當作作用域鏈。</p>
<p>JavaScript 所採用的是便是靜態作用域的方法，而大部分會搞錯都是認為 JavaScript 是以動態作用域的做法下去看的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  y()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 但 JavaScript 是採用靜態作用域，因此其實哪邊呼叫它並沒有關係，因為他看到是最初宣告它的作用域。</span></span><br><span class="line">&#125;</span><br><span class="line">x();</span><br></pre></td></tr></table></figure>

<p>若能搞懂動態與靜態的差別，並知道 JavaScript 是以靜態作用域的思維下去思考，作用域其實沒你想像中的難！</p>
<h1 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h1><ul>
<li><a href="https://pjchender.blogspot.com/2015/12/javascriptscope-chainouter-environment.html" target="_blank" rel="noopener">[筆記] JavaScript中Scope Chain和outer environment的概念</a></li>
<li><a href="http://notepad.yehyeh.net/Content/WebDesign/Javascript/ECMA/Core/JavaScriptCore.php#section8" target="_blank" rel="noopener">ECMA-262 Javascript核心 譯文</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10203387" target="_blank" rel="noopener">你不可不知的 JavaScript 二三事#Day5：湯姆克魯斯與唐家霸王槍——變數的作用域(Scope) (1)</a></li>
<li><a href="https://blog.techbridge.cc/2018/12/08/javascript-closure/#scope" target="_blank" rel="noopener">所有的函式都是閉包：談 JS 中的作用域與 Closure</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Variable Object &amp; Activation Object</title>
    <url>/JavaScript/JavaScript-Variable-Object-and-Activation-Object/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>理解變數物件（Variable Object，簡稱 VO）與執行物件（Activation Object）的概念對於理解作用域（Scope）、提升（Hoisting）、垃圾回收機制（Garbage collection）、閉包（Closure）與執行環境（Execution context）等等至關重要。</p>
<p>究竟變數物件到底指的是什麼？為何理解它會可以快速打通任督二脈？就讓我們一來看看它吧！</p>
<a id="more"></a>

<p>根據 ECMA <a href="https://www.ecma-international.org/archive/ecmascript/1999/TC39WG/990220-es2_func.pdf" target="_blank" rel="noopener">10.1.3 Variable Instantiation</a> 對於 Variable Object 的解釋：</p>
<blockquote>
<p>Every execution context has associated with it a variable object.<br>Variables and functions declared in the source text are added as properties of the variable object.<br>For function, anonymous, and implementation-supplied code, parameters are added as properties of the variable object.</p>
</blockquote>
<p>也就是說每個執行環境都會包含著一個變數物件（Variable Object），而執行函式等所創造出來的執行環境中，則會把參數（parameters）也加進去變數物件中，也就是活化（Acativation Object）</p>
<p>用物件來表示的話，全域變數物件大概就像這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GlobalExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  variableObject: &#123;</span><br><span class="line">    a: <span class="literal">undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而執行物件僅僅就是多了參數的變數物件版本：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FunctionExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  activationObject: &#123;</span><br><span class="line">    argument: []</span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: activationObject + [[scope]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中變數物件大致上會包含了三樣描述：</p>
<ul>
<li>phase：用來描述變數物件所處的階段。</li>
<li>variableObject、activationObject：初始化變數的值會存放在這，而函式的執行物件則多了 <code>argument</code>。</li>
<li>scopeChain：作用域鏈，用來理解作用域的關鍵（詳見 Scope 一文）</li>
</ul>
<h1 id="Phase"><a href="#Phase" class="headerlink" title="Phase"></a>Phase</h1><p>當每個執行環境（Execution Context）剛執行時，這裡的階段會被標為初始化，當下該環境中需要初始化的變數會被初始化為 <code>undefined</code>，若有函式則會將其移入為值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(x,y)</span><br></pre></td></tr></table></figure>

<p>對於全域的執行環境來說，一開始初始化階段會長得像這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GlobalExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  variableObject: &#123;</span><br><span class="line">    x: <span class="literal">undefined</span>,</span><br><span class="line">    y: <span class="literal">undefined</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123; <span class="keyword">return</span> a + b&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行到第一行 <code>let x = 1</code> 時，將 <code>x</code> 覆值 <code>1</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GlobalExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  variableObject: &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="literal">undefined</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123; <span class="keyword">return</span> a + b&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: variableObject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>後面依此類推。</p>
<p>我們可以發現初始化時最大的差別在於函式一開始就會被存入，因此宣告函式時我們可以在宣告前也能使用，而 <code>x</code>、<code>y</code> 變數則是要等到執行階段，執行到該行才會被覆值。</p>
<p>而在執行 <code>add</code> 函式所創建的執行環境中，一開始初始化階段會長得像這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addExecutionContext = &#123;</span><br><span class="line">  phase: <span class="string">'Creation'</span>,</span><br><span class="line">  activationObject: &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">3</span>,</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="number">1</span>: <span class="number">3</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  scopeChain: activationObject + [[scope]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看見執行物件中會隱性的（implicit）將參數（paramemter）建立值，並且對於原先 <code>add(x,y)</code> 中的引數（arguments）建立了一個獨立的物件，這裡也是為什麼我們能透過函式的 <code>arguments</code> 取得引進來的數值。</p>
<p>以上是變數物件與執行物件的概念介紹，熟悉了這個之後再去看作用域就可以更快速理解作用域鏈（Scope Chain）所帶來的影響。（詳見 Scope 一文）</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://www.ecma-international.org/archive/ecmascript/1999/TC39WG/990220-es2_func.pdf" target="_blank" rel="noopener">10.1.3 Variable Instantiation</a></li>
<li><a href="https://github.com/SDLyu/JavaScript/blob/master/Core/Variable%20Object.md" target="_blank" rel="noopener">變數物件(Variable Object)</a></li>
<li><a href="https://wiki.jikexueyuan.com/project/javascript-depth-understanding/variable-object.html" target="_blank" rel="noopener">變數物件(Variable Object)</a></li>
<li><a href="http://notepad.yehyeh.net/Content/WebDesign/Javascript/ECMA/Core/JavaScriptCore.php#section7" target="_blank" rel="noopener">ECMA-262 Javascript核心</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 call by value（call by address）</title>
    <url>/JavaScript/JavaScript-call-by-value/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>


<p>最近經過一年的淬鍊再回頭看看有關於傳值這篇文<br><a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/" target="_blank" rel="noopener">https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/</a></p>
<p>我覺得 call by value(address) 的解釋法應該是最接近且一致的心理模型了，來分享一下我對 JavaScript 中賦值、存取與修改的看法。</p>
<a id="more"></a>

<p>我預設的心理模型：</p>
<ol>
<li>識別字（identity）存取資料時是靠記憶體地址，並不是值本身。</li>
<li>重新賦值時（reassign），無論資料型別，一率另開一個記憶體地址放入該值，並儲存該記憶體地址。</li>
<li>修改物件內容時，修改的目標是該記憶體地址內的值。</li>
<li>賦值一個識別字時，會透過儲存的記憶體地址找到值：<ul>
<li>若該值為原始數值（primitive value），則另開一個記憶體地址放入該值，並儲存該記憶體地址。</li>
<li>若該值為非原始數值（Non-primitive value），則直接複製原先目標的記憶體地址。</li>
</ul>
</li>
</ol>
<p>接著以這個心理模型解釋以下幾種常見的狀況：</p>
<h1 id="若複製目標為原始數值並重新賦值："><a href="#若複製目標為原始數值並重新賦值：" class="headerlink" title="若複製目標為原始數值並重新賦值："></a>若複製目標為原始數值並重新賦值：</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> primitiveValue = <span class="number">1</span> <span class="comment">// 賦值一個記憶體地址（0x00）裡面放入 1</span></span><br><span class="line"><span class="keyword">var</span> copyPrimitiveValue = primitiveValue <span class="comment">// 從 primitiveValue 找到該記憶體地址（0x00）的值為 1，重新分配一個新的地址（0x01），並放入一個原始數值 1 進去（0x01）</span></span><br><span class="line"></span><br><span class="line">copyPrimitiveValue = <span class="number">2</span> <span class="comment">// 重新分配一個 0x02 的記憶體地址，而原先的 0x01 到時候會被瀏覽器記憶體清除機制標記掃除法（Mark-and-Sweep）清除。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(primitiveValue) <span class="comment">// 讀取 0x00 的值 =&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(copyPrimitiveValue) <span class="comment">// 讀取 0x02 的值 =&gt; 2</span></span><br></pre></td></tr></table></figure>

<h1 id="若複製目標為非原始數值並重新賦值："><a href="#若複製目標為非原始數值並重新賦值：" class="headerlink" title="若複製目標為非原始數值並重新賦值："></a>若複製目標為非原始數值並重新賦值：</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nonPrimitiveValue = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;  <span class="comment">// 賦值一個記憶體地址（0x00）裡面放入 &#123;a: 1&#125;</span></span><br><span class="line"><span class="keyword">var</span> copyNonPrimitiveValue = nonPrimitiveValue <span class="comment">// 從 nonPrimitiveValue 找到該記憶體地址（0x00）的值為 &#123;a: 1&#125;，發現為非原始數值，直接複製原先的地址（0x00）</span></span><br><span class="line"></span><br><span class="line">copyNonPrimitiveValue = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125; <span class="comment">// 重新分配一個 0x01 的記憶體地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nonPrimitiveValue) <span class="comment">// 讀取 0x00 的值 =&gt; &#123;a: 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(copyNonPrimitiveValue) <span class="comment">// 讀取 0x01 的值 =&gt; &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="若複製目標為非原始數值並修改："><a href="#若複製目標為非原始數值並修改：" class="headerlink" title="若複製目標為非原始數值並修改："></a>若複製目標為非原始數值並修改：</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nonPrimitiveValue = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;  <span class="comment">// 賦值一個記憶體地址（0x00）裡面放入 &#123;a: 1&#125;</span></span><br><span class="line"><span class="keyword">var</span> copyNonPrimitiveValue = nonPrimitiveValue <span class="comment">// 從 nonPrimitiveValue 找到該記憶體地址（0x00）的值為 &#123;a: 1&#125;，發現為非原始數值，直接複製原先的地址（0x00）</span></span><br><span class="line"></span><br><span class="line">copyNonPrimitiveValue.a = <span class="number">2</span> <span class="comment">// 這裡的 copyNonPrimitiveValue.a 屬於一種叫做 MemberExpression 的語法，因此它做的事情是先找到記憶體地址（0x00）中的 &#123;a: 1&#125;，在修改其中的 a 對應的 value 為 2。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nonPrimitiveValue) <span class="comment">// 讀取 0x00 的值 =&gt; &#123;a: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(copyNonPrimitiveValue) <span class="comment">// 讀取 0x00 的值 =&gt; &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="傳入函式中並重新賦值"><a href="#傳入函式中並重新賦值" class="headerlink" title="傳入函式中並重新賦值"></a>傳入函式中並重新賦值</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nonPrimitiveValue = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; <span class="comment">// (1.) 分配至 0x00，value 為 &#123;a: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reassign</span>(<span class="params">obj</span>) </span>&#123; <span class="comment">// (3.) 接收到 0x00</span></span><br><span class="line">  <span class="comment">// (4.) 在 JavaScript 創造期會隱性 assign obj 至 0x00 </span></span><br><span class="line">  obj = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125; <span class="comment">// (5.) 重新分配至 0x01</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reassign(nonPrimitiveValue) <span class="comment">// (2.) 傳入 0x00</span></span><br><span class="line"><span class="built_in">console</span>.log(nonPrimitiveValue) <span class="comment">// (6.) 讀取 0x00 =&gt; &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="傳入函式中並修改"><a href="#傳入函式中並修改" class="headerlink" title="傳入函式中並修改"></a>傳入函式中並修改</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nonPrimitiveValue = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; <span class="comment">// (1.) 分配至 0x00，value 為 &#123;a: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reassign</span>(<span class="params">obj</span>) </span>&#123; <span class="comment">// (3.) 接收到 0x00</span></span><br><span class="line">  <span class="comment">// (4.) 在 JavaScript 創造期會隱性 assign obj 至 0x00 </span></span><br><span class="line">  obj.a = <span class="number">2</span> <span class="comment">// (5.) 讀取 0x00 中的 &#123;a: 1&#125; 並將其中的 a 值修改為 2 =&gt; 0x00: &#123;a: 2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reassign(nonPrimitiveValue) <span class="comment">// (2.) 傳入 0x00</span></span><br><span class="line"><span class="built_in">console</span>.log(nonPrimitiveValue) <span class="comment">// (6.) 讀取 0x00 =&gt; &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>以上通通是用同個心理模型來解釋，所以我目前斷言 JavaScript 最主要是 call by value 而這個 value 指的是記憶體位置的部分。</p>
<p>而對於「賦值」為什麼會有情況原因在於「重新賦值」與「修改」的差別</p>
<ul>
<li>重新賦值（reassign）：給識別字（Identifer）一個新的記憶體地址</li>
<li>修改：從原先的記憶體地址中找到值再做修改，也就是物件成員表達式（MemberExpression）中的值。</li>
</ul>
<p>目前驗證的方法可以透過這個簡易的視覺化工具執行編譯分析，去觀察直接讀取識別字跟識別字成員的差別。</p>
<ul>
<li><a href="https://ui.dev/javascript-visualizer" target="_blank" rel="noopener">視覺化工具</a></li>
</ul>
<p>以上是我對於賦值、存取與修改的看法，也歡迎不同的意見來交流與驗證！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Callback Function 回呼函式</title>
    <url>/JavaScript/JavaScript-callback-function/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>回呼？回調？<br>Callback Function 到底 Call 了什麼東西回去？<br>就讓我們來瞭解回呼函式到底在做什麼吧！</p>
<a id="more"></a>

<h1 id="callback-function"><a href="#callback-function" class="headerlink" title="callback function"></a>callback function</h1><p>回呼函式（Callback Function）其實就是函式，只是一般都會定義<strong>某個函式為另一個函式的參數，當透過另一個函式呼叫該函式時</strong>，此時我們就可以說它是回呼函式。</p>
<p>比如我們從 <code>isbndb.com</code> 找到了一隻可以查閱書籍相關內容的 API，我們可以將其寫成下列函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBookInfo</span>(<span class="params">ISBN</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'https://api2.isbndb.com/book/'</span> + ISBN )</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// 這裡會回應一個 json 格式的書籍資料</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果我們想要取得書籍資料後做一些處理的話，直接寫在函式裡面就會難以重複利用，並且會副作用在裡面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBookInfo</span>(<span class="params">ISBN</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'https://api2.isbndb.com/book/'</span> + ISBN )</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在裡面對 responese 回來的資料做一些處理</span></span><br><span class="line">      <span class="comment">// 另外做了只有針對 ISBN 9862764414 的額外處理</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getBookInfo(<span class="string">'9862764414'</span>) <span class="comment">// 第一次沒問題</span></span><br><span class="line"></span><br><span class="line">getBookInfo(<span class="string">'986476246X'</span>) <span class="comment">// 糟了，是副作用，裡面的額外處理是我不想要的</span></span><br></pre></td></tr></table></figure>

<p>這時候我們可以將要處理的函式作為參數傳進去，使得取得資料的時候去呼叫這隻函式，接著就可以在使用函式的同時，同時定義好取到資料後要做什麼事情：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBookInfo</span>(<span class="params">ISBN, cb</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'https://api2.isbndb.com/book/'</span> + ISBN )</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> cb(res)) <span class="comment">// 執行 cb 參數，也就是我們使用函式時所定義的回呼函式。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getBookInfo(<span class="string">'9862764414'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 這裡可以寫取到 ISBN 9862764414 的資料後要做什麼事情</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">getBookInfo(<span class="string">'986476246X'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 現在可以各自做處理了！</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>從上面範例中可以看見，回呼函式輕鬆的將耦合降低了，我們將來要使用不同的 ISBN 取得書目資料時，我們不必再去更改 <code>getBookInfo</code> 函式裡的內容，而是在使用函式時可以自由的定義取到資料後要進行的處理！</p>
<h1 id="error-first"><a href="#error-first" class="headerlink" title="error first"></a>error first</h1><p>在上方的例子中我們可以看見我們只有定義了取得資料後的狀態，並沒有定義取得資料失敗的狀態，因此我們要在把錯誤狀態加進我們的回呼函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先不管 getBookInfo 內部的實作</span></span><br><span class="line"></span><br><span class="line">getBookInfo(<span class="string">'9862764414'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// x, y 應該要是什麼</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>從上面例子可以看到當我們在執行 <code>getBookInfo</code> 函式的回呼函式時，我們並無法知道 <code>x</code>、<code>y</code> 傳進來的參數代表什麼意思，此時如果要你選一個參數當判斷取得資料成功與否你會選擇哪個？</p>
<p>較好的做法其實是使用第一個參數來做判斷：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBookInfo</span>(<span class="params">ISBN, cb</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'https://api2.isbndb.com/book/'</span> + ISBN )</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> cb(<span class="literal">true</span>, err)) <span class="comment">// 如果取得失敗會執行這個函式</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> cb(<span class="literal">false</span>, res)) <span class="comment">// 如果取得成功會執行這個函式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getBookInfo(<span class="string">'9862764414'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 定義取得失敗後的做法，此時 res 可以回應錯誤的內容</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 定義取得成功後的做法，此時 res 可以回應成功的內容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>為什麼會是第一個參數呢？原因在於我們對於成功取得資料的與否這件事情是一定會遇到的，所以我們可以藉由放在第一個參數來減低不必要的參數使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getBookInfo(<span class="string">'9862764414'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, err</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 定義取得失敗後的做法，此時 res 可以回應錯誤的內容</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 定義取得成功後的做法，此時 res 可以回應成功的內容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面例子則是假如 callback function 第五個才是 err 處理，可以看見儘管我們只有要使用 <code>a</code> 參數與 <code>err</code> 處理，我們仍然要把其他參數列好列滿。</p>
<h1 id="callback-hell"><a href="#callback-hell" class="headerlink" title="callback hell"></a>callback hell</h1><p>當我們以為終於完成 Callback function 時，上忍告訴你事情沒有這麼簡單就結束，假如今天有一個狀況是有一連串的函式需要按順序執行時，你第一個可能會想到這麼做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  funcB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  funcC()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA()</span><br></pre></td></tr></table></figure>

<p>但你現在已經會回呼函式了，因此改寫成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  cb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  cb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA(        <span class="comment">// 執行完函式 A 時 callback 函式 B</span></span><br><span class="line">  funcB(      <span class="comment">// 執行完函式 B 時 callback 函式 C</span></span><br><span class="line">    funcC()</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>你不禁讚嘆自己如同 JavaScript 忍者一樣寫出低耦合的程式，如同一位上忍般解決了一個艱困的難題</p>
<p>直到當我們有多個順序需要執行時：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">funcA(</span><br><span class="line">  funcB(</span><br><span class="line">    funcC(</span><br><span class="line">      funcD(</span><br><span class="line">        funcE(</span><br><span class="line">          funcF(</span><br><span class="line">            funcG(</span><br><span class="line">              funcH(</span><br><span class="line">                funcI()</span><br><span class="line">              )</span><br><span class="line">            )</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>「此時你就可以看到著名的回呼地獄（Callback Hell），而且這還不含錯誤處理呢。」上忍如是說，「至於要怎麼解決，只能詳閱 Promise 一文」。</p>
<h1 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h1><ul>
<li><a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/callback.html" target="_blank" rel="noopener">Callback(回調)</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 Synchronous &amp; Asynchronous 同步與非同步</title>
    <url>/JavaScript/JavaScript-synchronous-and-asynchronous/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p>在介紹同步（synchronous）與非同步（asynchronous）前一定要來破個題，那就是</p>
<p><strong>JavaScript</strong> 的執行期（runtime）一定是有按行數順序的即時編譯。</p>
<p>可是為何有時執行的函式會稍晚的時候才輸出、執行？</p>
<p>會有這個疑問就讓我們一起來認識認識什麼是同步與非同步吧！</p>
<a id="more"></a>

<p>每個 JavaScript 程式區塊在執行時的步驟可分為呼叫與得到回應，而簡單來說能立即得到回應結果的就是同步（Synchronous），不能立即得到回應的就是非同步（Asynchronous），也就是說同步與非同步辨認的方式可以透過會不會<strong>阻塞（blocking）主程式</strong>來判斷。</p>
<h1 id="Synchronous-同步"><a href="#Synchronous-同步" class="headerlink" title="Synchronous 同步"></a>Synchronous 同步</h1><p>同步的 JavaScript 函式最大的特色就是<strong>會阻塞</strong>主程式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> money = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'do something'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (money &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  money++</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'money'</span>, money)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'do another thing'</span>)</span><br></pre></td></tr></table></figure>

<p>你會發現控制台依序輸出了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'do something'</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">1</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">2</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">3</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">4</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">5</span></span><br><span class="line"><span class="string">'do another thing'</span></span><br></pre></td></tr></table></figure>

<p>這也是我們一般預期寫完程式該要有的順序，然而有時候會有不同的情況發生。</p>
<h1 id="Asynchronous-非同步"><a href="#Asynchronous-非同步" class="headerlink" title="Asynchronous 非同步"></a>Asynchronous 非同步</h1><p>非同步的 JavaScript 函式最大的特色就是<strong>不會阻塞</strong>主程式，</p>
<p>將上面程式碼範例以非同步的方法撰寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> money = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'do something'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (money &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    money++</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'money'</span>, money)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'do another thing'</span>)</span><br></pre></td></tr></table></figure>

<p>你會發現輸出的順序變成了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'do something'</span></span><br><span class="line"><span class="string">'do another thing'</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">1</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">2</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">3</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">4</span></span><br><span class="line"><span class="string">'money'</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>現在你會知道了有同步跟非同步兩種寫法，但為何我們需要非同步，以及要怎麼寫非同步的函式呢？</p>
<h1 id="為何需要非同步？"><a href="#為何需要非同步？" class="headerlink" title="為何需要非同步？"></a>為何需要非同步？</h1><p>之所以在 JavaScript 中會需要使用到非同步的用法原因是 JavaScript 的執行期（runtime）本身是單執行緒（single thread）的，因此若在執行程式時遇到需要長時間執行的程式就會使整個 JavaScript 執行阻塞。</p>
<p>而藉任務循環（Event Loop）的機制，JavaScript 會將其函式交由任務序列（Task Queue）來處理，而一些比較常見被定義為非同步的函式如下：</p>
<ul>
<li><code>XMLHttpRequest</code>：預設採用非同步方式取得資料，它另外也提供同步的方式給需要的開發者。</li>
<li><code>fetch</code>：使用非同步的做法取得資料。</li>
<li><code>setTimeout</code>、<code>setInterval</code>：由於 JavaScript 本身沒有計時器，因此執行後會交由瀏覽器的計時器倒數，時間到了才回傳至任務序列（Task Queue）等待任務循環（Event Loop）機制將其傳入主線程。</li>
<li><code>promise</code></li>
</ul>
<h1 id="怎麼寫非同步的函式？"><a href="#怎麼寫非同步的函式？" class="headerlink" title="怎麼寫非同步的函式？"></a>怎麼寫非同步的函式？</h1><p><strong>JavaScript 工程師其實沒辦法自己定義非同步。</strong></p>
<p>沒錯，JavaScript 本身並沒有提供給你一個機制去定義，準確得來說是依照遵循 ECMA 的規則，由各瀏覽器去實作裡面的內容。</p>
<p>如果需要創建一個非同步的程式區塊，我們可以藉由原本就是被定義為非同步的函式搭配使用，而最快的方式就是 <code>setTimeout(fn, 0)</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'開始執行主程式'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'主程式執行完畢'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'再來執行一些東西吧！'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'處理主程式中'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'處理主程式中'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'處理主程式中'</span>)</span><br></pre></td></tr></table></figure>

<p>可以看見輸出結果為：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'開始執行主程式'</span></span><br><span class="line"><span class="string">'處理主程式中'</span></span><br><span class="line"><span class="string">'處理主程式中'</span></span><br><span class="line"><span class="string">'處理主程式中'</span></span><br><span class="line"><span class="string">'主程式執行完畢'</span></span><br><span class="line"><span class="string">'再來執行一些東西吧！'</span></span><br></pre></td></tr></table></figure>

<p>這裡重點在於 <code>setTimeout</code> 本身是非同步的，所以在 JavaScript 執行時期（runtime）中此程式區塊會先在瀏覽器中 API 中的 <code>Timer</code> 等候 <code>0</code> 秒，接著將其中的 callback function 排入任務隊列中，等待任務循環輪詢時執行。</p>
<p>另一個重點則是並非因為只需要等待 <code>0</code> 秒就會是同步的程式區塊。</p>
<p>如果需要更詳細的解釋可以參考：<br>詳見 回呼函式（Callback Function）一文<br>詳見 <code>Event Loop</code> 一文<br>詳見 <code>Promise</code> 一文<br>詳見 <code>Async</code> / <code>Await</code> 一文</p>
<h1 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h1><ul>
<li><a href="https://blog.huli.tw/2019/10/04/javascript-async-sync-and-callback/#sync" target="_blank" rel="noopener">JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 prototype</title>
    <url>/JavaScript/JavaScript-prototype/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p><code>prototype</code> 一直是個 JavaScript 核心裡面最難以解釋的概念，因為光是提到 <code>prototype</code>，就不得不提相關的概念：<code>constructor</code>、<code>__proto__</code>、<code>Function.prototype</code>、<code>Object.prototype</code> ……等等，所以等了一段時間我覺得是時候來講講他了。</p>
<a id="more"></a>


<p>要說為什麼會有 <code>prototype</code> 的出現其實需要考究到當時開發 <code>JavaScript</code> 的創造者 <strong>Brendan Eich</strong> 說起。</p>
<p>在 20 年代初期的瀏覽器當中，一開始使用者並沒有與客戶端（client side）互動的能力，頂多就是用來瀏覽與點擊各種連結的工具，假設有表單要使用者去輸入，發送時也僅能在伺服器端（server side）去做欄位檢查。</p>
<p>而當時對於使用撥接數據機上網的，也就是開起來會「嘰－－嘟嘟嘟嚕－－唰唰唰唰」的年代來說，這樣的體驗並不是很好，因為當時可是連開個頁面都要跑個一兩分鐘以上，當你填好表單結果等了一段時間伺服器才跟你說哪個欄位缺少資訊或錯誤，這種使用者體驗並不是很好。</p>
<blockquote>
<p>那要怎麼辦呢？</p>
</blockquote>
<p>在當時網景公司（Netscape）便想要改善這種很鳥的體驗，他們需要一種可以立刻跟使用者有互動的語言，所以便派了工程師去開發一套語言來做這件事情，沒錯，那個人就是 <strong>Brendan Eich</strong>。</p>
<p>當然 <code>JavaScript</code> 的命名與 <code>Java</code> 之間的關係並不在這篇的討論範圍內，因為我們要來討論 <code>JavaScript</code> 為何會有 <code>prototype</code> 的這件事：</p>
<p>首先 <code>JavaScript</code> 一開始設計理念就是 <strong>不要太複雜</strong>，而在當年程式語言正流行著物件導向設計（oriented），所以在 <strong>JavaScript</strong> 所有的東西都是物件。</p>
<p>如今，我們可以透過 <code>new</code> 關鍵字來透過函式建構式（constructor）建立一個實體物件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I love '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"><span class="keyword">var</span> banana = <span class="keyword">new</span> Fruit(<span class="string">'Banana'</span>)</span><br><span class="line">apple.log() <span class="comment">// I love Apple.</span></span><br><span class="line">banana.log() <span class="comment">// I love Banana.</span></span><br></pre></td></tr></table></figure>
<p>我們可以由上方例子看到 <code>apple</code> 與 <code>banana</code> 雖然都是使用 <code>Fruit</code> 這個建構式所創造出來的物件，但裡面的 <code>log</code> 方法其實是一樣的用法，我們並不需要每次初始化時都建立一個這個函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(apple) <span class="comment">// &#123; name: 'Apple', log: function()&#123; console.log('I love ' + this.name + '.') &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(banana) <span class="comment">// &#123; name: 'banana', log: function()&#123; console.log('I love ' + this.name + '.') &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>假如我要更改其中一個實體中的 <code>log</code> 函式，因為物件指向不同的地方，所以我得一個一個做更改，這時候我們就可以藉由 <code>prototype</code> 來解決這個問題。</p>
<h1 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h1><p><code>prototype</code> 的功用很簡單，其實就是幫助我們將要繼承的方法從建構式中抽離出來：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fruit.prototype.log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I love '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"><span class="keyword">var</span> banana = <span class="keyword">new</span> Fruit(<span class="string">'Banana'</span>)</span><br><span class="line">apple.log() <span class="comment">// I love Apple.</span></span><br><span class="line">banana.log() <span class="comment">// I love Banana.</span></span><br></pre></td></tr></table></figure>

<p>我們可以看見 <code>apple</code> 與 <code>banana</code> 依然能使用 <code>log</code> 方法，但我們來檢查一下他們本身：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(apple) <span class="comment">// &#123; name: 'Apple' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(banana) <span class="comment">// &#123; name: 'banana' &#125;</span></span><br></pre></td></tr></table></figure>

<p>不…不…不見了？</p>
<p>對於物件存取很熟悉的我們都知道用了點標示法存取物件內的東西應該要在物件內阿，可是怎麼在物件中找不到 <code>log</code> 的存在？</p>
<p>而這一切原來就是 <code>__proto__</code> 搞的鬼。</p>
<h1 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h1><p><code>__proto__</code> 這個東西主要就是用來指向繼承的物件是誰，而效果簡單來說就是當你在當下物件中尋找不到某個方法（methods）時，就會循著這 <code>__proto__</code> 去尋找，直到找到 <code>Object.prototype</code> 中的 <code>__proto__</code> 為止（因為該值為 <code>null</code>，意思即是沒有繼承的物件了）。</p>
<p>所以回過頭來看剛才範例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fruit.prototype.log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I love '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"></span><br><span class="line">apple.log() <span class="comment">// I love Apple.</span></span><br><span class="line"><span class="built_in">console</span>.log(apple) <span class="comment">// &#123; name: 'Apple' &#125;</span></span><br></pre></td></tr></table></figure>

<p>對於 <code>apple</code> 來說 <code>apple.__proto__</code> 會尋找到 <code>Fruit.prototype</code> 當中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">apple.__proto__ === Fruit.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因此我們透過 <code>apple.__proto__</code> 在 <code>Fruit</code> 物件裡面找到這個方法並且呼叫他。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Fruit) </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  log: function() &#123; console.log('I love ' + this.name + '.') &#125;,</span></span><br><span class="line"><span class="comment">  constructor: function Fruit(name) &#123; this.name = name &#125;</span></span><br><span class="line"><span class="comment">  __proto__: Function.prototype</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>假如我們要使用連在 <code>Fruit</code> 物件中都沒有的方法，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"></span><br><span class="line">apple.toString()</span><br></pre></td></tr></table></figure>

<p>現在我們知道透過 <code>apple.__proto__</code> 找到 <code>Fruit.prototype</code>，但裡面也沒有，所以又沿著 <code>Fruit.prototype.__proto__</code>，找到了 <code>Function.prototype</code> 裡的方法 <code>toString()</code>。</p>
<p>用 JavaScript 來表示的話，其實我們是呼叫到了 <code>apple.__proto__.__proto__.toString()</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">apple.toString() === apple.__proto__.__proto__.toString() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>而 <code>__proto__</code> 之間的連結也就是所謂的原型鍊（prototype chain）。</p>
<p>值得一提的是：</p>
<ul>
<li>所有物件 <code>__proto__</code> 最後會找到的是 <code>Object.prototype.__proto__</code> 中的 <code>null</code>，表示再也找不到所繼承的物件。</li>
<li>如果方法名稱相同，比如剛才的 <code>Fruit</code> 物件中也有個 <code>toString</code> 方法，則在找到 <code>Object.prototype.toString</code> 之前就會先找到 <code>Fruit.prototype.toString</code>。</li>
</ul>
<h1 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h1><p>但這樣我們要怎麼確認該方法是該物件實體本來的方法，還是透過原型鍊所找到的方法呢？<br>除了我們剛剛用 <code>console.log</code> 直接將 <code>apple</code> 整個叫出來看之外，我們其實可以透過 <code>hasOwnProperty</code> 來確認：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fruit.prototype.log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I love '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(apple) <span class="comment">// &#123; name: 'Apple' &#125;</span></span><br><span class="line">apple.hasOwnProperty(<span class="string">'log'</span>) <span class="comment">// false，log 方法並沒有存在實體中</span></span><br><span class="line">apple.__proto__.hasOwnProperty(<span class="string">'log'</span>) <span class="comment">// true，log 方法是存在 prototype 當中</span></span><br></pre></td></tr></table></figure>


<h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>在 <code>prototype</code> 中我們可以看到除了有物件的方法與 <code>__proto__</code> 之外，裡面還有一個 <code>constructor</code>，而這個 <code>constructor</code> 其實也就是代表建構函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple.constructor) <span class="comment">// function Fruit(name) &#123; this.name = name &#125;</span></span><br></pre></td></tr></table></figure>

<p>現在有整體原型鍊的概念了，我們現在看看 <code>new</code> 做了什麼</p>
<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p><code>new</code> 關鍵字在初始化物件時，做的動作其實就是：</p>
<ul>
<li>建立一個物件</li>
<li>將該物件的 <code>__proto__</code> 指向該函式建構式（constructor）的 <code>prototype</code></li>
<li>呼叫物件中的建構函式（constructor）</li>
<li>把物件回傳（所以我們才能用變數接這個物件）。</li>
</ul>
<p>最後我們要來比較一下初始化物件之間的關係。</p>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p><code>instnaceof</code> 簡單來說就是比較該實體與被比較的關聯式不是在同個原型鍊上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'Apple'</span>)</span><br><span class="line"><span class="keyword">var</span> shawn = <span class="keyword">new</span> Person(<span class="string">'Shawn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(apple <span class="keyword">instanceof</span> Fruit)   <span class="comment">// true，apple 是由 Fruit 所初始化的物件實體</span></span><br><span class="line"><span class="built_in">console</span>.log(shawn <span class="keyword">instanceof</span> Person)  <span class="comment">// true，shawn 是由 Person 所初始化的物件實體</span></span><br><span class="line"><span class="built_in">console</span>.log(apple <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">// true，apple 是由 Fruit 所初始化的物件實體，且 Fruit 物件本身是繼承於 Object 物件</span></span><br><span class="line"><span class="built_in">console</span>.log(shawn <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">// true，shawn 是由 Person 所初始化的物件實體，且 Person 物件本身是繼承於 Object 物件</span></span><br><span class="line"><span class="built_in">console</span>.log(Fruit <span class="keyword">instanceof</span> Person)   <span class="comment">// false，Fruit 並不繼承於 Person</span></span><br><span class="line"><span class="built_in">console</span>.log(Person <span class="keyword">instanceof</span> Fruit)   <span class="comment">// false，Person 並不繼承於 Fruit</span></span><br></pre></td></tr></table></figure>

<p>以上就是基礎的 <code>prototype</code> 的概念！</p>
<p>（其實還有更多細微的可以講，但一起弄懂可能大家都昏了，我們就慢慢提吧 XD）</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 深入淺出 This</title>
    <url>/JavaScript/JavaScript-this/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/JavaScript/JavaScript-logo.png' width='200px' height='200px' />
</div>

<p><code>this</code> 可以在 JavaScript 當中可以說是比 <code>prototype</code> 還要更難懂的概念，但今天要來嘗試以簡潔的方式來說明 <code>this</code> 到底是誰。</p>
<a id="more"></a>

<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>簡單來講，<code>this</code> 依據的是 <strong>函式被呼叫的方式</strong>，而呼叫方式可分為：</p>
<ul>
<li>預設綁定：全域呼叫、呼叫當下參考沒有自物件的函式。</li>
<li>隱含綁定：呼叫當下參考自物件的函式。</li>
<li>被綁定的呼叫：使用 bind、call、apply。</li>
<li>箭頭函式的呼叫。</li>
<li>函式建構式的呼叫。</li>
</ul>
<h1 id="預設綁定、隱含綁定"><a href="#預設綁定、隱含綁定" class="headerlink" title="預設綁定、隱含綁定"></a>預設綁定、隱含綁定</h1><p>隱含綁定主要是依據 <strong>執行當下該行程式碼時有沒有參考物件</strong>，如果沒有參考物件預設則會自動綁定全域物件（在瀏覽器是 <code>window</code>，在 Node.js 是 <code>global</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  getX: getX <span class="comment">// 這裡單純指向上方的 getX 函式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getX() <span class="comment">// 10</span></span><br><span class="line">obj.getX() <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p><code>getX()</code> 該行並沒有參考物件才去呼叫，所以 <code>this</code> 自動綁定全域物件 window，最後找到的是 window.x 的 10</p>
<p>此外如果是嚴格模式（strict mode），如果採用預設綁定， <code>this</code> 將不會自動綁定全域物件，而是給予 <code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  getThis: getThis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getThis() <span class="comment">// undefined</span></span><br><span class="line">obj.getThis() <span class="comment">// obj 本身</span></span><br></pre></td></tr></table></figure>

<p>現在來嘗試看看複雜例子並且想一下答案是什麼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  getX: getX</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj.getX</span><br><span class="line"></span><br><span class="line">getX()      <span class="comment">// ?</span></span><br><span class="line">obj.getX()  <span class="comment">// ?</span></span><br><span class="line">obj2()      <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>getX()</code>：10，因為參考時純粹拿到了該函式並且執行。</p>
</blockquote>
<blockquote>
<p><code>obj.getX()</code> ：20，透過 obj 物件去尋找該方法並呼叫，所以是指向 obj，因此是 obj.x 的值。</p>
</blockquote>
<blockquote>
<p><code>obj2()</code>：10，這裡有個陷阱，實際上該行並沒有參考物件，而是透過一個已經指向 <code>getX</code> 函式的參考去呼叫的</p>
</blockquote>
<p>所以簡單的來說，最主要是專注在執行的該行即可，執行該行所產生的執行環境，<code>this</code> 就綁在它上面！</p>
<p>再來一題：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  getX: getX</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  x: <span class="number">30</span>,</span><br><span class="line">  getX: obj.getX</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = obj2.getX</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj4 = &#123;</span><br><span class="line">  x: <span class="number">40</span>,</span><br><span class="line">  getX: obj3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getX()      <span class="comment">// ?</span></span><br><span class="line">obj.getX()  <span class="comment">// ?</span></span><br><span class="line">obj2.getX() <span class="comment">// ?</span></span><br><span class="line">obj3()      <span class="comment">// ?</span></span><br><span class="line">obj4.getX() <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>getX()</code>：10，剛行沒參考自物件，所以 <code>this</code> 預設綁定在全域上。<br><code>obj.getX()</code> ：20，剛行參考自物件 <code>obj</code>，所以 <code>this</code> 預設綁定在 <code>obj</code> 上。<br><code>obj2.getX()</code>：30，剛行參考自物件 <code>obj2</code>，所以 <code>this</code> 預設綁定在 <code>obj2</code> 上。<br><code>obj3()</code>：10，剛行沒參考自物件，所以 <code>this</code> 預設綁定在全域上。<br><code>obj4.getX()</code>：40，剛行參考自物件 <code>obj4</code>，所以 <code>this</code> 預設綁定在 <code>obj4</code> 上。</p>
</blockquote>
<p>最後一題：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">30</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">    &#125;</span><br><span class="line">    inner()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getX()  <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>obj.getX()</code>：答案為 10。</p>
</blockquote>
<p>剛才說到了執行該行所產生的執行環境，<code>this</code> 就綁在它上面，所以最後 <code>console.log</code> 前所執行的函式是哪句？</p>
<p>如果你看成 <code>obj.getX()</code> ，理所當然的你就會不小心答出 <code>20</code>。</p>
<p>而其實最後執行 <code>console.log</code> 的函式是 <code>inner()</code>，而 <code>inner()</code> 該行並沒有參考其他物件，所以是預設綁定在全域中，也就是 <code>window</code>，因此答案是 <code>10</code>。</p>
<h2 id="預設綁定、隱含綁定實戰中的問題"><a href="#預設綁定、隱含綁定實戰中的問題" class="headerlink" title="預設綁定、隱含綁定實戰中的問題"></a>預設綁定、隱含綁定實戰中的問題</h2><p>有時候我們呼叫函式時不想使用當下的 <code>this</code> 而是想要外層的 <code>this</code> 怎麼辦？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">second</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">  &#125;,second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x:<span class="number">10</span>,</span><br><span class="line">  wait: wait</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.wait(<span class="number">1000</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>在上面這段程式中我們雖然最底下執行當下有參考到 <code>obj</code> 了，但 <code>wait</code> 函式中真正在執行 <code>console.log()</code> 前呼叫的是 <code>window.setTimeout</code> 這個函式，所以其實是參考了 <code>window</code> 這個全域物件並把 <code>this</code> 綁定給他，最後拋出 <code>window.x</code> 的值，也就是 <code>undefined</code>。</p>
<p>所以用 <code>console.log(this)</code> 檢查其實會像這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">second</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)       <span class="comment">// 這個會指向執行當下該行呼叫函式的物件，在這範例中會指向 obj</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)     <span class="comment">// 這個會指向 window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">  &#125;,second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x:<span class="number">10</span>,</span><br><span class="line">  wait: wait</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.wait(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>確認 <code>this</code> 的範疇後，我們就可以利用作用域的特性（找不到變數值會向外層找）來實現抓取外面的 <code>this</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">second</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span> <span class="comment">// obj</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x) <span class="comment">// window.x</span></span><br><span class="line">    <span class="built_in">console</span>.log(that.x) <span class="comment">// obj.x</span></span><br><span class="line">  &#125;,second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x:<span class="number">10</span>,</span><br><span class="line">  wait: wait</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.wait(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>至於那個 <code>that</code> 主要是用來儲存 <code>this</code> 指向用的，另外也有人會取名為 <code>self</code> 等等名稱。</p>
<p>如果這個方法還不喜歡的話，可以繼續往下看看其他綁定方法。</p>
<h1 id="強制綁定-bind、call、apply"><a href="#強制綁定-bind、call、apply" class="headerlink" title="強制綁定 bind、call、apply"></a>強制綁定 bind、call、apply</h1><p>除了上面這種預設綁定與隱含（implicit）綁定之外，接下來要介紹強制綁定的三種方法。</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><code>bind</code> 的用法主要是在呼叫時加上綁定 <code>this</code> 的物件對象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  x: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getX()              <span class="comment">// 10</span></span><br><span class="line">getX.bind(obj)()    <span class="comment">// 20</span></span><br><span class="line">getX.bind(obj2)()   <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>原本 <code>getX()</code> 執行到該行時會由於該行當下沒有去其他物件中尋找函式，所以會採預設綁定在 <code>window</code> 當中，但透過 <code>bind</code> 的綁定，我們可以在呼叫時將 <code>this</code> 指定給另一個物件，因而可以參考到不同的物件當中。</p>
<p>上面所提到的實戰的部分也可以用 <code>bind</code> 解決</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">second</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x) <span class="comment">// 10</span></span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>),second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x:<span class="number">10</span>,</span><br><span class="line">  wait: wait</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.wait(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>上面的程式範例中，我們透過 <code>bind</code> 綁定了 <code>setTimeout</code> 裡面的 <code>this</code>，因此每次呼叫 <code>wait</code> 時，裡面 <code>setTimeout</code> 中回呼函式內的 <code>this</code> 都會與外面相同了，而不會被 <code>window.setTimeout</code> 的 <code>window</code> 物件所影響到。</p>
<h2 id="call、apply"><a href="#call、apply" class="headerlink" title="call、apply"></a>call、apply</h2><p><code>call</code>、<code>apply</code> 的用法比較接近，差別在使用時會立即呼叫該函式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params">num = <span class="number">0</span>, anotherNum = <span class="number">0</span></span>)</span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x + num + anotherNum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  getX: getX</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addX(<span class="number">1</span>, <span class="number">2</span>)              <span class="comment">// 13</span></span><br><span class="line">addX.call(obj, <span class="number">1</span>, <span class="number">2</span>)    <span class="comment">// 23</span></span><br><span class="line">addX.apply(obj, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>call()，第一個參數是要綁定 <code>this</code> 的物件，後續帶入參數是用逗號來區隔。</p>
</blockquote>
<blockquote>
<p>apply()，第一個參數也是綁定 <code>this</code> 的物件，但後續帶入參數是放在一個陣列當中。</p>
</blockquote>
<h1 id="箭頭函式的呼叫"><a href="#箭頭函式的呼叫" class="headerlink" title="箭頭函式的呼叫"></a>箭頭函式的呼叫</h1><p>箭頭函式（arrow function）本身並沒有 <code>this</code>，並且會遵循一般變數查找的邏輯來運作，因此在箭頭函式中的 <code>this</code> 如同綁定在<strong>函式宣告之處</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x) <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x) <span class="comment">// 10</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x) <span class="comment">// 20</span></span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  getX: getX</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getX()</span><br></pre></td></tr></table></figure>
<p>第一個 <code>setTimeout</code> 我們在上集已經討論過它是綁定到全域當中，所以最後會撈到 <code>window.x</code>。</p>
<p>然而第二個 <code>setTimeout</code> 中的回呼函式用了箭頭函式的寫法，因此在即時直譯的過程中在箭頭函式內是找不到 <code>this</code> 的，接著他會如同我們在找變數值所參考作用域的情況一樣，向外層作用域去尋找 <code>this</code>，最後在 <code>getX</code> 作用域找到了當下執行環境中的 <code>this</code>，也就是由 <code>obj.getX()</code> 所創造出來的 <code>this</code>。（如第一個 <code>console.log</code> 當下的作用域一樣）</p>
<p>現在我們便知道為何用在箭頭函式中的 <code>this</code> 如同綁定在<strong>函式宣告之處</strong>的這個由來了。</p>
<h2 id="箭頭函式的呼叫-in-嚴格模式"><a href="#箭頭函式的呼叫-in-嚴格模式" class="headerlink" title="箭頭函式的呼叫 in 嚴格模式"></a>箭頭函式的呼叫 in 嚴格模式</h2><p>箭頭函式中的 <code>this</code> 另一個值得一提的就是在嚴格模式下，以往嚴格模式是禁止預設綁定到全域當中，並且會給予 <code>undefined</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getX()    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>但如果是使用箭頭函式的話就沒有這個限制：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">var</span> getX = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getX()    <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<p>以上就是箭頭函式對於 <code>this</code> 的影響，最後再來談談個 <code>new</code>。</p>
<h1 id="new-的綁定"><a href="#new-的綁定" class="headerlink" title="new 的綁定"></a>new 的綁定</h1><p><code>new</code> 關鍵字主要是用來初始化函式建構式，而使用 <code>new</code> 的當下，<code>this</code> 就會綁定在對應的物件上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'apple'</span>)    <span class="comment">// &#123;name: "apple"&#125;</span></span><br><span class="line"><span class="keyword">var</span> banana = <span class="keyword">new</span> Fruit(<span class="string">'Banana'</span>)  <span class="comment">// &#123;name: "Banana"&#125;</span></span><br><span class="line"></span><br><span class="line">Fruit(<span class="string">'nothing'</span>) <span class="comment">// window.name =&gt; nothing</span></span><br></pre></td></tr></table></figure>

<p>雖然不是很完整，到這邊為止 <code>this</code> 的觀念已經可以解決大部分一般的 <code>this</code> 問題了。</p>
<blockquote>
<p>如果還想繼續深究 <code>this</code> 的話我只能推這篇<a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">文章</a>了</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入淺出</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest.js 入門、環境建置與範例（Install, Build environment）</title>
    <url>/Jest.js/Jest-001-intro/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="jest-logo" src='/images/Jest/jest-logo.png' width='200px' height='200px' />
</div>

<h1 id="What-is-Jest-js"><a href="#What-is-Jest-js" class="headerlink" title="What is Jest.js"></a>What is Jest.js</h1><p>Jest.js 是由 Facebook, Inc 公司所維護的測試框架，並且支援了 Babel、TypeScript、Node.js、Vue.js、React.js、Angular.js，基本上支援了全部的現代框架，而 Jest 的核心概念 <strong>batteries-included</strong>，使得我們在使用測試要找一些資源時不太需要費力，因為，Jest 都幫你準備好了！</p>
<a id="more"></a>

<h1 id="環境建置"><a href="#環境建置" class="headerlink" title="環境建置"></a>環境建置</h1><p>環境建置非常的快速，透過 npm 直接安裝 Jest 到 <strong>專案開發環境</strong> 下就完成了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev jest</span><br></pre></td></tr></table></figure>

<h1 id="測試範例"><a href="#測試範例" class="headerlink" title="測試範例"></a>測試範例</h1><p>在專案資料夾中直接新建一個 <code>sum.js</code> 檔案：</p>
<p><strong>sum.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = sum;</span><br></pre></td></tr></table></figure>

<p>你可以直接在同層資料夾新建一個 <code>sum.test.js</code> 檔案，並引入剛才建立好的 <code>sum.js</code> 檔（當然，仍然建議是在 <code>src/__test__/</code> 資料夾底下集中會比較好管理）：</p>
<p><strong>sum.test.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="built_in">require</span>(<span class="string">'./sum'</span>)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'adds 1 + 2 to equal 3'</span>, () =&gt; &#123;</span><br><span class="line">  expect(sum(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>目前的專案目錄應該看起來像是這樣：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">├── node_modules/</span><br><span class="line">├── src/</span><br><span class="line">│   └── __test__/</span><br><span class="line">│      └── sum<span class="selector-class">.test</span><span class="selector-class">.js</span>     <span class="comment">// 剛剛寫好的測試程式碼</span></span><br><span class="line">├── sum<span class="selector-class">.js</span>                 <span class="comment">// 剛剛寫好的程式</span></span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
</blockquote>
<p>接著將 <code>package.json</code> 設定檔增加一條快捷碼：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"jest"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接在終端機下輸入 <code>npm run test</code> 即可跑出測試：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PASS  ./sum.test.js</span><br><span class="line"> √ adds 1 + 2 to equal 3 (5ms)</span><br></pre></td></tr></table></figure>

<p>這個範例簡單的展示了 Jest 測試框架的魅力，自帶的斷言庫（assertion）讓我們在使用斷言判斷時可以與官方較有一致的行為，有利於後續的學習方面（官方文件）及相關的問題討論資源，如果看了 Intro 之後對 Jest.js 感到興趣的話不仿一起來用 Jest.js 吧！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://jestjs.io/docs/en/getting-started" target="_blank" rel="noopener">Jest-getting-started</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Jest.js</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Jest.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest.js 配對器（Matchers）a.k.a. 斷言（Assertion）</title>
    <url>/Jest.js/Jest-002-matchers-assertion/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="jest-logo" src='/images/Jest/jest-logo.png' width='200px' height='200px' />
</div>

<h1 id="斷言-Assertion"><a href="#斷言-Assertion" class="headerlink" title="斷言 Assertion"></a>斷言 Assertion</h1><p>在測試庫中，斷言（assertion）是一個很重要的概念，意思即為開發程式中執行完畢時，程式碼執行結果應與斷言所設定的結果一致，否則該處斷言碼會拋出錯誤的意思。你可能已經在某些情況下「斷言」過好幾次了，例如在 JavaScript 裡面使用全等比較（<code>===</code>）來比較兩者的資料類型是否一致，這便是斷言。而在 Jest.js 框架中，Jest 選擇的是使用 Matchers 配對器這個名稱，兩者其實在概念上是差不多的東西。</p>
<p>Jest.js 中的配對器（Matchers），主要採用的是 <code>expect()</code> 的方法，但 Jest.js 中的 expect 與 Node.js 和其他斷言庫（如 Chai.js）中的 <code>expect()</code> 是不一樣的，別搞混了！XD，我自認為比較好辨識 Jest 方法是當斷言中出現了 <code>expect().toBe()</code> 這個東西，基本上看到這個可以確認大概率是使用 Jest.js 了。</p>
<p>而為什麼辨識文件中是用誰家的斷言有一點小重要的點是，當你試著按照例如 Vue.js 的測試文件 Vue-test-utils 測試時，可能會遇到斷言方法 API 不一樣的情況，那麼你可能得回去翻翻其他斷言庫本身的斷言 API 文件了。</p>
<a id="more"></a>

<h1 id="配對器-Matchers"><a href="#配對器-Matchers" class="headerlink" title="配對器 Matchers"></a>配對器 Matchers</h1><p>在 Jest.js 中，我們可以直接使用 <code>expect()</code> 來寫斷言中的期望值，而關於 <code>expect</code> API 官方也有整理很棒的<a href="https://jestjs.io/docs/zh-Hans/expect" target="_blank" rel="noopener">列表</a>可以看，私心覺得比起隔壁棚的框架好讀多了（？<br>但在一開始學習配對器時，或許我們可能不是每個都會用得到，因此接下來，我們要跟著官方的範例一起來看看幾個常用的 API。</p>
<h2 id="toBe"><a href="#toBe" class="headerlink" title="toBe()"></a>toBe()</h2><p>一開始我們可以使用 <code>expect()</code> 來寫斷言中的期望值，後面接上 <code>.toBe()</code> 來寫下預期的配對值，<code>toBe()</code> 最主要的功用是在與檢查<strong>值的相等</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'1 加上 1 等於 2'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">1</span> + <span class="number">1</span>).toBe(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="toEqual"><a href="#toEqual" class="headerlink" title="toEqual()"></a>toEqual()</h2><p>如果要檢查<strong>資料型別（data type）</strong>的話，官方建議使用 <code>toEqual()</code> 來判斷（因為在 JavaScript 中物件會有記憶體存取位置不同而導致某些議題產生）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'物件中的值應該相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">'shawn'</span>&#125;</span><br><span class="line">  person[age: <span class="number">25</span>]</span><br><span class="line">  expect(obj).toEqual(&#123;<span class="attr">name</span>: <span class="string">'shawn'</span>, <span class="attr">age</span>: <span class="number">25</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Truthiness-類"><a href="#Truthiness-類" class="headerlink" title="Truthiness 類"></a>Truthiness 類</h2><p>Truthiness 主要在判斷的是有關於真假值上的問題，有經驗的開發者應該都體會過 JavaScript 中 truthy 與 falsy 的威力…（害怕.png），但在 Jest.js 中有一系列的真假值斷言可以直接使用。</p>
<ul>
<li>toBeNull： 斷言 null 值。</li>
<li>toBeUndefined： 斷言 undefined 值。</li>
<li>toBeDefined： 斷言不是 undefined 值。</li>
<li>toBeTruthy： 斷言該值在 if 判斷句中為 truthy。</li>
<li>toBeFalsy： 斷言該值在 if 判斷句中為 falsy。</li>
</ul>
<h2 id="Number-類"><a href="#Number-類" class="headerlink" title="Number 類"></a>Number 類</h2><p>數字類基本上就是那幾位大於小於等於家族。</p>
<ul>
<li>.toBeGreaterThan()：大於。</li>
<li>.toBeGreaterThanOrEqual()：大於等於。</li>
<li>.toBeLessThan()：小於。</li>
<li>.toBeLessThanOrEqual()：小於等於。</li>
<li>.toBe()：等於，同上方介紹。</li>
<li>.toEqual()：等於，同上方介紹。</li>
</ul>
<h2 id="String-類"><a href="#String-類" class="headerlink" title="String 類"></a>String 類</h2><ul>
<li>.toMatch：可以利用正則表達式（Regex）來配對是否相等。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'"test" is not to match "text"'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="string">'test'</span>).not.toMatch(<span class="regexp">/text/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Array、Iterables"><a href="#Array、Iterables" class="headerlink" title="Array、Iterables"></a>Array、Iterables</h2><ul>
<li>.toContain()：比較陣列或可迭代的值是否含有某個特定值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> favoFruits = [<span class="string">'orange'</span>, <span class="string">'banana'</span>, <span class="string">'strawberry'</span>]</span><br><span class="line">test(<span class="string">'my favo fruits'</span>, () =&gt; &#123;</span><br><span class="line">  expect(favoFruits).toContain(<span class="string">'durian'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="例外處理"><a href="#例外處理" class="headerlink" title="例外處理"></a>例外處理</h2><ul>
<li>.toThrow()：程式中可能會需要會拋出錯誤的情況，要比對是否拋出可以使用此 API。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwErrorMsg</span> (<span class="params">Msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(Msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'it should throw Error Msg'</span>, () =&gt; &#123;</span><br><span class="line">  expect(throwErrorMsg(<span class="string">'Error: Account data is missing.'</span>)).toThrow()</span><br><span class="line">  expect(throwErrorMsg(<span class="string">'Error: Account data is missing.'</span>)).toThrow(<span class="built_in">Error</span>)</span><br><span class="line">  expect(throwErrorMsg(<span class="string">'Error: Account data is missing.'</span>)).toThrow(<span class="string">'Error: Account data is missing.'</span>)</span><br><span class="line">  expect(throwErrorMsg(<span class="string">'Error: Account data is missing.'</span>)).toThrow(<span class="regexp">/missing/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上是 Jest.js 一些常見的配對器，接下來的章節將會介紹有關於一些 callback function、promise、async 與 await 等等的處理。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://jestjs.io/docs/en/using-matchers" target="_blank" rel="noopener">Jest-using-matchers</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Jest.js</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Jest.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest.js 設定、拆除與作用域（setup、teardown &amp; scope）、執行順序</title>
    <url>/Jest.js/Jest-004-setup-teardown/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="jest-logo" src='/images/Jest/jest-logo.png' width='200px' height='200px' />
</div>


<h1 id="setup、teardown"><a href="#setup、teardown" class="headerlink" title="setup、teardown"></a>setup、teardown</h1><p>在執行測試時，有時候會需要初始化一些基本資料以供測試進行，並且在測試完畢的時候要讓測試後的資料復原、整理。</p>
<p>而 Jest 在這方面提供的 API 如下：</p>
<ul>
<li><strong>describe()</strong>：測試套件，可以針對測試鉤子形成作用域（scope）並描述該部分的測試情境。</li>
<li><strong>test()</strong>：測試案例，用以描述該筆正在進行的測試內容與設定相關測試條件。（也可以使用別名 <code>it()</code>）</li>
<li><strong>beforeAll()</strong>：針對該<strong>測試套件</strong>的作用域，在<strong>第一筆</strong>測試案例<strong>開始前</strong>執行一次。</li>
<li><strong>afterAll()</strong>：針對該<strong>測試套件</strong>的作用域，在<strong>最後一筆</strong>測試案例<strong>結束後</strong>執行一次。</li>
<li><strong>beforeEach()</strong>：針對該<strong>測試套件</strong>的作用域，在<strong>每個</strong>測試案例<strong>開始前</strong>執行一次。</li>
<li><strong>afterEach()</strong>：針對該<strong>測試套件</strong>的作用域，在<strong>每個</strong>測試案例<strong>結束前</strong>執行一次。</li>
</ul>
<a id="more"></a>

<p>快速看個案例！</p>
<p>這裡先設置了一個基本的函式 <code>sum.js</code>，並且用 <code>module.exports</code> 來導出：</p>
<p><strong>sum.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = sum</span><br></pre></td></tr></table></figure>

<p>接著來寫給 Jest.js 跑測試用的測試程式碼：</p>
<p><strong>function.test.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入寫好的程式</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="built_in">require</span>(<span class="string">'./sum'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sumResult = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> randomNumberA = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> randomNumberB = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 設定每次測試案例要用的資料，這裡使用 random() 函式賦予每次案例不同的值。</span></span><br><span class="line">    randomNumberA = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>) <span class="comment">// 0 ~ 10</span></span><br><span class="line">    randomNumberB = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>) <span class="comment">// 0 ~ 10</span></span><br><span class="line">    sumResult = randomNumberA + randomNumberB</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'add 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">  expect(sum(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'add 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">  expect(sumResult).toBe(randomNumberA + randomNumberB)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>執行測試後秀出結果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> PASS  ./sum.test.js</span><br><span class="line">  √ add 函式返回兩者相加的值</span><br><span class="line">  √ add 函式返回兩者相加的值</span><br><span class="line">Test Suites: 1 passed, 1 total</span><br><span class="line">Tests:       2 passed, 2 total</span><br><span class="line">Snapshots:   0 total</span><br><span class="line">Time:        3.786s</span><br><span class="line">Ran all <span class="built_in">test</span> suites.</span><br></pre></td></tr></table></figure>

<h1 id="scope-與-執行順序"><a href="#scope-與-執行順序" class="headerlink" title="scope 與 執行順序"></a>scope 與 執行順序</h1><p>使用 JavaScript 都知道 JavaScript 擁有它的作用域，而在 Jest 中也有屬於它自己的作用域，官方提供了兩個很簡單能分別看出 Hook 之間與 <code>describe()</code>、<code>test()</code> 之間執行順序的測試程式碼：</p>
<h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><p>在鉤子中的順序我們可以透過以下程式碼來測試：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1 - beforeAll'</span>));</span><br><span class="line">afterAll(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1 - afterAll'</span>));</span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1 - beforeEach'</span>));</span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1 - afterEach'</span>));</span><br><span class="line">test(<span class="string">''</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'1 - test'</span>));</span><br><span class="line">describe(<span class="string">'Scoped / Nested block'</span>, () =&gt; &#123;</span><br><span class="line">  beforeAll(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2 - beforeAll'</span>));</span><br><span class="line">  afterAll(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2 - afterAll'</span>));</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2 - beforeEach'</span>));</span><br><span class="line">  afterEach(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2 - afterEach'</span>));</span><br><span class="line">  test(<span class="string">''</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'2 - test'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我們試著觀察測試結果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">● Console</span><br><span class="line">  1 - beforeAll    <span class="comment"># 全域級：最外層雖沒有明寫 describe()，但整個檔案其實算是一個測試套件，因此開始前就會執行一次。</span></span><br><span class="line">  1 - beforeEach   <span class="comment"># 全域級：每個測試案例前執行。</span></span><br><span class="line">  1 - <span class="built_in">test</span>         <span class="comment"># 全域級：測試案例。</span></span><br><span class="line">  1 - afterEach    <span class="comment"># 全域級：每個測試案例後執行。</span></span><br><span class="line">  <span class="comment"># 從這裡進入巢狀級測試套件</span></span><br><span class="line">  2 - beforeAll    <span class="comment"># 巢狀級：測試套件開始時執行一次。</span></span><br><span class="line">  1 - beforeEach   <span class="comment"># 全域級：每個測試案例前執行。</span></span><br><span class="line">  2 - beforeEach   <span class="comment"># 巢狀級：每個測試案例前執行。</span></span><br><span class="line">  2 - <span class="built_in">test</span>         <span class="comment"># 巢狀級：測試案例。</span></span><br><span class="line">  2 - afterEach    <span class="comment"># 巢狀級：每個測試案例後執行。</span></span><br><span class="line">  1 - afterEach    <span class="comment"># 全域級：每個測試案例後執行。</span></span><br><span class="line">  2 - afterAll     <span class="comment"># 巢狀級：測試套件結束時執行一次。</span></span><br><span class="line">  <span class="comment"># 從這裡離開巢狀級測試套件</span></span><br><span class="line">  1 - afterAll     <span class="comment"># 巢狀級：測試套件結束時執行一次。</span></span><br></pre></td></tr></table></figure>

<p>我們可以看到了幾個重點：</p>
<ol>
<li>整個檔案算是一個測試套件，因此全域級別的鉤子都會觸發。</li>
<li>測試開始前 <code>*All</code> 系列的鉤子先於 <code>*Each</code> 系列鉤子；離開時， <code>*All</code> 系列的鉤子則是後於 <code>*Each</code> 系列鉤子。</li>
<li><code>*Each</code> 系列的鉤子不僅只有在當下的級別執行，甚至還會往巢狀的測試套件中也執行。</li>
<li><code>*Each</code> 系列的鉤子，在測試案例前 <strong>全域級</strong> 的鉤子先於 <strong>巢狀級</strong> 的鉤子；在測試案例後， <strong>全域級</strong> 系列的鉤子則是後於 <strong>巢狀級</strong> 的鉤子。</li>
</ol>
<p>簡單來說的話便是：整個鉤子邏輯是屬於後進先出（LIFO，Last in, First Out）原則的，並且父層的鉤子邏輯會<strong>完整</strong>的套用在子層鉤子邏輯中。</p>
<h2 id="describe-與-test-之間的執行順序"><a href="#describe-與-test-之間的執行順序" class="headerlink" title="describe() 與 test() 之間的執行順序"></a>describe() 與 test() 之間的執行順序</h2><p>我們一樣透過官方範例程式碼來測試並觀察：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'outer'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'describe outer-a'</span>)</span><br><span class="line">  describe(<span class="string">'describe inner 1'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'describe inner 1'</span>)</span><br><span class="line">    test(<span class="string">'test 1'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test for describe inner 1'</span>)</span><br><span class="line">      expect(<span class="literal">true</span>).toEqual(<span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'describe outer-b'</span>)</span><br><span class="line">  test(<span class="string">'test 1'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test for describe outer'</span>)</span><br><span class="line">    expect(<span class="literal">true</span>).toEqual(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  describe(<span class="string">'describe inner 2'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'describe inner 2'</span>)</span><br><span class="line">    test(<span class="string">'test for describe inner 2'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'test for describe inner 2'</span>)</span><br><span class="line">      expect(<span class="literal">false</span>).toEqual(<span class="literal">false</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'describe outer-c'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>執行的結果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">describe outer<span class="_">-a</span></span><br><span class="line">describe inner 1</span><br><span class="line">describe outer-b</span><br><span class="line">describe inner 2</span><br><span class="line">describe outer-c</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> describe inner 1</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> describe outer</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> describe inner 2</span><br></pre></td></tr></table></figure>

<p>從上列測試碼中我們可以看出幾個重點：</p>
<ol>
<li><code>describe()</code> 的執行順序會優先於所有測試之前，接著才會開始執行 <code>test()</code> 的內容。</li>
<li>遵循上面的規則後，由上到下逐步執行每個測試內容。</li>
</ol>
<p>以上是關於 Jest 測試環境中的設定與執行順序，而真正要寫好測試還是得靠我們自己從實務上去慢慢證明想法與測試碼邏輯是否一致！</p>
<p>如果不確定的話也可以下個簡單的斷言來看斷點是否正常，有時候可能只是不慎打錯字才導致測試失敗喔！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://jestjs.io/docs/zh-Hans/setup-teardown" target="_blank" rel="noopener">Jest-setup-teardown</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Jest.js</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Jest.js</tag>
      </tags>
  </entry>
  <entry>
    <title>程式設計心法 避免重複原則（DRY principle）</title>
    <url>/Methodology/Methodology-001-DRY-principle/</url>
    <content><![CDATA[<h1 id="DRY-原則"><a href="#DRY-原則" class="headerlink" title="DRY 原則"></a>DRY 原則</h1><p>這次要來介紹的是我覺得開發程式中最有感的<strong>避免重複原則</strong>（簡稱 DRY 原則，意思即為 Don’t repeat youself!）。</p>
<p>根據此篇<a href="https://www.sharmaprakash.com.np/four-types-of-duplication-in-source-code/#" target="_blank" rel="noopener">文章</a>所述，在 The Pragmatic Programmer 一書中，DRY 發生的原因總共可以分為四種類別：</p>
<ul>
<li>強加的重複(Imposed duplication)</li>
<li>無意的重複(inadvertent duplication)</li>
<li>懶惰的重複(impatient duplication)</li>
<li>開發者間的重複(inter-developer duplication)：</li>
</ul>
<p>以下是四種類別所表示的意義：</p>
<a id="more"></a>

<h2 id="強加的重複-Imposed-duplication"><a href="#強加的重複-Imposed-duplication" class="headerlink" title="強加的重複 Imposed duplication"></a>強加的重複 Imposed duplication</h2><p>這一類的重複是發生在開發者自認為是<strong>開發環境需要</strong>的、被強迫需要的重複，像是<strong>不必要的註解</strong>以及<strong>開發文件</strong>等等。</p>
<p>例如我們寫了一些有關 cookie 用的函式，並為其加上了使用註解，但其實從函式名稱本身就能夠得知其用途：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 這是用來取得 cookie 值的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span> (<span class="params">cname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="string">"; "</span> + <span class="built_in">document</span>.cookie</span><br><span class="line">    <span class="keyword">let</span> parts = value.split(<span class="string">"; "</span> + cname + <span class="string">"="</span>)</span><br><span class="line">    <span class="keyword">if</span> (parts.length == <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> parts.pop().split(<span class="string">";"</span>).shift()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這是用來設定 cookie 值的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span> (<span class="params">cname, cvalue, exdays</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    d.setTime(d.getTime() + (exdays*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>))</span><br><span class="line">    <span class="keyword">let</span> expires = <span class="string">`expires=<span class="subst">$&#123;d.toUTCString()&#125;</span>`</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.cookie = <span class="string">`<span class="subst">$&#123;cname&#125;</span>=<span class="subst">$&#123;cvalue&#125;</span>;<span class="subst">$&#123;expires&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一例則是撰寫開發文件上沒有即時更新的結果，使註解變成多餘；即便是撰寫文檔也與程式中的內容重疊：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* get member data via Number type Member ID.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>id member ID</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;object&#125;</span> </span>member data.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMemberData</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 結果裡面的處理後來需要使用到 Number 類型的 id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>個人認為對於此分類的解決辦法便是使用<strong>清晰可辨別的命名</strong>，註解與文檔在非必要下的情況可以透過命名的方式來解決，例如第一例已經很清楚地寫出該函式的作用，就不必再重複註解；而若是使用函式的 jsDoc 註解，則應該注意內部邏輯，讓程式<strong>本身敘述正在做的事情</strong>會來得更有效率。</p>
<h2 id="無意的重複-inadvertent-duplication"><a href="#無意的重複-inadvertent-duplication" class="headerlink" title="無意的重複 inadvertent duplication"></a>無意的重複 inadvertent duplication</h2><p>第二類是屬於開發者沒有意識到內容上的重複，通常出現在<strong>邏輯設計上</strong>的內容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cube</span>(<span class="params">length, width, height, volumn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.length = length</span><br><span class="line">  <span class="keyword">this</span>.width = width</span><br><span class="line">  <span class="keyword">this</span>.height = height</span><br><span class="line">  <span class="keyword">this</span>.volumn = volumn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cube.prototype.getVolumn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.volumn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sixCMcube = <span class="keyword">new</span> Cube(<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>)</span><br><span class="line">sixCMcube.getVolumn()</span><br></pre></td></tr></table></figure>

<p>在這個例子中，首先我們已知 Cube（立方體）長寬高都一樣的情況下，只要給一個邊長（length）即可；除此之外 volumn（體積）其實也就是邊長的三次方，可以由建構式內部算完即可，不應該使其成為公共變數（public variable），因此更改後如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cube</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.length = length</span><br><span class="line">  <span class="keyword">this</span>.volumn = <span class="built_in">Math</span>.pow(length, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cube.prototype.getVolumn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.volumn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sixCMcube = <span class="keyword">new</span> Cube(<span class="number">6</span>)</span><br><span class="line">sixCMcube.getVolumn()</span><br></pre></td></tr></table></figure>

<h2 id="懶惰的重複-impatient-duplication"><a href="#懶惰的重複-impatient-duplication" class="headerlink" title="懶惰的重複 impatient duplication"></a>懶惰的重複 impatient duplication</h2><p>開發者為了節省時間上的重複，可能發生在使用 CV （複製貼上）大法的時候，尤其複製的程式碼量一大的時候，很有可能遺漏某些需要更改的東西。例如在實作多欄位的搜尋表單，有時候只是值上的替換，其程式碼模樣大同小異，就很有可能在複製貼上完後，忘記更改某個表單欄位的 id 值等等。</p>
<p>個人解決辦法是撰寫測試程式碼或模擬（Mock）程式碼，例如單元測試（Unit test）來觀測各函式的結果是否符合預期結果；如此一來可以節省打斷點、寫 <code>console.log</code> 的時間又能同時日後對於維護程式碼的信心度。</p>
<h2 id="開發者間的重複-inter-developer-duplication"><a href="#開發者間的重複-inter-developer-duplication" class="headerlink" title="開發者間的重複 inter-developer duplication"></a>開發者間的重複 inter-developer duplication</h2><p>最難解決也最常發生的重複議題，通常發生在開發者與開發者之間的<del>決鬥</del> 協作開發或接手開發的時候，因為在同個專案底下很容易有共同的需求，有時候沒有協調好或是接手專案對於架構不清楚時，容易開發出概念上重複的程式碼。</p>
<p>最簡單的例子就如同上面第一則 <code>cookie</code> 實作的函式一樣，有可能前人開發時已經有實作 <code>cookie</code> 的 <code>get</code>、<code>set</code> 與 <code>delete</code> 等方法，然後自己又實作了一次相關的方法。</p>
<h1 id="實行-DRY-時的危險之處？"><a href="#實行-DRY-時的危險之處？" class="headerlink" title="實行 DRY 時的危險之處？"></a>實行 DRY 時的危險之處？</h1><p>在遵循 DRY 原則的時候，有時得適度的拿捏這個原則的比例，避免有時為了避免 DRY 而<strong>過度抽象化（Abstraction）</strong>了某個函式的概念，反而犧牲了<strong>可讀性（readability）</strong>。因為就本質上來說其實抽象化與可讀性來說是<strong>矛盾的</strong>概念。因為我們需要抽象來簡化、避免重複程式碼，但同時我們也得兼顧程式碼的易讀性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">symbolParser</span> (<span class="params">source = <span class="string">''</span>, splitSymbol = <span class="string">'/'</span>, filterSymbol = <span class="string">'_'</span>, reverseParseResult = false</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> parseStorage = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> reverseResult = reverseParseResult ? [<span class="number">0</span>,<span class="number">1</span>] : [<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    source</span><br><span class="line">        .split(<span class="string">' '</span>)</span><br><span class="line">        .join(<span class="string">''</span>)</span><br><span class="line">        .split(splitSymbol)</span><br><span class="line">        .filter(<span class="function"><span class="params">req</span> =&gt;</span> req.indexOf(filterSymbol) &gt; <span class="number">-1</span>)</span><br><span class="line">        .forEach(<span class="function"><span class="params">req</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> parse = req.split(filterSymbol)</span><br><span class="line">            parseStorage[parse[reverseResult[<span class="number">0</span>]]] = parse[reverseResult[<span class="number">1</span>]]</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> parseStorage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">'firstname=Shawn&amp;lastname=Lin&amp;Age=25'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> textAfterParse = symbolParser(text, <span class="string">'&amp;'</span>, <span class="string">'='</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(textAfterParse)     <span class="comment">// return &#123;firstname: 'Shawn', lastname: 'Lin', Age: "25"&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>雖然這個函式可以應變不同種的字串（如 url 中的 parameter 或 cookie 中的值）並返回其物件形式，使在解析字串上達到了 DRY 原則，只要解析字串就用這個函式便能快速完成！<br>但是當函式有狀況需要更改調整的時候，能夠使其他開發者能<strong>快速的看出各個實作處理是為什麼要這麼做嗎？</strong></p>
</blockquote>
<p>另一個危險的開端則是類似於<strong>過早最佳化原則（premature-optimization）</strong>所提到的概念。在發生 DRY 的時候，我們可能會忍受不住 DRY 的原則，看到重複就忍不住想改動、優化，但是<strong>真的每次都有達到重複的涵義嗎？</strong></p>
<p>以上方的例子來說，我們有沒有必要使用<strong>同一隻函式</strong>來解決這種解析的需求？針對 <code>cookies</code> 時，使用前面提到的 <code>getCookie</code>、<code>setCookie</code> 會不會更加的容易閱讀？使用了 <code>symbolParser</code> 函式得到了含有全部 <code>cookie</code> 的值時，是否還要再實作寫入 <code>cookies</code> 的函式？諸如此類的問題會在<strong>死命奉守 DRY 原則</strong>時陸續出現，而我們應當使我們的程式保有彈性與自由，才不會因 DRY 而被過度局限於某些情境下。</p>
<p>因此，在遵循 DRY 心法時，仍別忘了考量到避免<strong>過度抽象化（over-abstraction）</strong>與<strong>過早最佳化（premature-optimization）</strong>等議題；適度抽象、適度避免 DRY，最後優化的部分等後續維護時真的出現問題再來解決吧！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://www.itread01.com/p/1318618.html" target="_blank" rel="noopener">優秀程式設計的原則</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/01/abstraction_principles.html" target="_blank" rel="noopener">代码的抽象三原则</a></li>
<li><a href="https://www.cnblogs.com/zhixin9001/p/6777608.html" target="_blank" rel="noopener">《程序员修炼之道》笔记(二)</a></li>
<li><a href="http://www.rocidea.com/one?id=33839" target="_blank" rel="noopener">DRY原則的誤區</a></li>
<li><a href="https://stackoverflow.com/questions/17788738/is-violation-of-dry-principle-always-bad" target="_blank" rel="noopener">Is violation of DRY principle always bad?</a></li>
</ul>
]]></content>
      <categories>
        <category>Methodology</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Methodology</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest.js 測試替身 Test double &amp; Mocks Functions</title>
    <url>/Jest.js/Jest-005-test-double-and-mocks/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="jest-logo" src='/images/Jest/jest-logo.png' width='200px' height='200px' />
</div>

<h1 id="Test-double-測試替身"><a href="#Test-double-測試替身" class="headerlink" title="Test double 測試替身"></a>Test double 測試替身</h1><p>測試替身最主要是透過封裝好的函式來協助開發者模擬一些函式、功能、模組所返回的值。</p>
<p>像是 Mocha.js 就會搭配像是 Sinon.js 這一類的隔離庫來使用測試替身。而 Jest 本身核心概念是屬於 <strong>batteries-included</strong> 類型的框架（即為你需要的功能，框架都盡量幫你準備好了），因此 Jest 在模擬測試替身上則是看 Jest 本身的 Mock API 即可！</p>
<a id="more"></a>

<h1 id="Mock-基礎範例"><a href="#Mock-基礎範例" class="headerlink" title="Mock 基礎範例"></a>Mock 基礎範例</h1><p>我們根據 Jest mock 中的範例程式，在自己的測試程式碼中寫入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">items, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; items.length; index++) &#123;</span><br><span class="line">    callback(items[index]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mockCallback = jest.fn(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">42</span> + x);</span><br><span class="line">forEach([<span class="number">0</span>, <span class="number">1</span>], mockCallback);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'mock test'</span>, () =&gt; &#123;</span><br><span class="line">  expect(mockCallback.mock.calls.length).toBe(<span class="number">2</span>); <span class="comment">// mockCallback 函式應該被呼叫了 `2` 次</span></span><br><span class="line">  expect(mockCallback.mock.calls[<span class="number">0</span>][<span class="number">0</span>]).toBe(<span class="number">0</span>); <span class="comment">// mockCallback 函式第一次呼叫時第一個參數是 `0`</span></span><br><span class="line">  expect(mockCallback.mock.calls[<span class="number">1</span>][<span class="number">0</span>]).toBe(<span class="number">1</span>); <span class="comment">// mockCallback 函式第二次呼叫時第一個參數是 `1`</span></span><br><span class="line">  expect(mockCallback.mock.results[<span class="number">0</span>].value).toBe(<span class="number">42</span>); <span class="comment">// mockCallback 函式第一次呼叫時，callback 返回的值是 42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>範例程式碼中的解釋，<br>1-5 行是一般的函式。<br>7 行是透過 Jest 所提供的 <code>jest</code> 物件，透過 API <code>fn</code> 的方法，來模擬一個函式，而使用該函式會得到類似有關呼叫與傳參等等行為上的資訊。<br>8 行則是實際使用 1-5 行函式，並在 callback function 的傳參中使用了被 Mock 了的函式，因此 <code>mockCallback</code> 會記載一些關於透過 <code>fn</code> 被記錄的內容。<br>好比測試案例（Test case）中的第 11 行，<code>mockCallback</code> 裡面有被記載到被呼叫了幾次，而我們透過 <code>fn.mock.calls.length</code> 可以得到該資訊。</p>
</blockquote>
<p>上面範例中可以看到被 <code>jest.fn</code> 所 Mock 的函式，我們可以透過 <code>.mock</code> 繼續取得該函式的相關資訊，而這裡使用另一個函式來模擬：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mockAdd = jest.fn(<span class="function">(<span class="params">a, b</span>)=&gt;</span> a + b)</span><br><span class="line">mockAdd(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">mockAdd(<span class="string">'test'</span>,<span class="string">'String'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'get mock info'</span>, mockAdd.mock)</span><br></pre></td></tr></table></figure>
<p>我們將裡面的 mock console.log 出來：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  calls: [</span><br><span class="line">      [ <span class="number">1</span>, <span class="number">2</span> ],</span><br><span class="line">      [ <span class="string">'test'</span>, <span class="string">'String'</span> ]</span><br><span class="line">    ],</span><br><span class="line">  instances: [ <span class="literal">undefined</span>, <span class="literal">undefined</span> ],</span><br><span class="line">  invocationCallOrder: [ <span class="number">1</span>, <span class="number">2</span> ],</span><br><span class="line">  results:[</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'return'</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'return'</span>, <span class="attr">value</span>: <span class="string">'testString'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>從 console.log 中我們可以得知經由 jest.fn 所模擬後我們能在 mock 裡面撈到什麼：</p>
<ul>
<li><strong>calls</strong>：顯示所使用過的傳參，並且依照函式呼叫順序排列。例如：第一次的呼叫兩個傳參為 <code>[1, 2]</code>。</li>
<li><strong>instances</strong>：顯示指向經由 <code>jest.fn()</code> 創建並經過 <code>new</code> 關鍵字所創造出來的實體。但範例中沒有使用，所以兩次都是 <code>undefined</code>。</li>
<li><strong>results</strong>：顯示函式最後返回的結果。例如：第一次的呼叫最後 <code>return</code> 了一個值 <code>3</code>。</li>
<li><strong>invocationCallOrder</strong>：回傳記錄了函式呼叫次數的陣列。換言之我們可以從這個陣列中的 length 值來判斷這個函式被呼叫了幾次。</li>
</ul>
<h1 id="Mocks-Functions"><a href="#Mocks-Functions" class="headerlink" title="Mocks Functions"></a>Mocks Functions</h1><p>除了以上基礎的 Mock 之外，Jest 還有多達十多種 Mock 函式可以模擬數值上的呈現。</p>
<h2 id="模擬-return-數值"><a href="#模擬-return-數值" class="headerlink" title="模擬 return 數值"></a>模擬 return 數值</h2><ul>
<li>mockReturnValueOnce()：使 Mock 函式接下來返回的數值被強制回傳其傳參值 <strong>一次</strong>。</li>
<li>mockReturnValue()：使 Mock 函式接下來返回的數值被 <strong>強制</strong> 回傳其傳參值。<br>我們直接來看一段測試碼：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'mockFn return value'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mockFn = jest.fn()</span><br><span class="line">  <span class="built_in">console</span>.log(myMock()) <span class="comment">// undefined</span></span><br><span class="line">    mockFn</span><br><span class="line">      .mockReturnValueOnce(<span class="number">10</span>)</span><br><span class="line">      .mockReturnValueOnce(<span class="string">'x'</span>)</span><br><span class="line">      .mockReturnValue(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">console</span>.log(mockFn(), mockFn(), mockFn(), mockFn())</span><br><span class="line">  <span class="comment">// &gt; 10, 'x', true, true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
我們可以從範例中看到，不論原先 Mock function 中的處理，只要被綁定之後就會強制返回其數值。</li>
</ul>
<p>第一次看到這個 Mock 肯定會一頭霧水，因為要回傳一個寫死的值為什麼不乾脆直接寫死在斷言中呢？</p>
<p>原因是為了<strong>有效分割測試的範圍</strong>，例如我們在某段程式邏輯中，依賴到其他函式邏輯，但我們並沒有要測試那個範圍就可以這麼做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'mockFn return value'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> alwaysReturnTrue = jest.fn()</span><br><span class="line">  alwaysReturnTrue.mockReturnValue(<span class="literal">true</span>) <span class="comment">// 強制將值返回為 true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> DBdata = [<span class="number">0</span>, <span class="string">""</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未經 Mock 所返回的 filter 處理</span></span><br><span class="line">  <span class="keyword">const</span> filterFunction = DBdata.filter(<span class="function"><span class="params">data</span> =&gt;</span> data) </span><br><span class="line">  <span class="built_in">console</span>.log(filterFunction) <span class="comment">// []</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 經 Mock 所返回的 filter 處理</span></span><br><span class="line">  <span class="keyword">const</span> afterMockfilterFunction = DBdata.filter(<span class="function"><span class="params">data</span> =&gt;</span> alwaysReturnTrue(data))</span><br><span class="line">  <span class="built_in">console</span>.log(afterMockfilterFunction) <span class="comment">// [ 0, '', false ]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>範例中我們透過 <code>alwaysReturnTrue</code> 函式加上 <code>mockReturnValue(true)</code> 來將值強制返回 true，而在原先 Array.prototype.filter 邏輯當中，<code>0</code>、<code>&quot;&quot;</code>、<code>false</code> 都屬於 <code>falsy</code> 值，應該要被 filter 篩選出來，因此返回一個空陣列。</p>
<p>但如果我們想檢測如果都 <strong>通過</strong> 的情況 filter 應該要返回哪些值，這時我們就可以使用 <code>mockReturnValue(true)</code> 來將返回值都修改判定為 <code>true</code>，如此一來就可以比對經由這個 <code>filter</code> 邏輯判斷返回值的前後差異。</p>
<p>而以上就是測試替身的基礎概念以及 Jest 中 Mock 的基礎用法，在實作中可能會有不少處需要 Mock 的情況，若沒有出現上述情況的話可以先翻翻 Jest API 中有沒有專門針對的 Mock API 可以使用。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://jestjs.io/docs/zh-Hans/mock-functions" target="_blank" rel="noopener">Jest-mock</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Jest.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Jest.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest.js 異步測試（Asynchronous Test）</title>
    <url>/Jest.js/Jest-003-async-test/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="jest-logo" src='/images/Jest/jest-logo.png' width='200px' height='200px' />
</div>

<h1 id="Asynchronous"><a href="#Asynchronous" class="headerlink" title="Asynchronous"></a>Asynchronous</h1><p>由於 JavaScript 在瀏覽器的宿主環境裡擁有單線程（single thread）的特性，使得在程式執行時期（Run time）中一些有關非同步（Asynchronous）的操作會等到主線程（Main thread）整個操作結束後才會回來執行處在任務序列（Event queue）中的非同步操作。</p>
<p>因此在測試中，如果遇到有關非同步的操作時，測試程式碼的執行順序（主線程）會先於任務序列，造成測試還未來得及收到非同步執行後的結果，進而導致測試失敗的產出。</p>
<p>我們能做的做法便是要將測試程式碼運行結束的時間，拖延至任務序列當中，讓測試套件（Test suit）中非同步的結果產出之後，才來進行測試中的斷言。</p>
<p>而在 Jest.js 解決這一類非同步測試的問題時，有提供了實際 API 的作法以供參考：</p>
<ul>
<li>callback function 類</li>
<li>promise 類</li>
<li>async / await 類</li>
</ul>
<a id="more"></a>

<h2 id="callback-function"><a href="#callback-function" class="headerlink" title="callback function"></a>callback function</h2><p>在處理 callback function 的作法是，在呼叫測試案例 API <code>test()</code> 時，使用 <code>done</code> API。</p>
<p>我們只需要在第二個回呼函式中給予 <code>done</code> 參數，並在非同步的結果處理完畢時，執行 <code>done()</code>，來表示整個測試案例的結束，而若給予參數 <code>done</code> 卻沒執行 <code>done()</code> 則表示測試失敗，意思也就是非同步的行為操作失敗，符合我們測試的期待。</p>
<p>一般測試寫法，但是這樣填寫會導致在執行非同步的 <code>fetch</code> 前，主線程的測試就已經測試完，因此導致測試失敗：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'查詢商品列表資料是否有正確傳送給輪播功能'</span>, () =&gt; &#123;</span><br><span class="line">  fetch(<span class="string">'某個商品公開列表 API 網址'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 假設完成後須執行 postItemToCarousel 函式</span></span><br><span class="line">      <span class="comment">// 這裡假設我們最後 callback 傳送了 &#123;id: 1, name: 'potato', price: 50 &#125; 進去</span></span><br><span class="line">      res.items.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        postItemToCarousel(&#123;</span><br><span class="line">          id: item.id, </span><br><span class="line">          name: item.name,</span><br><span class="line">          price: item.price</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postItemToCarousel</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    expect(item.id).toBe(<span class="number">1</span>)</span><br><span class="line">    expect(item.name).toBe(<span class="string">'potato'</span>)</span><br><span class="line">    expect(item.price).toBe(<span class="number">50</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>加上 <code>done</code> 參數的寫法，使非同步執行完畢才進行測試：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 測試案例第二個傳參傳入 `done`，如此一來這個測試案例本身就會等待 `done()` 被執行的時候才會開始測試斷言的部分。</span></span><br><span class="line">test(<span class="string">'查詢商品列表資料是否有正確傳送給輪播功能'</span>, done =&gt; &#123;</span><br><span class="line">  fetch(<span class="string">'某個商品公開列表 API 網址'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      res.items.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        postItemToCarousel(&#123;</span><br><span class="line">          id: item.id, </span><br><span class="line">          name: item.name,</span><br><span class="line">          price: item.price</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postItemToCarousel</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    expect(item.id).toBe(<span class="number">1</span>)</span><br><span class="line">    expect(item.name).toBe(<span class="string">'potato'</span>)</span><br><span class="line">    expect(item.price).toBe(<span class="number">50</span>)</span><br><span class="line">    done() <span class="comment">// 到這行表示才進行測試斷言</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>如果資料返回的形式是一個 promise 的話，需透過 <code>return</code> 來返回斷言：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料成功'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">'取得會員社交資料網址'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> expect(res.memberName).toBe(<span class="string">'ShawnL'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因為在 promise 中如果已經取得目標的狀態下（fulfilled）不會讓測試案例失敗，所以如果要測試 promise 中 <code>.catch()</code> 方法，需要透過 <code>expect.assertions</code> 來定義斷言的數量，來確保一定要通過幾筆斷言才算是成功的測試案例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料錯誤處裡'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">'取得會員社交資料網址'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> expect(error)).toMatch(<span class="string">'錯誤處理的訊息'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>除了上面的作法之外，也可以使用 Jest 提供的 <code>.resolves</code>、<code>.rejects</code> 配對器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> expect(fetch(<span class="string">'取得會員社交資料網址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json()).then(<span class="function"><span class="params">res</span> =&gt;</span> res.memberName)).resolves.toBe(<span class="string">'ShawnL'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料錯誤處裡'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> expect(fetch(<span class="string">'取得會員社交資料網址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json()).catch(<span class="function"><span class="params">error</span> =&gt;</span> error)).rejects.toMatch(<span class="string">'錯誤處理的訊息'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h2><p>Jest 關於非同步的議題也納入了 ES7 中的 <code>async</code>、<code>await</code> 用法，我們可以寫出更優雅的非同步測試程式碼：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> memberData = <span class="keyword">await</span> fetch(<span class="string">'取得會員社交資料網址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json()).then(<span class="function"><span class="params">res</span> =&gt;</span> res)</span><br><span class="line">  expect(memberData.name).toBe(<span class="string">'ShawnL'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料錯誤處裡'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  expect.assertions(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> fetch(<span class="string">'取得會員社交資料網址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    expect(err).toMatch(<span class="string">'錯誤處理的訊息'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同樣還可以再搭配 <code>.resolves</code>、<code>.rejects</code> 配對器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(fetch(<span class="string">'取得會員社交資料網址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json()).then(<span class="function"><span class="params">res</span> =&gt;</span> res.name)).resolves.toBe(<span class="string">'ShawnL'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'取得會員社交資料錯誤處裡'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(fetch(<span class="string">'取得會員社交資料網址'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json()).catch(<span class="function"><span class="params">err</span> =&gt;</span> err)).rejects.toMatch(<span class="string">'錯誤處理的訊息'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面介紹了一些在 Jest 中撰寫非同步測試的幾種情境與解決方法。</p>
<p>然而非同步議題在實際測試中，後續測試其實會比較關注在後續視覺與邏輯處理的部分，因為我們可能已經預期非同步執行的結果會是什麼，因此會利用 Mock 來仿造非同步資料，再來撰寫測試程式碼。</p>
<p>但為了真的要去測一些非同步執行的內容的話，還是要知道怎麼使用會比較好 XD</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://jestjs.io/docs/en/asynchronous" target="_blank" rel="noopener">Jest-asynchronous</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Jest.js</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Jest.js</tag>
      </tags>
  </entry>
  <entry>
    <title>程式設計心法 你不會需要它（YAGNI principle）</title>
    <url>/Methodology/Methodology-003-YAGNI-principle/</url>
    <content><![CDATA[<h1 id="YAGNI-原則"><a href="#YAGNI-原則" class="headerlink" title="YAGNI 原則"></a>YAGNI 原則</h1><p>繼 DRY 原則與 KISS 原則之後，最常被並列再一起討論的非 YAGNI 原則莫屬了，而 YAGNI 原則（You aren’t gonna need it），顧名思義為你不會需要它。但到底程式設計中我們會不需要什麼呢？</p>
<p>仔細回想一下，有沒有曾經在開發過程中為了預先擴充某樣功能而撰寫程式碼的經驗？</p>
<p>最終那些為了擴充的程式碼最後有真的派上用場還是就默默冷落在角落成為雞肋的存在？</p>
<p>抑或是派上了用場但與當初所預設的規格有所不同？</p>
<p>對於 YAGNI 原則來說，這些都是應該自己盡量避免的，而幾個可以達到 YAGNI 原則的概念：</p>
<a id="more"></a>

<ul>
<li>專注在實現專案文件中需求的功能</li>
<li>不要過早優化程式碼</li>
<li>不要替未來的功能預設立場，去撰寫用不到的程式碼</li>
</ul>
<h1 id="為何需要-YAGNI-原則"><a href="#為何需要-YAGNI-原則" class="headerlink" title="為何需要 YAGNI 原則?"></a>為何需要 YAGNI 原則?</h1><p>對於專案實務上來說，這些預設立場的功能並沒有辦法在專案上實際運用，很有可能自己猜想覺得完美無缺，但實際真的運用時會有沒想到的例外處理。即便是寫了單元測試（Unit testing）去細心維護這些擴充的功能，在將來也很有可能因為<strong>文件規格的改動</strong>使得這些擴充的功能並<strong>不符合預期</strong>效益。</p>
<p>另一點則是對於<strong>人員的調動</strong>與<strong>接手維護</strong>上的問題，當今年這個專案移交給其他人維護時，其他開發人員很有可能<strong>不清楚該段程式碼的想法</strong>，將原意可能良好的設計，<strong>突變（Mutate）了原本的設計，導致概念更加的混亂</strong>。除此之外，預設了越多立場程式碼也會對於後續維護的人在閱讀程式碼時得<strong>花上額外的心力</strong>，才能辨別該段程式碼中的原意。到頭來，還不如一開始留的乾淨直白，<strong>等到需要的時候</strong>，才真正地將原有不符合規格的程式重構（refacting）。</p>
<p>而對於<strong>實務經驗</strong>不多的 Junior 開發者來說，預先立場更是一件可怕的事情，由於實務經驗不多，對於功能將來擴充的方向不明，而做了多不必要的功能，甚至限制了該功能在將來的彈性，再加上針對不必要的功能所進行的防禦性與邊界處理等等，就會產生出更大量沒有必要的程式。</p>
<h1 id="YAGNI-的隱憂"><a href="#YAGNI-的隱憂" class="headerlink" title="YAGNI 的隱憂"></a>YAGNI 的隱憂</h1><p>因為每個開發環節關注的點不同，雷點也不盡相同，究竟要保留彈性到什麼樣的程度對於開發者來說是一個很艱困的難題。畢竟有些雷點即便是我們都聽過，但沒有親自踩過、痛過的經驗，有時候是難以體會的，而這部份真的只能依靠實務經驗來累積，所以除了上班寫的專案之外，下班後就靠 side project 來增加實務經驗吧！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://stackoverflow.com/questions/53595548/what-is-the-point-of-yagni-principle-applied-to-design-patterns" target="_blank" rel="noopener">What is the point of YAGNI principle applied to design patterns?</a></li>
<li><a href="https://www.itexico.com/blog/software-development-kiss-yagni-dry-3-principles-to-simplify-your-life" target="_blank" rel="noopener">KISS YAGNI &amp; DRY Principles | iTexico</a></li>
</ul>
]]></content>
      <categories>
        <category>Methodology</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Methodology</tag>
      </tags>
  </entry>
  <entry>
    <title>程式設計心法 簡單原則（KISS principle）</title>
    <url>/Methodology/Methodology-002-Kiss-principle/</url>
    <content><![CDATA[<h1 id="KISS-原則"><a href="#KISS-原則" class="headerlink" title="KISS 原則"></a>KISS 原則</h1><p>繼上次避免<strong>重複原則</strong>（DRY principle）後這次要來介紹的程式三大開發原則之一的<strong>簡單原則</strong>（簡稱 KISS 原則，即為 Keep it simple and stupid.）。</p>
<p>這個開發原則在古文中早已有驗證，在老子《道德經》之中，有句話叫做「萬物之始，大道至簡，演化至繁。」意思簡單來說就是任何事物之中，一開始都是非常簡單而直白的，經過不斷演化之後，才到達繁的境界，而程式設計也理應如此。</p>
<p>而 KISS 原則追尋的便是那種<strong>大道至簡</strong>的精神。</p>
<p>那麼我們要如何追尋這個原則呢？</p>
<a id="more"></a>

<h1 id="KISS-實踐"><a href="#KISS-實踐" class="headerlink" title="KISS 實踐"></a>KISS 實踐</h1><p>在程式開發的過程中，我們時常會針對將來的擴充性與例外處理做一些防衛性措施，例如針對函式參數設想了一些情境：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name !== <span class="literal">undefined</span> &amp;&amp; name !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Anonymous'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">setName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name = setName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要使其更容易閱讀其實可以這麼寫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Anonymous'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或是採用 ES6 的寫法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name = <span class="string">'Anonymous'</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在這個範例中我們可以看到簡化最後程式碼所想要表達的內容所帶來的效益，使程式碼變得更加的清晰。</p>
<h1 id="KISS-principle-amp-DRY-principle"><a href="#KISS-principle-amp-DRY-principle" class="headerlink" title="KISS principle &amp; DRY principle"></a>KISS principle &amp; DRY principle</h1><p>KISS 原則的誤區如同 DRY 原則一樣要避免<strong>過度抽象化（over-abstraction）</strong>與<strong>過早最佳化（premature-optimization）</strong>。</p>
<p>而 KISS 原則比起 DRY 原則就個人理解下，KISS 更偏向不要去預設任何立場並且稍微重複也有助於後續修改，而 DRY 則對各種意義上的重複概念比較注重；但兩種最終都還是得面向可讀性（readability）這道關卡，所以要適當的拿捏之間的尺度。</p>
<p>正所謂：</p>
<blockquote>
<p><em>“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”<br>「笨蛋都能寫出讓電腦看得懂的程式碼，只有優秀的程式開發者能寫出讓人看得懂的程式碼。」<br>-Martin Fowler</em></p>
</blockquote>
<p>一個良好的程式碼應該可以使其他開發者<strong>容易維護</strong>並且<strong>容易閱讀</strong>，多餘的預設立場只會<strong>限制後續的開發</strong>。</p>
<p>這也是為什麼多半 KISS 原則與 DRY 原則通常會與 YAGNI 原則放在一起討論的原因。</p>
<p>而 YAGNI 原則又是什麼呢？請待下回分曉。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://kknews.cc/zh-tw/home/8q5jj5e.html" target="_blank" rel="noopener">你不得不知的KISS原則（三大軟體原則之一）</a></li>
<li><a href="https://ihower.tw/blog/archives/7181" target="_blank" rel="noopener">Kent Beck 的四個簡單程式設計原則</a></li>
</ul>
]]></content>
      <categories>
        <category>Methodology</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Methodology</tag>
      </tags>
  </entry>
  <entry>
    <title>程式設計心法 三次原則（Rule Of Three principle）</title>
    <url>/Methodology/Methodology-004-Rule-Of-Three-principle/</url>
    <content><![CDATA[<h1 id="Rule-Of-Three-原則"><a href="#Rule-Of-Three-原則" class="headerlink" title="Rule Of Three 原則"></a>Rule Of Three 原則</h1><p>如果說 DRY 原則是將抽象發揮到極致，而 KISS 原則是保留抽象盡可能的使其單純化，那麼接下來三次原則（Rule Of Three principle）可以說是這兩個原則之間的中庸之道了。</p>
<p>而三次原則顧名思義其實就是<strong>重複到第三次才去抽象它</strong>！</p>
<p>還記得之前所提過的 YAGNI 原則（You aren’t gonna need it 原則）嗎？</p>
<p>三次原則可以說是提供了 YAGNI 原則一個準則，使得在重構上（refacting）的時機更有規則，但是為什麼會需要等待第三次才要抽象呢？接著就來思考這個問題。</p>
<a id="more"></a>

<h1 id="為什麼要第三次才抽象"><a href="#為什麼要第三次才抽象" class="headerlink" title="為什麼要第三次才抽象"></a>為什麼要第三次才抽象</h1><p>如果<strong>依據開發迭代的次數</strong>來討論這個問題的話，在第一次新專案開發時，對於<strong>預設立場</strong>上，YAGNI 原則已經解釋了<strong>預設立場這件事情並實際去開發未使用到的功能</strong>這件事情並不是件好事，原因是因為可能會<strong>限制</strong>將來開發人員對於該功能會綁手綁腳，甚至出現<strong>與實際規格文件不符合的預設立場</strong>。而 KISS （Keep it simple and stupid.）原則也指出應該要使開發程式碼盡可能<strong>乾淨</strong>，以利於往後實際遇到問題時的開發人員可以<strong>有足夠的彈性</strong>去<strong>維護</strong>、<strong>修改</strong>甚至<strong>重構</strong>原有的程式碼。</p>
<p>除此之外，對於 DRY （Don’t repeat youself.）原則來說，第一次新專案開發中的重複規模可能都偏小，由於第一手開發面向的會是開發文件中的功能。所以比較多是在於想<strong>怎麼符合現有的功能</strong>，因此需要做樣板（template)的可能已經有個雛形，並非做到才想到這件事。</p>
<p>而迭代到第二次，也就是接著開發、接手維護專案的時候。這時專案中可能充斥著<strong>已經上線</strong>的程式碼，那些存在伺服器倉庫中的程式碼是已經備受專案經理、測試人員、老闆甚至是使用者的反覆使用所驗證過的程式碼，若沒有特殊情況理論上來說要比新的程式碼還來的<strong>可靠</strong>。<del>就連上檔也會多少避開假日前的這種敏感時刻</del>。</p>
<p>因此，這時的維護開發多半可能多半會檢查既有程式中有沒有<strong>壞</strong>味道（Code smell），沒有的話就迎合既有的程式碼的味道，去持續端出<strong>穩定</strong>的料理，以<strong>便於下一個開發人員來維護</strong>。而即便從原有規格中發現了不符合新需求的程式碼，重構範圍應該不至於太大才是。</p>
<p>直至第三次再度踏入同專案中，需求功能開發與之前又再度類似，便能擁有更多的信心來確認需求面並依據前面的例子去做抽象。</p>
<p>如果<strong>依據代碼重複的次數</strong>來討論這個問題的話，則同上方例子，代碼重複第三次時，這時應該會有更多例子來思考要怎麼抽象來符合這些狀況。</p>
<h1 id="總結而論"><a href="#總結而論" class="headerlink" title="總結而論"></a>總結而論</h1><p>我們已經從情境模擬而出，第三次才抽象是基於第一次開發應保有它的<strong>乾淨</strong>；第二次重複的內容則是為了避免限制到將來的功能彈性，重複的實作在這時可以替程式碼增加可讀性；第三次才抽象是因為已有先前兩例可以有足夠的例子來思考抽象後的結構，並且是屬於真正有需求的時機。而至於在迭代下去的開發，如果更改的東西越簡單但開發時程越長時，該考慮的面相可以會變成是要抉擇重構或重寫升級了。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="http://www.ruanyifeng.com/blog/2013/01/abstraction_principles.html" target="_blank" rel="noopener">代码的抽象三原则</a></li>
<li><a href="https://jaceju.net/refactor-or-rebuild/" target="_blank" rel="noopener">面對 Legacy Code ，該重構還是重寫？</a></li>
</ul>
]]></content>
      <categories>
        <category>Methodology</category>
      </categories>
      <tags>
        <tag>w3HexSchool</tag>
        <tag>Methodology</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome DevTools Performance 與畫面處理</title>
    <url>/Optimization/Optimization-002.performance/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/google/chrome-devtools-logo.png' width='200px' height='200px' />
</div>

<p>之前有文章寫到在替網頁進行優化時會使用到像是 Google Chrome 瀏覽器的 Lighthouse 網頁檢測工具，並且會給予一些可行方案與提示來協助我們優化。而其中指標（Metrics）提示可能會要我們去觀察像是第一次內容繪製（FCP，First Contentful Paint）或是第一次有意義的繪製（FMP，First Meaningful Paint）等等。</p>
<p>但這些指標名詞代表更實際的意義在哪裡？這篇文章就要來整理一下這些東西：</p>
<a id="more"></a>

<h1 id="Chrome-DevTools-Performance"><a href="#Chrome-DevTools-Performance" class="headerlink" title="Chrome DevTools Performance"></a>Chrome DevTools Performance</h1><p>在 Google Chrome 中，檢測頁面的位置在開發人員工具列（DevTools）中的 Performance 分頁，點選左上角的灰色圓圈 Records 後，重整、刷新頁面後再點選一次 Record 關閉錄製，此時就會跑出一張效能表：</p>
<p><img src="/images/google/chrome-landing-page-lighthouse-performance-trace.jpg" alt="chrome-landing-page-lighthouse-performance"></p>
<p>當然我們也可以透過 Google Chrome DevTools 分頁中的 Audit 來檢測網頁相關效能（基於 Lighthouse），在指標（Metrics）一欄我們可以看見幾個被列出來的項目，以及大約執行的秒數（依據每次跑測試環境會有些微差距），而點選左下角的 View Trace，也同樣能產出效能表。</p>
<p><img src="/images/google/chrome-landing-page-lighthouse-performance.jpg" alt="chrome-landing-page-lighthouse-performance"></p>
<h1 id="Performance-Timings"><a href="#Performance-Timings" class="headerlink" title="Performance Timings"></a>Performance Timings</h1><p>在效能表裡的 Timings 中我們可以看見幾個專有名詞的縮寫分別為：</p>
<ul>
<li>FP（First Paint）：第一次繪製開始，各使用裝置開始傳輸像素的時間點，也就是載入的空框到有任何一點視覺上的變更的時間點。</li>
<li>FCP（First Contentful Paint）：第一次內容繪製，比起 FP 來說 FCP 可以看作是一個完整的元素被渲染完畢後的時間點。</li>
<li>FMP（First Meaningful Paint）：第一次有意義的繪製，<a href="https://github.com/berwin/Blog/issues/42" target="_blank" rel="noopener">採用推測</a>布局載入的大小方式來辨識其時間點。</li>
<li>LCP（Largest Contentful Paint）：最大元素渲染，透過 <a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver" target="_blank" rel="noopener">PerformanceObserver API</a> 來計算出最大的元素渲染值。</li>
<li>DCL（DOM Content Loaded）：DOM 載入完畢的時間，也就是開發上時常會監聽的事件。</li>
</ul>
<p>我們瞭解這些指標的用意了，現在我們要來瞭解對於使用者來說，在<strong>網頁載入過程</strong>時什麼會是他們所在乎的？</p>
<ul>
<li>畫面載入時間與過程。</li>
<li>畫面可以開始操作的時間。</li>
</ul>
<h1 id="畫面載入時間"><a href="#畫面載入時間" class="headerlink" title="畫面載入時間"></a>畫面載入時間</h1><p>取得畫面載入時間相對容易，我們可以觀察 FP 與 FCP 的時間點來判斷，並搭配 Performance Record 上方的畫面紀錄來觀察，而 FP 與 FCP 載入的時間點越快，也就表示使用者看到畫面在<strong>載入</strong>這件事情越快。</p>
<p>加快 FP 與 FCP 載入的時間點的方法有：</p>
<ul>
<li>盡可能最小化禁止轉譯的樣式表與第三方的程式碼。</li>
<li>將一些靜態檔案透過 HTTP Caching 處理，讓使用者再度訪問時能夠盡可能的存取未讀取過的資源。</li>
<li>將一些文字化的靜態資源壓縮化、最小化，提升資源載入的時間。</li>
</ul>
<p>而提升了 FP、FCP、FMP 甚至到 LCP 的時間點後，我們還有另一間事情得處理。</p>
<h1 id="畫面操作時間"><a href="#畫面操作時間" class="headerlink" title="畫面操作時間"></a>畫面操作時間</h1><p>當畫面載入時，使用者可能就會開始試圖去操作畫面上的內容，而這另外牽扯到主線程阻塞等等的問題，並且有幾項較為代表的時間點：</p>
<ul>
<li>FCI（First CPU Idle）：第一次 CPU 空閒下來的時間，也就是說此時可以接收到一些來至使用者的 Event 行為了。</li>
<li>TTI（Time to Interactive）：指整個頁面完全可以操作的時間點，而不單只是 FCI 的時間點。</li>
<li>FID（First Input Delay）：使用者第一次嘗試操作頁面元素時所遇到的阻塞時間長度。</li>
</ul>
<p>而依據整體使用者操作的時間點 與 <strong>主線程</strong> 空閒狀態大概會出現幾種情況：</p>
<ul>
<li>使用者根本不與網頁上的內容互動，也就是根本沒有操作問題 (X。</li>
<li>使用者在主線程忙碌時操作，由於此時操作會需要等待主線程空閒時，才能繼續處理，因此需要等待 Input Delay 時間會較長。</li>
<li>使用者在主線程空閒時操作，由於此時可以立即處理該操作，所以這時候 Input Delay 時間會較短。</li>
</ul>
<p>因此面向的問題可能會變成要盡可能的讓使用者可以快速操作（縮短 FCI 時間）。</p>
<p>而解決方法之一可以試著讓主線程忙碌時段分散，如將 Load 量大的程式移交至 Event Loop 當中（例如 <code>setTimeout(fn, 0)</code> 的<a href="https://stackoverflow.com/questions/10180391/javascript-how-to-avoid-blocking-the-browser-while-doing-heavy-work" target="_blank" rel="noopener">黑魔法</a>）</p>
<p>另一方法則是將畫面上蓋上 Loading 的畫面狀態，如此一來可以避免使用者在程式完全載入前操作，發生一些不可預期的錯誤，並且讓使用者在進入 FP 階段後，可以安心地等待整體資料 OnLoad 完成。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint" target="_blank" rel="noopener">First Contentful Paint</a></li>
<li><a href="https://premium.wpmudev.org/blog/improve-first-contentful-meaningful-paint/" target="_blank" rel="noopener">How to Improve First Contentful and Meaningful Paint</a></li>
<li><a href="http://mis101bird.js.org/metrics/" target="_blank" rel="noopener">[Performance]瀏覽器運作與效能指標評估</a></li>
<li><a href="https://blog.hinablue.me/2019-ithome-ironman-day-26/" target="_blank" rel="noopener">[IT 鐵人賽] 大型資料載入實例與狀況 Large of DOMs Day 26</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/98880815" target="_blank" rel="noopener">Web性能领域常见的专业术语</a></li>
<li><a href="https://blog.csdn.net/c_kite/article/details/104237256" target="_blank" rel="noopener">Chrome Performance常见名词解释(FP, FCP, LCP, DCL, FMP, TTI, TBT, FID, CLS)</a></li>
<li><a href="https://juejin.im/post/5dfc709b51882579dc6f7f71" target="_blank" rel="noopener">Chrome Devtool Performance中DCL, L, FP, FCP, FMP, LCP 的含义</a></li>
</ul>
]]></content>
      <categories>
        <category>Optimization</category>
        <category>Chrome DevTools</category>
      </categories>
      <tags>
        <tag>Optimization</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>網路優化不可不知的測評工具 Lighthouse, PageSpeed Insights &amp; Web.dev</title>
    <url>/Optimization/Optimization-001-lighthouse/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="lighthouse-logo" src='/images/Lighthosue/lighthouse-logo.png' width='200px' height='200px' />
</div>

<h1 id="Lighthouse、PageSpeed-Insights"><a href="#Lighthouse、PageSpeed-Insights" class="headerlink" title="Lighthouse、PageSpeed Insights"></a>Lighthouse、PageSpeed Insights</h1><p>Lighthouse 是由 Google 團隊所開發的檢測工具，主要用來檢測網站使用者體驗、效能與 SEO 等等網站優化的部分，若沒有聽過 Lighthouse，那麼應該有聽過同樣為 Google 為所開發的 <a href="https://developers.google.com/speed/pagespeed/insights/?hl=zh-TW" target="_blank" rel="noopener">PageSpeed Insights</a> 檢測網站，而 PageSpeed Insights 也在 2018 年的某次改版中將 Lighthouse 評分整併到 PageSpeed Insights 中。</p>
<p>而兩者相較之下， PageSpeed Insights 整併後主要是增加了較多視覺報表呈現的部分，並且可以選擇語系來看分析後的優化方案；而 Lighthouse 則有多個管道可以查看檢測後的結果：</p>
<ul>
<li>Google DevTools</li>
<li>Google Extensions Lighthouse</li>
<li>Web.dev</li>
</ul>
<p>接下來便介紹這三個工具的用法與差異：</p>
<a id="more"></a>

<h2 id="Google-DevTools"><a href="#Google-DevTools" class="headerlink" title="Google DevTools"></a>Google DevTools</h2><p>在 Google Chrome 瀏覽器中有著非常好用的 DevTools，而在 Chrome 60 版本後， DevTools 新增了一項面板 Audits 便是基於 Lighthouse 所製作出來的。我們只要打開 DevTools 在面板 Audits 執行 Run audits 即可開始測分。</p>
<p>採用這個方法的好處是可以針對於一些未實際架在 server 上的網頁做檢測，例如想在測試機上調校 SEO，或是以 local 端方式開啟的網站也能用這個方法評分。</p>
<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="lighthouse-devtool-audits" src='/images/Lighthosue/lighthouse-devtool-audits.png' width='500px' height='500px' />
</div>

<h2 id="Google-Extensions-Lighthouse"><a href="#Google-Extensions-Lighthouse" class="headerlink" title="Google Extensions Lighthouse"></a>Google Extensions Lighthouse</h2><p>第二項方法則是下載 <a href="https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk?hl=zh-TW" target="_blank" rel="noopener">Google Extension</a>，接著就可以在 Chrome 瀏覽器右上角直接點選使用。</p>
<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="lighthouse-google-extension" src='/images/Lighthosue/lighthouse-google-extension.png' width='500px' height='500px' />
</div>

<p>採用這個方法的好處是可以快速檢測每個頁面，但基本上功能與 DevTools 裡 Audits 面板差不多，若 Chrome 版本已經升到 60 的話直接用 Audits 可能會比較方便。</p>
<p>另外要注意的是使用 Google Extension 版本的 Lighthouse，它產生的 Report Viewer 是會藉由 Server 去訪問的，因此如果是沒對外開放的測試機或以 local 端執行的網站要進行測試就會沒辦法使用。</p>
<h2 id="Web-dev"><a href="#Web-dev" class="headerlink" title="Web.dev"></a>Web.dev</h2><p><a href="https://web.dev/measure/" target="_blank" rel="noopener">Web.dev</a> 也是由 Google 團隊所開發檢測工具裡面的東西，由於基於 Lighthouse 所開發，用起來與 PageSpeed Insights、Lighthouse 基本上是差不多的，比較不一樣的地方在於它的測評是依據衝擊度（Impact）來排名，可以較直覺從比較重要的項目開始優化。另外則是下載報表時會稍微方便一點。</p>
<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="web-dev-page" src='/images/Lighthosue/web-dev-page.png' width='500px' height='500px' />
</div>


<h1 id="Optimization-項目"><a href="#Optimization-項目" class="headerlink" title="Optimization 項目"></a>Optimization 項目</h1><p>上面介紹了一些基於 Lighthouse 有關的檢測工具，緊接著要來介紹有關 Lighthouse 上的設定以及要如何搭配檢測結果來調校我們的程式。</p>
<p>以 Google DevTools 為例，在跑分打開 Audits 面板會看到如下圖所示的設定：</p>
<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="lighthouse-devtool-audits" src='/images/Lighthosue/lighthouse-devtool-audits.png' width='500px' height='500px' />
</div>

<ul>
<li>Device：設定模擬使用桌機還是行動裝置來檢測當前的網頁。</li>
<li>Audits：設定要檢測的項目，可以適當的關掉沒有需要檢測的項目加速檢測時間（例如沒有考慮 PWA 的情況）。</li>
<li>Throttling：設定模擬檢測的網路速度，心臟不夠大顆的話可以考慮先從 <code>No throttling</code> 開始，否則一般慢速模擬的情況通常是以<strong>悲劇</strong>收場，<del>然後你就會想關掉 Lighthouse 結束這回合</del>。</li>
</ul>
<p>我們實際以目前這個 Blog 來跑分。可以看到大致上還算滿意，但仍然可以再補足一些缺漏：</p>
<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="lighthouse-devtool-audits-my-personal-blog" src='/images/Lighthosue/lighthouse-devtool-audits-my-personal-blog.png' width='500px' height='500px' />
</div>

<p>最後檢測報告主要可分為以下幾個面向：</p>
<ul>
<li>Performance：網站效能類，通常會反映在<strong>客戶端與伺服器端上的溝通</strong>為主。</li>
<li>Accessibilty：網站無障礙設計類，面相在<strong>使用非典型裝置（桌機手機平板）類的輔助裝置觀看網站時，能否讓使用者也能順暢的使用</strong>。<br>好比 Modern Web 設計時常使用 CSS 去改動 <code>&lt;a&gt;</code>、<code>&lt;button&gt;</code> 連結按鈕，若標籤內沒有任何文字的話會被視為不可觸及的對象，因此被扣分。</li>
<li>Best Practices：網站最佳實作類，主要是在於<strong>程式碼上的優化</strong>類別，像是使否使用緩存機制與是否用了不推薦的語法。</li>
<li>SEO：搜尋引擎優化類，這個部分應該是最多人關注的點，畢竟很可能會直接影響到網站在搜尋引擎的排名。例如 <code>&lt;meta&gt;</code> 方面的資料有沒有設定完整，<code>&lt;img&gt;</code> 有沒有確實加上 <code>alt</code> 屬性等等都會被考慮在內。</li>
<li>PWA：</li>
</ul>
<p>而要修正的方式也很直覺，往下拉就會看到 Lighthouse 是以什麼樣的檢測標準在審核，並且提示你是哪個地方出了問題，<strong>可能</strong> 需要解決。</p>
<p>不過看到分數有時先不用驚慌，好比將剛剛測驗結果拉到 Best Practice 區，可以看到有用了 <code>document.write</code> 的語法問題，但我們將它打開一看：</p>
<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="lighthouse-devtool-best-practices.png" src='/images/Lighthosue/lighthouse-devtool-best-practices.png' width='500px' height='500px' />
</div>

<p>可以看到哪段程式使用了該段語法。<del>然後就會發現有時所謂的問題，實際上也是可能我們自己無法處理的部分（google ads）。</del></p>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>透過上面例子，我們可以總結出 Lighthouse 的確可以使我們很直接地看出網站目前有哪些問題有需解決，有時可能會為了<strong>視覺</strong>上的美化、<strong>效能、程式實作</strong>上的考量、<strong>第三方</strong>提供的 SDK 等等問題，而拉低分數。但不盡然到要完全符合才能成為一個優質的網站，而在優化上面，最終檢測面向的依舊是要端看使用者<strong>平均的實際體驗</strong>。</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10210147" target="_blank" rel="noopener">WEB.DEV – Google SEO 工具</a></li>
<li><a href="https://seo.whoops.com.tw/pagespeed-insights-revamped-with-lighthouse/" target="_blank" rel="noopener">Google PageSpeed Insights 大改版，整合 Lighthouse 引擎提供更多 SEO 細節數據</a></li>
<li><a href="https://www.astralweb.com.tw/google-lighthouse-for-front-end-audits-to-imporve-better-seo-and-user-experience/" target="_blank" rel="noopener">Chrome 推出 Lighthouse 前端稽核功能 – 為了更好的 SEO 與使用者體驗</a></li>
</ul>
]]></content>
      <categories>
        <category>Optimization</category>
        <category>lighthouse</category>
      </categories>
      <tags>
        <tag>Optimization</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>重新解構：無瑕的程式碼（Clean Code）書序 及 Chapter 1 無暇的程式碼</title>
    <url>/cleancode/clean-code-a-handbook-of-agile-software-craftsmanship-001-intro/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/Book/Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship.jpg' width='200px' height='200px' />
</div>

<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>經過一段時間終於有機會再把它拿出來拜讀了！這本由 <strong>Robert C. Martin（Uncle Bob）</strong> 所撰寫的著作，為 《Agile software development principles patterns and practices.》（敏捷軟件開發）一書的前傳。而無暇的程式碼（Clean Code）究竟表示的是什麼？我想推薦序一文做了非常良好的解釋：</p>
<a id="more"></a>

<blockquote>
<p><em>“God is in the details.” -Ludwig Mies van der Rohe 「神就藏在細節裡面。」</em></p>
</blockquote>
<p>在推薦序中，<strong>James O. Coplien</strong> 引用了建築大師 <strong>Ludwig Mies van der Rohe</strong> 的這句名言來開場。描述程式開發，如同是在處於建築行業一般，我們在開發程式中每個環節，其實就如同在蓋房時所堆砌的一磚一瓦一樣，要成為建築大師、優良的程式開發人員，我們必須小心謹慎地對待每個角落。好比在 <strong>變數命名</strong> 議題上，我們總是對待變數得像是對待自己的小孩一般，不會隨意取下它們的姓名。</p>
<p>但真正在面相專案中的程式開發時，我們是否會受到時程開發、臨時需求變動等等需求，而影響到了這些想法？還是能像日本維護的優良方針（Total Productive Maintenance）中，身美（Shutsuke）概念一樣 <strong>保持堅守自身的信念</strong>？</p>
<blockquote>
<p>身美（Shutsuke）在日本維護優良方針中表示，在工作實踐的過程中，能夠遵守紀律、並無時無刻的反省自身在任務上是否能有改善之處。</p>
</blockquote>
<p>我想就 <strong>James O. Coplien</strong> 所引用的另一句丹麥諺語所說的一樣：</p>
<blockquote>
<p>丹麥諺語：<br>“Ærlighed i små ting er ikke nogen lille ting.” <em>「在小事情上誠實不是一件小事情。」</em></p>
</blockquote>
<p>當我們在小事都能夠堅守信念時，在大事上就不致馬虎了。<del>有夢最美希望相隨</del></p>
<h1 id="為什麼我們需要無瑕的程式碼？"><a href="#為什麼我們需要無瑕的程式碼？" class="headerlink" title="為什麼我們需要無瑕的程式碼？"></a>為什麼我們需要無瑕的程式碼？</h1><p>在寫得非常精闢的序文之後，隨即進入了第一章節 <strong>無瑕的程式碼</strong>，而第一章正是描述為什麼我們會需要無瑕的程式碼。</p>
<p>在實際開發過程中，比起撰寫真正提交出去的程式碼，我們更多時間是花費在<strong>閱讀之前的程式碼</strong>，我們從閱讀之前專案中留下來的程式碼，來暸解<strong>前開發者的思維與開發架構</strong>；或是來維護前幾個月、甚至是幾週前<strong>由自己所撰寫</strong>的程式碼。我們總是盡可能模仿裡面的味道，再來烹飪出類似的料理，好讓後續接手維護的人員，能夠品嘗到一手好菜。</p>
<blockquote>
<p><em>有時候並非是因為我們擁有強大的閱讀能力，而是厲害的開發者能端出五星級的料理，讓其他人輕易讓品嚐其中的滋味。</em></p>
</blockquote>
<p>如果我們若不這麼做、迫於專案時程關係，或是不慎端出了臭味道的料理怎麼辦？有些經驗的程式開發者可能已經透過了<del>惡劣的</del>環境來學習過了。如前面所說，我們花費在閱讀程式碼的時間已經隨著專案的大小，長得越來越大，閱讀時間也可能從短短的幾分鐘，進化到弄了一小時才解決，而<strong>越雜亂的程式碼也將花費更多的時間來去維護</strong>。<br></p>
<blockquote>
<p>童子軍原則：讓你所到之處，離開後比原先來得更加乾淨</p>
</blockquote>
<p>如同營地一般，某個專案中的程式可能已經歷經了一段風霜。不論當初撰寫專案的人是誰，我們所及之處的程式碼，最終應該都必須保持乾淨，在將來後續維護時，才不會受到歷史的阻礙。</p>
<p><del>當然，你也可以選擇重構或死亡，但在不重構的前提下，我們還是能做很多事的。</del></p>
<h1 id="重新解構再重構"><a href="#重新解構再重構" class="headerlink" title="重新解構再重構"></a>重新解構再重構</h1><p>標題中所提到重新解構再重構的意思是：這系列的文章拜讀，不會只是閱讀書本的心得文章而已，我所希望的是能藉由自己的思維將其內容重新解構再重構，透過這樣的方式訓練自己的思維，組合出屬於我自己的脈絡。</p>
<p>其中，解構的部分並不會打亂整本書的章節，因為我認為作者這樣規劃有其中的含意，而且如果我這麼做的話，也就喪失了許多原書的大脈絡；因此，解構的部分會縮小至章節的內容，讓整個系列的文章有如每個原書章節中的再譯版本，希望使有閱讀過此書的讀者也能夠有新的讀書體驗。</p>
<p>當然，如果你從來沒看過這本書的話，我仍然很推薦你一定要看過一次原書。</p>
<p>而在下一章開始，此系列文章將會從程式中最重要的部分－－命名（naming）部分，開始講起！</p>
]]></content>
      <categories>
        <category>Book</category>
        <category>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</category>
      </categories>
      <tags>
        <tag>Book</tag>
        <tag>w3HexSchool</tag>
        <tag>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</tag>
      </tags>
  </entry>
  <entry>
    <title>重新解構：無瑕的程式碼（Clean Code） Chapter 2 有意義的命名（上）－命名心法</title>
    <url>/cleancode/clean-code-a-handbook-of-agile-software-craftsmanship-002-naming-methodology/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/Book/Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship.jpg' width='200px' height='200px' />
</div>

<p>命名，對於工程師來說是一門重要的學問，因為它無所不在。不僅除了變數與函式，廣泛到連圖片、資料夾、甚至是文章標題、標籤都得經過命名的環節。</p>
<p>好的命名，可以讓其他人清楚的瞭解它的作用、功能；壞的命名，則會讓人擁有錯誤的印象，得花更多時間來釐清原本所該敘述的內容。</p>
<p>那麼，我們要怎麼取出有意義的命名呢？</p>
<a id="more"></a>

<p>在這一章節中，作者整理了幾個概念來闡述，而其中許多的概念是可以融會貫通的。因此我以命名的心法與規則為劃分，將其重新整理：</p>
<ul>
<li>命名心法：為何這樣命名？詮釋在命名前心中所具備的前提。</li>
<li>命名規則：實際怎麼命名？遵循與避免什麼樣的規則才可以接近所謂好的命名。</li>
</ul>
<h1 id="命名的心法"><a href="#命名的心法" class="headerlink" title="命名的心法"></a>命名的心法</h1><p>在命名前，工程師可以先想想以往所碰過的程式碼是如何命名的？有沒有遇過命名實際上與本身作用不同？或是實際上做的事情比命名本身來的多？</p>
<p>而在命名心法之中，我們將試著揣測往後看到同段程式碼時，自己或他人的想法。我將其區分了幾個性質來做為解釋：</p>
<ul>
<li>闡述性</li>
<li>符合性</li>
<li>一致性</li>
</ul>
<h2 id="闡述性"><a href="#闡述性" class="headerlink" title="闡述性"></a>闡述性</h2><p>闡述性即為命名本身做了什麼。具有闡述性的命名，可以使其解釋被命名的性質、作用，讓其他人能夠瞭解原先命名者的思維。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list =  [<span class="string">'apple'</span>,<span class="string">'banana'</span>];</span><br></pre></td></tr></table></figure>

<p>較好的作法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shopping_basket =  [<span class="string">'apple'</span>,<span class="string">'banana'</span>];</span><br></pre></td></tr></table></figure>

<p>透過 <code>shopping_basket</code> 來取代 <code>list</code>，讓後續閱讀的人可以知道這個陣列內容其實代表的是什麼。</p>
<h2 id="符合性"><a href="#符合性" class="headerlink" title="符合性"></a>符合性</h2><p>與闡述性的概念相近，但符合性更在意的是命名不只是解釋（explain），更是命名本身要能夠符合（match）背後的意義，才能避免解釋反而誤導了它人。以下舉例如果命名只具備了闡述，但不具備符合性時會發生什麼事情？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位於某個檔案中的函式呼叫</span></span><br><span class="line">getBook(<span class="function"><span class="keyword">function</span> (<span class="params">book</span>)) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(book) <span class="comment">// 預期會返回某個書籍的詳細資料</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一處檔案中，被呼叫的函式本身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBook</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'某個書籍清單'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> callback(res)) <span class="comment">// 只有回傳書籍清單，並沒有詳細資料</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程式呈現了一個預期從回呼函式（callback function）中拿到書籍的詳細資料，結果返回的是一個書籍的清單資料。</p>
<p>的確 <code>getBook</code> 函式解釋了拿取書籍有關的內容，但它並沒有說明拿的應該是什麼，因此名稱不完全符合它背後所做的事情。</p>
<p>而顯而易見的是我們可以讓命名再加上符合它所做的事情來解決這個問題。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得書籍清單的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBookList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得含有書籍詳細資料的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBookDetail</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>命名的一致性則是在說明同個概念、想法、作用的名稱，應該盡量用同個命名來代表它，不要用兩個或多個以上的詞彙。</p>
<p>如果命名時不考慮到一致性的話，影響的是下一個接手維護的人（甚至是半年後的自己）無法連貫。例如下列程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位於某個檔案中的資料來源</span></span><br><span class="line"><span class="keyword">let</span> member = [&#123;</span><br><span class="line">  name: <span class="string">'xxx'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位於某個檔案中的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAccountInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 裡面操作有關於 member 變數中的內容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在這段程式碼中，你可能會好奇 <code>account</code> 與 <code>member</code> 之間的不同點在哪？甚至如果後續維護的時候又不慎出現了一個被命名為 <code>getMemberInfo</code>　的函式時會有多頭痛。</p>
<p>因此我們將有關於同個概念的內容修改一致：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位於某個檔案中的資料來源</span></span><br><span class="line"><span class="keyword">let</span> member = [&#123;</span><br><span class="line">  name: <span class="string">'xxx'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位於某個檔案中的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMemberInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 裡面操作有關於 member 變數中的內容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一來我們可以透過名稱就能大概猜想這個函式與資料物件是有關聯的。</p>
<p>這章節整理了比較偏向心法方面的設計理念，而下一篇將會整理有關於命名實際上的規則與做法。</p>
]]></content>
      <categories>
        <category>Book</category>
        <category>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</category>
      </categories>
      <tags>
        <tag>Book</tag>
        <tag>w3HexSchool</tag>
        <tag>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js Why D3.js： D3.js 是什麼？</title>
    <url>/d3.js/D3-001-why-d3js/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<p>今天開始要進入到 D3.js 的單元啦，在進入 D3.js 的常用 API 章節前，我們一樣要先來介紹一下 D3.js：</p>
<a id="more"></a>

<blockquote>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190918/20119062xiIiM2NaBx.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190918/20119062xiIiM2NaBx.jpg"><br><del>絕對不是這個 D3，但有機會的話或許也可以介紹（？</del></p>
</blockquote>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190918/20119062fyOApfWwWF.png" alt="https://ithelp.ithome.com.tw/upload/images/20190918/20119062fyOApfWwWF.png"></p>
<h2 id="D3-js"><a href="#D3-js" class="headerlink" title="D3.js"></a>D3.js</h2><p>這個才是我們今天的主角 D3.js，D3.js 全名（<strong>D</strong>ata-<strong>D</strong>riven <strong>D</strong>ocuments），即為<strong>資料驅動文件</strong>，而其中的資料所驅動的文件，則是我們很熟悉的 <strong>DOM（Document Object Model）</strong>，與同樣為操作 DOM 的 JavaScript 函式庫 jQuery 有許多相似的概念與用法：</p>
<ul>
<li>兩者同樣都是在操作 <strong>DOM</strong> 的新增修改刪除</li>
<li>兩者同樣都採用了<strong>鍊式語法（chain syntax）</strong></li>
<li>D3.js 選擇器（selector）向 jQuery 選擇器看齊</li>
</ul>
<p>以上三點在實際使用 D3.js 便能深刻感受到他們類似的地方，所以有寫過 jQuery 的開發者們學習 D3.js 會更容易上手。不同的地方在於， D3.js 最主要是關注在<strong>資料視覺化</strong>（Data Visualization）的部分，我們可以透過 D3.js 來將資料轉化為視覺圖表，例如像是：</p>
<p>將資料繪製成簡單的<strong>圓餅圖</strong>：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190918/201190628OQTGlFrhY.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190918/201190628OQTGlFrhY.jpg"></p>
<p>甚至是程式語言列表的<strong>文字雲</strong>：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190918/20119062QEaKxTyJA7.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190918/20119062QEaKxTyJA7.jpg"></p>
<p>而這些由 D3.js 製成的圖表，由於是基於支援瀏覽器的 JavaScript 語言所製作而成的，因此開發者可以透過已經熟稔的 HTML、CSS 以及 JavaScript 技術，搭配 SVG 或 Canvas 標籤產生對應的元素後，來動態操作這些視覺圖表，讓圖表不在只是死板板的一張圖，更可以是一個富有相關資訊的多功能圖表。</p>
<blockquote>
<p>其中在台灣目前較為多人知曉的專案 <a href="http://budget.g0v.tw/budget" target="_blank" rel="noopener">零時政府-中央政府總預算視覺化</a> 便是由 D3.js 所製成的。</p>
</blockquote>
<h2 id="Why-D3-js"><a href="#Why-D3-js" class="headerlink" title="Why D3.js?"></a>Why D3.js?</h2><p><strong>這一類製作圖表的 JavaScript 函式庫並不是只有 D3.js，為何我們要選擇他呢？</strong></p>
<p>除了 D3.js 之外，這類以<strong>資料視覺化</strong>為主的 JavaScript 函式庫還有 Chart.js、C3.js、Echarts、CanvasJS……等等，為何要特別挑選 D3.js 的理由則是在於 D3.js <strong>富有高度的自由性</strong>，開發者可以透過 D3.js 的 API 繪製出各種點線面的圖，配合 DOM 圖層的概念與操作，來實現其他函式庫較難以做到的功能，但副作用也是在於它的高度自由性，一開始接觸 D3.js 需要多花一點時間來熟悉他的概念與文件，但等到熟悉 D3.js 之後就會對於他的方便與自由感到驚嘆！所以如果有興趣想要製作<strong>可以在網頁上與使用者互動的高度客製化動態圖表</strong>，不彷來訂閱一波吧！</p>
<blockquote>
<p>D3.js 的魅力如同黑黑漩渦一樣令人深陷而不能自拔。<br> <img src="https://ithelp.ithome.com.tw/upload/images/20190919/20119062HIUjY2oBLF.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190919/20119062HIUjY2oBLF.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>重新解構：無瑕的程式碼（Clean Code） Chapter 3 函式－函式語句（下）</title>
    <url>/cleancode/clean-code-a-handbook-of-agile-software-craftsmanship-005-function-statement/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/Book/Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship.jpg' width='200px' height='200px' />
</div>

<p>在上篇文章中，我們將<strong>函式（function）</strong>拆成了三個部分：</p>
<ul>
<li>函式名稱（naming）：以供辨識、呼叫用的名稱。</li>
<li>函式參數（parameter）：提供連結外部變數，傳送到內部語句的傳送參數。</li>
<li>函式語句（statements）：實際函式所執行的區域。</li>
</ul>
<p>其中<strong>函式語句（statements）</strong>的部分又可以拆為：</p>
<ul>
<li>語句類別（type）：探討函式是怎麼被開發者使用的。</li>
<li>語句結構（structure）：探討內部語句的寬度與深度。</li>
<li>語句脈絡（context）：探討內部語句的長度與敘述。</li>
</ul>
<p>而這篇文章將延續上篇文章繼續介紹語句脈絡的概念。</p>
<a id="more"></a>

<h2 id="語句脈絡（context）"><a href="#語句脈絡（context）" class="headerlink" title="語句脈絡（context）"></a>語句脈絡（context）</h2><p>別於語句結構的巢狀、深度，語句脈絡指的部分是在函式中的，語句整體的敘述與長度，包含了輸入、輸出值等等邏輯。</p>
<p>而根據無暇的程式碼一書中，一個較好的語句脈絡應該包含了：</p>
<ul>
<li>由上而下的敘述</li>
<li>越短越好</li>
<li>無副作用</li>
<li>只有一件目的</li>
<li>結構化函式</li>
</ul>
<h3 id="由上而下的敘述"><a href="#由上而下的敘述" class="headerlink" title="由上而下的敘述"></a>由上而下的敘述</h3><p>由上而下的敘述是指，在函式語句（statement）的過程中，我們可能會使用其他的函式來輔助，那麼這些函式應該要有父層（parent）、子層（child）這些相對的概念：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 計算淨利的程式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countIncome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> totalIncome = <span class="number">0</span></span><br><span class="line">  totalIncome = totalRevenue() - totalCost() - calcTax(totalRevenue())</span><br><span class="line">  <span class="keyword">return</span> totalIncome</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">totalRevenue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 計算並返回總營業額</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">totalCost</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 計算並返回總成本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcTax</span>(<span class="params">NTD</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 將總營業額帶入並計算營業稅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時</span></span><br><span class="line"><span class="keyword">const</span> INCOME = countIncome()</span><br><span class="line"><span class="built_in">console</span>.log(INCOME)</span><br></pre></td></tr></table></figure>

<p>我們可以看見將來實際使用時，我們會首先暴露相較於父層的 <code>countIncome</code> 函式。</p>
<p>因此如果將來想了解 <code>INCOME</code> 值是怎麼處理而來的時候，會先找到 <code>countIncome</code> 函式，接著在從內部語句中找到其餘計算相關內容的 <code>totalRevenue</code>、<code>totalCost</code> 與 <code>calcTax</code> 函式，我們就能輕易的透過這種由上而下的引入關係理解這些函式之間的關聯性。</p>
<h3 id="越短越好"><a href="#越短越好" class="headerlink" title="越短越好"></a>越短越好</h3><p>語句越短越好可以說是接著上節由上而下的敘述的補充。</p>
<p>經過剛剛的範例可以看見，當我們在閱讀 <code>countIncome</code> 時，內部並沒有做太多複雜的計算，而是將這些計算分工給其餘的程式，如此一來我們可以加快閱讀每個函式本身在做的事情，藉由快速理解各個函式本身的行為，強化理解函式與函式之間的關聯。</p>
<h3 id="無副作用"><a href="#無副作用" class="headerlink" title="無副作用"></a>無副作用</h3><p>無副作用的意思即為，在處理函式數值時，函式本身應該是針對其數值做運算、針對功能做出相對應的行為；如果函式背地裡修改了其他數值、執行其他的行為，將會大大的加深理解函式的困難度。</p>
<!-- todo -->

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span> (<span class="params">userID</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'...'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> location.reload())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時</span></span><br><span class="line">getUserInfo(<span class="string">'c8763'</span>) <span class="comment">// 找不到，但錯誤時直接重整，所以也不知道發生什麼事情</span></span><br></pre></td></tr></table></figure>

<p>在這段程式碼中，欲使用 <code>getUserInfo</code> 函式取得使用者相關資訊，但是卻不知道為何直接重整的案例。</p>
<p>去爬了定義 <code>getUserInfo</code> 的函式後，才發現語句中對於 ajax 的錯誤處理中，使用了 <code>location.reload()</code> 來重整頁面。</p>
<p>即便是直接使用了有副作用的函式都讓人覺得疑惑了，可以試想當你是在深層度的層次中使用到時會發生什麼情況：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderPage</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.init = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pageData = getPageData(obj.pageName) <span class="comment">// 取得 &lt;object&gt;頁面資料</span></span><br><span class="line">    <span class="keyword">let</span> userInfo = getUserInfo(obj.userID) <span class="comment">// 取得 &lt;object&gt;會員資料</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;userInfo.nickname&#125;</span>!`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.init(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPageData</span>(<span class="params">pageName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;</span><br><span class="line">  <span class="comment">// 取得頁面資料</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">userID</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'...'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> location.reload())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時，預期要渲染一個名稱為 'main' 的頁面。</span></span><br><span class="line">renderPage(&#123;</span><br><span class="line">  pageName: <span class="string">'main'</span></span><br><span class="line">  userID: <span class="string">'c8763'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你能夠輕易地看出為何 <code>renderPage()</code> 最後會導致不正常的頁面刷新嗎？如果可以的話，想像它只是某個不明顯的數值變更看看，你還能輕易地找到錯誤的地方嗎？</p>
<h3 id="只有一件目的"><a href="#只有一件目的" class="headerlink" title="只有一件目的"></a>只有一件目的</h3><p>一個函式語句（statement）應該要只有一件目的，如此一來閱讀程式碼時就不需要在多種目的下來回猜測，使函式本身做的事情更容易被表達。</p>
<p>例如錯誤處理中的 <code>catch</code> 本身就算是一件目的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMemberInfo</span> (<span class="params">memberID</span>) </span>&#123;</span><br><span class="line">  fetch(<span class="string">'...'</span> + memberID&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err)) <span class="comment">// 錯誤處理</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// 若無錯誤時的處理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在這 <code>getMemberInfo</code> 中，本身目的在於取得資料這件事情，因此我們可以掌握取得資料與沒有取得資料的行為。</p>
<p>如果我們在取得資料錯誤之後又做了其他事情，則會使函式變成有副作用的情況，將來要除錯時會無法聚焦錯誤訊息。</p>
<p>而透過讓函式符合專一職責的思維，最後可以帶來像是單元測試（unit testing）會更很容易測試他的邏輯以及重構時（refactoring）的抽象處理等等好處。</p>
<h3 id="結構化函式"><a href="#結構化函式" class="headerlink" title="結構化函式"></a>結構化函式</h3><p>現在我們知道只有一件目的的函式的語句脈絡的好處了，結構化函式則是在整體語句脈絡上訂下一個輸出輸入的準則。</p>
<p>例如在需要初始化區域變數我們應該在函式語句的開頭就定義完畢，這樣可以使我們更容易找到值的來源：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSomething</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = x</span><br><span class="line">  <span class="keyword">let</span> b = y</span><br><span class="line">  <span class="keyword">let</span> c = z</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 假設函式語句有一些長度，以至於你可能需要滑鼠滾動檢查整段語句。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  c += <span class="number">1</span> </span><br><span class="line">  d = a + b</span><br><span class="line">  <span class="keyword">return</span> a + b - c </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上方的例子中，我們快速檢查 c 變數的源頭是誰以及意識到 d 變數可能是來自更外一層的區域所宣告的區域變數或可能是忘記初始化，最後變成全域變數的危險分子。</p>
<p>另一個結構化的方式則是將進入點<strong>輸出點</strong>集中管理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumArray</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>; <span class="comment">// 將輸出值，透過變數初始化在上方</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;  <span class="comment">// 防禦處理、例外處理（exception handling），也可以移置上方管理。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    result += arr[i]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result <span class="comment">// 輸出的來源現在可以很確定是源自哪裡了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣的作法在函式語句需要 <code>if/else</code>、<code>switch</code> 判斷時會更加的明顯：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 沒有控制的情況</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPageData</span>(<span class="params">pageName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pageName === <span class="string">''</span>)  &#123;</span><br><span class="line">    <span class="keyword">let</span> something = <span class="string">''</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 進入流程處理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> something <span class="comment">// 處理完直接輸出值</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pageName  === <span class="string">'search'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> something = <span class="string">''</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 進入流程處理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> something <span class="comment">// 處理完直接輸出值</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> something = <span class="string">''</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 進入流程處理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> something <span class="comment">// 處理完直接輸出值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在沒有控制的情況，這個判斷流程（condition）將會逐漸使開發、除錯漸漸變得困難，我們可能要不斷在各種流程中下斷點來判斷裡面返回的數值狀況。</p>
<p>雖然不是不可，但是如果預期輸出的值是相同概念的話，可以將其控制為一點輸出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPageData</span>(<span class="params">pageName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>; <span class="comment">// 依照輸出的資料類型定義初始值，提供預期的輸出資料類型</span></span><br><span class="line">  <span class="keyword">if</span> (pageName === <span class="string">''</span>)  &#123;</span><br><span class="line">    <span class="keyword">let</span> something = <span class="string">''</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 進入流程處理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    result = something  <span class="comment">// 將處理好的數值接回輸出變數</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pageName  === <span class="string">'search'</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> something = <span class="string">''</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 進入流程處理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    result = something  <span class="comment">// 將處理好的數值接回輸出變數</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> something = <span class="string">''</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 進入流程處理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    result = something  <span class="comment">// 將處理好的數值接回輸出變數</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result <span class="comment">// 統一輸出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一來我們可以針對其 <code>result</code> 變數的過程作監控，在最後輸出前監控該數值的變化是否合乎預期。</p>
<p>以上兩篇就是有關於函式語句（statement）上的處理，下一篇文章我們將會介紹不同的函式參數所帶來的影響以及函式命名的做法。</p>
]]></content>
      <categories>
        <category>Book</category>
        <category>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</category>
      </categories>
      <tags>
        <tag>Book</tag>
        <tag>w3HexSchool</tag>
        <tag>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 環境建置</title>
    <url>/d3.js/D3-002-build/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="渲染範圍"><a href="#渲染範圍" class="headerlink" title="渲染範圍"></a>渲染範圍</h2><p>使用樣本語法時，我們可以在 HTML 中使用<strong>兩對花括號</strong>來表示要顯示的資料，並且透過 Vue.js 實體中的 <code>el</code> 來指定 Vue.js 渲染的範圍，並且在子元件的 <code>template</code> 中同樣也可以使用，然而如果是在 HTML 中的子元件標籤裡<strong>直接使用則會導致失效</strong>，如下面範例：</p>
<a id="more"></a>

<p>HTML部分：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span><span class="template-variable">&#123;&#123; childMessage &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>JavaScript部分：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:`<span class="symbol">&lt;div&gt;</span>&lt;/div&gt;`,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    message : <span class="string">'parent component'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後樣板語法將不會顯示任何資料。（這並非是什麼 BUG，而是 Vue.js 預設的渲染。）</p>
<h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><p>假使想要在子元件標籤中放些自定義的文字或內容，可以透過 <code>&lt;slot&gt;</code> 標籤來達成，我們試著將上面的元件稍微改寫一下：</p>
<p>JavaScript 部分：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.component</span>(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  <span class="attribute">template</span>:</span><br><span class="line">  `</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt; // 加入 slot 標籤</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line">  <span class="selector-tag">data</span>()&#123;</span><br><span class="line">    <span class="selector-tag">return</span> &#123;</span><br><span class="line">      <span class="attribute">childMessage </span>: <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>HTML 部分：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span><span class="xml"> //這裡的message 將會傳入父元件的資料物件</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>這樣將會使得在 <code>&lt;child-element&gt;&lt;/child-element&gt;</code> 標籤中的資料，傳入到子元件裡的<code>&lt;slot&gt;&lt;/slot&gt;</code>的位置，將其替換掉。並且我們可以也可以傳入 HTML 元素、甚至是其他的元件以及父元件的資料物件：</p>
<p><strong>注意</strong>當使用這樣的方法在子元件內使用樣板語法傳入資料，此時傳入的資料將會是<strong>父元件的資料物件</strong>，若要使用子元件的資料物件，仍然只能在子元件的<code>template</code>中去呼叫。</p>
<p>而當我們使用 <code>&lt;slot&gt;</code> 後，若沒有 HTML 部分中所綁定的元件中傳入資訊，則預設將會顯示<code>&lt;slot&gt;&lt;/slot&gt;</code>所包含的資料：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:</span><br><span class="line">  `</span><br><span class="line">  <span class="symbol">&lt;div&gt;</span></span><br><span class="line">    <span class="symbol">&lt;slot&gt;</span>Hello Vue!&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  `,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    message : <span class="string">'parent component'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後顯示的結果會是 <code>&lt;div&gt;Hello Vue!&lt;/div&gt;</code>。</p>
<h2 id="指定slot"><a href="#指定slot" class="headerlink" title="指定slot"></a>指定slot</h2><p>當今天 <code>slot</code> 所要傳入的對象越來越多時，可以透過指定插入的方式去分配 <code>slot</code> 要怎麼對應資料，方法是在子元件中使用 <code>template</code> 標籤並加上<code>v-slot</code>屬性，<code>v-slot</code>的值會對應到的是 <code>slot</code> 標籤的 <code>name</code> 屬性，這樣一來當我們有需要放多個 <code>slot</code> 時就不必擔心對應位置的問題，範例如下：</p>
<p>HTML部分：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:first</span>&gt;</span>First<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:second</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:third</span>&gt;</span>Third<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>JavaScript部分：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:</span><br><span class="line">  `</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"first"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"second"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"third"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  `,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = new Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    message : <span class="string">'parent component'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後 HTML 部分子元件的內容將會對應的傳入子元件中，並顯示出來。而這個 API 好用的地方在於今天有個元件我們純粹只是想要更換部分的顯示內容，就可以在父元件引入該子元件，並且透過 <code>v-slot</code> 直接傳入子元件中，而不用資料整筆 props 進去再接出來。</p>
<p>以上是目前 Vue.js 的最後一章節，而實作的部分將會等到我們以 Vue-cli 創建環境時，再搭配 D3.js 一起介紹！</p>
<blockquote>
<p>隨文附上今日的黑黑，據家人說他今天在同個地方躺了連續八小時 ( XD???<br><img src="https://ithelp.ithome.com.tw/upload/images/20190917/20119062Gz4i7Zt1Ic.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190917/20119062Gz4i7Zt1Ic.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>重新解構：無瑕的程式碼（Clean Code） Chapter 3 函式－函式語句（上）</title>
    <url>/cleancode/clean-code-a-handbook-of-agile-software-craftsmanship-004-function-statement/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/Book/Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship.jpg' width='200px' height='200px' />
</div>

<p>上回我們探討了命名的技巧，緊接著要來討論所有程式與語言幾乎都不可避免的函式！</p>
<p>這回我們要來重新檢視我們長期以來使用的函式方式，並重新解構函式本身的原貌，來探討可以怎麼使用函式會更好！</p>
<a id="more"></a>

<h1 id="為何我們需要函式"><a href="#為何我們需要函式" class="headerlink" title="為何我們需要函式"></a>為何我們需要函式</h1><p>使用函式時我們是否曾經想過：為何我們需要函式呢？我們真的有必要用它嗎？還是我們從來沒有考慮過使用它的時機呢？</p>
<p>此書的作者提及了其中一個使用函式的時機，那就是違反<strong>重複原則（DRY，Don’t repeat youself.）</strong>的時候。</p>
<p>當我們重複使用同樣程式碼的時後，我們可能付出許多代價來修改同樣的程式，這時我們就可以利用函式來將其中的概念封裝起來重複使用，藉此達到更高的效率與方便後續維護的人員能夠輕易地閱讀。</p>
<p>而對於重複程式碼的容忍度則可以遵循之前程式心法系列中所提及過的 <strong>三次原則（Rule Of Three principle）</strong>，達到一定次數的重複率再進行封裝，以避免過度的抽象來降低疑慮。</p>
<p>在有了使用函式的理由後，我們便可以開始來討論函式的細節：</p>
<h1 id="解構函式的細節"><a href="#解構函式的細節" class="headerlink" title="解構函式的細節"></a>解構函式的細節</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">parameter</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定義 function 的語句（statements）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方展示了一個簡單的宣告函式，我們可以清楚的看到函式至少包含了三個部分：</p>
<ul>
<li>函式名稱（naming）：以供辨識、呼叫用的名稱。</li>
<li>函式參數（parameter）：提供連結外部變數，傳送到內部語句的傳送參數。</li>
<li>函式語句（statements）：實際函式所執行的區域。</li>
</ul>
<p>我也將其重構原書的內容，以這三個部分重新整理內容。</p>
<h1 id="函式語句（statements）"><a href="#函式語句（statements）" class="headerlink" title="函式語句（statements）"></a>函式語句（statements）</h1><p>首先我想討論語句的部分，因為對於函式來說，當你透過程式編輯器的搜尋功能去尋找一個函式時，假如在找得到的情況下，通常最想做的事情是去觀看這函式裡面做了什麼事情，因此內部的語句是至關重要的地方。</p>
<p>而在語句（statement）之中我們可以探討的點可分為：</p>
<ul>
<li>語句類別（type）：探討函式是怎麼被開發者使用的。</li>
<li>語句結構（structure）：探討內部語句的寬度與深度。</li>
<li>語句脈絡（context）：探討內部語句的長度與敘述。</li>
</ul>
<h2 id="語句類別（type）"><a href="#語句類別（type）" class="headerlink" title="語句類別（type）"></a>語句類別（type）</h2><p>函式根據語句的處理則可分為<strong>指令型</strong>和<strong>查詢型</strong>：</p>
<h3 id="指令型（command）"><a href="#指令型（command）" class="headerlink" title="指令型（command）"></a>指令型（command）</h3><p>指令型的函式表示它將做了某件事情：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeUrlTo</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">  location.href = url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時：</span></span><br><span class="line">changeUrlTo(<span class="string">'https://www.google.com.tw'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="查詢型（query）"><a href="#查詢型（query）" class="headerlink" title="查詢型（query）"></a>查詢型（query）</h3><p>查詢型的函式表示它會回答某件事情：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> number === <span class="string">'number'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時：</span></span><br><span class="line"><span class="keyword">if</span> (isNumber(+<span class="string">'123'</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Magic! Nice job, JavaScript.'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在書中的筆者建議函式盡量不要將指令型與查詢型混合使用，否則很容易產生疑惑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAndCheckItem</span> (<span class="params">itemID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!shop[itemID]) &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line">  fetch(<span class="string">'...?itemID='</span> + itemID)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123; <span class="keyword">return</span> res.json()&#125;</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> res.data.info <span class="comment">// 回傳 &lt;object&gt;商品資料</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時：</span></span><br><span class="line"><span class="keyword">let</span> itemInfo = getAndCheckItem(<span class="string">'c8763'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(itemInfo) <span class="comment">// 無法確定回傳的資料到底是沒有此商品還是物件形式的商品資料</span></span><br></pre></td></tr></table></figure>

<h2 id="語句結構（structure）"><a href="#語句結構（structure）" class="headerlink" title="語句結構（structure）"></a>語句結構（structure）</h2><p>在語句結構的部分我們需要考量到它的深度問題，而深度最大的問題即是巢狀結構所造成的，例如一個函式中有太多的 <code>if/else</code> 結構，或是出現 <code>switch</code> 結構。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Single Page Application 假換頁</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goPage</span>(<span class="params">pipePageName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> page = pipePageName.split(<span class="string">'|'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (page[<span class="number">0</span>] === <span class="string">'main'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (page[<span class="number">1</span>] === <span class="string">'search'</span>) &#123;</span><br><span class="line">      history.pushState(<span class="string">''</span>,<span class="string">''</span>,<span class="string">'/main/search'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      history.pushState(<span class="string">''</span>,<span class="string">''</span>,<span class="string">'/main'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page[<span class="number">0</span>] === <span class="string">'contact'</span>) &#123;</span><br><span class="line">    history.pushState(<span class="string">''</span>,<span class="string">''</span>,<span class="string">'/contact'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    history.pushState(<span class="string">''</span>,<span class="string">''</span>,<span class="string">'/404'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時：</span></span><br><span class="line"><span class="keyword">let</span> searchButton = <span class="built_in">document</span>.querySelector(<span class="string">'#goSearchPage'</span>)</span><br><span class="line">searchButton.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  goPage(<span class="string">'main|search'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>往後想要增添頁面的時候，<code>goPage</code> 函式內部的結構將會成為阻礙，內部大量的判斷即便更改成 <code>switch</code> 來做也是一樣令人難以接受，並且還沒考量到要傳入 <code>pushState</code> 的參數就已經如此複雜。</p>
<p>我們將其判斷結構挪至外層，將判斷這件事情交給外面的邏輯來處理，使 <code>goPage</code> 函式專心做好它應該做的事情：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goPage</span> (<span class="params">pageName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(history.state)) || [];</span><br><span class="line">  <span class="keyword">let</span> title = <span class="built_in">document</span>.title;</span><br><span class="line">  <span class="keyword">let</span> stateFormat = &#123; <span class="attr">pageName</span>: pageName, <span class="attr">url</span>: location.href &#125;</span><br><span class="line"></span><br><span class="line">  state.push(stateFormat)</span><br><span class="line">  history.pushState(state, title, pageName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 實際使用時：</span></span><br><span class="line"><span class="keyword">let</span> searchButton = <span class="built_in">document</span>.querySelector(<span class="string">'#goSearchPage'</span>)</span><br><span class="line">searchButton.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  goPage(<span class="string">'search'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我們可以發現將判斷邏輯移出後可以使得原本的 <code>goPage</code> 函式將會更加清楚，並且還補上了其他的資訊，將來還可以藉由 <code>history.state</code> 來操作如同歷史頁面的紀錄。</p>
<p>而書中筆者則是建議，我們應該避免將巢狀結構納入其中，如果真的有必要這麼處理，應該確保這個函式是處於低層次的抽象概念當中，意思即為該函式幾乎不再被使用。</p>
]]></content>
      <categories>
        <category>Book</category>
        <category>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</category>
      </categories>
      <tags>
        <tag>Book</tag>
        <tag>w3HexSchool</tag>
        <tag>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</tag>
      </tags>
  </entry>
  <entry>
    <title>重新解構：無瑕的程式碼（Clean Code） Chapter 2 有意義的命名（下）－命名規則</title>
    <url>/cleancode/clean-code-a-handbook-of-agile-software-craftsmanship-003-naming-rule/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" src='/images/Book/Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship.jpg' width='200px' height='200px' />
</div>

<p>上一章節整理了偏向心法方面的命名設計理念，本篇將會整理有關於命名實際上的規則與做法。</p>
<a id="more"></a>


<h1 id="命名的規則"><a href="#命名的規則" class="headerlink" title="命名的規則"></a>命名的規則</h1><p>命名的規則，相較於心法的概念來說，則多了一點明文規定。</p>
<p>諸多的規則限制是來自於許多工程師的長期經驗，以及程式編譯與操作環境設備上的考量，透過命名來能幫助我們加速開發。</p>
<p>而同樣的我將其歸納成下列幾種：</p>
<ul>
<li><p>常見應避免的用法。</p>
</li>
<li><p>依資料型態的命名規則。</p>
</li>
<li><p>JavaBeans 規範。</p>
</li>
<li><p>添加資訊。</p>
</li>
<li><p>容易被搜尋的字眼</p>
</li>
<li><p>真的還是不行？</p>
<h2 id="常見應避免的用法"><a href="#常見應避免的用法" class="headerlink" title="常見應避免的用法"></a>常見應避免的用法</h2></li>
<li><p>避免使用無意義命名。<br>例如：<code>abc</code>、<code>a1</code>、<code>a2</code>。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> abc = <span class="string">'...'</span>;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="string">'...'</span>;</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="string">'...'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免單個字命名。<br>例如：<code>a</code>、<code>b</code>、<code>c</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'...'</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'...'</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="string">'...'</span>;</span><br></pre></td></tr></table></figure>

<p>尤其這對搜尋來說非常難以找到這個單字的源頭，試著想一下你打開了搜尋，然後輸入了 <code>a</code> 因為你想看看這個變數所儲存的來源是怎麼操作的，電腦只能跟你說很抱歉：這裡有 <code>9527</code> 個搜尋到的結果。</p>
<p>但如果是迴圈中常用的 <code>i</code>、<code>j</code>、<code>k</code>，則可以使用，因為這些對於工程師來說是有既定印象的，並且我們並不會在全域範圍中一直使用它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumArrayNumber</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++)  &#123;</span><br><span class="line">    result += array[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免匈牙利命名法。<br>例如：<code>string_Phone</code>、<code>string_Name</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string_Phone = <span class="string">'0912345678'</span>;</span><br><span class="line"><span class="keyword">let</span> string_Name = <span class="string">'shawn'</span>;</span><br></pre></td></tr></table></figure>
<p>這裡並非說匈牙利命名不好，因為它是有歷史背景的因素才出現的。</p>
<p>然而，在現代開發環境中，資料型態已經可以透過編譯器來一系列的檢查。</p>
<p>並且在 JavaScript 之中，型態很有可能會轉變，將變數命名型態會有很大的機率誤導他人。如果真的要有效辨別，則可以使用 TypeScript ，透過型別系統來定義變數才更有強制力。</p>
<h2 id="依資料型態的命名規則"><a href="#依資料型態的命名規則" class="headerlink" title="依資料型態的命名規則"></a>依資料型態的命名規則</h2><ul>
<li>常數與純數字中的命名<br>如果專案中某個特定的數字有原因的，可以試著賦予一個名稱，這會讓搜尋時與閱讀時更容易瞭解這個數字的來由。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target_item_price = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">50</span> &gt; target_item_price) &#123;</span><br><span class="line">  buyTarget()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target_item_price = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> current_balance = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current_balance &gt; target_item_price) &#123;</span><br><span class="line">  buyTarget()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更棒的好處是，當我們後續維護如果要變更該數字，我們也更容易能夠找到它。</p>
<ul>
<li>物件與類別的命名<br>物件與類別可以使用名詞來命名。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> member = &#123;</span><br><span class="line">  name: <span class="string">'Shawn'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函式與方法的命名<br>函式與方法可以使用動詞與動詞片語來命名。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postArticle</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特定領域的命名<br>有時候專案中是有關於某些特定領域，一般來說如果能採用工程師能理解的用語為優先。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title = <span class="string">'某某職稱'</span></span><br></pre></td></tr></table></figure>

<p>若真的找不到用語，至少也要使用該特定領域的名稱，之後也才有辦法詢問名稱的意義。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> agent = <span class="string">'某某代理人'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JavaBeans 規範<br>JavaBeans 原先是屬於 Java 語言中的一個類別（class），而要使用它必須遵守一些規則。</li>
</ul>
<p>例如提取統一使用 <code>get</code>，修改則是 <code>set</code>，布林值判斷則使用 <code>is</code>。</p>
<p>另外還有像是類別名稱首個單字大寫後續小寫，方法、變數名稱則是首個單字小寫後續大寫等等</p>
<p>舉例來說好比操作瀏覽器物件中的 localStroage 中的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'hello'</span>, <span class="string">'world'</span>);</span><br><span class="line">localStorage.getItem(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>添加資訊<br>有時候單一個詞彙解決不了的東西，那就試試第二個吧！</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Shawn'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">'Shawn'</span>;</span><br><span class="line"><span class="keyword">let</span> lastName =  <span class="string">'Lin'</span>;</span><br></pre></td></tr></table></figure>

<p>但前綴後綴的時候如果有遇到大量的情況，則應該考慮是否要將其便成為一個物件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> memberFirstName = <span class="string">'Shawn'</span>;</span><br><span class="line"><span class="keyword">let</span> memberLastName =  <span class="string">'Lin'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> member = &#123;</span><br><span class="line">  firstName: <span class="string">'Shawn'</span>,</span><br><span class="line">  lastName:  <span class="string">'Lin'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>容易被搜尋的字眼<br>最後一個則是容易被搜尋為原則。因為在維護舊專案時，第一件事情可能先要瞭解整個架構，而其中可能會用了大量的方法來建構，如果用了一個不好搜尋到的名稱，可能接手維護的人會感受到很挫折甚至是憤怒，這也跟前面的心法與規則息息相關。</li>
</ul>
<p>再來複習一次：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">t(<span class="number">9527</span>) ;  <span class="comment">// 這到底是什麼...</span></span><br></pre></td></tr></table></figure>

<p>搜尋結果:</p>
<blockquote>
<p>55 個檔案中有 10130 個結果。</p>
</blockquote>
<ul>
<li>真的還是不行<br>有的時候礙於規模大小還是發展的時候，當時的狀況確實沒辦法想到一個最好的命名。因此覺得真的不是一個好命名的時候，那麼就透過註解來提醒後續維護的人，記得幫忙想個好名字啊。</li>
</ul>
<p>警告：是真的無法才這麼做。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tmp = <span class="string">'something'</span>; <span class="comment">// 名稱仍有待改進</span></span><br></pre></td></tr></table></figure>

<p>以上是第一章節的觀後感，自己仔細整理過後真心覺得程式中的命名，比玩遊戲創角色時的命名真的難太多了…。</p>
]]></content>
      <categories>
        <category>Book</category>
        <category>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</category>
      </categories>
      <tags>
        <tag>Book</tag>
        <tag>w3HexSchool</tag>
        <tag>Clean-Code-A-Handbook-of-Agile-Software-Craftsmanship</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 重新認識圖表</title>
    <url>/d3.js/D3-003-recognize-chart/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="對於圖表的認知"><a href="#對於圖表的認知" class="headerlink" title="對於圖表的認知"></a>對於圖表的認知</h2><p>開發者學習 D3.js 的理由可能有很多種，有人可能是為了自己<strong>興趣</strong>、也有人可能是為了<strong>專案需求</strong>，不論出發點在哪，最終 D3.js 目標都是在<strong>產出圖表給使用者看</strong>，因此圖表實際的意涵<strong>是否能達到我們要訴說的</strong>便是我們所要關切的地方。若開發者對於圖表的認知不足，即使製作出來的圖表有對應資料，並且使用了較為困難的技術來呈現，<strong>對於使用者來說</strong>也只是個無效的資訊。</p>
<a id="more"></a>

<h2 id="圖表種類"><a href="#圖表種類" class="headerlink" title="圖表種類"></a>圖表種類</h2><p>對於圖表的認知與呈現上要有所精進，最簡單的方式就是先認識<strong>圖表類型</strong>有哪些，並且知道各圖表所想要<strong>強調的資訊</strong>在哪，進而才在圖表上做一些補強，而以下將介紹幾種最常見的圖表：</p>
<h3 id="長條圖-Bar-Chart"><a href="#長條圖-Bar-Chart" class="headerlink" title="長條圖 Bar Chart"></a>長條圖 Bar Chart</h3><p><img src="https://ithelp.ithome.com.tw/upload/images/20190921/20119062DXISTs8RoJ.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190921/20119062DXISTs8RoJ.jpg"><br>（英文單字使用字母頻率表 圖源來至 D3.js official website）</p>
<p>長條圖一般使用在<strong>二維的資料處理</strong>，其中一軸用來表示<strong>資料的類別</strong>，而長條的長度則表示<strong>該項資訊的大小</strong>，最常使用在於<strong>資料間的相互比較</strong>。</p>
<p>若類別軸資訊是屬於連續的資料（如年份、月份），則可以看出連續的資料趨勢，但可以使用折線圖可能較好表達。</p>
<p>若要表達三維的資訊則可以透過長條的寬度來顯示，但同樣會使得資訊較為混亂，也是要慎選處理。</p>
<blockquote>
<p>變化、相似圖型：堆積長條圖、雙向長條圖、百分比長條圖……等等</p>
</blockquote>
<h3 id="圓餅圖-Pie-Chart"><a href="#圓餅圖-Pie-Chart" class="headerlink" title="圓餅圖 Pie Chart"></a>圓餅圖 Pie Chart</h3><p><img src="https://ithelp.ithome.com.tw/upload/images/20190921/20119062OlFBnOYBz6.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190921/20119062OlFBnOYBz6.jpg"><br>（2015 美國人口年齡分布 圖源來至 D3.js official website）</p>
<p>圓餅圖一般用於比較<strong>資料的比例大小</strong>，通常會輔以其他數字資訊來搭配（如附註百分比比例），而若是資料之間比例如果差異不大的話，使用這個圖表將會難以看出差異。</p>
<blockquote>
<p>變化、相似圖型：玫瑰圖、環形圖、旭日圖</p>
</blockquote>
<h3 id="散點圖-Scatter-Chart"><a href="#散點圖-Scatter-Chart" class="headerlink" title="散點圖 Scatter Chart"></a>散點圖 Scatter Chart</h3><p><img src="https://ithelp.ithome.com.tw/upload/images/20190921/20119062gLfzdj0YEP.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190921/20119062gLfzdj0YEP.jpg"><br>（燃油效率與馬力散點圖 圖源來至 D3.js official website）</p>
<p>散點圖可以用來表示三維的資料處理，如附圖中<code>燃油效率</code>與<code>馬力</code>各為 X 軸與 Y 軸，而各家汽車廠商品牌資料則是透過點來對應前兩項資訊，散點圖可以用<strong>強調視覺上的資料呈現何種的關係取向</strong>（如正相關、負相關等等），而<strong>實際上是否相關仍須以統計計算來判斷</strong>。</p>
<blockquote>
<p>變化、相似圖型：氣泡圖</p>
</blockquote>
<h3 id="折線圖-Line-Chart"><a href="#折線圖-Line-Chart" class="headerlink" title="折線圖 Line Chart"></a>折線圖 Line Chart</h3><p><img src="https://ithelp.ithome.com.tw/upload/images/20190921/20119062isRTSm4IZH.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190921/20119062isRTSm4IZH.jpg"><br>（Apple 股票市值折線圖 圖源來至 D3.js official website）</p>
<p>折線圖與長條圖類似，但更強調於<strong>連續的資料走勢</strong>，透過其中一軸的資料變化（如時間）來觀測固定軸（如商品名稱）的資料變化。</p>
<blockquote>
<p>變化、相似圖型：面積圖、堆積面積圖、百分比面積圖……</p>
</blockquote>
<p>而其餘的圖表還有：</p>
<ul>
<li>熱圖</li>
<li>地圖</li>
<li>雷達圖</li>
<li>儀表圖</li>
<li>瀑布圖</li>
<li>桑葚圖</li>
<li>和弦圖</li>
<li>族繁不及備載</li>
</ul>
<p>以上是今天認識圖表的章節，章節雖簡單卻重要，瞭解資料適合以何種圖表呈現之後，再來決定圖表要做哪些修正與改良，才不會落得使用一手好技術使用者卻不以為意的窘境，而明天將開始介紹使用 D3.js 的基礎用法與繪製簡單圖型。</p>
<blockquote>
<p>每日一貓：黑黑表示我來看看你最近到底在打蝦米碗糕……<br><img src="https://ithelp.ithome.com.tw/upload/images/20190921/20119062lUJiSgzUz7.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190921/20119062lUJiSgzUz7.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 如何繪製圖形？</title>
    <url>/d3.js/D3-004-how-d3-draw/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<p>今天要來介紹 D3.js 如何繪製圖形，而其實 D3.js <strong>本身程式並不會繪圖</strong>，嚴格來說是藉由操作 <strong>HTML DOM</strong> 來達到<strong>新增修改刪除</strong>等功能，而<strong>實際繪製圖形</strong>的部分則是會依靠 <strong>SVG</strong> 來產生，這裡要來稍微介紹一下這些名詞來幫助大家更快理解 D3.js 是怎麼運作的：</p>
<a id="more"></a>

<h2 id="DOM（Document-Object-Model）"><a href="#DOM（Document-Object-Model）" class="headerlink" title="DOM（Document Object Model）"></a>DOM（Document Object Model）</h2><p><img src="https://ithelp.ithome.com.tw/upload/images/20190921/201190628ubodsiOQU.png" alt="https://ithelp.ithome.com.tw/upload/images/20190921/201190628ubodsiOQU.png"></p>
<p>DOM 簡單來說是一種 HTML、XML、SVG 的程式介面，我們可以<strong>透過這個介面來操作 HTML 上的節點</strong>，如附圖中展示的是當 <code>table</code> 元素與裡面的內容以 DOM 樹狀圖結構描述時的樣子，<code>table</code> 底下包了一個子節點 <code>rows</code>，而 <code>rows</code> 底下又有兩項 <code>tr</code> 節點，往下延伸最後可以看到最左邊則是 <code>td</code> 節點裡面放入了一個文字節點 <code>Shady Grove</code>，這個文件在 HTML 程式中則相當於：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rows</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Shady Grove<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Aeollan<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Over the River, Charlie<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Dorian<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rows</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="SVG（Scalable-Vector-Graphics）"><a href="#SVG（Scalable-Vector-Graphics）" class="headerlink" title="SVG（Scalable Vector Graphics）"></a>SVG（Scalable Vector Graphics）</h2><p>SVG 主要是用來描述<strong>平面圖形的一種格式</strong>，並且是以 <strong>XML 格式</strong>來描述，因此開發者可以直接在 HTML 檔案中使用 SVG，下面以一段簡單的 SVG 程式碼來說明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;svg xmlns=<span class="string">"http://www.w3.org/2000/svg"</span> version=<span class="string">"1.1"</span> </span><br><span class="line">    width=<span class="string">"450"</span> height=<span class="string">"450"</span>&gt;</span><br><span class="line">  &lt;rect x=<span class="string">"0"</span> y=<span class="string">"0"</span> width=<span class="string">"100"</span> height=<span class="string">"100"</span> fill=<span class="string">"blue"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure>

<p>在這段程式碼中可以看到要在 HTML 中使用 SVG，首先要使用 SVG 標籤來，並且在屬性中定義渲染的範圍與基本的文件說明與版本，接著在標籤內容放入要繪製的圖形標籤以及相關的位置、寬高以及填入的顏色等等。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190922/20119062ehXvPXwJ6G.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190922/20119062ehXvPXwJ6G.jpg"></p>
<p>如此一來，瀏覽器就會依照其 DOM 結構來繪製圖形（如上方），而我們也能透過 JavaScript 來操作這些 HTML DOM，至於 D3.js 提供的功能便是<strong>一系列操作這些圖形介面 DOM 的方法集</strong>給我們使用，透過包裝好的函式，我們可以更快速、方便的去取得這些內容與新增修改。</p>
<p>而目前 SVG 的標籤有以下幾種：</p>
<ul>
<li>圓形 <code>&lt;circle&gt;</code></li>
<li>橢圓形 <code>&lt;ellipse&gt;</code></li>
<li>矩形 <code>&lt;rect&gt;</code></li>
<li>線條 <code>&lt;line&gt;</code></li>
<li>折線 <code>&lt;polyline&gt;</code></li>
<li>多邊形 <code>&lt;polygon&gt;</code></li>
<li>路徑 <code>&lt;path&gt;</code></li>
</ul>
<p>明天我們則會繼續介紹這幾種基本圖形在 SVG 中要如何設定！</p>
<blockquote>
<p>今日一貓：最近黑黑每天都在找新的地方可以趴著，從南趴到北在從北趴到南的那種<br><img src="https://ithelp.ithome.com.tw/upload/images/20190922/20119062DmPChMevas.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190922/20119062DmPChMevas.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
        <tag>SVG</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js SVG 基本圖型繪製</title>
    <url>/d3.js/D3-005-svg-draw-1/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="繪製圖形"><a href="#繪製圖形" class="headerlink" title="繪製圖形"></a>繪製圖形</h2><p>上次提到了 D3.js 實際上是透過 HTML DOM 來操作元素標籤，並且透過 SVG 來繪圖的，而 SVG 繪圖十分簡單，各種基本圖形在 SVG 中都有標籤能夠直接使用，並且使用方法大同小異，只要控制該元素標籤的屬性，就能夠相對應的產生想要製作的圖形，以下列出 SVG 目前支援的標籤以及介紹各個標籤中有哪些屬性可以操控：</p>
<ul>
<li>圓形 <code>&lt;circle&gt;</code></li>
<li>橢圓形 <code>&lt;ellipse&gt;</code></li>
<li>矩形 <code>&lt;rect&gt;</code></li>
<li>線條 <code>&lt;line&gt;</code></li>
<li>折線 <code>&lt;polyline&gt;</code></li>
<li>多邊形 <code>&lt;polygon&gt;</code></li>
<li>路徑 <code>&lt;path&gt;</code></li>
</ul>
<a id="more"></a>

<h3 id="圓形"><a href="#圓形" class="headerlink" title="圓形"></a>圓形</h3><ul>
<li><code>cx</code> ：表示圓心在 SVG 畫布中的 X 座標</li>
<li><code>cy</code> ：圓心在 SVG 畫布中的 Y 座標</li>
<li><code>r</code> ：圓半徑</li>
</ul>
<p>例：產生一個半徑為 50 px 的圓形圖案</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"50"</span> <span class="attr">style</span>=<span class="string">"fill:red"</span>&gt;</span><span class="tag">&lt;/<span class="name">circle</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062JftvAFXvM1.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062JftvAFXvM1.jpg"></p>
<h3 id="橢圓形"><a href="#橢圓形" class="headerlink" title="橢圓形"></a>橢圓形</h3><ul>
<li><code>cx</code> ：圓心在 SVG 畫布中的 X 座標</li>
<li><code>cy</code> ：圓心在 SVG 畫布中的 Y 座標</li>
<li><code>rx</code> ：橢圓形的 X 軸半徑</li>
<li><code>ry</code> ：橢圓形的 Y 軸半徑</li>
</ul>
<p>例：產生一個 X 軸半徑為 50 px，Y 軸半徑為 25 px 的橢圓形圖案</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"50"</span> <span class="attr">rx</span>=<span class="string">"50"</span> <span class="attr">ry</span>=<span class="string">"25"</span> <span class="attr">style</span>=<span class="string">"fill:orange"</span>&gt;</span><span class="tag">&lt;/<span class="name">ellipse</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062o05UzrfJUw.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062o05UzrfJUw.jpg"></p>
<h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><ul>
<li><code>width</code> ：矩形寬度</li>
<li><code>height</code> ：矩形高度</li>
<li><code>x</code> ：以矩形左上角為基準的 X 座標</li>
<li><code>y</code> ：以矩形左上角為基準的 Y 座標</li>
<li><code>rx</code> ：導圓角的 X 軸半徑</li>
<li><code>ry</code> ：導圓角的 Y 軸半徑</li>
</ul>
<p>例：產生一個長寬為 50 px 且導圓角 10px 的矩形</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">"50"</span> <span class="attr">height</span>=<span class="string">"50"</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">rx</span>=<span class="string">"10"</span> <span class="attr">ry</span>=<span class="string">"10"</span> <span class="attr">style</span>=<span class="string">"fill:yellow"</span>&gt;</span><span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/2011906278Z9CQEVGO.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/2011906278Z9CQEVGO.jpg"></p>
<h3 id="線條"><a href="#線條" class="headerlink" title="線條"></a>線條</h3><ul>
<li><code>x1</code> ：起始位置的 X 座標</li>
<li><code>x2</code> ：終點位置的 X 座標</li>
<li><code>y1</code> ：起始位置的 Y 座標</li>
<li><code>y2</code> ：終點位置的 Y 座標</li>
</ul>
<p>例：產生一個 50 px 長寬，左上到右下與左下到右上的叉叉圖案</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"50"</span> <span class="attr">height</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">"0"</span> <span class="attr">x2</span>=<span class="string">"50"</span> <span class="attr">y1</span>=<span class="string">"0"</span> <span class="attr">y2</span>=<span class="string">"50"</span> <span class="attr">style</span>=<span class="string">"stroke: green; stroke-width: 2"</span> &gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">"0"</span> <span class="attr">x2</span>=<span class="string">"50"</span> <span class="attr">y1</span>=<span class="string">"50"</span> <span class="attr">y2</span>=<span class="string">"0"</span> <span class="attr">style</span>=<span class="string">"stroke: green; stroke-width: 2"</span> &gt;</span><span class="tag">&lt;/<span class="name">line</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062OIzxjDgTw3.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062OIzxjDgTw3.jpg"></p>
<h3 id="折線、多邊形"><a href="#折線、多邊形" class="headerlink" title="折線、多邊形"></a>折線、多邊形</h3><p>折線與多邊形基本上會以 <code>points</code> 屬性來表示每個點之間的 X、Y 座標，透過多個座標來連成一條線，多邊形與折線的差異在於多邊形的最後一點座標點會連回起始座標點。</p>
<p>例：產生一個上下彎折的折線與多邊形</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">"0,0 25,25 50,0 75,25"</span> <span class="attr">style</span>=<span class="string">"fill: none;stroke: blue;stroke-width: 4"</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062cslj7ius7N.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062cslj7ius7N.jpg"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">points</span>=<span class="string">"0,0 25,25 50,0 75,25"</span> <span class="attr">style</span>=<span class="string">"fill: none;stroke: purple;stroke-width: 4"</span>&gt;</span><span class="tag">&lt;/<span class="name">polygon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062xxws5OfM3F.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062xxws5OfM3F.jpg"></p>
<h3 id="路徑"><a href="#路徑" class="headerlink" title="路徑"></a>路徑</h3><p>路徑則是 SVG 標籤裡面功能最多樣的標籤元素，除了擁有類似於折線、多邊形的座標軸來定義各個點來繪製線條之外還可以透過其他輔助的屬性值來描述如何移動到下個座標軸，最後透過屬性 <code>d</code> 來將下列有用到的內容來定義圖形：</p>
<ul>
<li><code>M</code> ：移動到該座標軸（不繪製線條）。</li>
<li><code>L</code> ：繪製線條到下一個座標。</li>
<li><code>H</code> ：繪製水平線到下個 X 座標</li>
<li><code>V</code> ：繪製水平線到下個 Y 座標</li>
<li><code>C</code> ：經兩個指定座標來繪製貝茲曲線</li>
<li><code>S</code> ：輸入終點座標後與前一條貝茲曲線的指定座標，對稱產生下個貝茲曲線指定座標，來繪製貝茲曲線。</li>
<li><code>A</code> ：繪製一個橢圓曲線到下一個座標。</li>
<li><code>Z</code> ：繪製一條到起點座標的線條。（效果看起來像是封閉圖形）</li>
</ul>
<p>例：如 D3.js 官網本身的 LOGO 就是由 SVG 所定義而成的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"96"</span> <span class="attr">height</span>=<span class="string">"91"</span> <span class="attr">style</span>=<span class="string">"position:relative;top:22px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">clipPath</span> <span class="attr">id</span>=<span class="string">"clip"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M0,0h7.75a45.5,45.5 0 1 1 0,91h-7.75v-20h7.75a25.5,25.5 0 1 0 0,-51h-7.75zm36.2510,0h32a27.75,27.75 0 0 1 21.331,45.5a27.75,27.75 0 0 1 -21.331,45.5h-32a53.6895,53.6895 0 0 0 18.7464,-20h13.2526a7.75,7.75 0 1 0 0,-15.5h-7.75a53.6895,53.6895 0 0 0 0,-20h7.75a7.75,7.75 0 1 0 0,-15.5h-13.2526a53.6895,53.6895 0 0 0 -18.7464,-20z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">clipPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">"gradient-1"</span> <span class="attr">gradientUnits</span>=<span class="string">"userSpaceOnUse"</span> <span class="attr">x1</span>=<span class="string">"7"</span> <span class="attr">y1</span>=<span class="string">"64"</span> <span class="attr">x2</span>=<span class="string">"50"</span> <span class="attr">y2</span>=<span class="string">"107"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"0"</span> <span class="attr">stop-color</span>=<span class="string">"#f9a03c"</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"1"</span> <span class="attr">stop-color</span>=<span class="string">"#f7974e"</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">"gradient-2"</span> <span class="attr">gradientUnits</span>=<span class="string">"userSpaceOnUse"</span> <span class="attr">x1</span>=<span class="string">"2"</span> <span class="attr">y1</span>=<span class="string">"-2"</span> <span class="attr">x2</span>=<span class="string">"87"</span> <span class="attr">y2</span>=<span class="string">"84"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"0"</span> <span class="attr">stop-color</span>=<span class="string">"#f26d58"</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"1"</span> <span class="attr">stop-color</span>=<span class="string">"#f9a03c"</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">"gradient-3"</span> <span class="attr">gradientUnits</span>=<span class="string">"userSpaceOnUse"</span> <span class="attr">x1</span>=<span class="string">"45"</span> <span class="attr">y1</span>=<span class="string">"-10"</span> <span class="attr">x2</span>=<span class="string">"108"</span> <span class="attr">y2</span>=<span class="string">"53"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"0"</span> <span class="attr">stop-color</span>=<span class="string">"#b84e51"</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"1"</span> <span class="attr">stop-color</span>=<span class="string">"#f68e48"</span>&gt;</span><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span> <span class="attr">clip-path</span>=<span class="string">"url(#clip)"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M-100,-102m-27,0v300h300z"</span> <span class="attr">fill</span>=<span class="string">"url(#gradient-1)"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M-100,-102m27,0h300v300z"</span> <span class="attr">fill</span>=<span class="string">"url(#gradient-3)"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M-100,-102l300,300"</span> <span class="attr">fill</span>=<span class="string">"none"</span> <span class="attr">stroke</span>=<span class="string">"url(#gradient-2)"</span> <span class="attr">stroke-width</span>=<span class="string">"40"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062iOg34QXBk8.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062iOg34QXBk8.jpg"></p>
<p>以上光是看到屬性可能大家就已經暈了，而實際上開發時<strong>我們通常不會親自一個一個輸入</strong>這些座標屬性值，開發者除了可以<strong>透過 D3.js 的函式去產生</strong>對應的路徑之外，像是使用繪圖軟體 AI （Adobe Illustrator）也可以將圖片儲存為 SVG 的格式將其放置在網頁當中，最後就能產出像是上方 D3.js 官網的 SVG 程式碼了。</p>
<blockquote>
<p>阿橘固定都會在我要打文章的時候來蹭螢幕。前幾天阿橘還差一點幫我發文章 XD<br><img src="https://ithelp.ithome.com.tw/upload/images/20190923/20119062xqlw5CfNow.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190923/20119062xqlw5CfNow.jpg"><br>（阿橘一臉無辜地看著我）</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js SVG 基本圖型繪製（續）</title>
    <url>/d3.js/D3-005-svg-draw-2/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<p>SVG 除了基本的圖形繪製之外，另外還可以做到繪製文字、更改樣式、等等功能，今天我們將要來看看還有哪些功能沒介紹到的部分：</p>
<h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>SVG 中有提供一個 <code>text</code> 標籤以供我們繪製文字的部分：</p>
<ul>
<li><code>x</code> ：文字左上角的 X 座標。</li>
<li><code>y</code> ：文字左上角的 Y 座標。</li>
<li><code>dx</code> ：以 <code>x</code> 座標為基準，平行移動文字距離（正為往右，負為往左）。</li>
<li><code>dy</code> ：以 <code>y</code> 座標為基準，垂直移動文字距離（正為往上，負為往下）。</li>
<li><code>textLength</code> ：文字字距。</li>
<li><code>rotate</code> ：<strong>每個文字</strong>的旋轉角度。（若是要整組文字一起旋轉可以使用 <code>transform=&quot;rotate()&quot;</code> 。）</li>
</ul>
<a id="more"></a>

<p>範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">height</span>=<span class="string">"50"</span> <span class="attr">width</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">"20"</span> <span class="attr">y</span>=<span class="string">"20"</span> <span class="attr">fill</span>=<span class="string">"red"</span> <span class="attr">rotate</span>=<span class="string">"180"</span> <span class="attr">transform</span>=<span class="string">"rotate(30 20,40)"</span>&gt;</span>SVG<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>呈現結果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190924/20119062o2JJVfwDpH.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190924/20119062o2JJVfwDpH.jpg"></p>
<h2 id="基本樣式"><a href="#基本樣式" class="headerlink" title="基本樣式"></a>基本樣式</h2><p>SVG 的樣式幾乎都能夠依照我們所熟悉的 CSS 來使用，只是開發時需要依照 SVG 標籤定義好的樣式屬性來編寫樣式表，下面列出幾個比較不常出現的樣式屬性：</p>
<ul>
<li><code>fill</code> ：圖形內部顏色。</li>
<li><code>stroke</code> ：圖形邊框顏色。</li>
<li><code>stroke-width</code> ：圖形邊框寬度。</li>
<li><code>stroke-linecap</code> ：輪廓線兩端的樣式（可設為直角、圓角）。</li>
<li><code>stroke-dasharray</code> ：輪廓線條樣式（實線、虛線……等等）。</li>
</ul>
<p>範例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">&lt;svg <span class="built_in">height</span>=<span class="string">"30"</span> <span class="built_in">width</span>=<span class="string">"200"</span>&gt;</span><br><span class="line">    &lt;path <span class="built_in">stroke</span>=<span class="string">"black"</span> <span class="built_in">stroke</span>-<span class="built_in">width</span>=<span class="string">"4"</span> <span class="built_in">stroke</span>-dasharray=<span class="string">"5,5"</span> d=<span class="string">"M0 10 l200 0"</span> /&gt;</span><br><span class="line">    &lt;path <span class="built_in">stroke</span>=<span class="string">"black"</span> <span class="built_in">stroke</span>-<span class="built_in">width</span>=<span class="string">"6"</span> <span class="built_in">stroke</span>-dasharray=<span class="string">"10,10"</span> d=<span class="string">"M0 25 l200 0"</span> /&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>呈現結果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190924/20119062PQy5MXmhCn.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190924/20119062PQy5MXmhCn.jpg"></p>
<h2 id="定義樣式"><a href="#定義樣式" class="headerlink" title="定義樣式"></a>定義樣式</h2><p>在 SVG 中還有一些樣式需要<strong>先定義</strong>後才能使用的，而這些內容最後都會放在一個 <code>&lt;defs&gt;</code> 標籤當中，在 <code>&lt;defs&gt;</code> 這個標籤中，除了用來定義樣式外，最主要的功用是可以將其定義的樣式內容<strong>重覆給予其他圖形標籤作為使用</strong>，而以下為需要放在定義標籤中作為使用的樣式：</p>
<h3 id="濾鏡"><a href="#濾鏡" class="headerlink" title="濾鏡"></a>濾鏡</h3><p>常使用 CSS 開發的人應該多少有用過 <code>filter</code> 這個 CSS 屬性，而在 SVG 中也可以使用類似的功能，而樣式標籤名稱正也是 <code>&lt;filter&gt;</code> 。</p>
<p>使用方法也很簡單，在 <code>&lt;defs&gt;</code> 標籤中，放入 <code>&lt;filter&gt;</code> 標籤並輸入 <code>id</code> 屬性以供接指定，接著在子層中放入濾鏡標籤（濾鏡標籤可參考<a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter#See_also" target="_blank" rel="noopener"> MDN </a>上的列表）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">id</span>=<span class="string">"Blur"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">feGaussianBlur</span> <span class="attr">in</span>=<span class="string">"SourceGraphic"</span> <span class="attr">stdDeviation</span>=<span class="string">"5"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最後在使用圖形標籤時，在 <code>filter</code> 屬性中，使用 <code>url</code> 來指定剛剛定義好的樣式及可套用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">width</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">id</span>=<span class="string">"Blur"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">feGaussianBlur</span> <span class="attr">in</span>=<span class="string">"SourceGraphic"</span> <span class="attr">stdDeviation</span>=<span class="string">"5"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">"50"</span> <span class="attr">y</span>=<span class="string">"50"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>  <span class="attr">stroke-width</span>=<span class="string">"3"</span> <span class="attr">fill</span>=<span class="string">"blue"</span> <span class="attr">filter</span>=<span class="string">"url(#Blur)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>呈現結果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190924/20119062m0NRzIXNEV.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190924/20119062m0NRzIXNEV.jpg"></p>
<h3 id="漸層"><a href="#漸層" class="headerlink" title="漸層"></a>漸層</h3><p>漸層的標籤可分為線性漸層 <code>&lt;linearGradient&gt;</code> 以及放射性漸層 <code>&lt;radialGradient&gt;</code> ，使用上兩者大同小異，最主要是最後呈現結果的不同。</p>
<p>在 <code>Gradient</code> 標籤的屬性中，可以透過 <code>X</code> 與 <code>Y</code> 去定義漸層顏色的起點與終點：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">"linearGradient"</span> <span class="attr">x1</span>=<span class="string">"0%"</span> <span class="attr">y1</span>=<span class="string">"0%"</span> <span class="attr">x2</span>=<span class="string">"100%"</span> <span class="attr">y2</span>=<span class="string">"0%"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>並在內層中可以放入 <code>&lt;stop&gt;</code> 標籤，透過 <code>offset</code> 屬性來指定漸層位置，style 中的 <code>stop-color</code> 則可以用來指定該位置的顯示顏色：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"0%"</span> <span class="attr">style</span>=<span class="string">"stop-color:rgb(255,0,0);stop-opacity:1"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>完整範例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">width</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">"linearGradient"</span> <span class="attr">x1</span>=<span class="string">"0%"</span> <span class="attr">y1</span>=<span class="string">"0%"</span> <span class="attr">x2</span>=<span class="string">"100%"</span> <span class="attr">y2</span>=<span class="string">"0%"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"0%"</span> <span class="attr">style</span>=<span class="string">"stop-color:rgb(255,0,0);stop-opacity:1"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"50%"</span> <span class="attr">style</span>=<span class="string">"stop-color:rgb(255,255,0);stop-opacity:1"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">"100%"</span> <span class="attr">style</span>=<span class="string">"stop-color:rgb(0,255,255);stop-opacity:1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">"100"</span> <span class="attr">cy</span>=<span class="string">"100"</span> <span class="attr">rx</span>=<span class="string">"75"</span> <span class="attr">ry</span>=<span class="string">"50"</span> <span class="attr">fill</span>=<span class="string">"url(#linearGradient)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>呈現結果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190924/20119062nE5Uo8ixmi.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190924/20119062nE5Uo8ixmi.jpg"></p>
<h3 id="標記"><a href="#標記" class="headerlink" title="標記"></a>標記</h3><p>標記主要可以用來繪製線段上的箭頭，藉由 <code>&lt;marker&gt;</code>標籤來定義相關屬性：</p>
<ul>
<li><code>viewBox</code> ：用來定義 <code>marker</code> 內繪製圖形的比例（概念好比從五樓陽台上看陸地上的行人與從二十樓陽台上看的差別）。</li>
<li><code>refX</code>、<code>refY</code> ：繪製時從該點（如起點或終點）延伸成坐標系，再將 <code>viewBox</code> 所設定好的圖形放在此點上。</li>
<li><code>markerWidth</code>、<code>markerHeight</code> ：標記圖形顯示的寬高。</li>
<li><code>markerUnits</code> ：指定標記大小的參考對象（如線的寬度 <code>strokeWidth</code>）。</li>
</ul>
<p>而在圖形標籤中，則可以藉由 <code>marker-start</code> 、<code>marker-mid</code> 及 <code>marker-end</code> 來將上方製作好的標記放入線段的起點、中點以及結尾的部分。</p>
<p>範例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">marker</span> <span class="attr">id</span>=<span class="string">"m1"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 100 100"</span> <span class="attr">refX</span>=<span class="string">"25"</span> <span class="attr">refY</span>=<span class="string">"25"</span> <span class="attr">markerWidth</span>=<span class="string">"20"</span> <span class="attr">markerHeight</span>=<span class="string">"50"</span> <span class="attr">orient</span>=<span class="string">"auto"</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">"25"</span> <span class="attr">cy</span>=<span class="string">"25"</span> <span class="attr">rx</span>=<span class="string">"25"</span> <span class="attr">ry</span>=<span class="string">"50"</span> <span class="attr">fill</span>=<span class="string">"black"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">marker</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">marker</span> <span class="attr">id</span>=<span class="string">"m2"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 100 100"</span> <span class="attr">refX</span>=<span class="string">"50"</span> <span class="attr">refY</span>=<span class="string">"22"</span> <span class="attr">markerWidth</span>=<span class="string">"50"</span> <span class="attr">markerHeight</span>=<span class="string">"20"</span> <span class="attr">orient</span>=<span class="string">"auto"</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">"25"</span> <span class="attr">cy</span>=<span class="string">"25"</span> <span class="attr">rx</span>=<span class="string">"50"</span> <span class="attr">ry</span>=<span class="string">"25"</span> <span class="attr">fill</span>=<span class="string">"black"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">marker</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">"25,25 100,100"</span> <span class="attr">fill</span>=<span class="string">"none"</span> <span class="attr">stroke</span>=<span class="string">"black"</span> <span class="attr">stroke-width</span>=<span class="string">"1"</span> <span class="attr">marker-end</span>=<span class="string">"url(#m1)"</span> <span class="attr">marker-start</span>=<span class="string">"url(#m2)"</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>呈現結果：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190924/20119062vHOREh7m48.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190924/20119062vHOREh7m48.jpg"></p>
<p>以上就是 SVG 繪製圖形的一些輔助功能，而接下來的章節將會介紹 D3.js 如何選取與資料綁定！</p>
<blockquote>
<p>早上感冒請假去打針，回到家想發文，發現阿橘直接霸佔我的位置，動他還會生氣的那種（起床氣？），只好一個哭笑不得地拿書去其他地方看了……<br><img src="https://ithelp.ithome.com.tw/upload/images/20190924/20119062WcVX8mYlHe.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190924/20119062WcVX8mYlHe.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 資料選取 d3-selection 與資料綁定 Joining Data</title>
    <url>/d3.js/D3-006-selection-data-datum/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="資料選取"><a href="#資料選取" class="headerlink" title="資料選取"></a>資料選取</h2><p>在繪製圖表前，首先要掌握 D3.js 如何 <strong>選取元素</strong>，接著才能將要修改的資料輸出到選取的元素裡。而 D3.js 選取元素的部分與 jQuery 是同一套作法，也就是以往撰寫 CSS 相關程式時，開發者怎麼比對元素，就是以那一套為基準即可！</p>
<blockquote>
<p>例如選取 id 為 test 的元素則是使用 <code>#test</code> 作為選取器。</p>
<p>這裡假定開發者已稍微瞭解基礎的 CSS 選擇器（selector ），如果對於 CSS 選擇器還不熟悉的話，可以透過這個 <a href="https://flukeout.github.io" target="_blank" rel="noopener">有趣的盤子遊戲</a> 來快速學習 CSS 選擇器！</p>
</blockquote>
<p>而 D3.js 目前提供了兩種方法以供開發者捕捉元素：</p>
<a id="more"></a>

<ul>
<li><code>d3.select</code> ：捕捉符合選取器的第一個元素</li>
<li><code>d3.selectAll</code> ：捕捉符合選取器的所有元素</li>
</ul>
<p>使用 D3.js 選取器捕捉到的元素（選擇集），後續則可以繼續透過 D3.js 的方法來進行 DOM 的操作修改，例如將選取到的 <code>p</code> 元素中所有的文字都改成紅色：</p>
<p>JavaScript 部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">d3.selectAll(<span class="string">'p'</span>).style(<span class="string">'color'</span>,<span class="string">'red'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若想要測試語法，除了使用前面章節提到的開發環境建置之外，你可以直接在 <a href="https://d3js.org/" target="_blank" rel="noopener">D3.js 官方網站</a> 開啟開發者工具（DevTools）直接測試！</p>
</blockquote>
<h2 id="資料綁定"><a href="#資料綁定" class="headerlink" title="資料綁定"></a>資料綁定</h2><p>現在我們已經可以透過 D3.js 選取到資料集了，然而選取集上的元素裡面並<strong>沒有帶任何的資料</strong>，我們得透過 D3.js 提供的資料綁定方法將<strong>資料綁定於選取的資料集</strong>中，目前 D3.js 提供了兩種方法供開發者使用，接著就來介紹一下他們用法與差異：</p>
<ul>
<li><code>selection.datum</code></li>
<li><code>selection.data</code></li>
</ul>
<h3 id="datum"><a href="#datum" class="headerlink" title="datum"></a>datum</h3><p>datum 的用法有兩種，一種是<strong>未帶參數直接使用其函式</strong>，如<code>d3.selection.datum()</code> 將會<strong>返回選取集所綁定的數據資料</strong>。</p>
<p>第二種就是<strong>將數據資料當作參數帶入函式當中</strong>，如<code>d3.selection.datum(&#39;數據資料&#39;)</code> <strong>將會把數據資料綁定到選取集中每一個元素身上</strong>，而數據資料<strong>綁定的類型</strong>除了<code>undefined</code>與<code>null</code>值之外<strong>都可以賦予該元素</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d3datum = d3.selectAll(<span class="string">'p'</span>).datum(<span class="string">'綁定資料'</span>)</span><br></pre></td></tr></table></figure>

<p>以 D3.js 官網觀察，透過 <code>console.log(d3datum)</code> 可以很清楚的看到該選取集元素物件屬性中含有一個 <code>__data__</code> 的欄位，而這個欄位就是 D3.js 賦予這個元素的資料位置。（如下圖）</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190925/20119062yg0GqFbt7u.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190925/20119062yg0GqFbt7u.jpg"></p>
<p>綁定資料後可以接著以 D3.js 的提供方法來使用這筆資料，例如將透過 <code>text</code> 函式將內容更換為所綁定的資料：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d3datum = d3.selectAll(<span class="string">'p'</span>)</span><br><span class="line">                .datum(<span class="string">'綁定資料'</span>)</span><br><span class="line">                .text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure>

<p>所有被綁定到的資料透過 <code>text</code> 內函式的<strong>第一個傳送參數</strong>（<code>d</code>）替換進去，而 <code>text</code> 用法則是將返回（<code>return</code>）的數值替換為該文字節點的內容。</p>
<blockquote>
<p>註：部分 D3.js 提供的方法第一個傳送參數皆為<strong>元素所綁定的資料</strong>（<code>data</code>），第二個則為<strong>資料集的索引值</strong>（<code>index</code>）。</p>
</blockquote>
<p>最後就會看到 D3.js 官方網站變成了這樣：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190925/20119062XFSQrvYrxe.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190925/20119062XFSQrvYrxe.jpg"></p>
<p>要注意的是，datum 在綁定資料的過程時，有一個特性是若透過被綁定資料的元素來新增一個新的元素時，其<strong>子元素也會繼承父元素的數據資料</strong>（<code>__data__</code>）。</p>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>data 使用方法與 datum 相同，而不一樣的是其綁定資料的邏輯是會<strong>按照陣列索引值</strong>或<strong>指定的方法</strong>來依序的綁定資料到元素上。</p>
<p>例如網站上目前有三個<code>&lt;div&gt;</code>元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>若是有一筆數據資料為<code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code>，透過 data、datum 方法綁定後：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleData = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line">D3.selectAll(<span class="string">'div'</span>).data(sampleData)</span><br></pre></td></tr></table></figure>


<p>接著再觀察 <code>__data__</code> 將會得到：</p>
<table>
<thead>
<tr>
<th>\</th>
<th>透過 data 綁定得到的<code>__data__</code></th>
<th>透過 datum 綁定得到的<code>__data__</code></th>
</tr>
</thead>
<tbody><tr>
<td>第一個 <code>&lt;div&gt;</code>：</td>
<td><code>a</code></td>
<td><code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code></td>
</tr>
<tr>
<td>第二個 <code>&lt;div&gt;</code>：</td>
<td><code>b</code></td>
<td><code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code></td>
</tr>
<tr>
<td>第三個 <code>&lt;div&gt;</code>：</td>
<td><code>c</code></td>
<td><code>[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code></td>
</tr>
</tbody></table>
<p>由此可見，<code>data</code> 所綁定的數據資料的邏輯會依照其<strong>綁定的元素集</strong>下去做分配，因此若是綁定的元素數量與數據資料的數量不同時，將會被 D3.js 歸納為以下三種邏輯：</p>
<ul>
<li><strong>update</strong> : 輸入該筆數據資料時若<strong>還有</strong>元素可供資料輸入，該筆輸入的資料會被歸納 <code>update</code> 資料。</li>
<li><strong>enter</strong> : 輸入該筆數據資料時若<strong>沒有</strong>元素可供資料輸入，該筆輸入的資料會被歸納 <code>enter</code> 資料。</li>
<li><strong>exit</strong> : 若是資料已經輸入完了，還有剩餘被綁定的元素，則剩下的元素將會被歸納為 <code>exit</code> 資料。</li>
</ul>
<p><strong>例如被綁定的元素有三個，而數據資料有四筆時：</strong></p>
<table>
<thead>
<tr>
<th>元素</th>
<th>數據資料</th>
<th>整筆被綁定的元素會被歸納為</th>
</tr>
</thead>
<tbody><tr>
<td>第一筆被綁定的元素</td>
<td><code>a</code></td>
<td><code>update</code> 資料</td>
</tr>
<tr>
<td>第二筆被綁定的元素</td>
<td><code>b</code></td>
<td><code>update</code> 資料</td>
</tr>
<tr>
<td>第三筆被綁定的元素</td>
<td><code>c</code></td>
<td><code>update</code> 資料</td>
</tr>
<tr>
<td>無</td>
<td><code>d</code></td>
<td><code>enter</code> 資料</td>
</tr>
</tbody></table>
<p><strong>例如被綁定的元素有四個，而數據資料只有兩筆時：</strong></p>
<table>
<thead>
<tr>
<th>元素</th>
<th>數據資料</th>
<th>整筆被綁定的元素會被歸納為</th>
</tr>
</thead>
<tbody><tr>
<td>第一筆被綁定的元素</td>
<td><code>a</code></td>
<td><code>update</code> 資料</td>
</tr>
<tr>
<td>第二筆被綁定的元素</td>
<td><code>b</code></td>
<td><code>update</code> 資料</td>
</tr>
<tr>
<td>第三筆被綁定的元素</td>
<td>無</td>
<td><code>exit</code> 資料</td>
</tr>
<tr>
<td>第四筆被綁定的元素</td>
<td>無</td>
<td><code>exit</code> 資料</td>
</tr>
</tbody></table>
<p>透過 <code>d3.selection.data()</code> 返回的數值中，可以看到一個屬於 <code>update</code> 資料的陣列物件以及 <code>enter</code> 函式與 <code>exit</code> 函式分別可以找到對應類型的資料，而這個類別資料的重要性在於，繪製圖型時我們需要透過這些類型的資料來判斷那些是我們要更動的資料或哪些元素是我們不需要的。若開發者能夠分清楚這三種數據資料的差別，對往後的資料處理上將會更加的容易！</p>
<p>而我們今天已經能夠透過 D3.js 選取到資料集以及將資料綁定給元素了，並且我們還能夠判斷出哪些資料是屬於要更新 <code>update</code> 、進入 <code>enter</code> 以及離開 <code>exit</code>，接下來明天我們將會活用這三個類別資料來進行資料處理，就讓我們明天見啦！</p>
<blockquote>
<p>橘橘舉頭望明月<br><img src="https://ithelp.ithome.com.tw/upload/images/20190925/20119062iIohG6Xuvh.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190925/20119062iIohG6Xuvh.jpg"></p>
</blockquote>
<h2 id="9-26-更新"><a href="#9-26-更新" class="headerlink" title="9/26 更新"></a>9/26 更新</h2><p>不排斥英文文章閱讀的話，D3.js 作者本人 Mike Bostock 也有一篇文章詳細介紹了 D3.js 中 <a href="https://bost.ocks.org/mike/selection/" target="_blank" rel="noopener">選擇集的運作</a>，並且還有提供視覺動畫解釋之間的關係。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 資料處理與篩選</title>
    <url>/d3.js/D3-009-d3-data-processing/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<p>昨天我們已經成功的將 D3.js 放入 Vue.js 裡面，藉由 Vue.js 的 <code>生命週期鉤子</code> 與 <code>監聽</code> 來驅動函式重新繪製圖表，而今天要來說明的是 D3.js 中的資料處理與篩選：</p>
<blockquote>
<p>註：這裡指的資料處理是指對以優化過的資料集做延伸的處理，倘諾資料集本身需要大量的欄位調整、優化則建議需在資料庫、後端回傳 API 前就先將資料集處理完畢。</p>
</blockquote>
<a id="more"></a>

<h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p>在 D3.js 中的 <code>filter()</code> 與 JavaScript 中的 <code>filter()</code> 使用起來的功用差不多，主要用意是回傳<strong>資料集中符合條件的資料</strong>內容，主要使用時機與位置是在<strong>綁定資料集之後</strong>才來篩選，我們以昨天合併完的程式碼為例：</p>
<p>昨天範例在 Vue.js <code>methods</code> 中，我們有一段 <code>draw()</code> 函式用來繪製圖表，我們將 <code>filter()</code> 插入在新增元素之前：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">draw(newData) &#123;</span><br><span class="line">  <span class="keyword">let</span> dataset = newData || <span class="keyword">this</span>.sampleData;</span><br><span class="line">  <span class="keyword">let</span> circle = d3.select(<span class="string">"svg"</span>).selectAll(<span class="string">"circle"</span>);</span><br><span class="line">  <span class="keyword">let</span> update = circle.data(dataset);</span><br><span class="line">  <span class="keyword">let</span> enter = update.enter();</span><br><span class="line">  <span class="keyword">let</span> exit = update.exit();</span><br><span class="line"></span><br><span class="line">  update</span><br><span class="line">    .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">    .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">    &#125;)</span><br><span class="line">    .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">  enter</span><br><span class="line">    .filter(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;  <span class="comment">// 將 filter 插入在這裡，藉由 d 參數傳入綁定的資料集</span></span><br><span class="line">      <span class="keyword">return</span> d &gt; <span class="number">20</span>;       <span class="comment">// 將資料集中每筆資料拿出來比對，大於 20 才返回該筆資料</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .append(<span class="string">"circle"</span>)</span><br><span class="line">    .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">    .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">    &#125;)</span><br><span class="line">    .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">  exit.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最後因為資料集中 <code>[10, 20, 30]</code>中只剩下一筆資料符合，因此可以看到畫面上只剩下一個半徑為 <code>30</code> 的圓形。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190928/20119062nNh8BPrhSx.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190928/20119062nNh8BPrhSx.jpg"></p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><p><code>sort()</code> 的功用則也與 JavaScript 原生的用法類似，<strong>目的在於排列資料集中的順序</strong>，並且我們也同樣可以傳入排列的函式，來變更排序的方法：</p>
<ul>
<li>sort() ：若不填入比較函式，則預設內部會返回 <code>d3.ascending(a,b)</code> 的遞增排列。</li>
<li>d3.ascending(a,b)： 將資料集的資料<strong>遞增</strong>排列。</li>
<li>d3.descending(a,b)： 將資料集的資料<strong>遞減</strong>排列。</li>
</ul>
<p>使用時機是放在<strong>綁定資料的後方</strong>，例如昨天程式碼中，我們在 <code>update</code> 變數中綁定資料的位置裡：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">draw(newData) &#123;</span><br><span class="line">  <span class="keyword">let</span> dataset = newData || <span class="keyword">this</span>.sampleData;</span><br><span class="line">  <span class="keyword">let</span> circle = d3.select(<span class="string">"svg"</span>).selectAll(<span class="string">"circle"</span>);</span><br><span class="line">  <span class="keyword">let</span> update = circle.data(dataset.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123; <span class="comment">// 在綁定的資料集上做好排序</span></span><br><span class="line">      <span class="keyword">return</span> d3.descending(a,b) <span class="comment">// 這裡選擇資料集要返回遞減的排列</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="comment">// 以上寫法等同於 let update = circle.data(dataset.sort(d3.descending));</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> enter = update.enter();</span><br><span class="line">  <span class="keyword">let</span> exit = update.exit();</span><br><span class="line"></span><br><span class="line">  update</span><br><span class="line">    .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">    .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">    &#125;)</span><br><span class="line">    .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">  enter</span><br><span class="line">    .append(<span class="string">"circle"</span>)</span><br><span class="line">    .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">    .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">    &#125;)</span><br><span class="line">    .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">  exit.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一來， <code>dataset</code> 在綁定資料給 D3.js 的選擇集之前，就會將原本的資料 <code>[10, 20, 30]</code> 重新排列成 <code>[30, 20, 10]</code>，因此繪製圖型時最後便會顯示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190928/20119062mS7TsTuKQs.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190928/20119062mS7TsTuKQs.jpg"></p>
<h2 id="D3-js-常用的封裝函式"><a href="#D3-js-常用的封裝函式" class="headerlink" title="D3.js 常用的封裝函式"></a>D3.js 常用的封裝函式</h2><p>而除了以上兩種資料處理方法，D3.js 也提供了許多已經封裝好的數學函式可以直接對資料集做運算，以下列出幾個較為常用的運算函式：</p>
<h3 id="求數值"><a href="#求數值" class="headerlink" title="求數值"></a>求數值</h3><ul>
<li><code>d3.min()</code>：找出傳入陣列中的<strong>最小值</strong>。</li>
<li><code>d3.max()</code>：找出傳入陣列中的<strong>最大值</strong>。</li>
<li><code>d3.extent()</code>：找出傳入陣列中的<strong>最小值、最小值</strong>，返回一個<code>[最小值, 最大值]</code>。</li>
<li><code>d3.sum()</code>：將傳入陣列中的每筆資料<strong>加總</strong>起來。</li>
<li><code>d3.mean()</code>：求出傳入陣列中的<strong>平均數</strong>，並且<strong>忽略掉陣列中的 <code>undefined</code>、<code>NaN</code> 等等資料</strong>。</li>
<li><code>d3.median()</code>：求出傳入陣列中的<strong>中位數</strong>。</li>
<li><code>d3.deviation()</code>：求出傳入陣列中的<strong>標準差</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dataset = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">d3.min(dataset) <span class="comment">// 1</span></span><br><span class="line">d3.max(dataset) <span class="comment">// 9</span></span><br><span class="line">d3.extent(dataset) <span class="comment">// [1, 9]</span></span><br><span class="line">d3.sum(dataset) <span class="comment">// 20</span></span><br><span class="line">d3.mean(dataset) <span class="comment">// 4</span></span><br><span class="line">d3.median(dataset) <span class="comment">// 3</span></span><br><span class="line">d3.deviation(dataset) <span class="comment">// 3.1622776601683795</span></span><br></pre></td></tr></table></figure>

<h3 id="操作陣列"><a href="#操作陣列" class="headerlink" title="操作陣列"></a>操作陣列</h3><ul>
<li><code>d3.shuffle()</code>：將傳入陣列資料隨機打亂。</li>
<li><code>d3.merge()</code>：傳入一個陣列，將陣列中所有資料合併為一個陣列。</li>
<li><code>d3.range()</code>：返回一個等差數列。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dataset = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> dataset2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">d3.shuffle(dataset) <span class="comment">// [3, 5, 1, 9, 2]</span></span><br><span class="line">d3.merge([dataset, dataset2]) <span class="comment">// [1, 3, 2, 5, 9, 1, 2, 3]</span></span><br><span class="line">d3.range(<span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>) <span class="comment">// [1, 2, 3, 4] ，意即從 0 開始到 5 為止，回傳每筆資料數值差為 1 的陣列（不包含 5）</span></span><br></pre></td></tr></table></figure>

<p>以上為 D3.js 對資料集操作的常用 API 整理，而其餘沒列到內容可在 <a href="https://github.com/d3/d3/blob/master/API.md" target="_blank" rel="noopener">官方網站</a> 中查詢，因此假若下次要對資料集操作時，不彷可以看看官方網站是否已經有提供 API 來操作資料集，透過已經提供的 API 來操作資料就可以寫出味道聞起來<strong>較為 D3.js 的程式碼</strong>，而讓其他人一看就能瞭解資料邏輯是怎麼處理的囉！</p>
<blockquote>
<p>今天的阿橘看 UI/UX 書看到睡著。<br><img src="https://ithelp.ithome.com.tw/upload/images/20190928/20119062Gq1p2HvJVx.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190928/20119062Gq1p2HvJVx.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 資料圖形繪製與重繪 enter(), exit() &amp; update()</title>
    <url>/d3.js/D3-007-enter-exit-update/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="enter"><a href="#enter" class="headerlink" title="enter()"></a>enter()</h2><p>昨天我們已知 <code>enter</code> 資料類型的定義是<strong>當綁定資料時，選取元素不足以綁定時，該筆資料類型會被分類為 enter 類型</strong>。</p>
<p>因此，我們可以透過綁定一個頁面上沒有的元素類別，利用 <code>enter()</code>找出不夠資料塞入的元素筆數，再透過 <code>append()</code> 函式新增元素：</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleData = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line">d3.select(<span class="string">'body'</span>)</span><br><span class="line">    .selectAll(<span class="string">'div'</span>)</span><br><span class="line">    .data(sampleData)</span><br><span class="line">    .enter()</span><br><span class="line">    .append(<span class="string">'p'</span>)</span><br><span class="line">    .text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> d</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>最後畫面上就會顯示三筆剛透過 <code>append()</code> 產生的資料：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062pCiVqVa5G3.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062pCiVqVa5G3.jpg"><br>這三筆資料在 HTML DOM 中的結構：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062fUsBdpY8yd.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062fUsBdpY8yd.jpg"></p>
<p>現在我們再把他與 SVG 標籤圖形結合，透過 D3.js 新增一個 SVG 畫布：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleData = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line"><span class="keyword">let</span> svg = d3.select(<span class="string">'body'</span>)</span><br><span class="line">    .append(<span class="string">'svg'</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>,<span class="number">500</span>)</span><br><span class="line">    .attr(<span class="string">'height'</span>,<span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<p>再將資料綁定在 SVG 中的圖形標籤上並產生圖形，這裡的範例是用上次講解到的圓形標籤 <code>&lt;circle&gt;</code>，透過 <code>attr()</code> 來依序將屬性給予 <code>&lt;circle&gt;</code> 以供網頁瀏覽器渲染：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">svg.selectAll(<span class="string">'circle'</span>)          <span class="comment">// 這裡選了 cirlce 標籤 （對於當前網頁來說是空元素）</span></span><br><span class="line">    .data(sampleData)             <span class="comment">// 綁定 sampleData 資料給予接下來的元素</span></span><br><span class="line">    .enter()                      <span class="comment">// 透過 enter() 找到仍需要三個元素來存放資料</span></span><br><span class="line">    .append(<span class="string">'circle'</span>)             <span class="comment">// 將 enter() 返回的元素數量新增為 circle 標籤</span></span><br><span class="line">    .attr(<span class="string">'cx'</span>,<span class="function"><span class="keyword">function</span><span class="params">(d,i)</span></span>&#123;     <span class="comment">// 透過 attr() 來將前面教學提到的屬性給予 circle 標籤</span></span><br><span class="line">    <span class="keyword">return</span> (i+<span class="number">1</span>)*<span class="number">100</span>              <span class="comment">// 其中的 d 為 data， i 為 資料的陣列索引值</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">'cy'</span>,<span class="number">100</span>)</span><br><span class="line">    .attr(<span class="string">'r'</span>,<span class="function"><span class="keyword">function</span><span class="params">(d)</span></span>&#123;        <span class="comment">// 這裡的圓形半徑採用綁定的資料</span></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">    &#125;)</span><br><span class="line">    .style(<span class="string">'fill'</span>,<span class="string">'red'</span>)          <span class="comment">// 為圓形增添一下樣式</span></span><br></pre></td></tr></table></figure>

<p>最後網頁瀏覽器渲染出的樣子：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062Gqr5s6gE2s.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062Gqr5s6gE2s.jpg"></p>
<p>在 HTML DOM 中的結構：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/2011906276oUN1w5zx.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/2011906276oUN1w5zx.jpg"></p>
<h2 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h2><p><code>exit()</code> 用法與 <code>enter()</code> 類似，差異在於我們需要透過 <code>remove()</code> 來刪除 <code>exit()</code> 所篩選出來的多餘元素。</p>
<p>同樣以上方的例子做參考：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleData = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>] </span><br><span class="line"><span class="keyword">let</span> svg = d3.select(<span class="string">'body'</span>)</span><br><span class="line">    .append(<span class="string">'svg'</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>,<span class="number">500</span>)</span><br><span class="line">    .attr(<span class="string">'height'</span>,<span class="number">500</span>)</span><br><span class="line">    </span><br><span class="line">svg.selectAll(<span class="string">'circle'</span>)</span><br><span class="line">	.data(sampleData)</span><br><span class="line">  .enter()</span><br><span class="line">  .append(<span class="string">'circle'</span>)</span><br><span class="line">  .attr(<span class="string">'cx'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d,i</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> (i+<span class="number">1</span>)*<span class="number">100</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .attr(<span class="string">'cy'</span>,<span class="number">100</span>)</span><br><span class="line">  .attr(<span class="string">'r'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> d</span><br><span class="line">  &#125;)</span><br><span class="line">  .style(<span class="string">'fill'</span>,<span class="string">'red'</span>)</span><br><span class="line"> <span class="comment">// 上半部與上方相同，已預期會產生出三個依據 data 而產生不同半徑大小的圓</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> sampleData2 = [<span class="number">10</span>,<span class="number">20</span>] <span class="comment">// 這裡假設有另一筆新的資料產生</span></span><br><span class="line">  </span><br><span class="line">svg.selectAll(<span class="string">'circle'</span>)   <span class="comment">// 選取已經含有 sampleData 資料的圓形標籤</span></span><br><span class="line">    .data(sampleData2)    <span class="comment">// 將新的資料作為綁定</span></span><br><span class="line">    .exit()               <span class="comment">// 篩選出符合 exit 類別的資料元素</span></span><br><span class="line">    .remove()             <span class="comment">// 刪除符合上方條件的元素</span></span><br></pre></td></tr></table></figure>

<p>最後網頁瀏覽器渲染出的樣子，可以看到最右邊的圓形已經消失了：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062dxW3iCmZZQ.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062dxW3iCmZZQ.jpg"></p>
<p>同樣再來觀察 HTML DOM 的狀態，可以確認該圓形標籤是直接<strong>從 HTML DOM 上移除的</strong>，並<strong>非使用 CSS 樣式來消失該元素</strong>：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062QOZHdTTW25.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062QOZHdTTW25.jpg"></p>
<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>在 D3.js 中，<code>update</code> 類型的資料會直接覆蓋到對應的元素上，並且將舊的數據資料 <code>__data__</code> 直接替換成新的數據資料，所以 <code>updata</code> 類型的資料並不需要特地去操作，若如果需要利用新的數據資料來更動原本的圖表的作法只能依靠<strong>重新繪製</strong>一次新的圖表。</p>
<p>而目前 D3.js 並沒有方法驅動重新繪製圖表這件事情，因此比較好的做法是自己做一個可以重繪的方法來處理，以供資料變動時可以直接重複利用 D3.js 繪製圖形的程式碼：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sampleData = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">let</span> svg = d3</span><br><span class="line">    .select(<span class="string">"body"</span>)</span><br><span class="line">    .append(<span class="string">"svg"</span>)</span><br><span class="line">    .attr(<span class="string">"width"</span>, <span class="number">500</span>)</span><br><span class="line">    .attr(<span class="string">"height"</span>, <span class="number">500</span>);</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> circle = d3.select(<span class="string">"svg"</span>).selectAll(<span class="string">"circle"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> update = circle.data(sampleData);</span><br><span class="line">    <span class="keyword">let</span> enter = update.enter();</span><br><span class="line">    <span class="keyword">let</span> exit = update.exit();</span><br><span class="line"></span><br><span class="line">    update</span><br><span class="line">        .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">        .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">        &#125;)</span><br><span class="line">        .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">    enter</span><br><span class="line">        .append(<span class="string">"circle"</span>)</span><br><span class="line">        .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">        .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">        &#125;)</span><br><span class="line">        .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">    exit.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw();</span><br><span class="line"></span><br><span class="line">sampleData = [<span class="number">5</span>, <span class="number">30</span>];</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure>

<p>原本瀏覽器渲染後的圖：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062KdZ8KBy1h3.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062KdZ8KBy1h3.jpg"></p>
<p>啟動 <code>draw</code> 函式後渲染的圖：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062qcv9LbhK24.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062qcv9LbhK24.jpg"></p>
<p>如此一來若是 <code>sampleData</code> 資料有變更時，只要重新啟用 <code>draw</code> 函式就能將舊有資料去除後重新繪製新一筆的圖。</p>
<blockquote>
<p>然而……事情並沒有阿橘想像中這麼快就結束……<br>阿橘：蝦……蝦咪！？<br><img src="https://ithelp.ithome.com.tw/upload/images/20190927/20119062yzvRdt1WEE.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190927/20119062yzvRdt1WEE.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js in Vue.js</title>
    <url>/d3.js/D3-008-d3-in-vue/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="D3-js-in-Vue-js-阿彌陀丸-in-春雨"><a href="#D3-js-in-Vue-js-阿彌陀丸-in-春雨" class="headerlink" title="D3.js in Vue.js 阿彌陀丸 in 春雨"></a>D3.js in Vue.js <del>阿彌陀丸 in 春雨</del></h2><p><img src="https://ithelp.ithome.com.tw/upload/images/20190927/20119062asFjpda8Cf.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190927/20119062asFjpda8Cf.jpg"></p>
<p>既然最近介紹的主題是 Vue.js 跟 D3.js，那就沒有道理不把 D3.js 融合進 Vue.js 啦！我們接下來把昨天的繪製函式加入到我們 Vue.js 中，並著利用 Vue.js 的一些特色來完成我們的融合：</p>
<a id="more"></a>

<ol>
<li>首先最基本的是 HTML 部分需要一個元素作為 <strong>Vue.js 初始化</strong>的地方：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>由於 Vue.js 是依靠<strong>資料來驅動視覺層</strong>的，因此我們把 D3.js 資料的部分挪到 Vue.js 的 data 當中以供綁定：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        sampleData: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>再來則是針對 Vue.js 生命週期中的 <code>created</code> 階段，透過 Vue.js 初始化時將 D3.js 所需要的 SVG 畫布設置好：</li>
</ol>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">let vm = new Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        sampleData: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123; // 複習一下，這個 hook 將會在 Vue.js 初始化的階段會啟動它</span><br><span class="line">        d3.select(<span class="string">"#app"</span>)</span><br><span class="line">            .append(<span class="string">"svg"</span>)</span><br><span class="line">            .attr(<span class="string">"width"</span>, <span class="number">500</span>)</span><br><span class="line">            .attr(<span class="string">"height"</span>, <span class="number">500</span>)<span class="comment">;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>接著在 Vue.js 中的 <code>methods</code> 放入重新繪製的函式以供 Vue 實體使用，並把原先 D3.js 中 <code>data()</code> 所綁定的資料更改為 <code>dataset</code> ，加上一點邏輯判斷，使 <code>draw</code> 函式能夠接受外來的參數：</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let vm = new Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        sampleData: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        d3.select(<span class="string">"#app"</span>)</span><br><span class="line">            .append(<span class="string">"svg"</span>)</span><br><span class="line">            .attr(<span class="string">"width"</span>, <span class="number">500</span>)</span><br><span class="line">            .attr(<span class="string">"height"</span>, <span class="number">500</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        draw(newData) &#123; <span class="regexp">//</span> 加入剛剛辛苦改好的重繪函式</span><br><span class="line">            let dataset = newData || this.sampleData; <span class="regexp">//</span> 若沒有傳入資料，則會使用 Vue.js 實體中的 sampleData</span><br><span class="line">            let circle = d3.select(<span class="string">"svg"</span>).selectAll(<span class="string">"circle"</span>);</span><br><span class="line"></span><br><span class="line">            let update = circle.data(dataset); <span class="regexp">//</span> 更改一下綁定資料</span><br><span class="line">            let enter = update.enter();</span><br><span class="line">            let <span class="keyword">exit</span> = update.<span class="keyword">exit</span>();</span><br><span class="line"></span><br><span class="line">            update</span><br><span class="line">                .attr(<span class="string">"cx"</span>, <span class="keyword">function</span>(d, i) &#123;</span><br><span class="line">                return (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">                .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">                .attr(<span class="string">"r"</span>, <span class="keyword">function</span>(d) &#123;</span><br><span class="line">                return d;</span><br><span class="line">                &#125;)</span><br><span class="line">                .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">            enter</span><br><span class="line">                .append(<span class="string">"circle"</span>)</span><br><span class="line">                .attr(<span class="string">"cx"</span>, <span class="keyword">function</span>(d, i) &#123;</span><br><span class="line">                return (i + <span class="number">1</span>) * <span class="number">100</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">                .attr(<span class="string">"cy"</span>, <span class="number">100</span>)</span><br><span class="line">                .attr(<span class="string">"r"</span>, <span class="keyword">function</span>(d) &#123;</span><br><span class="line">                return d;</span><br><span class="line">                &#125;)</span><br><span class="line">                .style(<span class="string">"fill"</span>, <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">exit</span>.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 Vue.js 生命週期中的 <code>mounted</code> 放入從 Vue.js <code>methods</code> 撈來的繪製函式，使得 Vue.js 載入資料完畢後會繪製一次最初的圖形：</li>
</ol>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">let vm = new Vue(&#123;</span><br><span class="line"><span class="symbol">    el:</span> <span class="string">"#app"</span>,</span><br><span class="line"><span class="symbol">    data:</span> &#123;</span><br><span class="line"><span class="symbol">        sampleData:</span> [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123; </span><br><span class="line">        this.draw(); <span class="comment">// 等到 Vue.js 一載入完成就執行這個繪圖函式</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="symbol">    methods:</span> &#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>利用 Vue.js 的 <code>watch</code> 來監聽 <code>sampleData</code> 資料是否有改動，若有改動則啟用該函式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        sampleData: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>] <span class="comment">// watch 監控並執行對應的函式</span></span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123; </span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        sampleData: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.draw(<span class="keyword">this</span>.sampleData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>methods</code> 中再次加入一個函式 <code>changeData</code> 用來模擬新資料非同步的載入：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    changeData() &#123; </span><br><span class="line">        <span class="keyword">this</span>.sampleData = [<span class="number">5</span>, <span class="number">30</span>]; <span class="comment">// 模擬新資料的載入</span></span><br><span class="line">    &#125;,</span><br><span class="line">    draw(newData) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最後我們在 HTML 中加入一個按鈕來驅動 Vue.js 內的 <code>changeData</code> 函式：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeData"</span>&gt;</span>New Data<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>於是我們就得到了一個藉由資料驅動完成 D3.js 繪製的 Vue.js 程式！<a href="https://codepen.io/ShawnLin0201/pen/rNBbyqX" target="_blank" rel="noopener">程式碼範例請點這裡</a></p>
<p>而我們接下來的目標就是完善<strong>資料處理</strong>的部分與<strong>繪製圖形</strong>的部分，明天將會介紹有什麼方法可以調整資料與篩選。</p>
<blockquote>
<p>阿橘：終於可以來慵懶地曬著陽光了<br><img src="https://ithelp.ithome.com.tw/upload/images/20190926/20119062wcMRwdS8v4.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190926/20119062wcMRwdS8v4.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
        <category>前端</category>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 繪製比例尺 scale</title>
    <url>/d3.js/D3-010-scale/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<blockquote>
<p>在圖表當中不可或缺的除了基本的<strong>資料</strong>與<strong>圖表</strong>之外，另一項就是<strong>比例尺</strong>的部分。在 D3.js 中，開發者可以透過比例尺<strong>將一段範圍的某個數值對應到另一段範圍的數值</strong>，這麼做的好處在於我們可以將資料轉換成一個具有比例意義的圖表，並且依比例縮放成我們所要的大小而不是毫無比例根據的作圖。</p>
</blockquote>
<a id="more"></a>

<h2 id="線性比例尺-d3-scaleLinear"><a href="#線性比例尺-d3-scaleLinear" class="headerlink" title="線性比例尺 d3.scaleLinear"></a>線性比例尺 d3.scaleLinear</h2><p>線性比例尺指的是一段<strong>連續的</strong>數值可以<strong>依照一個線性函數來換算</strong>出數值：</p>
<blockquote>
<p>例如區間 <code>[0,20]</code> 依照 <code>y=2x</code> 可以換算出 <code>[0, 40]</code>，因此假如今天有一個值為 <code>10</code> ，我們便可以帶入函數 <code>y=2*10</code> 來求出 Y 值為 <code>20</code>。</p>
</blockquote>
<p>而使用方法很簡單，我們透過 D3.js 4版以後的語法 <code>d3.scaleLinear</code> 來創造一段比例尺，並由 <code>domain()</code> 定義範圍（如設為資料最大最小範圍），再使用 <code>range()</code> 定義一個取值的範圍（如圖表中的軸長），如此一來就可以將資料的大小比例對應到圖表中的 X 軸、Y 軸內：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let dataset = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">50</span>]</span><br><span class="line">let linear = d3</span><br><span class="line">    .scaleLinear()                    <span class="comment">// 使用 d3 線性比例尺</span></span><br><span class="line">    .domain([<span class="number">0</span>, d3.max(dataset)])     <span class="comment">// 設定比例範圍 0 到 資料集的最大值</span></span><br><span class="line">    .range([<span class="number">0</span>, <span class="number">100</span>])                  <span class="comment">// 設定輸出範圍 0 到 100 ，例如圖表想要的高度</span></span><br><span class="line">  </span><br><span class="line">console.log(linear(<span class="number">10</span>))               <span class="comment">// 得到 20，可以將其設定為例如矩形的高度</span></span><br><span class="line">console.log(linear(<span class="number">50</span>))               <span class="comment">// 得到 100，可以將其設定為例如矩形的高度</span></span><br></pre></td></tr></table></figure>

<p>另一個以 Vue.js in D3.js 的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"#app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      sampleData: [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">50</span>]              <span class="comment">// 設定基礎的資料集</span></span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      d3.select(<span class="string">"#app"</span>)                             <span class="comment">// SVG 畫布基礎設定</span></span><br><span class="line">        .append(<span class="string">"svg"</span>)</span><br><span class="line">        .attr(<span class="string">"width"</span>, <span class="number">200</span>)</span><br><span class="line">        .attr(<span class="string">"height"</span>, <span class="number">200</span>)</span><br><span class="line">        .style(<span class="string">"border"</span>, <span class="string">"1px solid #00000060"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="keyword">this</span>.draw();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      draw(newData) &#123;</span><br><span class="line">        <span class="keyword">let</span> dataset = newData || <span class="keyword">this</span>.sampleData;    <span class="comment">// 設定綁定資料等相關設定</span></span><br><span class="line">        <span class="keyword">let</span> rect = d3.select(<span class="string">"svg"</span>).selectAll(<span class="string">"rect"</span>);</span><br><span class="line">        <span class="keyword">let</span> update = rect.data(dataset);</span><br><span class="line">        <span class="keyword">let</span> enter = update.enter();</span><br><span class="line">        <span class="keyword">let</span> exit = update.exit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> linear = d3                              <span class="comment">// 這裡建立一個線性比例尺</span></span><br><span class="line">          .scaleLinear()</span><br><span class="line">          .domain([<span class="number">0</span>, d3.max(dataset)])              <span class="comment">// 設定比例範圍 0 與 50 (資料集最大值)</span></span><br><span class="line">          .range([<span class="number">0</span>, <span class="number">200</span>]);                          <span class="comment">// 設定取值範圍 0 至 200（SVG 畫布高）</span></span><br><span class="line"></span><br><span class="line">        enter</span><br><span class="line">          .append(<span class="string">"rect"</span>)</span><br><span class="line">          .attr(<span class="string">"width"</span>, <span class="number">30</span>)</span><br><span class="line">          .attr(<span class="string">"height"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;              <span class="comment">// 繪製矩形高時，採用資料輸入進去比例尺</span></span><br><span class="line">            <span class="keyword">return</span> linear(d);                        <span class="comment">// 例如第一筆資料為 10 ，比例尺取值後會得到 20</span></span><br><span class="line">          &#125;)</span><br><span class="line">          .attr(<span class="string">"x"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i * <span class="number">40</span> + <span class="number">5</span>;</span><br><span class="line">          &#125;)</span><br><span class="line">          .attr(<span class="string">"y"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;                   <span class="comment">// 矩形的屬性 y 是從上往下算</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">200</span> - linear(d);                  <span class="comment">// 因此要倒過來繪製需用最大高度去減資料高度</span></span><br><span class="line">          &#125;)                                         <span class="comment">// 所以在這邊矩形的高度也需換算成比例尺取值的高</span></span><br><span class="line">          .attr(<span class="string">"fill"</span>, <span class="string">"blue"</span>);</span><br><span class="line"></span><br><span class="line">        exit.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>顯示結果：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190929/20119062mroGQIbD8X.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190929/20119062mroGQIbD8X.jpg"></p>
<p>圖中可以看到 SVG 畫布 長高各為 <code>200px</code> 的情況，我們設定資料範圍為 <code>0</code> 至 <code>50</code> （資料集最大值），並把輸出範圍設定為 <code>0</code> 至 <code>200</code>，因此最後一筆資料 <code>50</code> 經由比例尺轉換後繪製出高度為 <code>200</code>的矩形，可以看到確實撐滿了整個 SVG 的高。</p>
<blockquote>
<p>由此範例可以看出比例尺在 D3.js 中潛力，像是 RWD 網頁透過 JavaScript 監聽視窗大小變動時，便可以藉由將視窗比例等等資訊傳遞進 D3.js 來調整比例尺，達到圖表縮放的功能。</p>
</blockquote>
<p>而比例尺的功能除了簡單的依比例輸出外還有其他的 API 可供調整：</p>
<ul>
<li><code>rangeRound()</code> ：替換 <code>range()</code> 使用，使最後輸出的數值會四捨五入到個位數。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dataset = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">50</span>]</span><br><span class="line"><span class="keyword">let</span> linear = d3</span><br><span class="line">    .scaleLinear()                    </span><br><span class="line">    .domain([<span class="number">0</span>, d3.max(dataset)])     </span><br><span class="line">    .rangeRound([<span class="number">0</span>, <span class="number">100</span>])             </span><br><span class="line">    </span><br><span class="line"><span class="built_in">console</span>.log(linear(<span class="number">9.84521</span>))          <span class="comment">// 得到 20，若以 range 取則得到 19.69042。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>clamp()</code> ：啟用後會將輸入超過範圍的數值，輸出時縮放為範圍的最大、最小值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dataset = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">50</span>]</span><br><span class="line"><span class="keyword">let</span> linear = d3</span><br><span class="line">    .scaleLinear()                    </span><br><span class="line">    .domain([<span class="number">0</span>, d3.max(dataset)])     </span><br><span class="line">    .range([<span class="number">0</span>, <span class="number">100</span>])             </span><br><span class="line">linear.clamp(<span class="literal">true</span>)                     <span class="comment">// true，啟用該設定；反之 false （預設）為仍會縮放該數值。</span></span><br><span class="line"><span class="built_in">console</span>.log(linear(<span class="number">1000</span>))              <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(linear(<span class="number">-1000</span>))             <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>nice()</code> ：將定義範圍中的無窮小數捨去至合理的範圍，<strong>用以資料集當 <code>domain</code> 範圍時若遇到無窮小數需要整理時</strong>可使用此函數。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> linear = d3</span><br><span class="line">    .scaleLinear()                    </span><br><span class="line">    .domain([<span class="number">0.62271947</span> , <span class="number">0.13879428</span>])     </span><br><span class="line">    .range([<span class="number">0</span>, <span class="number">100</span>])             </span><br><span class="line">linear.nice()</span><br><span class="line"><span class="built_in">console</span>.log(linear.domain())           <span class="comment">// [0.65, 0.1]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ticks()</code> ：將比例尺的定義範圍切成數段，並且返回一個較有意義段落的陣列，用來<strong>製作座標軸數值</strong>非常方便。</p>
</li>
<li><p><code>tickFormat()</code> ：如同 <code>ticks</code> 用法，但是可以在第二個傳送參數中定義返回的數值格式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dataset = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">50</span>]</span><br><span class="line"><span class="keyword">let</span> linear = d3</span><br><span class="line">    .scaleLinear()                    </span><br><span class="line">    .domain([<span class="number">0</span>, d3.max(dataset)])     </span><br><span class="line">    .range([<span class="number">0</span>, <span class="number">100</span>])             </span><br><span class="line"><span class="keyword">let</span> ticks = linear.ticks(<span class="number">2</span>)           </span><br><span class="line"><span class="built_in">console</span>.log(ticks)                    <span class="comment">// [0, 20, 40]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tickFormat = linear.tickFormat(<span class="number">0</span>, <span class="string">'+'</span>)</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ticks.length; i++)&#123;</span><br><span class="line">	ticks[i] = tickFormat(ticks[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ticks)                    <span class="comment">// ["+0", "+20", "+40"]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>以上是<strong>線性比例尺</strong>的用法，而除此之外還有像是 <strong>序列比例尺</strong>、<strong>量化比例尺</strong>、<strong>分位數比例尺</strong>等等不同的比例尺以供不同時機使用，這裡舉出一個比較常用到的比例尺來作為例子，往後圖表中若有用到其他比例尺時再仔細好好來介紹它們的細項，另外以下是 D3.js 比例尺在三版與四版的 API 差異表！</p>
<h2 id="附註-D3-js-比例尺-3-版與-4-版差異補充"><a href="#附註-D3-js-比例尺-3-版與-4-版差異補充" class="headerlink" title="附註 D3.js 比例尺 3 版與 4 版差異補充"></a>附註 D3.js 比例尺 3 版與 4 版差異補充</h2><ul>
<li>d3.scale.linear ↦ d3.scaleLinear</li>
<li>d3.scale.sqrt ↦ d3.scaleSqrt</li>
<li>d3.scale.pow ↦ d3.scalePow</li>
<li>d3.scale.log ↦ d3.scaleLog</li>
<li>d3.scale.quantize ↦ d3.scaleQuantize</li>
<li>d3.scale.threshold ↦ d3.scaleThreshold</li>
<li>d3.scale.quantile ↦ d3.scaleQuantile</li>
<li>d3.scale.identity ↦ d3.scaleIdentity</li>
<li>d3.scale.ordinal ↦ d3.scaleOrdinal</li>
<li>d3.time.scale ↦ d3.scaleTime</li>
<li>d3.time.scale.utc ↦ d3.scaleUtc</li>
</ul>
<blockquote>
<p>明天颱風天只好跟貓咪一起在家繼續研究 D3.js 啦！附上黑黑美照一張：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190929/2011906256tqok0zxy.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190929/2011906256tqok0zxy.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 繪製座標軸 axis</title>
    <url>/d3.js/D3-011-axis/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="繪製座標軸"><a href="#繪製座標軸" class="headerlink" title="繪製座標軸"></a>繪製座標軸</h2><p>透過 D3.js 比例尺後，我們現在已經可以透過資料得到對應比例尺的數值了，而今天要緊接著透過這個數值來繪製座標軸，並且一樣採用 Vue.js 框架來說明。</p>
<p>而在 Vue.js 中的實體設定基本上與前幾天差不多，最主要我們將資料集換成<strong>每筆資料各有兩個屬性資料</strong>的格式：</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      sampleData: [</span><br><span class="line">        &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">80</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">x</span>: <span class="number">70</span>, <span class="attr">y</span>: <span class="number">40</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">x</span>: <span class="number">60</span>, <span class="attr">y</span>: <span class="number">50</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">x</span>: <span class="number">30</span>, <span class="attr">y</span>: <span class="number">100</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">x</span>: <span class="number">90</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      d3.select(<span class="string">"#app"</span>)</span><br><span class="line">        .append(<span class="string">"svg"</span>)</span><br><span class="line">        .attr(<span class="string">"width"</span>, <span class="number">250</span>)</span><br><span class="line">        .attr(<span class="string">"height"</span>, <span class="number">250</span>)</span><br><span class="line">        .style(<span class="string">"border"</span>, <span class="string">"1px solid #00000060"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="keyword">this</span>.draw();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      draw(newData) &#123;</span><br><span class="line">        <span class="keyword">let</span> dataset = newData || <span class="keyword">this</span>.sampleData;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>此時應該會看的到目前我們 SVG 畫布（灰線標示框內），應該是沒有任何東西的：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062zZPgxGAmfB.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062zZPgxGAmfB.jpg"></p>
<p>接著來繪製 X 軸線，首先我們得取出用來當作 X 軸線資料參考的資料：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// draw() 函式內部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dataset = newData || <span class="keyword">this</span>.sampleData;</span><br><span class="line"><span class="keyword">let</span> Xdata = dataset.map(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d.x;                              <span class="comment">// [10, 70, 60, 30, 90]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>再來是用到我們昨天剛學到的比例尺換算，來換算 <strong>X 軸要顯示的比例長度</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// draw() 函式內部</span></span><br><span class="line"><span class="keyword">let</span> dataset = newData || <span class="keyword">this</span>.sampleData;</span><br><span class="line"><span class="keyword">let</span> Xdata = dataset.map(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d.x;                              <span class="comment">// [10, 70, 60, 30, 90]</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> Xscale = d3</span><br><span class="line">  .scaleLinear()</span><br><span class="line">  .domain([<span class="number">0</span>, d3.max(Xdata)])              <span class="comment">// 座標 X 軸的長度將會依據 0 至 Xdata 資料的最大值</span></span><br><span class="line">  .range([<span class="number">0</span>, <span class="number">200</span>]);                        <span class="comment">// 換算成實際上會輸出的長度 0 至 200</span></span><br></pre></td></tr></table></figure>

<p>緊接著下方加入 D3.js 軸線的樣式定義：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Xaxis = d3.axis<span class="constructor">Bottom(Xscale)</span>;         <span class="comment">// 繪製一個數值朝下的平行座標線，並依據 Xscale 比例尺換算</span></span><br></pre></td></tr></table></figure>

<p>建立一個 X 座標軸的群組：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">let gXaxis = d3</span><br><span class="line"><span class="meta">  .select</span>(<span class="string">"svg"</span>)</span><br><span class="line"><span class="meta">  .append</span>(<span class="string">"g"</span>)</span><br><span class="line"><span class="meta">  .attr</span>(<span class="string">"transform"</span>, <span class="string">"translate(30,220)"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>最後呼叫 <code>Xaxis</code> 來執行繪圖：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Xaxis(<span class="name">gXaxis</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>畫面上最後顯示：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062IYr3UlvqlZ.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062IYr3UlvqlZ.jpg"></p>
<p>整段程式跑的邏輯在於，最後呼叫 <code>Xaxis</code> 時，會回傳 <code>gXaxis</code> 建立好的範圍給 <code>d3.axisBottom(Xscale)</code> 做新增，接著 <code>d3.axisBottom(Xscale)</code> 接收到範圍後， <code>d3.axisBottom()</code> 會幫我們 <code>gXaxis</code> 範圍中繪製一條數值朝下的平行座標線，並採用 <code>Xscale</code> 比例尺換算。</p>
<p>釐清觀念後，快速歸納出以下步驟：</p>
<ol>
<li>建立 <code>Xscale</code> ，放入比例尺設定，供 X 軸產生時有依據可供參考（<code>domain</code> 負責<strong>座標軸資料</strong>對應、<code>range</code> 負責<strong>座標軸長度</strong>對應。</li>
<li>建立 <code>Xaxis</code> ，放入 D3.js 座標軸定義，並採用 <code>Xscale</code> 比例來繪製。</li>
<li>建立 <code>gXaxis</code> ，在 SVG 新增一塊群組範圍 <code>&lt;g&gt;</code>，供繪製座標時的 <strong>實際位置範圍</strong></li>
<li>啟用 <code>Xaxis</code> 來繪製座標軸。</li>
</ol>
<p>而 Y 軸的部分則也是依樣畫葫蘆即可完成：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> Ydata = dataset.<span class="built_in">map</span>(function(d) &#123;</span><br><span class="line">  <span class="built_in">return</span> d.y;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">let</span> Yscale = d3</span><br><span class="line">  .scaleLinear()</span><br><span class="line">  .<span class="built_in">domain</span>([<span class="number">0</span>, d3.<span class="built_in">max</span>(Ydata)])</span><br><span class="line">  .<span class="built_in">range</span>([<span class="number">200</span>, <span class="number">0</span>]);</span><br><span class="line"><span class="built_in">let</span> Yaxis = d3.axisLeft(Yscale);</span><br><span class="line"><span class="built_in">let</span> gYaxis = d3</span><br><span class="line">  .select(<span class="string">"svg"</span>)</span><br><span class="line">  .<span class="built_in">append</span>(<span class="string">"g"</span>)</span><br><span class="line">  .attr(<span class="string">"transform"</span>, <span class="string">"translate(30,20)"</span>);</span><br><span class="line"></span><br><span class="line">Yaxis(gYaxis);</span><br></pre></td></tr></table></figure>

<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062JaD1vQwZWL.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062JaD1vQwZWL.jpg"></p>
<p>這樣就完成了座標軸繪製的部分，很簡單吧！</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062TlhU0te1Un.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062TlhU0te1Un.jpg"></p>
<h2 id="座標軸客製化"><a href="#座標軸客製化" class="headerlink" title="座標軸客製化"></a>座標軸客製化</h2><p>若繪製完還對於座標軸有些不滿意的話，D3.js 還有提供一些客製化的部分：</p>
<ul>
<li><p><code>ticks()</code> ：將座標軸劃分為指定的段落（會自動取成較為代表意義的範圍）。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">let Xaxis = d<span class="number">3.</span>axisBottom<span class="comment">(Xscale)</span>.ticks<span class="comment">(4)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/201190622kWbFtC8s0.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/201190622kWbFtC8s0.jpg"></p>
</li>
<li><p><code>tickValues()</code> ：只顯示特定座標數值的刻線</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">let Xaxis = d3.axisBottom(Xscale).tickValues([<span class="number">13</span>, <span class="number">55</span>, <span class="number">79</span>]);</span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062ZqjUOZHw6U.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062ZqjUOZHw6U.jpg"></p>
</li>
</ul>
<ul>
<li><p><code>tickSize()</code> ：更改座標軸刻線長度</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Xaxis = d3.axis<span class="constructor">Bottom(Xscale)</span>.tick<span class="constructor">Size(0)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/2011906228iavULhvG.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/2011906228iavULhvG.jpg"></p>
</li>
<li><p><code>tickPadding()</code> ：座標軸與座標軸標籤之間的距離（例如調整一下剛剛上方調整刻線長度後，數值太接近座標線的問題。）</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Xaxis = d3</span><br><span class="line">    .axis<span class="constructor">Bottom(Xscale)</span></span><br><span class="line">    .tick<span class="constructor">Size(0)</span></span><br><span class="line">    .tick<span class="constructor">Padding(10)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/201190624jAQNY7hPi.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/201190624jAQNY7hPi.jpg"></p>
</li>
<li><p><code>tickFormat()</code> ：定義座標軸數值的格式，可以傳入一個回呼函式（callback function）來定義內容，也可以參考 <a href="https://github.com/d3/d3-format" target="_blank" rel="noopener">d3-format</a> 文件定義資料格式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Xaxis = d3.axisBottom(Xscale).tickFormat(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d + <span class="string">"元"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062Vsix7e4oAh.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062Vsix7e4oAh.jpg"></p>
</li>
</ul>
<h2 id="附註-D3-js-座標軸-3-版與-4-版差異補充"><a href="#附註-D3-js-座標軸-3-版與-4-版差異補充" class="headerlink" title="附註 D3.js 座標軸 3 版與 4 版差異補充"></a>附註 D3.js 座標軸 3 版與 4 版差異補充</h2><p>在 D3.js 3 版中，原先座標軸會<strong>需要以 CSS 以及 JavaScript 去定義座標軸的樣式</strong>，否則座標軸只會呈現一條線：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062ma7eL0TCiC.png" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062ma7eL0TCiC.png"></p>
<blockquote>
<p>（圖源源自 D3.js <a href="https://github.com/d3/d3/blob/master/CHANGES.md" target="_blank" rel="noopener">官方網站</a> 座標軸圖）</p>
</blockquote>
<p>而在 4 版本之後我們可以透過藉由直接呼叫座標軸方向的 API 來直接採用他的基本樣式與相關設定。</p>
<ul>
<li><code>d3.axisTop</code> ：繪製一個數值朝 <strong>上</strong> 的 <strong>平行</strong> 座標線</li>
<li><code>d3.axisRight</code> ：繪製一個數值朝 <strong>右</strong> 的 <strong>垂直</strong> 座標線</li>
<li><code>d3.axisBottom</code> ：繪製一個數值朝 <strong>下</strong> 的 <strong>平行</strong> 座標線</li>
<li><code>d3.axisLeft</code> ：繪製一個數值朝 <strong>左</strong> 的 <strong>垂直</strong> 座標線</li>
</ul>
<p>以上便是今天 D3.js 繪製座標軸的說明，會繪製座標軸後，基本上要繪製各種座標圖表類型也難不倒了我們了，而明天我們將要來繪製與座標軸有關的相關圖表。</p>
<blockquote>
<p>今天外面颱風天時而暴雨時而寧靜，只要一下雨，阿橘就會很好奇的趴在窗邊看天空。<br><img src="https://ithelp.ithome.com.tw/upload/images/20190930/20119062K6oywinqWO.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190930/20119062K6oywinqWO.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 繪製臺灣地圖</title>
    <url>/d3.js/D3-013-geojson-topojson/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="D3-js-地圖"><a href="#D3-js-地圖" class="headerlink" title="D3.js 地圖"></a>D3.js 地圖</h2><p>今天我們要來繪製 D3.js 人人必<strong>繪</strong>的地圖啦！</p>
<p>我們首先到臺灣 <a href="https://data.gov.tw/dataset/7442" target="_blank" rel="noopener">政府資料開放平臺</a> 的網站中下載以縣市為界的台灣地圖 SHP 檔案：</p>
<a id="more"></a>

<p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062X0e9kJFd5j.png" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062X0e9kJFd5j.png"></p>
<blockquote>
<p>Shapefile（SHP），是美國環境系統研究所公司（ESRI）開發的空間資料開放格式。目前 SHP 檔案格式為地理資訊軟體界的開放標準。（資料來源： <a href="https://zh.wikipedia.org/wiki/Shapefile" target="_blank" rel="noopener">SHP Wiki</a>）</p>
</blockquote>
<p>接著透過 <a href="https://mapshaper.org/" target="_blank" rel="noopener">mapshaper</a> 網站將下載好的 SHP 檔案轉成 D3.js 能夠編寫的 GeoJson 格式（或 TopoJson 格式），直接將剛下載好的解壓縮檔案丟進去即可：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062OjzoV2L2q3.png" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062OjzoV2L2q3.png"></p>
<p>選擇 Import 匯入：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062XzLfH86A9a.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062XzLfH86A9a.jpg"></p>
<p>就可以畫面上顯示出預覽地圖：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062jsybOxZlUW.png" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062jsybOxZlUW.png"></p>
<p>而在輸出檔案前我們還要先把地圖優化一下，點選右上方的 Simplify 簡化地圖：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062B231g98mW7.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062B231g98mW7.jpg"></p>
<p>將地圖簡化到 30% 左右，此時可以稍微看到地圖邊緣稍微被簡化一些，但失真程度不大還能接受：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062kl3blfOO3d.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062kl3blfOO3d.jpg"></p>
<p>最後點選右上方 Export 輸出檔案，可以看到有各種檔案類型可供選擇，這裡可以選擇 GeoJSON 或 TopoJSON，而本章範例將會採用 TopoJSON 的格式來示範：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062UTQsSF9wUN.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062UTQsSF9wUN.jpg"></p>
<p>而為什麼範例要選擇 TopoJSON 的格式呢？我們可以來比較一下簡化後與兩種檔案格式的大小差異：</p>
<p>GeoJSON 100% 檔案大小：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062kdwThk8UlU.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062kdwThk8UlU.jpg"><br>GeoJSON  30% 檔案大小：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062TK14DueitY.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062TK14DueitY.jpg"><br>TopoJSON 30% 檔案大小：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062E4cQI1EJrK.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062E4cQI1EJrK.jpg"></p>
<p>我們可以看到簡化過的檔案容量降了將近快要 10MB ，而 TopoJSON 又還能比 GeoJSON 更少了約八成左右，最後檔案從 12.1MB 的大怪物被優化到剩下 622KB 的檔案大小，並且品質還在能接受的範圍。</p>
<p>而這兩種檔案究竟差在哪裡呢？</p>
<h2 id="GeoJSON"><a href="#GeoJSON" class="headerlink" title="GeoJSON"></a>GeoJSON</h2><blockquote>
<p>RFC 7946:<br>GeoJSON is a geospatial data interchange format based on JavaScript Object Notation (JSON). </p>
</blockquote>
<p>根據 <a href="https://tools.ietf.org/html/rfc7946" target="_blank" rel="noopener">RFC 7946</a> 的定義，GeoJSON 主要是基於 JSON 編寫的一種地理交換資料格式。也就是說 <strong>GeoJSON 其實就是 JSON 格式的檔案，並非是一種新的格式</strong>，只是將地理的一些訊息描述以 JSON 規則呈現並受嚴格的定義控管。</p>
<blockquote>
<p>Geometry Object<br>A Geometry object represents points, curves, and surfaces in coordinate space.  Every Geometry object is a GeoJSON object no matter where it occurs in a GeoJSON text.</p>
</blockquote>
<p>而在幾何物件（Geometry Object）的 <a href="https://tools.ietf.org/html/rfc7946#section-3" target="_blank" rel="noopener"> RFC 文件章節</a>  裡也提到：不論用來描述的點、線、面等等訊息在檔案的何處，<strong>都需要以 GeoJSON 物件形式呈現</strong>，並且底下也詳細列出了描述地圖的一些規範和代表含意說明（如位置、點、多點、線段、多邊形等等）。</p>
<h2 id="TopoJSON"><a href="#TopoJSON" class="headerlink" title="TopoJSON"></a>TopoJSON</h2><p>由 D3.js 作者 Mike Bostock 所發明的 <a href="https://github.com/topojson/topojson-specification/blob/master/README.md" target="_blank" rel="noopener">TopoJSON</a> 則是以 GeoJSON 為基礎，以拓樸學的科學基礎編碼而成的格式。其最大的特色就是原先在 GeoJSON 中描述地理訊息的邊緣，會以共同邊（<code>arcs</code>）所表示，並且消除掉一些較為冗贅的地理資訊後而產生。</p>
<h2 id="繪製地圖"><a href="#繪製地圖" class="headerlink" title="繪製地圖"></a>繪製地圖</h2><p>D3.js 根據了 GeoJSON 與 TopoJSON 格式來處理地圖訊息，透過像是 SVG 中的路徑 <code>path</code> ，將處理好的的資訊轉換為視覺呈現，而要以 TopoJSON 檔案來繪製地圖的話，可以透過 Mike Bostock 在 <a href="https://github.com/topojson/topojson" target="_blank" rel="noopener">TopoJSON 專案</a> 中的 API 來解碼使用，目前專案上也提供了 CDN 連結供快速開發使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://unpkg.com/topojson@3"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>接著如同前面幾章，我們依樣畫葫蘆開一個 Vue.js 的 HTML 版面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">'500'</span> <span class="attr">height</span>=<span class="string">'500'</span> <span class="attr">style</span>=<span class="string">'border:1px solid #00000060;'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">g</span> <span class="attr">class</span>=<span class="string">"counties"</span>&gt;</span><span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span> <span class="attr">class</span>=<span class="string">"county-borders"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Vue 實體中則是開了一個 data <code>taiwanCountry</code> 給予預設值，待實體載入完畢時將我們前面處理好的 TopoJSON 檔 <code>COUNTY_MOI_1080726.json</code> 透過 fetch 的方式載入我們的地圖資料以供取用，並且呼叫 <code>draw()</code> 函式來繪製地圖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        taiwanCountry: []</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        fetch(<span class="string">'COUNTY_MOI_1080726.json'</span>)</span><br><span class="line">            .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">            .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.taiwanCountry = result</span><br><span class="line">                <span class="keyword">this</span>.draw(<span class="keyword">this</span>.taiwanCountry)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        draw(mapData) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 <code>draw</code> 函式中，使用 <code>d3.geoMercator()</code> 來定義投影模式，並以 <code>center</code> 定義經緯度位置，<code>scale</code> 定義縮放比例尺：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> projection = d3.geoMercator()</span><br><span class="line">    .center([<span class="number">123</span>, <span class="number">24</span>])</span><br><span class="line">    .scale(<span class="number">5500</span>);</span><br></pre></td></tr></table></figure>

<p>接著加入 <code>d3.geoPath()</code> （用來產生供 <code>path</code> 路徑標籤所使用的 <code>d</code>），並且傳入剛才定義好的投影模式 <code>projection</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> path = d3.geoPath(projection);</span><br></pre></td></tr></table></figure>

<p>最後透過 d3.js 選擇器選擇我們剛以開好的 HTML 版面，在 <code>g.counties</code> 產生地圖面積、<code>path.county-borders</code> 產生地圖輪廓：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">d3.select(<span class="string">'g.counties'</span>)</span><br><span class="line">    .selectAll(<span class="string">"path"</span>)</span><br><span class="line">    .data(topojson.feature(mapData, mapData.objects[<span class="string">"COUNTY_MOI_1080726"</span>]).features)</span><br><span class="line">    .enter().append(<span class="string">"path"</span>)</span><br><span class="line">    .attr(<span class="string">"d"</span>, path);</span><br><span class="line"></span><br><span class="line">d3.select(<span class="string">'path.county-borders'</span>)</span><br><span class="line">    .attr(<span class="string">"d"</span>, path(topojson.mesh(mapData, mapData.objects[<span class="string">"COUNTY_MOI_1080726"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a !== b; &#125;)));</span><br></pre></td></tr></table></figure>

<p>而裡面使用到的 <code>topojson</code> API 方法說明如下：</p>
<ul>
<li><code>topojson.feature</code> ：將 TopoJSON 轉換成 GeoJSON 的格式。</li>
<li><code>topojson.mesh</code> ：將 TopoJSON 中的 geometry 物件轉換成 GeoJSON 中的線段。<br>其餘未使用到的 API 可參考 GitHub 上的 <a href="https://github.com/topojson/topojson" target="_blank" rel="noopener">topojson 專案</a></li>
</ul>
<p>加上一點點 CSS 來點綴：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-class">.counties</span> &#123;</span><br><span class="line">        <span class="attribute">fill</span>:<span class="number">#33474e</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.counties</span> <span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">fill</span>: <span class="number">#7f9ca7</span>;</span><br><span class="line">        <span class="attribute">transition</span>: <span class="number">0.5s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.county-borders</span> &#123;</span><br><span class="line">        <span class="attribute">fill</span>: none;</span><br><span class="line">        <span class="attribute">stroke</span>: <span class="number">#fff</span>;</span><br><span class="line">        <span class="attribute">stroke-width</span>: <span class="number">0.5px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>最後畫面上顯示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062PzAXSvqUed.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062PzAXSvqUed.jpg"></p>
<p><a href="https://codepen.io/ShawnLin0201/pen/zYOgdXM" target="_blank" rel="noopener">範例程式碼</a></p>
<blockquote>
<p>躺爆！<br><img src="https://ithelp.ithome.com.tw/upload/images/20191002/20119062tKSJRlr5q4.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191002/20119062tKSJRlr5q4.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>D3.js 繪製散點圖與折線圖 scatter chart &amp; line chart</title>
    <url>/d3.js/D3-012-scatter-chart-and-line-chart/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="d3-logo" src='/images/d3js/d3.png' width='300px' height='300px' />
</div>

<h2 id="繪製散點圖-scatter-chart"><a href="#繪製散點圖-scatter-chart" class="headerlink" title="繪製散點圖 scatter chart"></a>繪製散點圖 scatter chart</h2><p>昨天我們已經繪製出座標軸了，而接下來要繪製散點圖就非常的容易了，繪製散點圖的原理與繪製座標軸的原理類似，並且更簡單，我們只要在圖表內生成 SVG 圓形標籤時，藉由其屬性 <code>cx</code> 與 <code>cy</code> 定義圓形標籤的位置之後，即可將圓點產生在資料對應的位置。</p>
<p>以下範例用昨天已繪製好的座標軸繼續延伸：</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// draw() 函式內部</span></span><br><span class="line">enter.append(<span class="string">'circle'</span>)</span><br><span class="line">    .attr(<span class="string">'cx'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Xscale(d.x)                        <span class="comment">// 將 X 資料換算成 X 軸的比例</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">'cy'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Yscale(d.y)                        <span class="comment">// 將 Y 資料換算成 Y 軸的比例</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .attr(<span class="string">'r'</span>,<span class="number">5</span>)</span><br><span class="line">    .attr(<span class="string">'fill'</span>,<span class="string">'#000'</span>)</span><br><span class="line">    .attr(<span class="string">"transform"</span>, <span class="string">"translate(30,20)"</span>);       <span class="comment">// 調整原點產生位置，對齊座標軸中心</span></span><br></pre></td></tr></table></figure>

<p>結果顯示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191001/20119062s7pR6uUYWP.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191001/20119062s7pR6uUYWP.jpg"></p>
<p>而要注意的事情是，<strong>圓點之間距離比例需要對應到圖表坐標軸的比例</strong>，藉由坐標軸的比例，將原先的資料能隨著比例一同對應到畫面上，另一方面也要記得調整<strong>生成圓點群組時的位置</strong>要對應到座標軸的中心位置 <code>(0, 0)</code>。</p>
<h2 id="繪製折線圖-line-chart"><a href="#繪製折線圖-line-chart" class="headerlink" title="繪製折線圖 line chart"></a>繪製折線圖 line chart</h2><p>繪製完散點圖後，另一個跟散點圖有異曲同工之妙的圖表就是折線圖啦，折線圖與散點圖的邏輯其實差不了多少，主要都是<strong>將資料輸出給圖形座標點 <code>(X, Y)</code> 來繪製</strong>。而 D3.js 的線段，便是<strong>藉由 SVG 中的 <code>path</code> 路徑標籤來繪製</strong>，以<strong>屬性 <code>d</code></strong> 來描述路徑，如果大家還記得的話我們曾經在 <a href="https://ithelp.ithome.com.tw/articles/10219120" target="_blank" rel="noopener">SVG 基本圖型繪製</a> 章節中介紹過下面這段<strong>符咒</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M0,0h7.75a45.5,45.5 0 1 1 0,91h-7.75v-20h7.75a25.5,25.5 0 1 0 0,-51h-7.75zm36.2510,0h32a27.75,27.75 0 0 1 21.331,45.5a27.75,27.75 0 0 1 -21.331,45.5h-32a53.6895,53.6895 0 0 0 18.7464,-20h13.2526a7.75,7.75 0 1 0 0,-15.5h-7.75a53.6895,53.6895 0 0 0 0,-20h7.75a7.75,7.75 0 1 0 0,-15.5h-13.2526a53.6895,53.6895 0 0 0 -18.7464,-20z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本上這段 <code>path</code> 路徑要由人類來編寫實在是太辛苦了，縱使有能力能通靈繪製出這個線段，一但要改變某段線條，那將會非常痛苦，因此 D3.js 提供一個 <code>d3.line()</code> 來協助我們定義這條線，而我們只要將座標傳入到 <code>x()</code> 以及 <code>y()</code> 中即可產生出這條線段的路徑，並且在產生圖表時將其帶入屬性 <code>d</code> 即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// draw() 函式內部</span></span><br><span class="line"><span class="keyword">let</span> line = d3.line()                        <span class="comment">// 定義線段</span></span><br><span class="line">    .x(<span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Xscale(d.x);</span><br><span class="line">    &#125;)</span><br><span class="line">    .y(<span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Yscale(d.y);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">d3.select(<span class="string">'svg'</span>).append(<span class="string">'path'</span>)</span><br><span class="line">    .attr(<span class="string">'d'</span>, line(dataset))               <span class="comment">// 使用定義線段</span></span><br><span class="line">    .attr(<span class="string">"transform"</span>, <span class="string">"translate(30,20)"</span>)</span><br><span class="line">    .attr(<span class="string">'stroke'</span>, <span class="string">'black'</span>)</span><br><span class="line">    .attr(<span class="string">'stroke-width'</span>,<span class="number">2</span>)</span><br><span class="line">    .attr(<span class="string">'fill'</span>, <span class="string">'none'</span>);</span><br></pre></td></tr></table></figure>

<p>畫面上結果顯示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191001/20119062cDgJma6soy.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191001/20119062cDgJma6soy.jpg"></p>
<p>打開開發者工具來看看這條線：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191001/20119062Fj2hKV7SAa.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191001/20119062Fj2hKV7SAa.jpg"></p>
<p>…恩，我想還是關起來好了。</p>
<h3 id="客製化線條"><a href="#客製化線條" class="headerlink" title="客製化線條"></a>客製化線條</h3><p>D3.js 除了已經處理好 <code>path</code> 基本路徑之外，還提供了一些客製化功能：</p>
<ul>
<li><code>line.defined()</code>：定義繪製的資料範圍<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> line = d3.line()</span><br><span class="line">    .x(<span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Xscale(d.x);</span><br><span class="line">    &#125;)</span><br><span class="line">    .y(<span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Yscale(d.y);</span><br><span class="line">    &#125;)</span><br><span class="line">    .defined(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;<span class="keyword">return</span> d.y &gt; <span class="number">30</span> &#125;); <span class="comment">// 只繪製資料 Y 中大於 30 的點所連起來的線段</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>結果顯示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191001/201190628HUbwC6NmB.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191001/201190628HUbwC6NmB.jpg"></p>
<ul>
<li><code>line.curve()</code>：定義線段樣式，前身在 3 版中為 <code>line.interpolate</code>。</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">let line = d3.line()</span><br><span class="line">    .x(<span class="keyword">function</span> <span class="title"></span>(d) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Xscale(d.x)</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .y(<span class="keyword">function</span> <span class="title"></span>(d) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Yscale(d.y)</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .curve(d3.curveBasis);         // 加入這段 curve 來定義線條，並且樣式採用 d3.curveBasis 呈現</span><br></pre></td></tr></table></figure>

<p>結果顯示：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191001/20119062NgAh5xLKsN.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191001/20119062NgAh5xLKsN.jpg"></p>
<p>以上即為 D3.js 中繪製散點圖以及折線圖的部分，明天就是鐵人賽的最後一天啦，老實說還有很多東西可以講，像是 Vue-cli 與 D3.js 的結合、透過 Vuex 撈取資料給 D3.js 繪圖等等，或許有機會就會直接繼續寫下去吧？總之，明天我們將會來繪製 D3.js 裡面算是最經典的圖表－－地圖！</p>
<blockquote>
<p>黑黑黑到只剩眼睛跟鈴鐺<br><img src="https://ithelp.ithome.com.tw/upload/images/20191001/20119062eMtIHfEnSu.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191001/20119062eMtIHfEnSu.jpg"></p>
</blockquote>
<h2 id="附註-D3-js-3-版與-4-版線段相關-API-差異表"><a href="#附註-D3-js-3-版與-4-版線段相關-API-差異表" class="headerlink" title="附註 D3.js 3 版與 4 版線段相關 API 差異表"></a>附註 D3.js 3 版與 4 版線段相關 API 差異表</h2><blockquote>
<p>// 線段相關<br>d3.svg.line ↦ d3.line<br>d3.svg.line.radial ↦ d3.radialLine<br>// 線段樣式<br>linear ↦ d3.curveLinear<br>linear-closed ↦ d3.curveLinearClosed<br>step ↦ d3.curveStep<br>step-before ↦ d3.curveStepBefore<br>step-after ↦ d3.curveStepAfter<br>basis ↦ d3.curveBasis<br>basis-open ↦ d3.curveBasisOpen<br>basis-closed ↦ d3.curveBasisClosed<br>bundle ↦ d3.curveBundle<br>cardinal ↦ d3.curveCardinal<br>cardinal-open ↦ d3.curveCardinalOpen<br>cardinal-closed ↦ d3.curveCardinalClosed<br>monotone ↦ d3.curveMonotoneX</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>D3.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>D3.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown筆記</title>
    <url>/markdown/tool-001-markdown/</url>
    <content><![CDATA[<h1 id="Markdown由來"><a href="#Markdown由來" class="headerlink" title="Markdown由來"></a>Markdown由來</h1><p>　　Markdown語言創始人為<strong><em>John Gruber</em></strong>，與<strong><em>Aaron Swartz</em></strong>共同合作完成。他的宗旨在於創造一個<strong>「易於閱讀、撰寫的純文字格式」</strong>語言，並且觀念圍繞在它的可讀性，因此在編寫時就算沒有解析器的輔助其實也是很容易可以看得懂文章的脈絡。而隨著時間的推移之下，markdown語言由廣大的開發人員開發了許多新的功能，但在沒有規範的情況下使得Markdown解析器的開發人員，在開發解析器的時候感到困難，因此標準化討論的議題便浮上檯面。而作者<strong><em>John Gruber</em></strong>在2014年的twitter上對此議題發表了一段話：</p>
<blockquote>
<p>Because different sites (and people) have different needs. No one syntax would make all happy.<br>節自：<a href="https://twitter.com/gruber/status/507670720886091776" target="_blank" rel="noopener">https://twitter.com/gruber/status/507670720886091776</a></p>
</blockquote>
<p>　　縱使作者認為Markdown不應受到標準化的影響，最終2016年3月還是發布了RFC7763與RFC7764，其中RFC7764的討論也就是目前開發社群知名的網站Github也將其格式註冊了上去<strong>(GitHub Flavored Markdown)</strong>。而在2017年，GitHub也發布了GFM的正式規範，並且在他們的網站上實作了他們的解析器，使得開源專案的說明文件有較為統一的格式，也讓開發人員有一個更容易閱讀文件的模式。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>使用 Markdown 格式在如今的規範下非常的簡單，大部分都只依靠簡單的符號與數字便能完成：</p>
<a id="more"></a>

<h3 id="1-標題"><a href="#1-標題" class="headerlink" title="1.標題"></a>1.標題</h3><p>使用hash符號，來當作標題，越多#符號表示層級越小<br>效果：</p>
<h4 id="可以當作標題"><a href="#可以當作標題" class="headerlink" title="可以當作標題"></a>可以當作標題</h4><h3 id="2-粗體與斜體"><a href="#2-粗體與斜體" class="headerlink" title="2.粗體與斜體"></a>2.粗體與斜體</h3><p>使用單一星號框住為斜體，兩個為粗體，三個為粗斜體。<br>效果：<br><em>字體變斜體</em><br><strong>字體變粗體</strong><br><strong><em>字體變粗斜體</em></strong></p>
<h3 id="3-區塊"><a href="#3-區塊" class="headerlink" title="3.區塊"></a>3.區塊</h3><p>使用&gt;大於符號，將會把後方文字框住表示<br>效果：</p>
<blockquote>
<p>可以用來當作說明文字</p>
</blockquote>
<h3 id="4-無序清單"><a href="#4-無序清單" class="headerlink" title="4.無序清單"></a>4.無序清單</h3><p>使用-星號來來表示清單項目<br>效果：</p>
<ul>
<li>清單一</li>
<li>清單二</li>
</ul>
<h3 id="5-有序清單"><a href="#5-有序清單" class="headerlink" title="5.有序清單"></a>5.有序清單</h3><p>使用數字來來表示清單項目<br>效果：</p>
<ol>
<li>清單一</li>
<li>清單二</li>
</ol>
<h3 id="6-程式碼"><a href="#6-程式碼" class="headerlink" title="6.程式碼"></a>6.程式碼</h3><p>而身為工程師最常需要在文章內使用程式碼片段的部分markdown也有提供啦！<br>使用‵‵‵　‵‵‵‵來框住的程式碼<br>效果：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span> = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span> = <span class="number">2</span> ;</span><br><span class="line">console.log( a + b )</span><br></pre></td></tr></table></figure>

<p>介紹完了這些基本的Markdown用法外，其實還有更多可以參考<a href="https://docs.microsoft.com/zh-tw/contribute/how-to-write-use-markdown" target="_blank" rel="noopener">Mircosoft的文件</a>，官方文件還是說明得比較清楚啦哈哈哈。我之後文章將會主力討論程式語言的部分，若有其他想要我介紹的部分歡迎來信告知，那麼我們下次再見囉，掰掰！</p>
<p>參考文件：</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Markdown</a></li>
<li><a href="https://docs.microsoft.com/zh-tw/contribute/how-to-write-use-markdown" target="_blank" rel="noopener">https://docs.microsoft.com/zh-tw/contribute/how-to-write-use-markdown</a></li>
</ul>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Mocha.js 入門、環境建置與範例（Install, Build environment）</title>
    <url>/mocha.js/Mocha-001-intro/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="mocha-logo" src='/images/Mocha/mocha-logo.svg' width='200px' height='200px' />
</div>

<h1 id="What-is-Mocha-js"><a href="#What-is-Mocha-js" class="headerlink" title="What is Mocha.js"></a>What is Mocha.js</h1><p>Mocha.js 是一款基於 Node.js 的 JavaScript 測試框架，用意在於使開發人員可以寫出更優雅且容易閱讀的測試程式碼，並且支援不同斷言庫來判斷程式。而彈性、多樣的配置是 Mocha.js 最大的特點，不同於像是 Jest.js 的 <strong>batteries-included</strong> 的概念，Mocha.js 只提供了最基本的測試環境，而斷言與隔離的選擇，都可以自由地搭配其他的函式庫來使用。例如：選配 Chai.js 斷言庫以及 Sinon.js 隔離庫。如此一來就能使用較自由的測試風格來撰寫測試程式碼。</p>
<a id="more"></a>

<blockquote>
<p>註：<br>斷言（assertion）意思即為開發程式中執行完畢時，程式碼執行結果應與斷言所設定的結果一致，否則該處斷言碼會拋出錯誤。<br>隔離則表示在測試中，我們會透過工具來仿造原先開發中的模組、元件、函式、數值等，來使測試能夠集中於某個特定的進入點。</p>
</blockquote>
<h1 id="環境建置"><a href="#環境建置" class="headerlink" title="環境建置"></a>環境建置</h1><p>首先，我們可以透過 npm 來安裝 Mocha 到 <strong>全域環境</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --global mocha</span><br></pre></td></tr></table></figure>
<p>或是將它安裝到 <strong>專案開發環境</strong> 下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev mocha</span><br></pre></td></tr></table></figure>

<p>安裝完畢後，我們需要在專案中新建一個名稱為 <code>test</code> 的資料夾，並且在資料夾裡面再新建一個 <code>sample.spec.js</code> 檔案。</p>
<blockquote>
<p>創立 <strong>sample.spec.js</strong> 之後，目前的專案目錄應該看起來像是這樣：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">├── node_modules/       <span class="comment">// 使用 npm 下載管理的模組會集中在此</span></span><br><span class="line">├── test/               <span class="comment">// 測試程式碼預設資料夾位置</span></span><br><span class="line">│   └── sample<span class="selector-class">.spec</span><span class="selector-class">.js</span>     <span class="comment">// 測試程式碼檔案</span></span><br><span class="line">├── package-lock<span class="selector-class">.json</span>   <span class="comment">// npm 文件檔（管理 npm 預設模組，不必去動他）</span></span><br><span class="line">└── package<span class="selector-class">.json</span>        <span class="comment">// npm 文件檔（管理專案中客製的模組）</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>如此一來 <code>Mochajs</code> 便能根據預設設定去找尋 <code>test</code> 資料夾底下有 <code>spec.js</code> 結尾的檔案來執行測試。</p>
<h1 id="撰寫測試程式碼"><a href="#撰寫測試程式碼" class="headerlink" title="撰寫測試程式碼"></a>撰寫測試程式碼</h1><p>在撰寫測試程式碼前，我們先來準備一隻檔案 <code>sum.js</code> 以供測試：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = sum</span><br></pre></td></tr></table></figure>
<p>範例中展示的是一個簡單的加法運算函式，我們透過 <code>module.exports = sum</code> 來導出我們的函式，使待會我們可以在測試程式碼 <code>sample.spec.js</code> 中使用 <code>require</code> 來導入。</p>
<blockquote>
<p>創立 <strong>sum.js</strong> 之後，目前的專案目錄應該看起來像是這樣：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">├── node_modules/</span><br><span class="line">├── test/</span><br><span class="line">│   └── sample<span class="selector-class">.spec</span>.js</span><br><span class="line">├── sum<span class="selector-class">.js</span>              <span class="comment">// 剛剛寫好的 JavaScript 檔案</span></span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
</blockquote>
<p>接著我們回到 <code>sample.spec.js</code> 準備來撰寫測試程式碼：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>)  <span class="comment">// 引入 Mocha 的斷言庫。</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="built_in">require</span>(<span class="string">'../sum'</span>)   <span class="comment">// 引入寫好的程式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述測試環境</span></span><br><span class="line">describe(<span class="string">'sum 函式測試'</span>, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述測試案例</span></span><br><span class="line">    it(<span class="string">'1 加上 2 應該等於 3'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 透過斷言庫來寫判斷式</span></span><br><span class="line">        assert.equal(sum(<span class="number">1</span>,<span class="number">2</span>), <span class="number">3</span>,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述另一個測試案例</span></span><br><span class="line">    it(<span class="string">'100 加上 200 應該等於 300'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(sum(<span class="number">100</span>, <span class="number">200</span>), <span class="number">300</span>,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在這個範例程式碼中，主要是在測試剛剛我們寫好的 <code>sum.js</code> 函式，並且透過兩個測試案例來描述情境，並斷言該情境預期的結果。（語法在後面的篇章將會有更詳細的介紹。）</p>
<h1 id="執行測試"><a href="#執行測試" class="headerlink" title="執行測試"></a>執行測試</h1><p>準備好測試程式碼後，我們回到 <code>package.json</code> 來撰寫最後要執行用的快捷程式碼：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"test"</span>: <span class="string">"mocha"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一來，我們在終端機中執行 <code>npm run test</code> 便可以執行 <code>Mocha</code> 來根據測試程式碼來測試程式了。而本次測試執行的結果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span> sum 函式測試</span><br><span class="line">    √ 1 加上 2 應該等於 3</span><br><span class="line">    √ 100 加上 200 應該等於 300</span><br><span class="line">2 passing (13ms)</span><br></pre></td></tr></table></figure>

<p>我們看到測試結果首先跑出我們前面使用 <code>describe</code> 所描述的測試情境，並且在底下顯示兩條通過的測試案例，後面帶有使用 <code>it</code> 所描述的測試案例說明，到這裡基本上我們已經完成了一個測試基本的概念雛型。</p>
<p>有興趣的讀者，可以再試試看假設今天的程式結果與斷言不一致時會發生什麼事情？</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://mochajs.org/#installation" target="_blank" rel="noopener">Mocha-installation</a></li>
<li><a href="https://mochajs.org/#getting-started" target="_blank" rel="noopener">Mocha-get-started</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Mocha.js</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Mocha.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Mocha.js 運行週期、週期鉤子（Run cycle, Hook）</title>
    <url>/mocha.js/Mocha-002-run-cycle/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="mocha-logo" src='/images/Mocha/mocha-logo.svg' width='200px' height='200px' />
</div>

<h1 id="Run-Cycle-運行週期"><a href="#Run-Cycle-運行週期" class="headerlink" title="Run Cycle 運行週期"></a>Run Cycle 運行週期</h1><p>Mocha.js 在執行測試時，會遵循它的運行週期，只要瞭解了它的運行週期，我們便能快速掌握撰寫測試程式碼的基本架構：</p>
<a id="more"></a>

<p><img src="/images/Mocha/mocha-run-cycle.png" alt="mocha-run-cycle.png"></p>
<ol>
<li>執行 Mocha 主程式</li>
<li>生成並進入子處理程序。</li>
<li>處理並執行 Mocha options 選項內容。</li>
<li>依序單筆地執行所有 spec 檔案。</li>
<li>在 spec 檔案中，依序執行所有的測試套件 <code>describe()</code> 中的 callback function。</li>
<li>第一筆測試案例開始前，執行 <code>before()</code> 週期鉤子。</li>
<li>在執行每個測試案例前，都各別觸發一次 <code>beforeEach()</code> 週期鉤子。</li>
<li>執行測試案例 <code>it()</code> 中的 callback function。</li>
<li>在執行每個測試案例後，都各別觸發一次 <code>afterEach()</code> 週期鉤子。</li>
<li>最後一筆測試案例結束後，執行 <code>after()</code> 週期鉤子。</li>
<li>執行完所有 spec 檔案。</li>
<li>結束子處理程序。</li>
</ol>
<p>而整個週期最重要的概念在於每個 spec 檔案被執行的時候，會觸發測試套件（Test suit）與測試案例（Test case）的 callback function 以及週期鉤子（Hook），而我們最主要的撰寫測試程式碼的邏輯都會集中在個週期內。接下來要來介紹這些 API 大致上在做什麼。</p>
<hr>
<h1 id="Test-suit-測試套件"><a href="#Test-suit-測試套件" class="headerlink" title="Test suit 測試套件"></a>Test suit 測試套件</h1><p>每個 spec 檔案中可以允許有多個測試套件，可用來劃分每種測試情境。</p>
<ul>
<li><strong>describe(‘test suit name’, callback function())：</strong><br>第一個參數主要用來描述該測試套件中的整體環境，而第二個參數則是用來呼叫測試案例以及週期鉤子。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'App router test'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 放入 it() 或其他週期鉤子 before()、beforeEach()、after()、afterEach()</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="Test-case-測試案例"><a href="#Test-case-測試案例" class="headerlink" title="Test case 測試案例"></a>Test case 測試案例</h1><p>每個測試套件中可以允許有多個測試案例，可用來釐清該筆案例所測試的內容。</p>
<ul>
<li><strong>it(‘test case name’, callback function())</strong><br>第一個參數主要用來描述該筆測試案例（Test Case）的情境，而第二個參數則是用來呼叫斷言（assertion）的內容。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'App router test'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 放入斷言內容</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><p>運行週期裡面最主要的概念在於每個 spec 檔案被執行的時候，會依序觸發的 callback function 與週期鉤子（Hook），接下來來介紹與週期有關的 API：</p>
<ul>
<li><p><strong>before()</strong><br>進入測試套件時便會執行一次，主要用來放入執行測試案例前的測前資料。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 測前資料</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>beforeEach()</strong><br>每個測試案例（Test Case）開始前都會執行一次，用來更新每筆測試案例的測前資料。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 更新測前資料</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>afterEach()</strong><br>每個測試案例（Test Case）結束後都會執行一次，用來更新每筆測試案例的結束後的資料。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">afterEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 更新測後資料</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>after()</strong><br>離開測試套件時便會執行一次，用來更新整個測試套件結束後的資料，以避免測試時汙染到原先的資料，影響到下一個測試套件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 測後資料</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>釐清了上述的週期、測試套件、測試案例、與鉤子後，現在我們可以嘗試來寫一個跟週期鉤子有關的測試 spec 檔（建置的部分可參考之前的 Mocha 環境建置 文章）。</p>
<p><strong>sum.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = sum</span><br></pre></td></tr></table></figure>

<p><strong>minus.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minus</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = minus</span><br></pre></td></tr></table></figure>

<p><strong>function.spec.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 Mocha 的斷言庫。</span></span><br><span class="line"><span class="keyword">let</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>)</span><br><span class="line"><span class="comment">// 引入寫好的程式</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="built_in">require</span>(<span class="string">'../sum'</span>)   </span><br><span class="line"><span class="keyword">const</span> minus = <span class="built_in">require</span>(<span class="string">'../minus'</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述測試環境</span></span><br><span class="line">describe(<span class="string">'函式測試'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 給予容器資料類型應有的預設值</span></span><br><span class="line">    <span class="keyword">let</span> sumResult = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> minusResult = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> randomNumberA = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> randomNumberB = <span class="number">0</span></span><br><span class="line">    beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">        <span class="comment">// 設定每次測試案例要用的資料，這裡使用 random() 函式賦予每次案例不同的值。</span></span><br><span class="line">        randomNumberA = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>) <span class="comment">// 0 ~ 10</span></span><br><span class="line">        randomNumberB = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>) <span class="comment">// 0 ~ 10</span></span><br><span class="line">        sumResult = randomNumberA + randomNumberB</span><br><span class="line">        minusResult = randomNumberA - randomNumberB</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'add 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(sum(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'add 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(sum(<span class="number">100</span>, <span class="number">200</span>), <span class="number">300</span>,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'add 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(sum(randomNumberA, randomNumberB), sumResult,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'minus 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(minus(<span class="number">3</span>, <span class="number">2</span>), <span class="number">1</span>,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'minus 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(minus(<span class="number">300</span>, <span class="number">200</span>), <span class="number">100</span>,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'minus 函式返回兩者相加的值'</span>, () =&gt; &#123;</span><br><span class="line">        assert.equal(minus(randomNumberA, randomNumberB), minusResult,<span class="string">'沒有返回預期的結果'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>執行測試後秀出結果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">函式測試</span><br><span class="line">  √ add 函式返回兩者相加的值</span><br><span class="line">  √ add 函式返回兩者相加的值</span><br><span class="line">  √ add 函式返回兩者相加的值</span><br><span class="line">  √ minus 函式返回兩者相加的值</span><br><span class="line">  √ minus 函式返回兩者相加的值</span><br><span class="line">  √ minus 函式返回兩者相加的值</span><br></pre></td></tr></table></figure>

<p>以上便是一個簡單搭配週期鉤子的範例。當然，這比起真正的測試還有段距離，得隨著不斷的練習才能寫出快速有效率的測試程式碼！</p>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://mochajs.org/#run-cycle-overview" target="_blank" rel="noopener">Mocha-run-cycle</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Mocha.js</category>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>w3HexSchool</tag>
        <tag>Testing</tag>
        <tag>Mocha.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 為何需要框架與 Vue.js ？</title>
    <url>/vue.js/Vue-001-why-do-I-need-vue/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h1 id="為什麼要學框架？"><a href="#為什麼要學框架？" class="headerlink" title="為什麼要學框架？"></a>為什麼要學框架？</h1><p>HTML、CSS 以及 JavaScript 是身為前端不可或缺的技能組合，然而要投履歷時會發現許多公司都會要求至少要有一個框架的經驗，再加上一些工具才會達到應徵門檻，不求甚解的話很容易認為框架只是個公司需求，但可以反問的是，<strong>為什麼公司會有框架的需求呢？</strong></p>
<p>在不同類型的公司可能會遇到不同的問題，團隊開發專案會需要配合互相的 code，翻修、維護舊專案則是要看前人寫的 code，就連自己想要在自己 side project 上加功能，都得看自己以前寫的 code。在哪都要看 code 的情況下，看 code 顯然就變成了一門值得探討的技術，並且延伸到<strong>命名規則</strong>、<strong>編寫風格規定</strong>等等，而框架就我認為在某種程度上是<strong>提升</strong>了看 code 這門技術的<strong>優雅性</strong>。</p>
<p>隨著時代的演進，網路開發已從一人包辦變成前後端分離，而分離出來的前端要實作的功能也越趨複雜，以致於程式碼的維護與管理越來越困難，如果公司沒有固定設計模式的情況下，不同專案的開發人員依自己喜好編寫開發架構，甚至維護他人專案時又採用自己的喜好，未來維護專案時將會需要花相對更長的時間在看 code，除了基本的 review code 似乎可以稍微防止這類的事情發生，若能依照各個框架本身提供的 <strong>API</strong> 、<strong>風格</strong>、<strong>邏輯</strong>與<strong>架構</strong>開發，下一個人要接手維護時只要懂得該框架的邏輯與用法就能繼續延續前人的程式碼，至於選用哪個框架則會依據<strong>公司專案的需求不同而有不同</strong>，另外也會因為<strong>時代的不同</strong>，而有<strong>不同的選擇可以考量</strong>。</p>
<a id="more"></a>

<h1 id="jQuery-不好嗎，為什麼要用-Vue-js？"><a href="#jQuery-不好嗎，為什麼要用-Vue-js？" class="headerlink" title="jQuery 不好嗎，為什麼要用 Vue.js？"></a>jQuery 不好嗎，為什麼要用 Vue.js？</h1><p>上個段落提到了不同的時代會有不同的選擇，作為前輩的 jQuery ，當時出現的歷史原因是 JavaScript 在<strong>早期的一些原生功能較為薄弱</strong>，並且當時<strong>瀏覽器不一致</strong>的問題使得同樣一段程式碼在不同瀏覽器會產生不同結果，<br>舉例來說，在操作 <code>DOM</code> 的時候，原生 JavaScript 可以使用 <code>document.getElementById(&#39;test&#39;)</code> 這種寫法去捕捉，再透過方法來將值輸入進節點。但使用 jQuery 的作法可以透過更簡單的方法如 <code>$(&#39;#text&#39;).html()</code> 就可以輕鬆達成，除此之外還有像是對於 <strong>AJAX 的發送</strong>、<strong>建立新的 DOM 元素</strong>、<strong>各種事件</strong>與<strong>動畫</strong>等等，jQuery 都提供更完善與簡潔的方法來解決他們。</p>
<p>至於 Vue.js 解決的主要問題在於 <strong>UI 與狀態同步的難處</strong>，假設有一個代辦清單的專案需求，不論原生 JavaScript 或是使用 jQuery，都得<strong>相對頻繁地的操作 DOM</strong> ，也因此使得網頁性能下降，而且在同步與非同步的難題中，容易漏了一個環節後就漸漸與 UI 脫離，並且這樣的做法也相對<strong>難以知道</strong>最後是由誰去更動了目標。而 Vue.js 則是以<strong>監聽</strong>特定節點中的值來觸發需要改動的狀態，透過<strong>綁定 HTML 元素</strong>，使用<strong>模板語法</strong>來將我們想要顯示的資料輸出。範例如下：<br>HTML 部分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; myData &#125;&#125;</span><br><span class="line">    <span class="comment">&lt;!-- 使用花括弧可直接取得 Vue.js 實體中的資料 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        myData: <span class="string">'我的資料'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>這樣的做法除了在 HTML 部分可以更清楚的掌握整個元件的樣貌，往後也能透過 Vue 實體來控管整個狀態的運作。</p>
<p>由此可知 jQuery 解決的問題與 Vue.js 其實不太一樣，並且當時關注點分離著重的地方也不太相同（以前強調 HTML、CSS、JavaScript 要盡量分開，現在則是偏好以單一個元件為一個單位），所以我認為並非 jQuery 不好用，只是 Vue.js 更貼近目前前端的趨勢。但也並非完全就不用 jQuery，以往專案有用到 jQuery 的話，仍需要瞭解 jQuery 的用法，才能符合舊專案的<del>形狀</del>思維。</p>
<h1 id="我還能靠-Vue-js-做到什麼？"><a href="#我還能靠-Vue-js-做到什麼？" class="headerlink" title="我還能靠 Vue.js 做到什麼？"></a>我還能靠 Vue.js 做到什麼？</h1><p>除了以上 UI與狀態同步 的優點之外，Vue.js 身為一款靈活的<strong>漸進式框架</strong>，你可以<strong>決定在不同的專案中引入不同程度的 Vue.js</strong>，小至只使用他提供的<strong>資料綁定（Data Binding）</strong>功能；大則到可以藉由 Vue-cli 建立一個較為完整的單頁式應用程式(SPA, Single Page Application)，讓你<strong>殺雞焉用牛刀</strong>。</p>
<p>擁有<strong>相對平緩的學習曲線</strong>，不如 React.js 要求較高的 JavaScript 能力（需要使用大量的 es6 以及 JSX），不如 Angular 要學習許多內建的函式庫以及 TypeScript、Rx.js，並且擁有<strong>簡單易讀的文件</strong>，需要特定功能（router、vuex、nust）時再去使用也沒問題。</p>
<p>若是更加深度比較框架間的差異與優勢也可以參考下列文章：</p>
<ul>
<li><a href="https://kknews.cc/zh-tw/code/r33n9vn.html" target="_blank" rel="noopener">全面的 React、Angular 和 Vue.js 比較指南</a></li>
<li><a href="https://buzzorange.com/techorange/2017/07/31/all-about-javascript-framework/" target="_blank" rel="noopener">JavaScript 框架大比拼</a></li>
</ul>
<p>看完本篇文章不知道大家是否心中有個底要追 Vue.js 呢？而下一篇文章將會開始建立基礎環境，若還在猶豫不彷繼續走走，或許到後面你會愛上 Vue.js！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 指令 Directives</title>
    <url>/vue.js/Vue-003-directives/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h1 id="指令（Directives）"><a href="#指令（Directives）" class="headerlink" title="指令（Directives）"></a>指令（Directives）</h1><p>在 Vue.js 中有提供一些帶有前綴<code>v-</code>的指令，指令主要放在 HTML 標籤當中，如同 HTML 屬性一樣，而我們可以透過指令去<strong>命令那些元素做事情</strong>，只要指令<strong>條件符合</strong>時，就會執行該指令的動作。而透過這些指令與上一回的樣板語法，我們可以直接在 HTML 上去綁定我們需要做的事情，以下列出幾個常用到的指令與用法：</p>
<a id="more"></a>

<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>透過<code>v-if</code>指令，當<code>v-if</code>後的條件為<code>true</code>時，該元素就會<strong>顯示</strong>在 DOM 上，若<code>false</code>則該元素<strong>不會顯示</strong>在 DOM 的結構上。</p>
<p>範例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">'text1'</span>&gt;</span>最後這段文字會顯示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">'text2'</span>&gt;</span>最後這段文字不會顯示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">  el:<span class="string">'#app'</span>,</span></span><br><span class="line">  data:&#123;</span><br><span class="line"><span class="actionscript">    text1:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">    text2:<span class="literal">false</span></span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>和上面的<code>v-if</code>很像，但<code>v-show</code>在<code>false</code>時的消失，實際觀察 DOM 會發現該元素只是被加上了行內樣式 <code>style=&quot;display:none&quot;</code>而已，並<strong>沒有從DOM上消失</strong>。</p>
<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>接下來介紹的這個指令非常的好用，透過<code>v-for</code>，我們可以將<code>data</code>中的某筆資料遍歷輸出，用法就有如原生 JavaScript 中的 <code>for...of</code>迴圈一樣，取一個變數名稱去拿到<strong>資料物件裡面的值</strong>，可以用來快速製作一個<strong>樣板</strong>。</p>
<p>範例：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(person,index) in class001"</span> <span class="attr">:key</span>=<span class="string">"person.id"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      第</span><span class="xquery">&#123;&#123; index &#125;</span><span class="xml">&#125;筆資料，姓名：</span><span class="xquery">&#123;&#123; person<span class="built_in">.name</span> &#125;</span><span class="xml">&#125;，年齡：</span><span class="xquery">&#123;&#123; person.age &#125;</span><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">let vm = new Vue(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">  el:<span class="string">'#app'</span>,</span></span><br><span class="line"><span class="xquery">  data:&#123;</span></span><br><span class="line"><span class="xquery">    class001:[</span></span><br><span class="line"><span class="xquery">      &#123;</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> id</span>:<span class="string">'001'</span>,</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> name</span>:<span class="string">'小明'</span>,</span></span><br><span class="line"><span class="xquery">        age:<span class="number">12</span></span></span><br><span class="line"><span class="xquery">      &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> id</span>:<span class="string">'002'</span>,</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> name</span>:<span class="string">'小美'</span>,</span></span><br><span class="line"><span class="xquery">        age:<span class="number">10</span></span></span><br><span class="line"><span class="xquery">      &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> id</span>:<span class="string">'003'</span>,</span></span><br><span class="line"><span class="xquery">       <span class="built_in"> name</span>:<span class="string">'小華'</span>,</span></span><br><span class="line"><span class="xquery">        age:<span class="number">11</span></span></span><br><span class="line"><span class="xquery">      &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    ]</span></span><br><span class="line"><span class="xml">  &#125; </span></span><br><span class="line"><span class="xml">&#125;)</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>需要注意的地方</strong>，在使用<code>v-for</code>指令輸出時，<a href="https://cn.vuejs.org/v2/style-guide/#%E4%B8%BA-v-for-%E8%AE%BE%E7%BD%AE%E9%94%AE%E5%80%BC-%E5%BF%85%E8%A6%81" target="_blank" rel="noopener">官網強烈建議</a>需要給予一個 <code>key</code> 來作為可識別的資料，有點類似於身分證的概念；而當我們需要對資料操作時，Vue.js 也才能依靠身分證去找到對的人，如果我們是使用門牌（如<code>index</code>）來檢驗的話，哪天裡面的租客搬走換人了就會找錯人了！</p>
<p><strong>另外一個須注意的地方是</strong>，需要避免<code>v-for</code>與<code>v-if</code>在同一個地方上使用，因為有可能會渲染到本來應該會隱藏的欄位，而官方也做了<a href="https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7-%E5%BF%85%E8%A6%81" target="_blank" rel="noopener">詳細解釋</a>，簡單來說你叫貓咪要趴下，又要他站起來，那牠到底是要趴下還是站起來呢？</p>
<p>橘橘：我選擇趴下好了<br><img src="https://ithelp.ithome.com.tw/upload/images/20190906/20119062JZFpwznF0E.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190906/20119062JZFpwznF0E.jpg"></p>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>透過<code>v-model</code>指令綁定在元素上，可以創造一個雙向綁定資料的概念，例如我們讓資料雙向綁定在一個<code>input</code>元素上，<code>input</code>的值就會顯示出他對應的<code>&#39;我會顯示在input中&#39;</code>，如果我們更改<code>input</code>的值，最後 <code>data</code> 裡面的值也會被我們更改。</p>
<p>範例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">  el:<span class="string">'#app'</span>,</span></span><br><span class="line">  data:&#123;</span><br><span class="line"><span class="actionscript">    message:<span class="string">'我會顯示在input中'</span></span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p><code>v-on</code>指令使用方法類似於使用 HTML 原生屬性<code>on</code>一樣。例如要使用點擊觸發的行為，我們只要在元素上寫上<code>v-on:click=&quot;yourFunction&quot;</code>即可，而寫函式的位置則是在 Vue.js 實體中的 <code>methods</code> 裡頭。範例如下：</p>
<p>HTML部分</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;button type=<span class="string">"button"</span> v-<span class="keyword">on</span>:click=<span class="string">"handleOnClick"</span>&gt;Click Me!&lt;/button&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>JavaScript部分</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  method<span class="variable">s:</span>&#123;</span><br><span class="line">    handleOnClick : <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">      alert(<span class="string">'Hello Vue!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>除此之外，<code>v-on</code>也可以縮寫為<code>@</code>，將上面的範例改寫後會變成：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"handleOnClick"</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>這樣的效果會跟上方一模一樣。</p>
<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p><code>v-bind</code>主要可以用來綁定元素中的屬性，並且將屬性的值交由 Vue.js 中的 <code>data</code> 來控管，達到<strong>動態控制</strong>，使該元素變成是<strong>可控制的元素</strong>，這個觀念在 React.js 中也常常用到，例如常用到的一個做法就是控制元素的<code>class</code>屬性。下方範例將示範一個由按鈕去<strong>驅動資料</strong>讓元素的 <code>class</code> 能動態變化：</p>
<p>CSS部分，這裡簡單定義了box與rotate的樣式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.rotate</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HTML部分，這裡透過<code>v-on</code>的點擊事件讓<code>isRotate</code>的值可以反轉布林值，而 <code>v-bind:class</code> 的意思則是當<code>isRotate</code>為<code>true</code>該元素加上<code>rotate</code>的 <code>class</code>名稱，若<code>false</code>則不添加。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span> v-bind:<span class="built_in">class</span>=<span class="string">"&#123;'rotate':isRotate&#125;"</span>&gt;&lt;<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;button type=<span class="string">"button"</span> v-<span class="keyword">on</span>:click=<span class="string">"isRotate = !isRotate"</span>&gt; Rotate <span class="keyword">the</span> box&lt;/button&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>JavaScript部分</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    isRotate: false,</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如此一來我們便可以使用按鈕來驅動元素樣式。而這個指令也有縮寫的寫法，用法省略<code>v-bind</code>只留下<code>:</code>的部分，範例修改上面後的如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span> :<span class="built_in">class</span>=<span class="string">"&#123;'rotate':isRotate&#125;"</span>&gt;&lt;<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;button type=<span class="string">"button"</span> @click=<span class="string">"isRotate = !isRotate"</span>&gt; Rotate <span class="keyword">the</span> box&lt;/button&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>以上是一些常用到的指令與用法，關於其他更多深入的用法，可到官網上有更多詳細範例說明可以<a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">參考</a>，而下一段章節將會介紹到<strong>修飾符</strong>的內容，我們將會知道怎麼用簡單的<strong>修飾符</strong>讓指令的變化更加豐富！我們下個章節見！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 基礎環境建置</title>
    <url>/vue.js/Vue-002-basic-build/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>
# 環境搭建

<p>一般來說建置 Vue.js 的完整專案會使用 Vue-cli 工具來產生專案目錄，但如果只是想要快速學習 Vue.js 不必安裝過多的環境，Vue.js 的官網提供了 CDN 的作為引入方式，讓有興趣的人可以更快參與其中，而目前提供的版本分別為：</p>
<ul>
<li><strong>開發版本：</strong>這個版本包含了<strong>完整的開發人員工具</strong>以及<strong>提示報錯</strong>等等的協助，適合<strong>開發</strong>時使用。</li>
<li><strong>生產版本：</strong>這個版本則是將上述開發工具都拔除，盡量縮小它的體積，適合<strong>正式發布</strong>時使用。</li>
</ul>
<p>而我們目的是體驗 Vue.js 的開發，因此選擇<strong>開發版本</strong>，並將其導入 HTML 的 head 中即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接著在 HTML 的部分我們需要建立一個元素並選擇性使用 <code>class</code> 或 <code>id</code>，讓待會 Vue.js 知道它要渲染的範圍。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 待會用來初始化 Vue 的地方</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>在 JavaScript 部分，我們需要初始化 Vue.js 的實體，就好像飲料販賣機一樣，投個硬幣拿到這個商品後我們就可以開始使用它。透過 <code>new</code> 初始化 Vue 的物件之後，傳入一些基本的設定，其中 <code>el</code> 的值需要放入綁定的元素好比上方範例中的（<code>app</code>）；而 <code>data</code> 的值則是傳入一個物件，這裡主要是用來存放資料的部分，而 <code>key</code>（<code>message</code>）的部分將會用在<strong>樣板語法</strong>中供 Vue.js 去找到對應的 <code>value</code>（<code>&#39;Hello, Vue.js!&#39;</code>）最後將它顯示出來。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    message:<span class="string">'Hello, Vue.js!'</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後，我們在剛才的 HTML 部分中使用<strong>樣板語法（兩對花括弧）</strong>，裡面塞入剛才的 <code>key</code>（<code>message</code>），就可以將其對應的 <code>&#39;Hello, Vue.js!&#39;</code> 渲染出來：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">     var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">      el:'#app',</span></span><br><span class="line"><span class="xml">      data:&#123;</span></span><br><span class="line"><span class="xml">        message:'Hello, Vue.js!'</span></span><br><span class="line"><span class="xml">      &#125; </span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>如此一來，將頁面打開來時就能看到 Hello, Vue.js!了。<del>找回最初的感動（？</del></p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190904/20119062w0tUzpaNA2.png" alt="https://ithelp.ithome.com.tw/upload/images/20190904/20119062w0tUzpaNA2.png"></p>
<h1 id="BONUS：平時開發常用設定"><a href="#BONUS：平時開發常用設定" class="headerlink" title="BONUS：平時開發常用設定"></a>BONUS：平時開發常用設定</h1><ul>
<li>作業系統： 目前主要是在 Windows、以前則是用 macOS (雙棲動物)</li>
<li>程式碼編輯器： Visual Studio Code (free)</li>
</ul>
<p>編輯器推薦套件</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag" target="_blank" rel="noopener">Auto Rename Tag</a>：更改標籤時，想一次更改開始標籤與結尾標籤可以考慮安裝這個！</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer" target="_blank" rel="noopener">Bracket Pair Colorize</a>：將程式碼區塊前後顏色配對，可以快速找到該區塊範圍在哪。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.live-sass" target="_blank" rel="noopener">Live Sass Compiler</a>：可以自動編譯 SASS（SCSS）並同步輸出成未壓縮版與壓縮版的 CSS 檔。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer" target="_blank" rel="noopener">Live Server</a>：模擬一個 Local Web 環境，具有熱更新的功能，也就是一更改程式碼就會即時顯示變化在頁面上。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=octref.vetur" target="_blank" rel="noopener">Vetur</a>：由 Vue.js 作者<strong>尤雨溪</strong>與微軟開發者<strong>Pine Wu</strong>官方合作的套件，支援了<strong>語法高亮</strong>、<strong>語法快捷</strong>等等強大的功能。</li>
</ul>
<p>Chrome 瀏覽器推薦套件</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/dimensions/baocaagndhipibgklemoalmkljaimfdj" target="_blank" rel="noopener">Dimensions</a>：可以快速量網頁上元素之間的距離。</li>
<li><a href="https://chrome.google.com/webstore/detail/colorpick-eyedropper/ohcpnigalekghcmgcdcenkpelffpdolg" target="_blank" rel="noopener">ColorPick Eyedropper</a>：可以快速捕捉網頁上的色彩顏色（RGB、HEX 等等應有盡有）。</li>
<li><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd" target="_blank" rel="noopener">Vue.js devtools</a>：開發必備，可以即時監測 Vue 實體中的資料狀態等等資料，你想一邊 Debug 一邊觀看 Data 的狀況嗎？安裝他吧！</li>
</ul>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190904/20119062BP5oyN0ahL.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190904/20119062BP5oyN0ahL.jpg"></p>
<p>如果還有其他好用的工具也歡迎讀者投稿囉！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 資料選項 Options</title>
    <url>/vue.js/Vue-005-options/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h1 id="data-資料"><a href="#data-資料" class="headerlink" title="data 資料"></a>data 資料</h1><p>data 是用來儲存資料的地方，而 Vue.js 會透過前面介紹的樣板語法，將其對應的值輸出顯示到 DOM 上，並且最重要的是，只要一更動 data 裡面的資料，Vue.js 將會透過內部已經幫我們處理好的邏輯，去比對 HTML 哪邊需要更改，實現部分渲染，達成資料驅動畫面的概念。範例：</p>
<p>HTML 部分：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">    &#123;&#123; a &#125;&#125;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>JavaScript部分：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">let</span> <span class="string">vm = new Vue(&#123;</span></span><br><span class="line">  <span class="attr">el</span>: <span class="string">'#app',</span></span><br><span class="line">  <span class="attr">data</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">a</span>: <span class="string">1,</span></span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">b1</span>: <span class="string">'something',</span></span><br><span class="line">        <span class="attr">b2</span>: <span class="string">'another</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;)</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>首先如同前面介紹，使用 <code>new</code> 關鍵字去創建一個實體，並使用花括弧傳入我們所需要的參數，例如在 <code>el</code> 中去填入我們要渲染的元素範圍 <code>#app</code> ，在 data 中則一樣是透過物件再把我們要的資料配對給他，我們就可以在 HTML 部分以樣板語法取得對應的值。</p>
<h1 id="computed-計算屬性"><a href="#computed-計算屬性" class="headerlink" title="computed 計算屬性"></a>computed 計算屬性</h1><p>前面提到的 data 主要是用來存放一些資料，如果我們今天在顯示資料前需要<strong>先計算</strong> data 的內容<strong>再顯示</strong>到畫面上時，就可以使用 computed 來幫助我們，例如以匯率計算來說：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  目前擁有台幣：</span><span class="template-variable">&#123;&#123; money &#125;&#125;</span><span class="xml">元。</span></span><br><span class="line"><span class="xml">  轉換為日幣後：</span><span class="template-variable">&#123;&#123; money / 0.3&#125;&#125;</span><span class="xml">日圓。</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    money:<span class="number">1000</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>原先我們可能在樣板語法中直接去計算內容，但是如果要重複使用的話將會大量的複製貼上，此時便可以使用<code>computed</code>來計算，修改後如下：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  目前擁有台幣：</span><span class="template-variable">&#123;&#123; money &#125;&#125;</span><span class="xml">元。</span></span><br><span class="line"><span class="xml">  轉換為日幣後：</span><span class="template-variable">&#123;&#123; JPY &#125;&#125;</span><span class="xml">日圓。</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    money:<span class="number">1000</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">    JPY : <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">      <span class="keyword">return</span> this.money / <span class="number">0.3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>這樣改變後，在 HTML 的部分將更加的直觀，而將計算的方法寫在實體當中，需要取得的時候如同在 data 的資料，將對應的 key（<code>JPY</code>）寫在樣板語法鐘即可。</p>
<p><strong>而使用這個方法要注意的地方在於</strong>，若其計算的途中沒有使用到 <code>data</code> 中的任何一筆資料時，<strong>資料將會無法更新！</strong>，因此若確定每次使用都會更新到的部分建議還是使用 <code>methods</code> 的方法來驅動。</p>
<h1 id="methods-方法"><a href="#methods-方法" class="headerlink" title="methods 方法"></a>methods 方法</h1><p>與<code>computed</code>不一樣的是，<code>methods</code>可以直接供 Vue.js 的實體來使用，也可以藉由指令中的表達式使用，更重要的是還能將參數帶入其函式中( <code>computed</code> 是無法傳入參數的)。</p>
<p>範例如下：</p>
<p>在這個完整範例中，原先按鈕會顯示 <code>data</code> 中的 <code>text</code>資料，按下按鈕後透過指令 <code>v-on:click</code> 縮寫（<code>@click</code>）去執行  <code>methods</code> 裡面的 <code>handleOnClick</code>，並將參數 ‘Shawn’傳到函式中，最後透過 <code>this.text</code> 方法取得 data 裡面的 <code>text</code> 並且更改為我們需要的內容。</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleOnClick('Shawn')"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span></span><span class="template-variable">&#123;&#123;text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    tex<span class="variable">t:</span><span class="string">'Hello Vue!'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  method<span class="variable">s:</span>&#123;</span><br><span class="line">    handleOnClick : <span class="function"><span class="keyword">function</span><span class="params">(name)</span>&#123;</span></span><br><span class="line">      <span class="keyword">return</span> this.text = `Hello $&#123;name&#125;!`</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>而<code>methods</code>要注意的地方是</strong>，函式的部分不能使用 ES6 中的箭頭函式<code>arrow function</code>，否則<code>this</code>指向 window 最後拋出<code>undefined</code>。</p>
<h1 id="watcher-監聽器"><a href="#watcher-監聽器" class="headerlink" title="watcher 監聽器"></a>watcher 監聽器</h1><p><code>watch</code>的用法如同監聽器一樣，在與其綁定的資料有更動時會執行對應的函式，需要異步執行資料變化時便可以使用，而參考官網的範例如下：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    今晚晚餐吃這個：</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"question"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; answer &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    question:<span class="string">''</span>,</span><br><span class="line">    answer:<span class="string">'讓我來幫你決定要吃什麼吧！'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  watch:&#123;</span><br><span class="line">    question : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.getAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    getAnswer:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">      fetch(<span class="string">'https://yesno.wtf/api'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span>=&gt;</span>res.json())</span><br><span class="line">      .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        self.answer = res.answer</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>這個範例是透過 yesno 網站所提供的 API 去實作一個決定晚餐要不要吃這個的簡單應用程式，使用者在 <code>input</code> 輸入問題後，透過上篇提過的 <code>v-model</code> 雙向綁定資料到<code>data</code>中的<code>question</code>，接著資料內容被改變後去驅動監聽器去啟動對應的方法並啟動 <code>methods</code> 裡面的 <code>getAnswer</code> ，接著 <code>getAnswer</code> 發送了一個<code>request</code>到<a href="https://yesno.wtf/api" target="_blank" rel="noopener">https://yesno.wtf/api</a>並得到一個回應後，我們再將回應的資料傳回去 data 中的 <code>answer</code>。</p>
<p>以上這幾個用法是屬於 Vue.js 實體的一些相關用法，結合樣板語法、指令與修飾符後我們已經可以完成一個簡單的小應用了，而下個章節我們將繼續介紹 Vue.js 的生命週期！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 修飾符 modifier</title>
    <url>/vue.js/Vue-004-modifier/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="修飾符"><a href="#修飾符" class="headerlink" title="修飾符"></a>修飾符</h2><p>上一章節介紹到指令的部分，還蠻多的東西需要一點時間消化，而今天要來介紹一點相對簡單的東西，那就是修飾符(modifier)啦！在 Vue.js中，修飾符以半形句號(<code>.</code>)<strong>後綴</strong>在指令上來表示<strong>觸發事件時會另外使用什麼方法</strong>，而修飾符的種類分別有：</p>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">事件修飾符</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">按鍵修飾符</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/events.html#%E7%B3%BB%E7%BB%9F%E4%BF%AE%E9%A5%B0%E9%94%AE" target="_blank" rel="noopener">系統修飾鍵</a></li>
</ul>
<a id="more"></a>

<h2 id="事件修飾符"><a href="#事件修飾符" class="headerlink" title="事件修飾符"></a>事件修飾符</h2><p>事件修飾符是將常用的一些事件處理事件綁定在我們所觸發的指令上，例如我們常會在實作上遇見的<strong>點擊冒泡</strong>觸發事件，以往我們會透過<code>event.preventDefault()</code>來處理這一類事件，而在 Vue.js 中我們可以在<code>@click</code>後面加上<code>.prevent</code>就能夠在觸發<code>handleOnClick</code>後觸發<code>event.preventDefault()</code>：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">&lt;button <span class="class"><span class="keyword">type</span></span>=<span class="string">"button"</span> <span class="meta">@click</span>.prevent=<span class="string">"handleOnClick"</span>&gt;<span class="type">Click</span> <span class="type">Me</span>!&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>除此之外的事件修飾符還有：</p>
<ul>
<li><code>.stop</code>：可以阻止原先綁定的指令繼續傳播回其他元素。</li>
<li><code>.once</code>：該指令所綁定的事件只會執行一次。</li>
<li><code>.passive</code>：被修飾的指令若條件符合將會立即觸發，例如在監聽捲軸滾動時<code>v-on:scroll.passive</code>，只要捲軸一滾動就會立即觸發，並不需要等到完成捲軸滾動的行為。</li>
<li><code>.prevent</code>：有如在方法上使用 <code>event.preventDefault()</code> 來阻止冒泡事件。</li>
<li><code>.capture</code>：在冒泡事件中，原本會先到<strong>目標元素</strong>才執行，並往回觸發而被此修飾符修飾的元素將會優先執行。</li>
</ul>
<p>舉例來說，下方例子原本會因為<strong>冒泡事件</strong>的關係，點擊<code>#div2</code>的元素後會先觸發<code>handleOnClickTwo</code>，在冒泡觸發<code>handleOnClickOne</code>，但因為現在有在<code>#div1</code>的點擊事件增加<code>.capture</code>修飾符，所以反而會先觸發<code>handleOnClickOne</code>，在到達目標元素<code>#div2</code>，並觸發<code>handleOnClickTwo</code>。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"div1"</span> @click.capture=<span class="string">"handleOnClickOne"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"div2"</span> @click=<span class="string">"handleOnClickTwo"</span>&gt;</span><br><span class="line">        &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.self</code>：類似上面的範例概念，但這個修飾符是當指令是觸發在自己元素身上的時候才會去執行，例如下面範例點擊元素<code>#div2</code>，原先一樣原本會依序觸發<code>handleOnClickTwo</code>、<code>handleOnClickOne</code>，但因為元素<code>#div1</code>的指令增加了<code>.self</code>修飾符所以不會觸發<code>handleOnClickOne</code>。</li>
</ul>
<p>只有在是點擊元素<code>#div1</code>的情況下，才會觸發<code>handleOnClickOne</code>。</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="symbol">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="symbol">id</span>=<span class="string">"div1"</span> @click.<span class="literal">self</span>=<span class="string">"handleOnClickOne"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="symbol">id</span>=<span class="string">"div2"</span> @click=<span class="string">"handleOnClickTwo"</span>&gt;</span><br><span class="line">        &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>冒泡事件相關的修飾符概念比較難懂一些，大家可以多練習看看，順便跟黑黑一起複習<a href="https://javascript.info/bubbling-and-capturing" target="_blank" rel="noopener">冒泡事件</a>！<br><img src="https://ithelp.ithome.com.tw/upload/images/20190907/20119062ODC8RZPq34.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190907/20119062ODC8RZPq34.jpg"></p>
<h2 id="按鍵修飾符"><a href="#按鍵修飾符" class="headerlink" title="按鍵修飾符"></a>按鍵修飾符</h2><p>第二個要介紹的按鍵修飾符則是提供<strong>偵測鍵盤按鍵</strong>觸發方法(<code>methods</code>)的功能，例如當我們要使用按下<code>enter</code>鍵時啟用方法可以這麼做：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> @keyup.<span class="attribute">enter</span>=<span class="string">"sumbitValid"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>這樣一來如果有一些 input 欄位想要讓使用者快速 keyin 就可以使用這個修飾符增加使用者良好體驗。</p>
<p>另外，按鍵修飾符在更早的版本也支援<code>keycode</code>的用法，只可惜目前已經廢除了。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> @keyup.<span class="attribute">13</span>=<span class="string">"sumbitValid"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>其他官方提供的按鍵修飾符：</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code></li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<h2 id="系統修飾鍵"><a href="#系統修飾鍵" class="headerlink" title="系統修飾鍵"></a>系統修飾鍵</h2><p>系統修飾鍵則是將事件綁定在要按下相對應的按鍵才能觸發方法的功能，假如上方範例還要多一個同時按下<code>shift</code>才能觸發的情境，就會變成：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> @keyup.enter.<span class="attribute">shift</span>=<span class="string">"sumbitValid"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>其他也可以使用的系統修飾鍵：</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<p>透過本篇 Vue.js 所介紹的修飾符，搭配昨天的指令，已經可以組合出許多花樣！而下一章節將會介紹 Vue.js 實體一些常用 api(<code>data</code>、<code>computed</code>、<code>methods</code>以及<code>watch</code>)。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 生命週期 lifecycle</title>
    <url>/vue.js/Vue-006-lifecycle/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p><img src="https://ithelp.ithome.com.tw/upload/images/20190909/20119062ONbDHOY5Nq.png" alt="https://ithelp.ithome.com.tw/upload/images/20190909/20119062ONbDHOY5Nq.png"></p>
<h2 id="生命週期"><a href="#生命週期" class="headerlink" title="生命週期"></a>生命週期</h2><p>生命週期（如上圖）主要是在說明一個元件從生(初始化)到死(註銷)的過程，對於生命週期有良好的理解，可以更有效的運用他，譬如要在哪個階段載入 AJAX 的資料？哪個階段之後才能開始撈 <code>data</code> 裡的資料？為了解決這一類時機的問題，Vue.js 提供了這些<strong>時機</strong>的呼叫方式，稱之為 <strong>hook</strong>。而為了要好好地瞭解 Vue.js 的生命週期，下面透過一個簡單的範例，來捕捉各種生命週期的狀態：</p>
<a id="more"></a>

<p>HTML部分</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"app"</span>&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>JavaScript部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message:<span class="string">'get Data!'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        handleOnClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeCreate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'beforeCreate'</span>)</span><br><span class="line">        alert(<span class="string">"el屬性： "</span>+<span class="keyword">this</span>.$el)</span><br><span class="line">        alert(<span class="string">"data資料： "</span>+<span class="keyword">this</span>.$data.message)</span><br><span class="line">    &#125;,</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(<span class="string">'created'</span>)</span><br><span class="line">      alert(<span class="string">"el屬性： "</span>+<span class="keyword">this</span>.$el)</span><br><span class="line">      alert(<span class="string">"data資料： "</span>+<span class="keyword">this</span>.$data.message)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(<span class="string">'beforeMount'</span>)</span><br><span class="line">      alert(<span class="string">"el屬性： "</span>+<span class="keyword">this</span>.$el)</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'mounted'</span>)</span><br><span class="line">        alert(<span class="string">"el屬性： "</span>+<span class="keyword">this</span>.$el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>設定好一個 Vue.js 的實體之後，接著一步一步對照生命週期的圖來說明：</p>
<h2 id="new-Vue"><a href="#new-Vue" class="headerlink" title="new Vue"></a>new Vue</h2><p>初始化 Vue.js 實體。</p>
<h2 id="init-events-lifecycle"><a href="#init-events-lifecycle" class="headerlink" title="init events $ lifecycle"></a>init events $ lifecycle</h2><p>開始初始化 Vue.js 的生命週期。</p>
<h2 id="beforeCreate-hooks"><a href="#beforeCreate-hooks" class="headerlink" title="beforeCreate (hooks)"></a>beforeCreate (hooks)</h2><p>在此週期下， <code>$el</code> 尚未被建立，且 <code>data</code> 此時也尚未被定義出來，說明在這個階段中我們可以做的基本上是在於資料尚未被讀取進來的事情。而深入查看 Vue.js 檔案 <code>init.js</code> 中，會發現此階段尚未初始化 <code>props</code>、<code>data</code>、<code>methods</code>、<code>watch</code>、<code>computed</code>等 <code>options</code> 所以顯然上述的功能基本上是都不能夠使用的。</p>
<h2 id="init-injection-amp-reactivity"><a href="#init-injection-amp-reactivity" class="headerlink" title="init injection &amp; reactivity"></a>init injection &amp; reactivity</h2><p><del>9/9前原文：開始注入依賴項目。</del></p>
<p>比較好理解的話應該是<strong>此階段會開始將父元件所提供的資料傳遞給子元件做接收</strong>。也就是說在 <code>created</code> hook 執行前要將「提供/拿取 <code>data</code>值」這件事情給初始化完畢，以供使用。</p>
<p>在官方文件 <a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener">provide / inject</a> 一文中提到，父元件可以透過 <code>provide</code> 傳遞一個物件或是讓函式回傳一個物件的方法，供給子元件利用 <code>inject</code> 來得到該物件。</p>
<p>程式碼的部分則可以透過 Vue.js 官方 github 庫的檔案 <a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/inject.js" target="_blank" rel="noopener">inject.js</a> 中可以瞭解到底層的運作方式。</p>
<h2 id="created-hooks"><a href="#created-hooks" class="headerlink" title="created (hooks)"></a>created (hooks)</h2><p>由 <code>alert</code> 取得 <code>$el</code> 結果為 <code>undefined</code> ， <code>data</code> 的結果為 <code>get Data!</code> 的結論得出：</p>
<p>在此週期下， <code>$el</code> 尚未被建立，但 <code>data</code> 此時已經可以讀取的到了，說明在這個階段中我們可以做的基本上在於讀取資料相關的事情。深入研究，查看 Vue.js 中裡的檔案 <code>init.js</code> ，會發現已經初始化<code>props</code>、<code>data</code>、<code>methods</code>、<code>watch</code>、<code>computed</code>，因此也說明了若想要使用<code>data</code>等等的資料的話，至少得等到<code>created</code>這個階段才可以使用。</p>
<h2 id="el檢查"><a href="#el檢查" class="headerlink" title="el檢查"></a>el檢查</h2><p>這個階段會檢查Vue實體中是否含有 <code>$el</code> 的項目，有的話就繼續檢查是否含有 <code>template</code>，沒有的話則是等到手動調用 <code>vm.$mount()</code> 的時候才繼續。</p>
<h2 id="template檢查"><a href="#template檢查" class="headerlink" title="template檢查"></a>template檢查</h2><p>這個階段會檢查 Vue.js 實體中是否含有 <code>template</code> 的項目，沒有的話會將被 <code>$el</code> 綁定的 <code>outerHTML</code> 區域作為樣板替換，若有的話則是將 <code>template</code> 編譯進 <code>render function</code>。</p>
<h2 id="beforeMount-hooks"><a href="#beforeMount-hooks" class="headerlink" title="beforeMount (hooks)"></a>beforeMount (hooks)</h2><p>由 <code>alert</code> 取得 <code>$el</code> 結果顯示此時已經抓的到 <code>$el</code>：</p>
<p>在此週期下 DOM 已經被 Vue.js 載入了一個新的元素。但此時的差異在於， <code>$el</code> 裡面樣板語法尚未被賦予值進去，所以顯示的仍然是兩個花括號的部分<code></code>。</p>
<h2 id="mounted-hooks"><a href="#mounted-hooks" class="headerlink" title="mounted (hooks)"></a>mounted (hooks)</h2><p>由 <code>alert</code> 取得 <code>$el</code> 結果顯示此時已經抓的到 <code>$el</code>，並且此時樣板語法也確實的將資料傳遞進去，因此最後看到的是顯示<code>get Data!</code>的字串而非 <code></code> 了。而一般初始化的 Vue.js 元件的必經之路到此階段就結束了 (<strong>除了使用<code>keep-alive</code>的元件，<code>keep-alive</code>元件再次渲染時並不會觸發<code>created</code>、<code>mounted</code>等hooks</strong>)，因此我們可以再次看向官網的說明圖中，此階段後的線條是虛線的部分。</p>
<h2 id="beforeUpdate-hooks"><a href="#beforeUpdate-hooks" class="headerlink" title="beforeUpdate (hooks)"></a>beforeUpdate (hooks)</h2><p>此生命週期發生在資料即將被更新前，這個階段主要可以用在得知哪個元件即將發生資料改動，並且可以移除對其綁定的事件監聽器。</p>
<h2 id="updated-hooks"><a href="#updated-hooks" class="headerlink" title="updated (hooks)"></a>updated (hooks)</h2><p>此階段已經重新渲染完成資料更新後的狀態，並且要注意在此期間更改狀態，如果要更改官方建議使用<code>computed</code>或<code>watch</code>來進行資料更改。</p>
<h2 id="beforeDestroy-hooks"><a href="#beforeDestroy-hooks" class="headerlink" title="beforeDestroy (hooks)"></a>beforeDestroy (hooks)</h2><p>當一個實體要被銷毀前會觸發此生命週期(譬如透過主動調用<code>vm.$destroy()</code>或是當該元素所綁定的<code>v-if</code>條件為<code>false</code>時)。而這個階段我們可以做一些提醒的動作，例如<code>alert</code>來確認使用者的意圖。</p>
<h2 id="destroyed-hooks"><a href="#destroyed-hooks" class="headerlink" title="destroyed (hooks)"></a>destroyed (hooks)</h2><p>當一個實體已經被銷毀時會觸發此生命週期，這個階段的銷毀意味著所綁定的<code>watcher</code>、<code>child components</code>以及<code>event listeners</code>等等已經與原本元素毫無關聯了，但要注意的事情是父元件已經渲染在DOM上的視圖仍然會保留在頁面上，只有子元件會完全消失。</p>
<h3 id="補充：觸發渲染-Render-時機"><a href="#補充：觸發渲染-Render-時機" class="headerlink" title="補充：觸發渲染 Render 時機"></a>補充：觸發渲染 Render 時機</h3><p>透過以上生命週期，大致上已經可以瞭解每個周期 Vue.js 正在做什麼事情、我們能做什麼事情了，而觸發渲染的關鍵時刻是<code>beforeMount</code>到<code>mounted</code>時以及<code>beforeUpdate</code>至<code>updated</code>的這兩個階段。</p>
<p>最後如果在編寫 Vue.js 時有遇到哪邊渲染有問題，或是資料讀取不到的時候，不彷查看一下是不是做了生命週期所不能及的事情喔！</p>
<p>黑黑：沒有我所不能及的事情！（翻滾）<br><img src="https://ithelp.ithome.com.tw/upload/images/20190909/20119062gSCDaeWfkk.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190909/20119062gSCDaeWfkk.jpg"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 元件 component</title>
    <url>/vue.js/Vue-007-component/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>元件的概念可以把它看作成一個<strong>重複利用性高</strong>的程式，好比只要輸入資料進去，就能夠輸出得到對應的需求，至於其他相關的外觀樣式等等都會相應產生。而要將 Vue.js 的程式元件化之前，首先一起來瞭解它的核心觀念：</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="https://ithelp.ithome.com.tw/upload/images/20190910/20119062r5BJ41crhr.png" alt="https://ithelp.ithome.com.tw/upload/images/20190910/20119062r5BJ41crhr.png"></p>
<p>Vue.js 的架構深受 <a href="https://zh.wikipedia.org/wiki/MVVM" target="_blank" rel="noopener">MVVM</a> 的影響，而 MVVM 講的也就是，M(model)、V(view)以及 VM(view-model)，官網範例中常用到的 <code>vm</code> 也是因此而來的。</p>
<p>三者之間的關係也非常簡單，前端可能會透過像是 API 取得一些後端的資料（Model），接著會撰寫 Vue.js 的部分來讓 API 資料更有邏輯或整理成更加容易讓視覺可以顯示的資料（View-Model），接著就可以使用 Vue.js 的樣板語法來讓整理好的資料顯示在畫面上（View）。</p>
<p>反過來則是今天當按鈕（View）的部分被使用者點擊，因此觸發向 View-Model 獲取一些資訊，而作為 View-Model 可能會直接提供自己本身就有的資料，亦或是最後再向 Model 拿取更多的資訊回來整理。</p>
<p>而 Vue.js 最主要是幫我們把<strong>連結 View 與 Model 的部分</strong>給處理掉了（<strong>View-Model</strong>），因此我們接下來要做的元件，最主要是要透過 Vue.js 提供的 API 等功能（也就是前面所說的指令、修飾符等等），來打造元件，並且搭配 View 與 CSS（SCSS）來塑造他的外觀。</p>
<a id="more"></a>

<h2 id="元件註冊"><a href="#元件註冊" class="headerlink" title="元件註冊"></a>元件註冊</h2><p>在 Vue.js 中要使用 <code>components</code> 時，可以選擇在初始化 Vue.js 時將其資訊帶進去，或是使用 <code>Vue.component</code> 的方式來註冊，並且依據使用方法不同分為區域性的註冊方式(<code>scope</code>)以及全域性的註冊方式(<code>global</code>)，以下介紹兩種註冊方式的差異：</p>
<h3 id="區域註冊"><a href="#區域註冊" class="headerlink" title="區域註冊"></a>區域註冊</h3><p>使用區域性的元件時，可以選擇在初始化 Vue.js 的時候將元件的資訊帶進去：</p>
<p>HTML部分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS部分</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.myComponent</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        <span class="string">'my-component'</span>:&#123;</span><br><span class="line">            template:<span class="string">'&lt;div class="myComponent"&gt;Hello Vue&lt;/div&gt;'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>範例註冊了一個名稱為<code>my-component</code>的元件，並且該元件有一個<code>template</code>，使得 Vue.js 會將其渲染出來，最後在 DOM 產生三個<code>&lt;div class=&quot;myComponent&quot;&gt;Hello Vue&lt;/div&gt;</code>，並且將CSS的style渲染上去，而這種註冊方式是會僅限於原先的區域，假使有另一個 Vue.js 應用程式 <code>app2</code> <code>(如下），在裡面同樣使用</code>my-component<code>，最終結果將會是</code>app2`不認得這個元件，也沒辦法將結果渲染在畫面上。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="全域註冊"><a href="#全域註冊" class="headerlink" title="全域註冊"></a>全域註冊</h2><p>而在某些情境下，專案可能要在兩個或多個應用程式間共享元件。我們可以透過 <code>Vue.component</code> 進行註冊，如此一來不管在哪個程式中都可以使用<code>my-component</code>元件，這種註冊方式會稱他為全域的<code>global</code>的註冊方式，範例程式碼如下：</p>
<p>JavaScript部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>,&#123;</span><br><span class="line">    data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            message:<span class="string">''</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template:<span class="string">'&lt;div class="myComponent"&gt;Hello Vue&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>而這裡有一點要注意的是</strong>，若不將 <code>data</code> 以函式返回物件的方式封裝起來的話，資料物件將會混淆，並且被各個元件共享（原因是物件是屬於複雜類型，複雜類型的參考方式是<code>call by reference</code>），也就是說元件對 <code>data</code> 操作時將會連帶影響到其他元件的數值。而解決辦法就是利用 Javascript 切割 scope 最小單位<code>function</code>來做封裝（如上面範例程式碼所示）。</p>
<p>以上章節是透過基本的<strong>元件註冊</strong>，將<strong>重複的程式碼</strong>包裝成元件，來達成<strong>可重複利用性更高</strong>的程式，而明天要介紹的部分則是在元件中設置元件的作法。</p>
<p>附上今日的黑黑元件以及橘橘元件<br><img src="https://ithelp.ithome.com.tw/upload/images/20190910/20119062caNJOFKmnT.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190910/20119062caNJOFKmnT.jpg"></p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190911/20119062t3y8rmF2D3.png" alt="https://ithelp.ithome.com.tw/upload/images/20190911/20119062t3y8rmF2D3.png"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 子元件 child component</title>
    <url>/vue.js/Vue-008-component-child/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="父子元件"><a href="#父子元件" class="headerlink" title="父子元件"></a>父子元件</h2><p>在某些情境下我們可能會在元件內使用大量重複的元素標籤以及內容，這個時候我們就可以把元件中的重複的內容再次元件化，並且作法同樣可以分為<strong>區域性</strong>與<strong>全域性</strong>。假設目前需求是把一個頁面拆分成 wrapper-header、wrapper-body 以及 wrapper-footer 元件並且在 wrapper-body 中還要再塞入其他元件：</p>
<p>在 HTML 部分要注意的地方是，HTML 在編譯的時候是<strong>不區分大小寫</strong>的，而在 JavaScript 中是<strong>無法使用<code>-</code>連字號來編寫</strong>，因此在格式上<a href="https://cn.vuejs.org/v2/style-guide/#%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99-%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90" target="_blank" rel="noopener">官方建議</a> HTML 部分採用 <code>kebab-case</code> 連字號命名法，而在 Vue.js 裡面採用<code>PascalCase</code>駝峰式命名法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wrapper-header</span>&gt;</span><span class="tag">&lt;/<span class="name">wrapper-header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wrapper-body</span>&gt;</span><span class="tag">&lt;/<span class="name">wrapper-body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wrapper-footer</span>&gt;</span><span class="tag">&lt;/<span class="name">wrapper-footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>在 JavaScript部分，區域性的作法是在 Vue.js 實體的 <code>components</code> 中使用 <code>Vue.extend</code> 去擴充元件，使得元件中物件除了可以回傳 <code>template</code> 之外，可以在裡面繼續使用 <code>components</code> 註冊一個新的元件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        WrapperHeader: Vue.extend(&#123;</span><br><span class="line">            template:<span class="string">'&lt;div&gt;Header&lt;/div&gt;'</span></span><br><span class="line">        &#125;),</span><br><span class="line">        WrapperBody: Vue.extend(&#123;</span><br><span class="line">            template:</span><br><span class="line">            <span class="string">'&lt;div&gt;'</span>+</span><br><span class="line">              <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">              <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">              <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">            <span class="string">'&lt;/div&gt;'</span>,</span><br><span class="line">            components:&#123;</span><br><span class="line">                wrapperInnerBody: Vue.extend(&#123;</span><br><span class="line">                    template: <span class="string">' &lt;div&gt;Body&lt;/div&gt; '</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">        WrapperFooter: Vue.extend(&#123;</span><br><span class="line">            template:<span class="string">'&lt;div&gt;Footer&lt;/div&gt;'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面這個作法是將元件以<strong>區域性</strong>的方法註冊，而這個方式會使得初始 Vue.js 的程式碼段落過長，如果每個元件都寫在裡頭，可能將來會不易管理，因此透過 ECMAScript 6 的物件縮寫（物件名稱與值相同時可省略值），將元件的部分挪到外頭，可使得程式碼更加的簡潔：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapperHeader = Vue.extend(&#123;</span><br><span class="line">    template:<span class="string">'&lt;div&gt;Header&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapperBody = Vue.extend(&#123;</span><br><span class="line">    template:</span><br><span class="line">    <span class="string">'&lt;div&gt;'</span>+</span><br><span class="line">        <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">        <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">        <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">    <span class="string">'&lt;/div&gt;'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        wrapperInnerBody: Vue.extend(&#123;</span><br><span class="line">            template: <span class="string">' &lt;div&gt;Body&lt;/div&gt; '</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapperFooter = Vue.extend(&#123;</span><br><span class="line">    template:<span class="string">'&lt;div&gt;Footer&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        wrapperHeader,</span><br><span class="line">        wrapperBody,</span><br><span class="line">        wrapperFooter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但這樣的作法依然是屬於<strong>區域性</strong>的，也就是只有在初始化 Vue.js 的變數 <code>vm</code> 中才能使用，而如果要讓元件變成是全域性的話，同樣可以使用 <code>Vue.component</code> 進行封裝：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapperHeader = Vue.extend(&#123;</span><br><span class="line">    template:<span class="string">'&lt;div&gt;Header&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapperBody = Vue.extend(&#123;</span><br><span class="line">    template:</span><br><span class="line">    <span class="string">'&lt;div&gt;'</span>+</span><br><span class="line">        <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">        <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">        <span class="string">'&lt;wrapper-innerBody&gt;&lt;/wrapper-innerBody&gt;'</span>+</span><br><span class="line">    <span class="string">'&lt;/div&gt;'</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        wrapperInnerBody: Vue.extend(&#123;</span><br><span class="line">            template: <span class="string">' &lt;div&gt;Body&lt;/div&gt; '</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapperFooter = Vue.extend(&#123;</span><br><span class="line">    template:<span class="string">'&lt;div&gt;Footer&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'wrapper-header'</span>,wrapperHeader)</span><br><span class="line">Vue.component(<span class="string">'wrapper-body'</span>,wrapperBody)</span><br><span class="line">Vue.component(<span class="string">'wrapper-footer'</span>,wrapperFooter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app1'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app2'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如此一來不論是 <code>vm1</code> 或是 <code>vm2</code> 的 Vue.js 實體都可以使用這些元件之外，被註冊的元件中還能再使用其他的元件。</p>
<p>今天這個章節除了複習元件註冊方式並製作多個元件之外，還將子元件擴充進去元件當中，也示範了子元件區域性與全域性的作法，而下個章節，我們將會學習到如何把元件中 <code>template</code> 部分抽取成一個 script 成為樣板，來大大地增加程式碼可重複利用性。</p>
<p>隨文附上一直想出門溜溜的阿橘一枚：<br><img src="https://ithelp.ithome.com.tw/upload/images/20190911/20119062TWW83vTNvO.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190911/20119062TWW83vTNvO.jpg"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 元件樣板 template</title>
    <url>/vue.js/Vue-009-template/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>前幾章花了一點時間在介紹元件的註冊方式與用法，除了能夠建立一個元件並使用對應的 <code>&lt;tag&gt;</code> 標籤建立在網頁上，也能將元件塞入其他元件當中成為他的子元件。</p>
<p>然而，對於真正顯示的內容，最主要還是得依靠 <code>template</code> 所產生，回顧一下之前<a href="https://ithelp.ithome.com.tw/articles/10214359" target="_blank" rel="noopener">生命週期</a>的章節會發現到，Vue.js 的生命週期中，會有一段過程檢查實體中是否有包含 <code>template</code> 的選項：</p>
<ul>
<li>若有 <code>template</code> 的情況：最後會使用 <code>render function</code>去編譯裡面的內容到網頁上。</li>
<li>若沒有 <code>template</code> 的情況：則是會使用綁定 <code>el</code> 元素的 <code>outerHTML</code>來做為編譯範圍。</li>
</ul>
<p>其中 <code>template</code> 指的就是元件樣板的部分，我們可以透過不同的封裝方式來管理內容，例如使用 <code>HTML</code> 標籤來進行封裝：</p>
<a id="more"></a>

<h2 id="HTML標籤封裝"><a href="#HTML標籤封裝" class="headerlink" title="HTML標籤封裝"></a>HTML標籤封裝</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">    template:<span class="string">'&lt;div&gt;HTML封裝方式&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>作法是直接在 <code>template</code> 中以 <code>HTML</code> 字串方式直接編寫，但是內容一多的時候將會變成非常長一條，不易於閱讀，而所幸在 JavaScript ES6 中我們可以透過<strong>模版字符串（template literal）</strong>的方式去書寫，透過<strong>反引號</strong>快速解決這個難處：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">    template:`</span><br><span class="line">    <span class="symbol">&lt;div&gt;</span></span><br><span class="line">        <span class="symbol">&lt;h1&gt;</span>HTML封裝方式&lt;/h1&gt;</span><br><span class="line">        <span class="symbol">&lt;div&gt;</span>ES6 讓這種方式變得更容易閱讀了！&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;`</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="inline-template"><a href="#inline-template" class="headerlink" title="inline-template"></a>inline-template</h2><p>這種封裝方式，則是在編寫樣板的時候直接在元件上加上 <code>inline-template</code> 屬性，它的效果是能夠讓 Vue.js 認為其元件標籤內的內容是元件的樣板（原先預設元件標籤內的值都不會渲染出來）：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;thumb-slider inline-template&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"thumb-wrapper"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"title"</span>&gt; ... &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/thumb-slider&gt;</span><br></pre></td></tr></table></figure>

<p>使用這種封裝方式的好處是在渲染時由於是直接寫在 HTML 當中，因此在頁面載入的過程中就會出現在頁面上，而不用等到 JavaScript 執行到才編譯元件內容。</p>
<h2 id="x-template"><a href="#x-template" class="headerlink" title="x-template"></a>x-template</h2><p><code>x-template</code>的封裝方式，則是可以將整段樣板抽取出來，以另一個 <code>script</code> 標籤作為樣板來管理，使用方法僅需要另外加入一個<code>script</code>標籤，並且將其 <code>type</code> 屬性定義為 <code>x-template</code> ， id 的部分則對應到 Vue.js 實體中的 <code>template</code> 即可：</p>
<p>x-template 部分</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/x-template"</span> <span class="symbol">id</span>=<span class="string">"my-component"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt; <span class="comment">// 最外層只能由單個元素包裝</span></span><br><span class="line">        &lt;<span class="keyword">div</span>&gt;<span class="symbol">x</span>-template封裝法&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span>&gt;<span class="symbol">x</span>-template封裝法&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>Vue.js 實體部分</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line"><span class="actionscript">        template:<span class="string">'#my-component'</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是在使用 <code>x-template</code> 方法封裝時，最外層必須只能使用單個元素來做包裝，否則最後將會只渲染出第一個元素，這一點跟 React.js 的 JSX 概念是一樣的。</strong></p>
<h2 id="Render-function"><a href="#Render-function" class="headerlink" title="Render function"></a>Render function</h2><p>最後這一種方式則是原先 Vue.js 在編譯所做的事情，意思就如同我們平常在使用<code>template</code>時，主要是依靠 Vue.js 去幫我們做編譯，但今天如果我們想要自己寫更多 JavaScript 的內容去管理時，就可以透過這種封裝方式來編寫樣板，而範例程式碼如下：</p>
<p>Render function 作法：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">(createElement)</span>&#123;</span></span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">'div'</span>,<span class="string">'內容'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>原本 template 作法：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">    template:<span class="string">'&lt;div&gt;內容&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>透過 Render function 的作法，我們可以藉由返回一個樣板物件來建立一個樣板，而樣板物件寫法好處是可以寫更加詳細的內容去編譯，而不是只是透過 Vue.js 幫我們包裝好的方法去開發，但相對難處便是在於實在太過抽象，元件內容一多，編寫 render function 將會十分困難。</p>
<hr>
<p>以上便是 template 的一些常見封裝方式，而除了以上這幾種方式之外，還有一種常見的是單一文件檔（.vue檔），而這種封裝方式到時候會在 Vue-cli 的章節一併解說。至於封裝方式的選用到底用哪種，最後決定權還是要看專案上實際上的需求來選用可能會好一點！</p>
<p>明天的部分將會看到 Vue.js 對於元件溝通的核心概念，以及 Vue.js 元件之間到底要怎麼溝通，就讓我們一起繼續努力撐到最後吧！</p>
<p>附上一起陪我撐到很晚的黑黑一枚<br><img src="https://ithelp.ithome.com.tw/upload/images/20190912/20119062DGAD832DiF.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190912/20119062DGAD832DiF.jpg"><br>黑黑：我幫你暖好被了，快來睡吧~</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 元件傳遞 props</title>
    <url>/vue.js/Vue-010-props/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="單向資料流"><a href="#單向資料流" class="headerlink" title="單向資料流"></a>單向資料流</h2><p>前面章節大部分的範例都是取用元件自己本身的 data 來操作的，而實際開發時的元件最主要是用來當作一個可重複利用的樣板，裡面即使有 data 的存在，可能大部分也是用於預設值的初始化，更多時候子元件所接收到的資料，會來自於父元件所傳遞的。</p>
<p>而在傳遞資料時要遵守單向資料流的規定，意思是我們只能透過<strong>父元件傳遞資料給子元件</strong>，子元件並不能<strong>直接傳遞資料給父元件</strong>，這樣做的原因是當今天很有多子元件依賴父元件某項資料物件時，如果每個子元件都可以任意更改父元件的資料時，就容易造成牽一髮而動全身的行為，因此這種行為是被禁止。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190913/20119062xmubDbCYt5.png" alt="https://ithelp.ithome.com.tw/upload/images/20190913/20119062xmubDbCYt5.png"></p>
<a id="more"></a>

<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>在傳遞資料時，我們可以使用元件內的 <code>props</code> 選項來指定傳遞的資料名稱，如下面範例中，我們在子元件 <code>props</code> 中指定了元件外面可以傳遞給他的資料為 <code>childmsg</code> ，並在 <code>template</code> 中將傳遞進來的資料當作數值，分別放入樣板語法與 v-model 中以供顯示。</p>
<p>子元件 的部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">"child-component"</span>, &#123;</span><br><span class="line">    template:</span><br><span class="line">        <span class="string">'&lt;div&gt;&#123;&#123; childmsg &#125;&#125; &lt;br&gt;&lt;input type="text" v-model="childmsg"&gt;&lt;/div&gt;'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        childmsg: <span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>父元件 Vue.js 實體的部分：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">let vm = new Vue(&#123;</span><br><span class="line"><span class="symbol">    el:</span> <span class="string">"#app"</span>,</span><br><span class="line"><span class="symbol">    data:</span> &#123;</span><br><span class="line"><span class="symbol">        parentmsg:</span> <span class="string">"父元件資料"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>而在 HTML 部分中，我們跟之前章節一樣，使用已經註冊好的子元件標籤 <code>child-component</code>，並且在子元件的屬性中透過 <code>v-bind</code> (縮寫<code>:</code>)綁定來自於父元件本身的資料 <code>parentmsg</code>，接著子元件就能透過這種方法來得到傳遞的對象來源，假如今天是要傳入不同的資料，我們只要將 <code>:childmsg-message=&quot;parentmsg&quot;</code> 中的 <code>parentmsg</code> 更改為其他資料來源即可。</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>父元件：<span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="template-variable">&#123;&#123; parentmsg &#125;&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"parentmsg"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>子元件：</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">child-component</span> <span class="attr">:childmsg</span>=<span class="string">"parentmsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/ShawnLin0201/pen/WNeyZqV" target="_blank" rel="noopener">點我看線上範例</a></p>
<h1 id="props-型別檢查"><a href="#props-型別檢查" class="headerlink" title="props 型別檢查"></a>props 型別檢查</h1><p>而在實際在工作上實作時，我們有可能會遇到<code>components</code>的部分是由 teammate 所撰寫的，因此在接手專案時，對於 <code>components</code> 的 <code>props</code> 型別檢查就特別重要，我們可以在 <code>props</code> 設定傳送資料時一起寫入一些設定，範例如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.component</span>(<span class="string">'my-component'</span>,&#123;</span><br><span class="line">    <span class="attribute">props</span>: &#123;</span><br><span class="line">        <span class="attribute">parentMsg</span>: null,  <span class="comment">// 表示傳遞進來的類別沒有限制</span></span><br><span class="line">        <span class="attribute">parentMsgA</span>: Number,<span class="comment">// 表示傳遞進來的類別須為數字類型</span></span><br><span class="line">        <span class="attribute">parentMsgB</span>: [String, Number], <span class="comment">// 表示傳遞進來的類別可以是字串或數字</span></span><br><span class="line">        <span class="attribute">parentMsgC</span>: &#123;</span><br><span class="line">            <span class="attribute">type</span>: String, </span><br><span class="line">            <span class="attribute">required</span>: true, <span class="comment">// 表示使用這個元件時一定要有 `parentMsgC` 參數，否則會報錯</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attribute">parentMsgD</span>: &#123;</span><br><span class="line">            <span class="attribute">type</span>: Number, </span><br><span class="line">            <span class="attribute">default</span>: <span class="number">100</span> <span class="comment">// 表示如果沒有給予這個參數，則預設會顯示的資料為 100</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attribute">parentMsgE</span>: &#123;</span><br><span class="line">            <span class="attribute">type</span>: Object,</span><br><span class="line">            <span class="attribute">default</span>: function()&#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    <span class="attribute">message </span>: <span class="string">'Hello Vue!'</span> <span class="comment">// 我們也可以透過傳送參數來返回一個資料物件</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attribute">parentMsgF</span>: &#123;</span><br><span class="line">            <span class="attribute">validator</span>: function(value)&#123;</span><br><span class="line">                return value &gt; <span class="number">100</span> <span class="comment">// 我們也可以自己撰寫一個驗證器，來看傳進來的資料是否有符合條件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上是介紹父元件傳遞給子元件資料的方法，以及如何透過 <code>props</code> 的型別檢查來限制我們傳進去的資料，有效提升子元件不會被濫用的情況。而明天的章節，我們將會說明子元件如果真的想要傳遞資料給父元件時，我們可以透過什麼方式來執行？</p>
<p>阿橘在這裡也祝大家中秋佳節愉快<br><img src="https://ithelp.ithome.com.tw/upload/images/20190913/20119062H4W48vp757.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190913/20119062H4W48vp757.jpg"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 動態元件 Dynamic component</title>
    <url>/vue.js/Vue-013-dynamic-component/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="Dynamic-component-動態元件"><a href="#Dynamic-component-動態元件" class="headerlink" title="Dynamic component 動態元件"></a>Dynamic component 動態元件</h2><p>在某些情境下的專案中可能會需要透過標籤來切換頁面，可能第一個想到的會是使用 <code>v-if</code> 或是 <code>v-show</code> 的方式去顯示，並且透過在標籤上綁定資料物件來顯示內容：</p>
<p>在 HTML 部分，我們可能會使用<code>v-on</code>（縮寫<code>@</code>）去綁定 <code>click</code> 事件，透過點擊事件來更動 <code>data</code> 裡的資料（<code>pagename</code>）：</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'mainpage'"</span>&gt;</span>switch to Main page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接著在要顯示頁面的元件中掛上<code>v-if</code>來限定顯示的條件，如 <code>pagename</code> 的值是 <code>mainpage</code> 時就會顯示該元素，藉此來達到如切換分頁的效果，並且重複以上動作將各個顯示頁面用的元件加入如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'mainpage'"</span>&gt;</span>switch to Main page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'aboutpage'"</span>&gt;</span>switch to About page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'contactpage'"</span>&gt;</span>switch to Contact page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mainpage</span> <span class="attr">v-if</span>=<span class="string">"pagename === 'mainpage'"</span>&gt;</span><span class="tag">&lt;/<span class="name">mainpage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aboutpage</span> <span class="attr">v-if</span>=<span class="string">"pagename === 'aboutpage'"</span>&gt;</span><span class="tag">&lt;/<span class="name">aboutpage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contactpage</span> <span class="attr">v-if</span>=<span class="string">"pagename === 'contactpage'"</span>&gt;</span><span class="tag">&lt;/<span class="name">contactpage</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而 JavaScript部分除了基本的頁面內容樣板之外， 在 Vue.js 初始化的實體中則是在 <code>data</code> 中先放入一開始預設頁面值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'mainpage'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;This page is mainpage&lt;/div&gt;`</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'created mainpage'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed mainpage'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">'aboutpage'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;This page is aboutpage&lt;/div&gt;`</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'created aboutpage'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed aboutpage'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">'contactpage'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;This page is contactpage&lt;/div&gt;`</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'created contactpage'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed contactpage'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    pagename : <span class="string">'mainpage'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如此一來就能達成進入後顯示主要頁面，接著透過按鈕切換數值來驅動顯示不同的畫面。這樣的做法確實可以達到切換分頁的效果，但缺點在於一開始進入根目錄頁面時，DOM 就已經載入該元素了。</p>
<p>解決辦法是透過 Vue.js 所提供的 API (<code>:is</code>) 來達成同樣的效果，我們只需要放入一個名為<code>component</code>的標籤（ Vue.js 的內建元素 <code>Built-In Components</code>），並且透過 <code>:is</code> 來對應元件名稱，最後 Vue.js 就會依照<code>:is</code>的數值來決定被渲染的元件，HTML部分改寫後如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'mainpage'"</span>&gt;</span>switch to Main page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'aboutpage'"</span>&gt;</span>switch to About page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'contactpage'"</span>&gt;</span>switch to Contact page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"pagename"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>往後新增頁面時，只要將觸發更改頁面的按鈕、方法寫好，並且新增對應名稱的元件，即可快速做到更動頁面的效果，而同樣的方法也適用於快速切換小區域的元件內中（如表單等等），大家不彷一起嘗試看看這個 API 吧。</p>
<blockquote>
<p>橘橘也有周一病，一到周末晚上就各種厭世臉哈哈哈<br><img src="https://ithelp.ithome.com.tw/upload/images/20190916/20119062aZXueKQpKU.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190916/20119062aZXueKQpKU.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 元件傳遞 event bus</title>
    <url>/vue.js/Vue-012-event-bus/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>前面兩天提到的元件間的資料傳遞，主要是父元件對子元件的 <code>props</code> 以及子元件對於父元件的 <code>event</code> 發送，而最後留下一個問題是假如今天我們要子元件與子元件溝通，要怎麼做呢？</p>
<p>第一個最快想到的方法，可能是按照前面兩天提到的方法，不斷的往上傳遞到共同的父元件，再往下傳遞到想溝通的子元件當中，但這樣的做法會耗費太多心力，並且作了很多重複的動作、難以維護等等，而這些行為也是工程師不喜歡的<strong>壞味道</strong>，要知道未卜先知跟通靈以後要維護的東西可說是工程師的另一個價值 （？</p>
<p>而雖然第一個方法可以達成，但實在太搞剛（台）了，因此官方也直接列了第二個方法作為標準，那就是……</p>
<a id="more"></a>

<h2 id="event"><a href="#event" class="headerlink" title="event"></a>event</h2><p>而 <code>event</code> 實際上的用法如同公車一樣，當我們今天元件之間不是父子關係，而是多層元件關係時，都可以使用 <code>event</code> ，而 <code>event</code> 搭乘的乘客便是我們昨天提到的 <code>event</code>，只是今天我們<strong>發送與監聽的對象改 <code>event</code> 身上</strong>，而我們接下來以兩個平行的子元件之間的溝通來當作實作範例：</p>
<p>HTML 部分是兩個平行的元件<code>element-city1</code>與<code>element-city2</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element-city1</span>&gt;</span><span class="tag">&lt;/<span class="name">element-city1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element-city2</span>&gt;</span><span class="tag">&lt;/<span class="name">element-city2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript部分，<code>event</code> 既然要乘載我們 Vue.js 的功能，首先我們自然得先使用 <code>new</code> 去初始化一個 Vue 物件，使我們要乘載 <code>event</code> 的變數擁有 Vue 物件的屬性與功能：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bus = <span class="keyword">new</span> <span class="constructor">Vue()</span>;</span><br></pre></td></tr></table></figure>

<p>接著子元件 <code>element-city1</code> 以 <code>$emit</code> 發送事件而發送事件對象改為 <code>bus</code>：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'element-city1'</span>, &#123;</span><br><span class="line">  template:</span><br><span class="line">  `</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"submit"</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  `,</span></span><br><span class="line"><span class="xml">  methods:</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    submit()&#123;</span></span><br><span class="line"><span class="xquery">      bus.<span class="variable">$emit</span>(<span class="string">'receive'</span>, this.message)</span></span><br><span class="line"><span class="xquery">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  data()</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="xquery">      message : <span class="string">"this is city1's message"</span></span></span><br><span class="line"><span class="xquery">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>要接受資料的 <code>element-city2</code>，監聽對象也同樣改為<code>bus</code>：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'element-city2'</span>, &#123;</span><br><span class="line">  <span class="attribute">template</span>:<span class="string">`&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  created()&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">    bus.$<span class="keyword">on</span>(<span class="string">'receive'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">newMessage</span>)</span>&#123;</span><br><span class="line">      self.message = newMessage</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      <span class="attribute">message</span>: <span class="string">"this is city2's message"</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後同樣的要初始化一個最基本的根元件來當作 Vue.js 要渲染的範圍。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    tex<span class="variable">t:</span><span class="string">'Hello Vue!'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  method<span class="variable">s:</span>&#123;</span><br><span class="line">    handleOnClick : <span class="function"><span class="keyword">function</span><span class="params">(name)</span>&#123;</span></span><br><span class="line">      <span class="keyword">return</span> this.text = `Hello $&#123;name&#125;!`</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/ShawnLin0201/pen/OJLwpap" target="_blank" rel="noopener">點我看範例</a></p>
<p>如此一來，子元件 <code>element-city1</code> 便能將資料藉由發送給 <code>bus</code>，讓監聽著 <code>bus</code> 的子元件 <code>element-city2</code> 拿到他想要的資料，藉此達成子元件與子元件的溝通技術。</p>
<p><strong>而往後開發要注意的是</strong>，由於註冊與監聽事件都是在 <code>bus</code> 上，不同元件間註冊與監聽可能事件名稱會有<strong>撞名的問題</strong>，可以透過初始化另一台<code>bus</code>來稍微緩解這個問題。</p>
<p>今天介紹了子元件如何與子元件的做資料傳遞的溝通，接下來隨著 Vue.js 即將進入尾聲，因此要來介紹幾個 Vue.js 幾個也蠻重要的功能補充，祝大家周末愉快囉！</p>
<blockquote>
<p>今天依然是由黑黑擔任每日一貓的工作，因為弟弟阿橘正在梳毛中不開心哈哈哈。而最近剛好是換毛季，感覺梳下來的毛都可以拿去做貓毛氈了……<br><img src="https://ithelp.ithome.com.tw/upload/images/20190915/20119062QkffxkBKJg.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190915/20119062QkffxkBKJg.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 元件傳遞 event</title>
    <url>/vue.js/Vue-011-event/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>上一章節中，我們介紹了父元件如何透過 <code>props</code> 傳遞資料給子元件，並且使用<strong>型別設定</strong>來規範傳進元件中的值，而今天要來介紹<strong>子元件要如何傳遞資料給父元件</strong>。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190913/20119062xmubDbCYt5.png" alt="https://ithelp.ithome.com.tw/upload/images/20190913/20119062xmubDbCYt5.png"></p>
<p>昨天在解說這張圖的時候，有提到了一個單向資料流的概念，Vue.js 只允許我們透過 <code>props</code> 來傳遞資料給 子元件，為了避免一些不可預期更改導致最後不知道是哪個子元件去更改了父元件的資料，那麼如果子元件真的有需求，想要傳遞資料給父元件的話，官方給了一個作法是 <code>emit event</code> 發送事件。</p>
<p>透過子元件發送事件給父元件，父元件的部分可以藉由<strong>監聽</strong>這個任務事件，去觸發相對應的行為，而藉由這個做法，就可以達成類似於<strong>子元件傳遞資料給父元件</strong>的行為，並且<strong>仍然是單向資料流的行為</strong>，而實際上要怎麼來發送事件以及監聽事件就一起來看看下面的範例：</p>
<blockquote>
<p>這個範例中我們將會跟上一章節一樣，做一個父元件可以將資料傳遞給子元件的表單，但不一樣的事情是我們將會在子元件中新增一個按鈕，藉由<strong>點擊按鈕</strong>來觸發<strong>將我們輸入在子元件的內容資料傳遞給父元件</strong>。</p>
</blockquote>
<a id="more"></a>

<p>在 HTML 的部分，我們一樣先建立一個基礎的版型，：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>父元件：<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        &#123;&#123; message &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>子元件：</span><br><span class="line">        <span class="tag">&lt;<span class="name">child-component</span> <span class="attr">:parent-message</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 也是一樣建立一個基本的實體：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">    dat<span class="variable">a:</span>&#123;</span><br><span class="line">        message : <span class="string">'父元件資料'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'child-component'</span>,&#123;</span><br><span class="line">    template:`</span><br><span class="line"><span class="symbol">&lt;div&gt;</span> &#123;&#123; parentMessage &#125;&#125; <span class="symbol">&lt;br&gt;</span></span><br><span class="line">  &lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"parentMessage"</span>&gt;</span><br><span class="line">  &lt;button <span class="built_in">type</span>=<span class="string">"button"</span>&gt;Update&lt;/button&gt;&lt;/div&gt;`,</span><br><span class="line">    prop<span class="variable">s:</span>&#123;</span><br><span class="line">        parentMessage: String</span><br><span class="line">    &#125;,</span><br><span class="line">    dat<span class="variable">a:</span> <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            message : this.parentMessage</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>現在我們已經擁有了父元件可以傳資料給子元件，並且子元件同樣只能更改屬於自己資料的表單，接下來我們要撰寫的部分是在按鈕點擊的時候要發送事件，而發送事件的行為我們同樣是將函式寫在 <code>methods</code> 當中，只是我要註冊的對象我們可以透過 <code>this.$parent</code> 來捕捉，並藉由 <code>$emit</code> 來發送行為。</p>
<p>而 <code>$emit</code> 函式使用方法是在第一個傳送參數中，填入要觸發方法的名稱，就像是告訴對方說我要做什麼事情：而第二個傳送參數則是傳入想要給予對方什麼樣的內容。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-component'</span>,&#123;</span><br><span class="line">    template:`</span><br><span class="line"><span class="symbol">&lt;div&gt;</span> &#123;&#123; parentMessage &#125;&#125; <span class="symbol">&lt;br&gt;</span></span><br><span class="line">  &lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"parentMessage"</span>&gt;</span><br><span class="line">  &lt;button <span class="built_in">type</span>=<span class="string">"button"</span> @click=<span class="string">"updateText"</span>&gt;Update&lt;/button&gt;&lt;/div&gt;`,</span><br><span class="line">    prop<span class="variable">s:</span>&#123;</span><br><span class="line">        parentMessage: String</span><br><span class="line">    &#125;,</span><br><span class="line">    dat<span class="variable">a:</span> <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            message : this.parentMessage</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    method<span class="variable">s:</span>&#123;</span><br><span class="line">      updateTex<span class="variable">t:</span> <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        this.$parent.$emit(<span class="string">'update'</span>,this.parentMessage)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>將上方的範例更改之後，現在的子元件 <code>child-component</code> 已經可以發送給父元件一個 <code>update</code> 事件，並且將要傳遞的資料 <code>this.parentMessage</code> 傳送給父元件。</p>
<p>接著在父元件的部分，我們則是要註冊一個監聽事件，用來監聽其他人發送給他的事件，而本次監聽的方法，我們寫在父元件實體中的 <code>mounted</code> 生命週期鉤子中，透過 <code>$on</code>這個方法來監聽目標的事件，同樣的第一個傳送參數是<strong>我們要監聽的事件名稱</strong>，第二個則是監聽到這個事件的時候，元件要選擇做什麼事情；而這裡我們是選擇監聽到這個事件之後，我們要去觸發 <code>selfUpdate</code> 的這個函式，這個函式將會將元件自己的資料，賦與傳遞進來的值。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message : <span class="string">'父元件資料'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      selfUpdate(<span class="keyword">value</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = <span class="keyword">value</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$<span class="keyword">on</span>(<span class="string">'update'</span>, <span class="keyword">this</span>.selfUpdate)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/ShawnLin0201/pen/MWgBWpe" target="_blank" rel="noopener">範例連結請點我！</a></p>
<p>透過這個方式大家可以很明顯地看到，<strong>子元件其實並沒有真正直接傳遞資料給父元件</strong>，而是雙方<strong>各自註冊了事件去溝通要傳遞什麼資料</strong>，如此一來父元件最後更新的掌握權利還是<strong>保留在自己</strong>身上，若是子元件自己單獨想要發送資料給父元件的話，是同樣無法使父元件觸發行為的，且最後要不要將傳遞資料更動到自己本身的資料上也是由父元件自己所掌握，這樣能使得傳遞的資料來源流向更加的清晰，也解決子元件想要傳遞給父元件資料的這個問題。</p>
<p>而到目前為止，我們已經學會了父元件傳遞資料給子元件的方法，也學會了子元件傳遞給父元件的正確知識<del>姿勢</del>，但事情總不會這麼簡單就結束！假如今天我們是要將子元件傳遞給另外一個子元件的時候，我們可以怎麼做呢？這邊就留個謎底給大家想想，明天我們將會公布解答！</p>
<blockquote>
<p>隨文小故事<br>最近發現黑黑好像對於自己是黑色的貓這件事情感到很無奈，時常發現他有的時候會照著鏡子發呆，難道他想要變成白貓嗎？<br>黑黑：我很黑我也很無奈好嗎<br><img src="https://ithelp.ithome.com.tw/upload/images/20190914/20119062vxXds9RVWs.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190914/20119062vxXds9RVWs.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 介紹與環境建置</title>
    <url>/vue.js/Vue-cli-001-build/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h2><p>當我們終於熟悉 Vue.js 的一些基本用法後，專案上可能會要使用 webpack 來建立專案，而今天要來介紹的 Vue-cli ，主要是提供開發者一個快速建置 Vue.js 架構的工具，並基於 webpack，提供了許多相關的功能、套件安裝協助。而這裡建議使用 Vue-cli 前可以稍微瞭解 Vue.js 一些基本的指令以及元件概念基礎，並且要有不怕操作基本終端機指令的一顆心。</p>
<a id="more"></a>

<h2 id="環境建置"><a href="#環境建置" class="headerlink" title="環境建置"></a>環境建置</h2><p>要下載 Vue-cli 之前，我們會需要透過 NPM 套件管理工具來下載，而 NPM 在下載 Node.js 時就會一併包進去了，雖然安裝 Node.js 比較好的方式是依靠 NVM 來管理 Node.js 版本，但如此一來我們就要使用 NVM 來下載 Node.js，再來檢查有沒有一併安裝好 NPM 後，最後才能用 NPM 來下載 Vue-cli。（好饒口）</p>
<p>但如果大家真的只是在家體驗玩看看的話，其實也不彷直接載 Node.js 就是了。</p>
<p>首先，我們到 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> 官方網站下載 Node.js，接著打開這個黑色的視窗，window 系統叫他<strong>命令提示字元（cmd）</strong>，而 Mac 電腦要找到他則可搜尋<strong>終端機（Terminal）</strong>。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191003/20119062P4LfYSn7rD.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191003/20119062P4LfYSn7rD.jpg"></p>
<p>打開它之後會看到全黑的視窗，以 Windows 系統的為例會看到這個：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191003/20119062KSvKqPCe8s.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191003/20119062KSvKqPCe8s.jpg"></p>
<p>接著在裡面輸入<code>node -v</code>，如果有出現 Node.js 版本號表示有下載到 Node.js：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> node <span class="literal">-v</span></span><br></pre></td></tr></table></figure>

<p>NPM 的部分同樣可以輸入 <code>npm -v</code> 來查詢：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npm <span class="literal">-v</span></span><br></pre></td></tr></table></figure>

<p>確認同樣有跳出版本號後，我們就可以來使用 NPM 來下載 Vue-cli 啦！而這裡 Windows 系統與 Mac 會略有一點差別：</p>
<p>Windows 在 cmd 中直接輸入 <code>npm install -g @vue/cli</code> 來下載，<code>npm install @vue/cli</code> 表示藉由 npm 來下載 <code>@vue/cli</code>，而 <code>-g</code> 則表示此套件將會下載到全域環境之中，也就是說接下來你在任何資料夾路徑中都可以使用這個套件。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npm install <span class="literal">-g</span> @vue/cli</span><br></pre></td></tr></table></figure>


<p>Mac 用戶下載全域(<code>global</code>)套件的部分會受到一些限制，第一個是需要在指令前面多加 <code>sudo</code> 來執行，並且會要求你提供 Mac 帳戶密碼，如果帳戶沒設置密碼的話會沒辦法使用，因此得替帳戶設定一組密碼：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> sudo npm install <span class="literal">-g</span> @vue/cli</span><br></pre></td></tr></table></figure>

<p>安裝完畢之後，可以輸入指令來確認 Vue-cli 是否有安裝成功：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> vue -<span class="literal">-version</span></span><br></pre></td></tr></table></figure>

<p>下載完成後，若是熟悉終端機指令的朋友可以下面方案一的方式創建，若不熟悉終端機操作的人，Vue-cli 也很貼心地推出介面的管理方式，可以參考底下方案二的方式管理（但我還是推薦大家可以多熟悉終端機指令啦 XD）。</p>
<h2 id="方案一-終端機"><a href="#方案一-終端機" class="headerlink" title="方案一 終端機"></a>方案一 終端機</h2><p>將終端機切換到存放管理的資料夾執行指令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> vue create *你的專案名稱*</span><br></pre></td></tr></table></figure>

<p>接著他會顯示要安裝哪種預設套裝，默認 <code>default</code> 設定可以快速建立一個基本原型，而實際專案較常會使用下方的手動設定 <code>Manually</code> 來調整想要使用的內容，如官網圖所示：</p>
<blockquote>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191003/20119062NIJtU0zTOl.png" alt="https://ithelp.ithome.com.tw/upload/images/20191003/20119062NIJtU0zTOl.png"></p>
</blockquote>
<p>而手動設定的部分我一般是選用 Router、Vuex、CSS Pre-processors 以及 Linter。</p>
<h2 id="方案二-介面安裝法"><a href="#方案二-介面安裝法" class="headerlink" title="方案二 介面安裝法"></a>方案二 介面安裝法</h2><p>雖然 Vue-cli 幫大家做了一個介面來管理，但第一行還是要請大家到終端機去輸入指令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> vue ui</span><br></pre></td></tr></table></figure>

<p>這樣一來他就會開啟一個瀏覽器頁面來幫助建立專案的流程，最後一樣會建立一個以你專案名稱為名字的資料夾。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191003/201190621ygmc1dhMd.png" alt="https://ithelp.ithome.com.tw/upload/images/20191003/201190621ygmc1dhMd.png"></p>
<p>設定完畢啟動後，我們透過終端機 <code>cd</code> 指令切換到我們的專案資料夾中，再使用 <code>npm run serve</code> 來啟用本地伺服器：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cd <span class="string">'你的專案夾名稱'</span></span><br><span class="line"><span class="variable">$</span> npm run serve</span><br></pre></td></tr></table></figure>

<p>最後啟動後將可以看到 Vue.js 大大的 LOGO 以及 <code>Welcome to Your Vue.js App</code> 字樣出現在網頁上了。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191003/20119062AgkG8fqvm2.png" alt="https://ithelp.ithome.com.tw/upload/images/20191003/20119062AgkG8fqvm2.png"></p>
<h2 id="結構目錄"><a href="#結構目錄" class="headerlink" title="結構目錄"></a>結構目錄</h2><p>在專案資料夾被創立之後，Vue-cli 會在裡面建立一些預設檔案，而產生的目錄如下，可以先稍微了解大概檔案的目的是什麼：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">├── dist/               // 使用 npm run build 會在此處建立一個靜態檔案</span><br><span class="line">├── node_modules/       // 使用 npm 下載管理的模組會集中在此</span><br><span class="line">├── public/             // 放在此處的公共檔案可以使用絕對路徑取得，並且不會經過編譯壓縮處理</span><br><span class="line">│   ├── favicon.ico     // 範例用的圖片檔</span><br><span class="line">│   └── index.html      // 網站入口</span><br><span class="line">├── src/                // 前端開發的原始檔案，基本上要寫的程式都是放在此處</span><br><span class="line">│   ├── assets/         // 放在此處的公共檔案可以使用相對路徑取得，並且會經過編譯壓縮處理</span><br><span class="line">│   ├── components/     // Vue 元件檔案</span><br><span class="line">│   ├── views/          // Vue rounter 頁面檔案</span><br><span class="line">│   ├── App.vue         // Vue 專案的進入點</span><br><span class="line">│   ├── main.js         // Vue 專案的設定檔</span><br><span class="line">│   ├── router.js       // Vue rounter設定</span><br><span class="line">│   └── store.js        // Vuex設定</span><br><span class="line">├── .gitignore          // git 設定檔案</span><br><span class="line">├── package.json        // npm 產生的專案文件</span><br><span class="line">└── vue.config.js       // Vue 設定文件 ( 需手動建立 )</span><br></pre></td></tr></table></figure>

<blockquote>
<p>環境建置的章節就到這裡結束囉，下一章會來介紹一下 Vue-cli 裡面的 .vue 檔案究竟是什麼東西？<br><img src="https://ithelp.ithome.com.tw/upload/images/20191003/20119062S6FmV59sIA.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191003/20119062S6FmV59sIA.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 單一元件檔 （.vue 檔）</title>
    <url>/vue.js/Vue-cli-002-vue-file/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="單一元件檔"><a href="#單一元件檔" class="headerlink" title="單一元件檔"></a>單一元件檔</h2><p>今天要來介紹的是<strong>單一元件檔</strong>，單一元件檔在 Vue-cli 中被大量地使用，算是寫 Vue-cli 不可不知的一環，而在昨天我們安裝好 Vue-cli 環境後，可以看見 src 資料夾底下充滿著大量 .vue 結尾的檔案，大家或許會滿臉疑惑，因為前一兩周寫 Vue.js 根本沒有提到這個東西啊？那他到底是什麼呢？</p>
<a id="more"></a>

<p><img src="https://ithelp.ithome.com.tw/upload/images/20191004/20119062Z2qnzMoZH6.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191004/20119062Z2qnzMoZH6.jpg"></p>
<p>其實顧名思義，單一元件檔（single-file-component）就是一個元件專屬的檔案，還記得我們當時使用  <code>Vue.component</code> 建立了一個全域環境的元件嗎？單一元件檔就好比把該元件所需的資訊封裝成一種檔案格式，透過 <code>import</code> 註冊到其他的檔案當中，最後以工具解析後，產生網頁能夠讀懂的相關靜態檔案（如 HTML、CSS、JavaScript 等等。）那他跟我們寫得全域性註冊元件差在哪呢？</p>
<p>當我們以 Vue.component 註冊元件會遇到的問題：</p>
<ul>
<li>以全域性註冊的元件，<strong>元件名稱不能重複使用</strong>。</li>
<li>樣板字面值在文字編輯器中一般情況都是<strong>沒有語法顏色提醒輔助</strong>，需要自行下載額外工具。</li>
<li>在元件當中通常<strong>沒有區塊能夠讓元件單獨使用 CSS 的地方</strong>。</li>
<li>沒有建立環境的步驟，因此需要預處理器的協助時通常會有一定難度。</li>
</ul>
<p>而在使用了單一元件檔之後：</p>
<ul>
<li>即使在不同資料夾中元件名稱一樣，仍可<strong>透過 import 時指定元件名稱</strong>來引入。</li>
<li>單一元件檔<strong>提供各種語法顏色輔助提醒</strong>，在編寫程式時可以容易分辨樣板字面值的區塊（template）。</li>
<li>單一元件檔提供撰寫 CSS 的地方，並且<strong>支援 SCSS 等預處理器</strong>，讓你可以<strong>直接在檔案中撰寫 SCSS</strong>，經由熱處理直接在運行的網頁上立刻看到更改後的結果，另外還能封裝成限定該元件區域使用，不會汙染全域環境。</li>
<li>Vue-cli <strong>基於 webpack</strong>，要引入各種工具都十分方便。</li>
</ul>
<p>除了以上使用單一元件檔後的差別，最重要是更能體現<strong>關注點分離</strong>的部分：</p>
<h2 id="關注點分離"><a href="#關注點分離" class="headerlink" title="關注點分離"></a>關注點分離</h2><p>在之前程式開發時，關注點分離可能指的像是 HTML、CSS 以及 JavaScript 的檔案類型要分離的很乾淨，各司其職彼此井水不犯河水，不要在 HTML 裡面看到 inline 版本的 CSS 或是 JavaScript，而在 JavaScript 裡面可能不要去寫到 HTML 或是去定義樣式等等，然而近代前端開發的思維已逐漸邁向另一種<strong>元件化</strong>的思維。</p>
<p>元件化的思維，最主要的想法是在於要盡可能的<strong>把重複性高的程式碼，包裝成一個可重複利用的元件</strong>，並且裡面的樣式與功能可能都大同小異，差異在於帶進去的數值不同，因此返回不同的結果。以前端開發為例，可能就像是將每頁都會固定用到的 Navbar 區塊寫成一個可重複利用的檔案，以 HTML 定義好結構，用 CSS 替元件修飾一下外觀，最後用 JavaScirpt 提供更多元的功能等等；因此 HTML、CSS 與 JavaSciprt 基本上都會混和在一起。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>而說了這麼多，單一元件檔到底要怎麼用呢？我們點開 Vue-cli 中的範例檔案 Hello.vue，可以看見該檔案中分成三個區塊，分別為 <code>template</code>、<code>script</code> 和 <code>style</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>template</strong> 區塊，如同之前我們寫元件時的 template 一樣，這裡主要是放置 HTML 結構與 Vue 指令、樣板指令的地點。</p>
<p><strong>script</strong> 區塊，則是以往我們寫 JavaScript 的地方，而單一元件檔則是透過 export 指令匯出，使我們可以在其他元件檔中以 import 方式引入該元件。</p>
<p><strong>style</strong> 區塊，這個地方是最令我開心的地方，因為我們將可以在這邊直接編寫如 SCSS 等 CSS 預處理器等工具，只要我們在安裝 Vue-cli 時有指定要選用這個選項即可無痛快速使用！</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191004/20119062l0e3DH9v5z.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191004/20119062l0e3DH9v5z.jpg"></p>
<blockquote>
<p>而實務上要怎麼應運這些區塊呢，明天我們將直接開發一個專案來當作範例！<br><img src="https://ithelp.ithome.com.tw/upload/images/20191004/20119062Pcn7QO96UM.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191004/20119062Pcn7QO96UM.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 單一元件檔（ 以 iT 邦幫忙鐵人賽檔案當作開發範例）</title>
    <url>/vue.js/Vue-cli-003-vue-file-sample-1/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>今天要來以 iT 邦幫忙的鐵人賽檔案當作開發範例啦！</p>
<p>首先我們先來看看<strong>正版</strong>的鐵人賽檔案長什麼樣子：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/201190626f3Cl5S3qh.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/201190626f3Cl5S3qh.jpg"></p>
<p>忽略左上角之後，我們可以看到下方的這個區塊非常適合來開發成一個元件，而這個元件要考慮到哪些地方呢？假如今天大雄有參與<strong>不同年度的鐵人賽</strong>，並且又報名<strong>不同組別</strong>等等，加上文章本身就會有<strong>標題</strong>、<strong>鐵人是否練成</strong>、<strong>發了幾篇文章</strong>、<strong>有多少人訂閱</strong>等等，有許多控制項目可以玩，我們挑選其中幾個項目之後，在這裡發揮我們工程師的技能</p>
<a id="more"></a>

<h3 id="通靈"><a href="#通靈" class="headerlink" title="通靈!!!!!!"></a>通靈!!!!!!</h3><p>於是經過通靈之後，我們拿到了鐵人賽的 json 檔案格式：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/201190628yNCgj9k6B.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/201190628yNCgj9k6B.jpg"></p>
<p>好吧，其實是經過通靈之後，按我認為可能會拿到的 json 檔案格式（？</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    irontitle: "第 11 屆 iT 邦幫忙鐵人賽",</span><br><span class="line">    articles: [</span><br><span class="line">      &#123;</span><br><span class="line">        type: "Modern Web",</span><br><span class="line">        title:</span><br><span class="line">          "「小孩才做選擇，我全都要。」小白也能輕鬆瞭解的 Vue.js 與 D3.js 。",</span><br><span class="line">        href:</span><br><span class="line">          "https://ithelp.ithome.com.tw/users/20119062/ironman/2242",</span><br><span class="line">        info: &#123;</span><br><span class="line">          success: true,</span><br><span class="line">          count: 32,</span><br><span class="line">          subscribe: 39</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>接下來我們就可以拿著這份檔案，把他塞進我們的 .vue 檔之中，假裝他是 AJAX 下來的資料：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">"articleBoard"</span>,</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      json: &#123;</span><br><span class="line"><span class="actionscript">          <span class="comment">// 把上面的檔案直接放進來，</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 或是寫一個 methods 做 AJAX 把這個檔案拿進來。</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如此一來該單一元件檔就擁有了這份通靈的資料了。</p>
<p>而接著在塞資料進去之前，我們可以先刻好一個寫死的元件畫面：</p>
<p>在 template 的部分中，先把元件該要有的結構劃分清楚，否則後面透過 <code>v-for</code> 塞資料進去時，會容易跑版：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"board-wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"board-header"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-title"</span>&gt;</span>鐵人檔案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-deco"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"board-body"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"article-wrapper"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-year"</span>&gt;</span>第 11 屆 iT 邦幫忙鐵人賽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-body"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"article-type"</span>&gt;</span>Modern Web<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"article-title"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">href</span>=<span class="string">"https://ithelp.ithome.com.tw/users/20119062/ironman/2242"</span></span></span><br><span class="line"><span class="tag">            &gt;</span>「小孩才做選擇，我全都要。」小白也能輕鬆瞭解的 Vue.js 與 D3.js 。 系列<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"article-info"</span>&gt;</span>鐵人鍊成 ｜ 共 32 篇文章 ｜ 39 人訂閱<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"board-footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>樣式的部分直接以 SCSS 寫好寫滿，命名的話我自己是比較喜歡 SMACSS 與 OOCSS 的味道，而當許多元件都會用到共用的 CSS 時，可以自己建立共用的 SCSS，放在 <code>/src/assets/scss/</code> 中，透過主要 SCSS 檔案 style.scss 引入其他設定的 SCSS：</p>
<p><code>style.scss</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">'./basic'</span>;</span><br></pre></td></tr></table></figure>

<p><code>_basic.scss</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"Noto Sans TC"</span>, sans-serif;</span><br><span class="line">  <span class="attribute">background</span>:<span class="number">#F2F2F2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: inherit;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1140px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">48px</span> auto <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最後在單一元件檔要使用共用 SCSS 檔案時就可以透過 import 直接引入主要的 SCSS 檔案：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;style</span> <span class="string">scoped</span> <span class="string">lang="scss"&gt;</span></span><br><span class="line"><span class="string">@import</span> <span class="string">"@/assets/scss/style.scss"</span><span class="string">;</span></span><br><span class="line"><span class="string">.board-wrapper</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">margin:</span> <span class="string">20px</span> <span class="string">auto;</span></span><br><span class="line">  <span class="attr">max-width:</span> <span class="string">1140px;</span></span><br><span class="line">  <span class="attr">border:</span> <span class="string">1px</span> <span class="string">solid</span> <span class="comment">#e5e5e5;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="comment">#fff;</span></span><br><span class="line">  <span class="string">.board-header</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">padding:</span> <span class="string">14px</span> <span class="string">30px;</span></span><br><span class="line">    <span class="attr">z-index:</span> <span class="number">1</span><span class="string">;</span></span><br><span class="line">    <span class="string">.header-title</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">font-size:</span> <span class="string">24px;</span></span><br><span class="line">      <span class="attr">padding-left:</span> <span class="string">24px;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="string">.header-deco</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">background:</span> <span class="comment">#ffe8cc;</span></span><br><span class="line">      <span class="attr">width:</span> <span class="number">100</span><span class="string">%;</span></span><br><span class="line">      <span class="attr">height:</span> <span class="string">30px;</span></span><br><span class="line">      <span class="attr">margin-top:</span> <span class="string">-19px;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">.board-body</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">padding:</span> <span class="number">0</span> <span class="string">30px</span> <span class="string">14px;</span></span><br><span class="line">    <span class="string">.article-wrapper</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">.article-year</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">relative;</span></span><br><span class="line">        <span class="attr">padding:</span> <span class="string">8px</span> <span class="string">24px;</span></span><br><span class="line">        <span class="attr">border-bottom:</span> <span class="string">1px</span> <span class="string">solid</span> <span class="comment">#dddddd;</span></span><br><span class="line">        <span class="attr">color:</span> <span class="comment">#495057;</span></span><br><span class="line">        <span class="attr">font-size:</span> <span class="string">18px;</span></span><br><span class="line">        <span class="string">&amp;::before</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">position:</span> <span class="string">absolute;</span></span><br><span class="line">          <span class="attr">top:</span> <span class="string">18px;</span></span><br><span class="line">          <span class="attr">left:</span> <span class="string">10px;</span></span><br><span class="line">          <span class="attr">content:</span> <span class="string">""</span><span class="string">;</span></span><br><span class="line">          <span class="attr">width:</span> <span class="string">8px;</span></span><br><span class="line">          <span class="attr">height:</span> <span class="string">8px;</span></span><br><span class="line">          <span class="attr">background:</span> <span class="comment">#495057;</span></span><br><span class="line">          <span class="attr">border-radius:</span> <span class="string">50px;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">      <span class="string">.article-body</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">padding:</span> <span class="string">12px</span> <span class="string">4px;</span></span><br><span class="line">        <span class="attr">border-bottom:</span> <span class="string">1px</span> <span class="string">solid</span> <span class="comment">#dddddd;</span></span><br><span class="line">        <span class="string">.article-type</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">margin-bottom:</span> <span class="string">6px;</span></span><br><span class="line">          <span class="attr">padding:</span> <span class="string">2px</span> <span class="string">8px;</span></span><br><span class="line">          <span class="attr">border-radius:</span> <span class="string">20px;</span></span><br><span class="line">          <span class="attr">background:</span> <span class="comment">#4a89dc;</span></span><br><span class="line">          <span class="attr">font-weight:</span> <span class="string">lighter;</span></span><br><span class="line">          <span class="attr">font-size:</span> <span class="string">14px;</span></span><br><span class="line">          <span class="attr">color:</span> <span class="comment">#fff;</span></span><br><span class="line">          <span class="attr">cursor:</span> <span class="string">pointer;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">        <span class="string">.article-title</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">display:</span> <span class="string">block;</span></span><br><span class="line">          <span class="attr">margin:</span> <span class="string">6px</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">          <span class="attr">color:</span> <span class="comment">#303233;</span></span><br><span class="line">          <span class="attr">font-size:</span> <span class="string">18px;</span></span><br><span class="line">          <span class="attr">font-weight:</span> <span class="string">bold;</span></span><br><span class="line">          <span class="attr">transition:</span> <span class="number">0.</span><span class="string">3s;</span></span><br><span class="line">          <span class="attr">cursor:</span> <span class="string">pointer;</span></span><br><span class="line">          <span class="string">&amp;:hover</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="attr">color:</span> <span class="comment">#007db6;</span></span><br><span class="line">          <span class="string">&#125;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">        <span class="string">.article-info</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">color:</span> <span class="comment">#e8590c;</span></span><br><span class="line">          <span class="attr">font-size:</span> <span class="string">14px;</span></span><br><span class="line">          <span class="attr">font-weight:</span> <span class="string">lighter;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/20119062sG6tnlDDqx.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/20119062sG6tnlDDqx.jpg"></p>
<p>最後結果顯示，我自己是覺得刻的還可以啦：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/20119062RSW6VEwg7C.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/20119062RSW6VEwg7C.jpg"></p>
<p>接下來呢我們就要將這個已經刻好的版面來挖洞塞值進去 <code>template</code> 裡面！</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"board-wrapper"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"board-header"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-title"</span>&gt;</span>鐵人檔案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-deco"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"board-body"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(year,index) in this.json"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"article-wrapper"</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-year"</span>&gt;</span></span><span class="template-variable">&#123;&#123; year.irontitle &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-body"</span> <span class="attr">v-for</span>=<span class="string">"(articles,index) in year.articles"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"article-type"</span>&gt;</span></span><span class="template-variable">&#123;&#123; articles.type &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"article-title"</span> <span class="attr">:href</span>=<span class="string">"articles.href"</span>&gt;</span></span><span class="template-variable">&#123;&#123; articles.title &#125;&#125;</span><span class="xml"> 系列<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span></span></span></span><br><span class="line"><span class="xml">              class="article-info"</span></span><br><span class="line"><span class="xml">            &gt;</span><span class="template-variable">&#123;&#123; articles.info.success ? '鐵人練成' : '鐵人未練成' &#125;&#125;</span><span class="xml"> ｜ 共 </span><span class="template-variable">&#123;&#123; articles.info.count &#125;&#125;</span><span class="xml"> 篇文章 ｜ </span><span class="template-variable">&#123;&#123; articles.info.subscribe &#125;&#125;</span><span class="xml"> 人訂閱<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"board-footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>完成之後就會看到畫面……</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/20119062QDVJMZZUP8.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/20119062QDVJMZZUP8.jpg"></p>
<p>還是一樣！</p>
<p>但不一樣的事情是裡面的數值是由資料所供應的，因此面板上的東西會隨著資料而有所變動！</p>
<p>現在來模擬一下假如大雄去年也有參加鐵人賽，因此資料庫回傳的 JSON 檔案變成下面這樣：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">[</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">irontitle:</span> <span class="string">"第 11 屆 iT 邦幫忙鐵人賽"</span><span class="string">,</span></span><br><span class="line">    <span class="attr">articles:</span> <span class="string">[</span></span><br><span class="line">      <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">"Modern Web"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">title:</span></span><br><span class="line">          <span class="string">"「小孩才做選擇，我全都要。」小白也能輕鬆瞭解的 Vue.js 與 D3.js 。"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span></span><br><span class="line">          <span class="string">"https://ithelp.ithome.com.tw/users/20119062/ironman/2242"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">info:</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">success:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">          <span class="attr">count:</span> <span class="number">32</span><span class="string">,</span></span><br><span class="line">          <span class="attr">subscribe:</span> <span class="number">39</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">]</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">irontitle:</span> <span class="string">"2019 邦幫忙鐵人賽"</span><span class="string">,</span></span><br><span class="line">    <span class="attr">articles:</span> <span class="string">[</span></span><br><span class="line">      <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">"自我挑戰"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"挑戰連續三十天喝不同家手搖飲。"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">""</span><span class="string">,</span></span><br><span class="line">        <span class="attr">info:</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">success:</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line">          <span class="attr">count:</span> <span class="number">29</span><span class="string">,</span></span><br><span class="line">          <span class="attr">subscribe:</span> <span class="number">512</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">"自我挑戰"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"連續三十天發廢文。"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">""</span><span class="string">,</span></span><br><span class="line">        <span class="attr">info:</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">success:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">          <span class="attr">count:</span> <span class="number">999</span><span class="string">,</span></span><br><span class="line">          <span class="attr">subscribe:</span> <span class="number">87</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;,</span></span><br><span class="line">    <span class="string">]</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure>

<p>而依照 Vue.js 核心概念以資料驅動視覺，最後元件就會依其資料產生對應的視覺出來：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/20119062r7NDCP4e1b.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/20119062r7NDCP4e1b.jpg"></p>
<p>這樣就完成半個元件啦！</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191005/20119062rljfyj8Vxe.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/20119062rljfyj8Vxe.jpg"></p>
<p>還記得我們元件最初的資料傳遞概念嗎？明天我們將會以 props 的方式傳遞資料進去，讓這個元件成為真正可以復用的元件！</p>
<blockquote>
<p>最近翻著阿橘一年前的照片發現阿橘變胖好多，那時候大概才現在的一半大小吧…(?<br><img src="https://ithelp.ithome.com.tw/upload/images/20191005/20119062DYd3umJBXN.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191005/20119062DYd3umJBXN.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli 單一元件檔（ 以 iT 邦幫忙鐵人賽檔案當作開發範例）續</title>
    <url>/vue.js/Vue-cli-004-vue-file-sample-2/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="單一元件檔-props"><a href="#單一元件檔-props" class="headerlink" title="單一元件檔 props"></a>單一元件檔 props</h2><p>今天要來把昨天製作好的元件檔案拆分的更乾淨一點，昨天我們的資料都還放在<strong>元件自己本身中的 data 裡面</strong>，這樣子在 View 頁面使用時套用該元件都只會讀到元件自己本身中的資料，而我們今天要來將元件中的 data 清除乾淨，透過父層在決定要使用這個元件時，才將要輸入的資料傳遞進去。</p>
<a id="more"></a>

<p>首先，我們將元件自己本身中的 data 給清除，因為我們之後將會由父層去決定塞什麼資料給子元件，並且在裡面塞入 props 欄位，指定這個子元件能夠接收父層傳遞哪個欄位給他：</p>
<p>子元件的 script 區塊：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">"articleBoard"</span>,</span></span><br><span class="line"><span class="actionscript">  props: &#123; json: <span class="literal">null</span> &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接著，template 區域，改動的地方最主要是在於 li 標籤元素中，原本我們是透過 <code>this.json.iron</code> 去抓取子元件自己本身的資料，而現在要改成 <code>json</code> 去對應到 script 中 props 所給予的資料（也就是父層傳遞進來的欄位）！</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"board-wrapper"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"board-header"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-title"</span>&gt;</span>鐵人檔案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-deco"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"board-body"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(year,index) in json"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"article-wrapper"</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-year"</span>&gt;</span></span><span class="template-variable">&#123;&#123; year.irontitle &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-body"</span> <span class="attr">v-for</span>=<span class="string">"(articles,index) in year.articles"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"article-type"</span>&gt;</span></span><span class="template-variable">&#123;&#123; articles.type &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"article-title"</span> <span class="attr">:href</span>=<span class="string">"articles.href"</span>&gt;</span></span><span class="template-variable">&#123;&#123; articles.title &#125;&#125;</span><span class="xml"> 系列<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span></span></span></span><br><span class="line"><span class="xml">              class="article-info"</span></span><br><span class="line"><span class="xml">            &gt;</span><span class="template-variable">&#123;&#123; articles.info.success ? '鐵人練成' : '鐵人未練成' &#125;&#125;</span><span class="xml"> ｜ 共 </span><span class="template-variable">&#123;&#123; articles.info.count &#125;&#125;</span><span class="xml"> 篇文章 ｜ </span><span class="template-variable">&#123;&#123; articles.info.subscribe &#125;&#125;</span><span class="xml"> 人訂閱<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"board-footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>調整完畢後，現在該元件已經可以接受來自父層所傳遞的資料了。現在我們把該元件檔命名為 <code>articleBoard.vue</code> 並把它放入 <code>/src/components/board/</code> 的路徑底下，並且在 <code>/src/view</code> 路徑中的元件檔中透過 import 引入這個元件，並取名為 <code>infoBoard</code>（可自由命名），然後把資料 data 放在這個父層中模擬由父層給予子元件資料的過程：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;script&gt;</span></span><br><span class="line">import infoBoard from <span class="string">"@/components/board/articleBoard"</span>;</span><br><span class="line"></span><br><span class="line">export <span class="class">default </span>&#123;</span><br><span class="line"><span class="symbol">  name:</span> <span class="string">"home"</span>,</span><br><span class="line"><span class="symbol">  components:</span> &#123;</span><br><span class="line">    infoBoard</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="class">return </span>&#123;</span><br><span class="line"><span class="symbol">      json:</span> [</span><br><span class="line">        &#123;</span><br><span class="line"><span class="symbol">          irontitle:</span> <span class="string">"第 11 屆 iT 邦幫忙鐵人賽"</span>,</span><br><span class="line"><span class="symbol">          articles:</span> [</span><br><span class="line">            &#123;</span><br><span class="line"><span class="symbol">              type:</span> <span class="string">"Modern Web"</span>,</span><br><span class="line"><span class="symbol">              title:</span></span><br><span class="line">                <span class="string">"「小孩才做選擇，我全都要。」小白也能輕鬆瞭解的 Vue.js 與 D3.js 。"</span>,</span><br><span class="line"><span class="symbol">              href:</span> <span class="string">"https://ithelp.ithome.com.tw/users/20119062/ironman/2242"</span>,</span><br><span class="line"><span class="symbol">              info:</span> &#123;</span><br><span class="line"><span class="symbol">                success:</span> true,</span><br><span class="line"><span class="symbol">                count:</span> <span class="number">32</span>,</span><br><span class="line"><span class="symbol">                subscribe:</span> <span class="number">39</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="symbol">          irontitle:</span> <span class="string">"2019 邦幫忙鐵人賽"</span>,</span><br><span class="line"><span class="symbol">          articles:</span> [</span><br><span class="line">            &#123;</span><br><span class="line"><span class="symbol">              type:</span> <span class="string">"自我挑戰"</span>,</span><br><span class="line"><span class="symbol">              title:</span> <span class="string">"挑戰連續三十天喝不同家手搖飲。"</span>,</span><br><span class="line"><span class="symbol">              href:</span> <span class="string">""</span>,</span><br><span class="line"><span class="symbol">              info:</span> &#123;</span><br><span class="line"><span class="symbol">                success:</span> false,</span><br><span class="line"><span class="symbol">                count:</span> <span class="number">29</span>,</span><br><span class="line"><span class="symbol">                subscribe:</span> <span class="number">512</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line"><span class="symbol">              type:</span> <span class="string">"自我挑戰"</span>,</span><br><span class="line"><span class="symbol">              title:</span> <span class="string">"連續三十天發廢文。"</span>,</span><br><span class="line"><span class="symbol">              href:</span> <span class="string">""</span>,</span><br><span class="line"><span class="symbol">              info:</span> &#123;</span><br><span class="line"><span class="symbol">                success:</span> true,</span><br><span class="line"><span class="symbol">                count:</span> <span class="number">999</span>,</span><br><span class="line"><span class="symbol">                subscribe:</span> <span class="number">87</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="params">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 Home.vue 的 template 中，我們使用剛剛命名的 <code>infoBoard</code> 來當作標籤使用，接著使用 <code>json</code> 欄位來引入資料，然後這樣只會將後面的值 <code>&quot;this.json.iron&quot;</code> 當作資料寫進去，要與 Vue.js 元件本身檔案有關係的話我們仍必須透過 <code>v-bind</code> 去引用，因此最後是使用 <code>:json</code> 來引入 <code>this.json.iron</code> 而非 <code>json</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page page-home"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">infoBoard</span> <span class="attr">:json</span>=<span class="string">"this.json.iron"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>完成之後我們就得到了一個由 Home.vue 父元件所引入的 articleBoard.vue 子元件，並且透過父層傳遞資料進去給他，而最後顯示的畫面應該還是要跟之前一模一樣才對：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20119062Hl3TkzMIgb.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20119062Hl3TkzMIgb.jpg"></p>
<p>差異在於今天可以由父層的 data 去給予這個元件不同的資料，而非寫死在子元件裡面的，所以現在每個頁面都可以使用這個元件了！</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20119062tW3oLgXAz3.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20119062tW3oLgXAz3.jpg"></p>
<p>然而問題馬上就出現了，現在我們已經可以自由引入這個元件，並透過 data 去引入他的資料，但是萬一這個資料哪天要更動，不就每個引用這個 data 的元件都要改變嗎？因此有個東西叫做 Vuex 他替我們解決了這個問題…</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20119062BvFnfN60P6.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20119062BvFnfN60P6.jpg"></p>
<blockquote>
<p>補班的隔天一整個睡死，起來就看到兩姊弟不知道在討論什麼秘密……？<br><img src="https://ithelp.ithome.com.tw/upload/images/20191006/20119062nlEYZZB7Dw.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191006/20119062nlEYZZB7Dw.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli What is Vuex? Why do we need Vuex?</title>
    <url>/vue.js/Vue-cli-005-vuex/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>這幾天陸陸續續講解了 Vue.js 在 Vue-cli 裡偏向實作的說明，而目前我們也已經完成了一個簡單的元件，可以透過父層引用這個元件時，將需要的資料傳遞給元件，使子元件可以在不同頁面、區塊重複使用。</p>
<p>然而昨天有提出了一個問題，<strong>「假設今天不同頁面（不同 .vue 檔案），都要使用共同的狀態時，我們應該如何處理？」</strong></p>
<a id="more"></a>

<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20119062j4oXCz4l8w.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20119062j4oXCz4l8w.png"></p>
<p>如果大家還有印象，我們之前曾經在 Vue.js 章節中講過類似的 <a href="https://ithelp.ithome.com.tw/articles/10215277" target="_blank" rel="noopener">傳遞</a> ，在當時我們提到了子元件可以透過 <code>$emit</code> 去發送事件給另一個 Vue 實體（例如當時命名的 <code>bus</code>），而父元件就可以藉由監聽 <code>bus</code> 上的事件，等待其他元件去觸發他，從而達到<strong>事件的集中管理</strong>。</p>
<p>而<strong>資料狀態</strong>的集中管理，在 Vue.js 則是藉由一個簡單的 <code>store</code> 來達成：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/201190623CyZpsmxn6.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/201190623CyZpsmxn6.png"></p>
<p>建立一個 store 物件，而各個 Vue 實體引入該 store 來做為狀態的集中管理：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> store = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vmA = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  <span class="built_in">data</span>: store</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vmB = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  <span class="built_in">data</span>: store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>只要 <code>vmA</code> 或 <code>vmB</code> 任一方更動了 store 裡的資料都會觸發雙方因<strong>資料改變而驅動視覺改變</strong>的過程。</p>
<p>而這個過程必須遵循著之前所提的單向資料流的部分，我們應該由視覺（view）的部分去觸發事件（action），而讓事件去更改狀態（state），最後狀態（state）會更新視覺（view）：<br><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20119062llpUTj8JUN.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20119062llpUTj8JUN.png"></p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>今天要介紹的 Vuex 其實就是綜合了以上的概念，將<strong>資料狀態與事件操作集中管理的一項工具</strong>。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20119062FSAgtZHqGQ.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20119062FSAgtZHqGQ.png"></p>
<p>在 Vuex 中，主要負責的是上圖綠色框中的部分，左邊 Vue.component 則是元件本身自己的部分，而元件本身最主要的工作就是藉由發送（dispatch）給 Vuex，Vuex 幫我們處理了後續的內容之後，藉由更改狀態（state）來觸發元件本身重新渲染。</p>
<p>因此單看元件本身的話，<strong>元件本身</strong>會需要的是：</p>
<ul>
<li><strong>寫下發送（dispatch）的事件</strong></li>
<li><strong>接收 Vuex（store） 裡的狀態（state）</strong></li>
</ul>
<p>而在 Vuex 中的<strong>狀態管理倉庫（store）中則會提供</strong>：</p>
<ul>
<li><strong>Actions</strong> ：接收來自元件發送（dispatch）的事件，並且提交（commit）事件給 Mutations 去執行他該做的事情。</li>
<li><strong>Mutations</strong> ：接收來自 Actions 的事件，並且發送變更（Mutate）給 store 裡本身的 State。</li>
<li><strong>State</strong> ：接收來自 Mutations 發送的變更，更改 State 自己本身的狀態。</li>
</ul>
<p>以昨天更改好的 Home.vue 為例子，原先在 data 中的資料改成放置在 store 中的 action 去跟後端呼叫，取而代之的是以 computed 去抓取 store 中的值，並且在 created 生命週期中發送 <code>getIronmanData</code> 事件給 store：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">import infoBoard from "@/components/board/articleBoard";</span></span><br><span class="line"></span><br><span class="line"><span class="xml">export default </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery"> <span class="built_in"> name</span>: <span class="string">"home"</span>,</span></span><br><span class="line"><span class="xquery">  components: &#123;</span></span><br><span class="line"><span class="xquery">    infoBoard</span></span><br><span class="line"><span class="xquery">  &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">  created()</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    this.<span class="variable">$store</span>.dispatch(<span class="string">'getIronmanData'</span>)</span></span><br><span class="line"><span class="xquery">  &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">  computed:</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    ironmanData()&#123;</span></span><br><span class="line"><span class="xquery">      <span class="keyword">return</span> this.<span class="variable">$store</span>.state.ironmanData</span></span><br><span class="line"><span class="xquery">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>而在 /src/store.js 中，我們在 actions 區塊放入監聽事件名稱對應的函式 <code>getIronmanData</code> 並將 <code>context</code> 參數傳入，透過 <code>context.commit</code> 將發送的事件提交給 Mutations 來做變更：</p>
<figure class="highlight roboconf"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">    <span class="attribute">getIronmanData (context) &#123;</span></span><br><span class="line"><span class="attribute">      fetch('https</span>://raw<span class="variable">.githubusercontent</span><span class="variable">.com</span>/shawnlin0201/ironmanData/master/ironman<span class="variable">.json</span>')</span><br><span class="line">        <span class="variable">.then</span>(res =&gt; res<span class="variable">.json</span>())</span><br><span class="line">        <span class="variable">.then</span>(res =&gt; &#123;</span><br><span class="line">          context<span class="variable">.commit</span>('setItonmanData', res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mutations 區塊則是放入 actions 所提交的事件名稱 <code>setItonmanData</code> 並將 <code>state</code> 與 <code>payload</code> 傳入函式當中，這裡的 state 指向的是 store.state，而 payload 則是前面 actions 函式所帶進來的數值：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    <span class="built_in">set</span>ItonmanData (<span class="keyword">state</span>, json) &#123;</span><br><span class="line">      <span class="keyword">state</span>.ironmanData = json</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>最後在 state 中放入初始值即完成一個簡單的狀態集中管理。</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">import Vue <span class="keyword">from</span> 'vue'</span><br><span class="line">import Vuex <span class="keyword">from</span> 'vuex'</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> new Vuex.Store(&#123;</span><br><span class="line">  <span class="keyword">state</span>: &#123;</span><br><span class="line">    ironmanData: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="built_in">set</span>ItonmanData (<span class="keyword">state</span>, json) &#123;</span><br><span class="line">      <span class="keyword">state</span>.ironmanData = json</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    getIronmanData (context) &#123;</span><br><span class="line">      fetch('https://raw.githubusercontent.com/shawnlin0201/ironmanData/master/ironman.json')</span><br><span class="line">        .then(res =&gt; res.json())</span><br><span class="line">        .then(res =&gt; &#123;</span><br><span class="line">          context.commit('<span class="built_in">set</span>ItonmanData', res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>現在的程式碼概念如下：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20119062DELL7jQX63.png" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20119062DELL7jQX63.png"></p>
<p>而最後顯示的畫面理所當然的是……還是一樣</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/20119062E0sXO8pBst.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191007/20119062E0sXO8pBst.jpg"></p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20191007/2011906215bC8QVWPG.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191007/2011906215bC8QVWPG.jpg"></p>
<p>正如梗圖所示，Vuex 最終在做的事情是方便各個元件要取得、修改同筆資料來源時，能夠有個<strong>狀態集中管理</strong>的地方，協助我們處理不同元件間最後<strong>視覺層上的一致性</strong>，但假如項目只是個單純一頁網站、沒有太多元件引用同隻資料來源，則 Vuex 確實是不一定加入項目當中的，所以工具選用上還是要自己權衡一下是否真的需要，否則會有點殺雞用牛刀的感覺！</p>
<p>當然，Vuex 的部分其實還不僅止於此，假設項目真的大到 store 塞滿滿的話，我們還有 <a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener">Module</a> 的方式去管理 store 的部分，並且如果 store 中的 state 狀態需要很多計算的話，其實可以利用 <a href="https://vuex.vuejs.org/zh/guide/getters.html" target="_blank" rel="noopener">getter</a> （有如元件中的 computed）來先計算好數值再傳給元件去重新渲染等等，但這麼一說下去可能這系列會寫不完吧（？，所以明天我們會先回頭來介紹 Vue.router 要如何使用再做打算吧！</p>
<blockquote>
<p>今天就以阿橘的肉球跟大家說再見！<br><img src="https://ithelp.ithome.com.tw/upload/images/20191007/201190629y4SXlpmsv.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191007/201190629y4SXlpmsv.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-cli Router</title>
    <url>/vue.js/Vue-cli-006-vue-router/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>今天要介紹的是對<strong>單頁式應用網站（SPA，Single Page Application）</strong> 非常重要的 Router， SPA 為何會需要 Router 來處理網頁路徑呢？這裡簡單介紹一下他們之間的關係：</p>
<p>在 SPA 技術被大肆使用之前，以前的網站多是採用<strong>多頁式網頁（MPA，Multiple Page Application）</strong>，而兩者差異最大的地方在於<strong>向伺服器請求的東西不同</strong>。</p>
<p>一開始不論 SPA 還是 MPA 網站都需要使用者輸入網址，透過一個叫做 DNS 的服務器找到該網站伺服器，接著經過一連串回應後，伺服器回應給使用者一個 HTML 網頁檔案。</p>
<p>而 MPA 在後續轉換頁面上，則是<strong>藉由輸入的網址不同，重複以上動作向網站伺服器拿取每頁的網頁檔案</strong>，並且重新渲染每頁的內容，因此會造成網頁整個畫面都被刷新。</p>
<p>SPA 則是進入入口網頁（SPA 進入點）後透過 AJAX 技術，跟伺服器拿取部分資料替換內容進去；而替換的區域，小至更新收藏狀態的按鈕，大至整個頁面都被刷新，此時網址列的路徑卻仍是我們一開始進去的那個 SPA 進入點網址。</p>
<p>因此，SPA 網頁需要<strong>藉由 History API</strong> 來操控網址列，並且藉由<strong>前端辨識使用者輸入的網頁路徑</strong>不同，而透過前端給予使用者不同的頁面內容，這也代表著原先由後端伺服器所負責的路徑管理，將交由前端來負責辨識與處理，也使得前端的複雜度上升了一個檔次。</p>
<p>為了使用者的品質體驗，身為前端工程師的我們當然不會因為這種小事而被擊倒，但管理路徑上確實是不容易的事情，因此工程師們逐漸發展出一系列管理路徑的方法。而在 Vue 框架中，我們可以藉由 Vue Router 來協助處理這一類的問題，這也就是今天所要提到的內容。</p>
<a id="more"></a>

<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>在 Vue.js 中，可以單獨在頁面中引入 script 檔使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">https:<span class="comment">//unpkg.com/vue-router@2.0.0/dist/vue-router.js</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而在 Vue-cli 中，我們可以在一開始建立檔案時，將 Router 模組安裝進去，安裝完畢後會在 <code>/src</code> 路徑底下看到一隻 router.js 設定檔案，這也就是我們今天主要會操作到的檔案。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">├── dist/               </span><br><span class="line">├── node_modules/       </span><br><span class="line">├── public/             </span><br><span class="line">│   ├── favicon.ico     </span><br><span class="line">│   └── index.html      </span><br><span class="line">├── src/                </span><br><span class="line">│   ├── assets/         </span><br><span class="line">│   ├── components/     </span><br><span class="line">│   ├── views/          </span><br><span class="line">│   ├── App.vue         </span><br><span class="line">│   ├── main.js         </span><br><span class="line">│   ├── router.js       // 在這裡</span><br><span class="line">│   └── store.js        </span><br><span class="line">├── .gitignore          </span><br><span class="line">├── package.json        </span><br><span class="line">└── vue.config.js</span><br></pre></td></tr></table></figure>

<p>而打開 router.js 後我們可以看到下列檔案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./views/Home.vue'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  base: process.env.BASE_URL,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'home'</span>,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/about'</span>,</span><br><span class="line">      name: <span class="string">'about'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./views/About.vue'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>首先我們先來關注放在 Router 裡面所回傳的物件可放入的屬性，第一個屬性 <code>mode</code> 模式可以切換為：</p>
<ul>
<li><code>hash</code> ：默認值，在這種模式下路徑會以 hash 來模擬路徑，藉由 hash 特性使切換路徑時頁面不會刷新。</li>
<li><code>history</code> ：history 模式，則是利用前面提到的 history API 來達成切換路徑的效果。</li>
</ul>
<p>以本機伺服器為例子切換到 /about 的話兩者差異如下：</p>
<ul>
<li>hash<ul>
<li><a href="http://localhost:8080/#/" target="_blank" rel="noopener">http://localhost:8080/#/</a></li>
<li><a href="http://localhost:8080/#/about" target="_blank" rel="noopener">http://localhost:8080/#/about</a></li>
</ul>
</li>
<li>history<ul>
<li><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></li>
<li><a href="http://localhost:8080/about" target="_blank" rel="noopener">http://localhost:8080/about</a></li>
</ul>
</li>
</ul>
<p>第二個屬性 <code>base</code> 則是決定好根目錄的名稱，建立環境如果在特定路徑下需要更改。</p>
<p>第三個屬性 <code>routes</code> 則可以設定頁面路徑等相關設定，以下列出幾個較常用的項目：</p>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>用來核對網址路徑使用，若符合該路徑則會渲染出對應的元件（component），並且支援多種比對的方法。<br>路徑          | 涵義<br>————- | ————-<br>/             | 根目錄網址<br>/*             | 所有網址都符合此路徑，會攔截所有網址，要謹慎使用。<br>/member       | 網址剛好為 /member 才符合<br>/member-*       | 開頭為 /member 皆符合條件<br>/member/*       |  /member/ 底下網址都符合此條件<br>/member/:id       | 網址為 <code>/member/9527</code> 的話，可在該頁面透過 this.$route.params 取到 <code>{id:9527}</code><br>/member?       | 網址為 <code>/member?from=ithome</code> 的話，可在該頁面透過 this.$route.query 取到 <code>{from:ithome}</code> </p>
<h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><p>path 條件符合時，渲染該頁面對應的單一元件檔（.vue）。</p>
<p>透過 import 方式我們可以在使用者開啟網站時就先導入該頁面的資源，而透過放在 component 裡的 callback function 則可以達到 lazy loading 載入元件的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./views/About.vue'</span>)</span><br></pre></td></tr></table></figure>

<p>另外在執行 <code>npm run build</code> 建置靜態檔案準備上傳伺服器前，可在 import 內放入 webpackChunkName 來設定包裝元件檔的模組名稱，而該模組名稱主要是用來執行異步載入用，避免元件檔數量太多而造成載入時受影響。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'./views/About.vue'</span>)</span><br></pre></td></tr></table></figure>


<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>識別該頁面的名稱，如在元件中可透過方法切換到指定的頁面名稱：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123;<span class="attr">name</span>: <span class="string">'about'</span>&#125;) <span class="comment">// 使用 Vue router 切換到 about 頁面</span></span><br></pre></td></tr></table></figure>

<h3 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h3><p>將進入到符合到 path 路徑條件的網址，重新轉向 redirect 所指定的網址：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">redirect</span>: <span class="string">'/b'</span> &#125; <span class="comment">// 此設定將會使進入 /a 網址的使用者，被導向到 /b 網址並使用符合 /b path 路徑的元件</span></span><br></pre></td></tr></table></figure>

<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>將進入到符合到 path 路徑條件的網址，改成 alias 所指定的網址：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">alias</span>: <span class="string">'/b'</span>, <span class="attr">component</span>:A &#125;    <span class="comment">// 此設定將會使進入 /a 並使用符合 /a 路徑的元件，但網址會轉換成 /b</span></span><br></pre></td></tr></table></figure>

<h2 id="切換頁面"><a href="#切換頁面" class="headerlink" title="切換頁面"></a>切換頁面</h2><p>在設定完頁面相關資訊之後，我們現在已經擁有了一個網址路徑比對的工具了，現在我們要在頁面中執行切換頁面的效果。</p>
<p>最簡單的方式，是透過 Vue router 所提供的 <code>&lt;router-link&gt;</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最後會轉譯成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而特地要使用 <code>&lt;router-link&gt;</code> 而不是 <code>&lt;a&gt;</code> 的原因在於，他在有設定 base 路徑的情況下，可以直接使用 <code>to</code> 來導向網域底下的頁面，並且防止頁面重新載入以及遇到不支援 history 模式的瀏覽器時會自動降級成 hash 模式的路徑。</p>
<p><strong>此外也可以傳入一個 router 物件：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"&#123; path: 'about'&#125;"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 9527 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">以上等同於</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/user?userId=9527"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>以 JavaScript 轉頁：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">'about'</span>&#125;&#125;)  <span class="comment">// 網址 /about</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">9527</span> &#125;)  <span class="comment">// 網址 /user?userId=9527</span></span><br></pre></td></tr></table></figure>

<p><strong>針對歷史紀錄切換頁：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.go(<span class="number">1</span>)    <span class="comment">// 下一頁</span></span><br><span class="line"><span class="keyword">this</span>.$router.go(<span class="number">-1</span>)   <span class="comment">// 上一頁</span></span><br><span class="line"><span class="keyword">this</span>.$router.go(<span class="number">9527</span>) <span class="comment">// 若跳轉頁面數量不構，會發生錯誤，需自行處理</span></span><br></pre></td></tr></table></figure>

<h2 id="顯示頁面"><a href="#顯示頁面" class="headerlink" title="顯示頁面"></a>顯示頁面</h2><p>Vue router 提供了 <code>&lt;router-view&gt;</code> 標籤供我們使用，只要符合路徑，而在標籤使用區塊須注意 router 中所設定的 route 層級，以下方為例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">App.vue </span><br><span class="line">├── Home.vue</span><br><span class="line">└── About.vue</span><br><span class="line">    ├── Info.vue</span><br><span class="line">    └── Contact.vue</span><br></pre></td></tr></table></figure>

<p>若在 App.vue 中所使用的話，路徑可比對到 <code>Home.vue</code> 以及 <code>About.vue</code>。</p>
<p>但若想要在 About.vue 中嵌套顯示底下的 <code>Info.vue</code> 或 <code>Contact.vue</code> 則需在 About.vue 裡面也放置 <code>&lt;router-view&gt;</code>標籤，並在 router 中設定 children 路徑配對：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">path</span>: <span class="string">'/about'</span>,</span><br><span class="line">  name: <span class="string">'AboutPage'</span>,</span><br><span class="line">  component: () =&gt; <span class="built_in">import</span>(/* webpackChunkName: <span class="string">"About"</span> */ <span class="string">'./views/About.vue'</span>),</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/about/info'</span>,</span><br><span class="line">      component: () =&gt; <span class="built_in">import</span>(/* webpackChunkName: <span class="string">"About"</span> */ <span class="string">'./views/Info.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attribute">path</span>: <span class="string">'/about/contact'</span>,</span><br><span class="line">      component: () =&gt; <span class="built_in">import</span>(/* webpackChunkName: <span class="string">"About"</span> */ <span class="string">'./views/Contact.vue'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一來首先會從 <code>App.vue</code> 的 <code>&lt;router-view&gt;</code> 配對到 about 頁面並載入 <code>About.vue</code> 後，在透過連結配對到 info 頁面或 contact 頁面，切換 About.vue 頁面當中的 <code>&lt;router-view&gt;</code> ，載入 <code>Info.vue</code> 或 <code>Contact.vue</code>。</p>
<p>以上就是 Vue-cli Router 中一些最基礎的用法！基本上依靠這幾個 API 切換加上之前所介紹到的 Vue.js 指令與 Vue-cli .vue 檔案，已經能做出完整的應用程式了，而其中還有少數幾個 API 沒有講到的，不過這都可以待需要使用時再繼續深入研究，希望大家會喜歡這個系列！</p>
<blockquote>
<p>接下來我們就有緣再相見啦！<br><img src="https://ithelp.ithome.com.tw/upload/images/20191008/20119062b1DjmDGged.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20191008/20119062b1DjmDGged.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 2.x 升級 Vue 3.0 紀錄</title>
    <url>/vue.js/Vue-cli-007-update-3-0/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>Vue.js 底層還沒來得及摸透，在 2020 年 6 月 30 號 Vue 作者尤雨溪又發布<a href="https://github.com/vuejs/rfcs/issues/183" target="_blank" rel="noopener">聲明</a>：</p>
<p>大致上是在說明即將在 2020 年七月中 Vue 3.0 將進入 RC 階段並且八月初官方就會釋出正式版。</p>
<p>心想該來的還是要來，不如趁現在 branch 開下去馬上升級一波。</p>
<a id="more"></a>

<h1 id="起始式-vue-add-vue-next"><a href="#起始式-vue-add-vue-next" class="headerlink" title="起始式 vue add vue-next"></a>起始式 vue add vue-next</h1><p>要升級最快的方式便是直接在 <code>vue-cli</code> 專案中使用 <code>vue add vue-next</code> 指令來升級。</p>
<p>但不愧是升級之路，一開始馬上就來噴個錯誤給你看…</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue add vue-next</span><br><span class="line"></span><br><span class="line">📦  Installing vue-cli-plugin-vue-next...</span><br><span class="line">✔  Successfully installed plugin: vue-cli-plugin-vue-next</span><br><span class="line"></span><br><span class="line">🚀  Invoking generator <span class="keyword">for</span> vue-cli-plugin-vue-next...</span><br><span class="line">ERROR  TypeError: Received an unexpected value [object Undefined]</span><br></pre></td></tr></table></figure>

<p>這個問題不難，主要是因為 <code>vue-cli</code> 版本不支援的關係，所以透過 <code>npm install -g @vue/cli @latest</code> 將 <code>vue-cli</code> 升級到最新版即可，接著再跑一次  <code>vue add vue-next</code> 指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue add vue-next</span><br><span class="line"></span><br><span class="line">📦  Installing vue-cli-plugin-vue-next...</span><br><span class="line">✔  Successfully installed plugin: vue-cli-plugin-vue-next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">🚀  Invoking generator <span class="keyword">for</span> vue-cli-plugin-vue-next...</span><br><span class="line">ERROR  Cannot find file src/main.js</span><br><span class="line">📦  Installing additional dependencies...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">✔  Successfully invoked generator <span class="keyword">for</span> plugin: vue-cli-plugin-vue-next</span><br><span class="line"> vue-next  Installed vuex 4.0.</span><br><span class="line"> vue-next  Documentation available at https://github.com/vuejs/vuex/tree/4.0</span><br><span class="line"></span><br><span class="line">This dependency was not found:</span><br><span class="line"></span><br><span class="line">* vue <span class="keyword">in</span> ./node_modules/vuex/dist/vuex.esm-browser.js, ./src/index.js and 17 others</span><br></pre></td></tr></table></figure>

<h1 id="修復"><a href="#修復" class="headerlink" title="修復"></a>修復</h1><p>從上述報告中可以看出，安裝升級的套件有做了簡易的 migration，並且依據不同工具來做自動轉換。</p>
<p>但有舊專案總是有一些設定不如預期就沒辦法靠工具自動解決了，比如說專案使用了 <code>index.js</code> 來做為進入點的 js 檔案名稱，就會因為工具沒偵測到而拋出了 <code>ERROR  Cannot find file src/main.js</code>，</p>
<p>因此即便升級完畢，最後執行 <code>npm run serve</code> 時，仍會 log 出這樣的訊息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">This dependency was not found:</span><br><span class="line"></span><br><span class="line">* vue <span class="keyword">in</span> ./node_modules/vuex/dist/vuex.esm-browser.js, ./src/index.js and 17 others</span><br></pre></td></tr></table></figure>

<p>甚至我在同事電腦中看到的版本還會叫你去安裝 <code>Vue.js</code> …（別傻傻地又 install 回 2.X 版本阿 XD</p>
<p>而各套件中修復的方向不同，以下針對這個專案所遇到的問題來改改：</p>
<ul>
<li>進入點</li>
<li>Vuex</li>
<li>vue.config.js</li>
</ul>
<h2 id="進入點"><a href="#進入點" class="headerlink" title="進入點"></a>進入點</h2><p>進入點主要就是用來綁定渲染元素的地方，基本上 Vue 2.x 的寫法 3.0 都有支援，所以主要是引入的地方要改，而原本進入點檔案可能長得像這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而在 Vue 3.0 的做法是透過 createApp 引入 Vue，並且需透過 <code>mount</code> 來綁定的元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">'#app'</span>) <span class="comment">// 注意不是用 $mount，$mount 是 Vue 2.x 的寫法</span></span><br></pre></td></tr></table></figure>

<p>這樣就完成進入點的設定了。</p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vuex 更動則是包含了進入點的引入與本身檔案的設定。</p>
<p>Vuex 檔案（store.js）本身，原本引入與使用都在這個檔案中設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Vue 3.0 後，我們需要將 <code>createStore</code> 引入，並透過它創建好一個 <code>store</code> 後 <code>export</code> 出去，怎麼使用完全交由引入的檔案設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store =  createStore(&#123;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>接著原本進入點的地方原本是透過這樣載入，我們拿上方進入點章節修改好的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">  store, <span class="comment">// 原本是引入到裡面</span></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>修改一下 <code>@/store</code> 所引入的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">'@/store'</span> <span class="comment">// 這裡要注意引入的方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(store) <span class="comment">// 改成透過 `use` 使用</span></span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>Vuex 到這裡就可以繼續使用啦！</p>
<h2 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h2><p>config 檔案多數偏向客製的設定，而這裡主要原先需求是要能透過靜態的 html 檔案使用 vue.js 功能，也就是讓 SSR 渲染完能接回 Vue.js SPA 的概念，所以原本大概會有這些設定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pages: &#123;  <span class="comment">// multiple page SSR contect with SPA</span></span><br><span class="line">    index: &#123;</span><br><span class="line">      entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      chunks: [<span class="string">'chunk-vendors'</span>, <span class="string">'chunk-common'</span>, <span class="string">'index'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'about'</span>: &#123;</span><br><span class="line">      entry: <span class="string">'./src/page/about.js'</span>,</span><br><span class="line">      template: <span class="string">'public/about.html'</span>,</span><br><span class="line">      filename: <span class="string">'about.html'</span>,</span><br><span class="line">      chunks: [<span class="string">'chunk-vendors'</span>, <span class="string">'chunk-common'</span>, <span class="string">'about'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'contact'</span>: &#123;</span><br><span class="line">      entry: <span class="string">'./src/contact.js'</span>,</span><br><span class="line">      template: <span class="string">'public/contact.html'</span>,</span><br><span class="line">      filename: <span class="string">'contact.html'</span>,</span><br><span class="line">      chunks: [<span class="string">'chunk-vendors'</span>, <span class="string">'chunk-common'</span>, <span class="string">'contact'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  filenameHashing: <span class="literal">false</span>,</span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>, <span class="string">'.css'</span>],</span><br><span class="line">      alias: &#123;</span><br><span class="line">        vue$: <span class="string">'vue/dist/vue.esm.js'</span>, <span class="comment">// 對應的解析方式</span></span><br><span class="line">        <span class="string">'@'</span>: resolve(<span class="string">'src'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而裡面最主要會拋出錯誤的地方在於透過 <code>configureWebpack</code> 設定 <code>webpack</code> 的 <code>resolve</code> 時，這是因為原先用來定義引入 <code>vue</code> 的 <code>vue/dist/vue.esm.js</code> 在 Vue 3.0 的 module 中消失了。</p>
<p>因此我們將其改為 Vue 3.0 對應 ES module 的檔案 <code>vue/dist/vue.esm-bundler.js</code> 引回即可。</p>
<p>修復完畢後執行 <code>npm run serve</code> 應該就能看到頁面長回來了，接下來就可以使用 <code>composition API</code> 的寫法將原本的 <code>lifecycle</code>、<code>methods</code> 或其他 API 改寫完畢！</p>
<p><del>寫文當下還沒有出 Vue 3.0 的 devtool，升級投資有賺有賠申購前請記得先開 branch 改</del></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>Vue-cli</tag>
        <tag>w3HexSchool</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 狀態保留 keep-alive</title>
    <url>/vue.js/Vue-014-keep-alive/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<p>上一章節介紹到動態元件的使用方法，我們可以使用 <code>is</code> 來快速切換元件中的內容，藉著省下不少程式碼上的複製貼上，並且在 DOM 結構上也不會渲染出不必要的內容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'mainpage'"</span>&gt;</span>switch to Main page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'aboutpage'"</span>&gt;</span>switch to About page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'contactpage'"</span>&gt;</span>switch to Contact page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"pagename"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但假如使用者在這些頁面中進行如<strong>表單輸入</strong>等等的操作，接著切換到另一個元件中，原本的元件頁面就會消失，並且觸發 <code>destroyed</code>的生命週期鉤子，而當使用者在切換回原先的頁面時，就會發現已經輸入過的資料<strong>已經遺失</strong>了。</p>
<a id="more"></a>

<p>而這並不是什麼奇怪的 BUG ，我們可以透過 <strong><code>created</code> 生命週期鉤子被觸發</strong>的現象觀察證實，此時載入的已經是另一個<strong>全新的元件</strong>，而如果這時我們想要能夠自在的切換元件間，又想要保留元件原先的資料內容，則可以使用 <code>keep-alive</code> 這個標籤。</p>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>這個標籤最主要的功能，就是保留如上述一樣的情境時，因為切換而遺失的資料內容，原先消失的原因是因為 Vue.js 在虛擬 DOM 上的計算，導致渲染時會以該元件作為一個重新渲染的節點，最後刷新整個元件內部的資訊，而要藉由 <code>keep-alive</code> 保留內部資訊的使用方法也很簡單，我們只要在外層包覆一層 <code>keep-alive</code> 標籤即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'mainpage'"</span>&gt;</span>switch to Main page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'aboutpage'"</span>&gt;</span>switch to About page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"pagename = 'contactpage'"</span>&gt;</span>switch to Contact page<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"pagename"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'mainpage'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;This page is mainpage. Enter this page : &#123;&#123; count &#125;&#125; &lt;/div&gt;`</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">'aboutpage'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;This page is aboutpage. Enter this page : &#123;&#123; count &#125;&#125; &lt;/div&gt;`</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">'contactpage'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;This page is contactpage. Enter this page : &#123;&#123; count &#125;&#125; &lt;/div&gt;`</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    pagename : <span class="string">'mainpage'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我們在上面範例中加入了一些觸發生命週期的鉤子，透過開發者工具列可以看到的是，原先當元件切換時，理應當觸發 <code>destroyed</code> 的生命週期鉤子，並且顯示 <code>destroyed</code>，然而最後結果卻沒有顯示，表示元件在切換到不同元件時，該元件<strong>並沒有被銷毀</strong>。</p>
<p>此時切換回原先的元件時，可以發現觸發了生命週期鉤子中的 <code>activated</code>，表示元件並<strong>不是走原先 <code>created</code> 等初始化元件的過程</strong>，而 <code>activated</code> 在官方生命週期中則是表示元件<strong>重新被啟用</strong>的意思，並且可以發現先前的資料內容也同時被保存下來，如此一來將來有如表單輸入等等需要暫時保留資料的元件，可以透過 <code>keep-alive</code> 的這個標籤來達到保存的功能。</p>
<p>以上就是今天狀態保存 <code>keep-alive</code> 的說明與用法，明天將會介紹 Vue.js 的最後的一個好用功能 <code>slot</code>。</p>
<blockquote>
<p>明天就是 Vue.js 的最後一張啦，<del>橘橘表示興奮到模糊</del>。<br><img src="https://ithelp.ithome.com.tw/upload/images/20190917/20119062yrB2Z2gY2w.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190917/20119062yrB2Z2gY2w.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 插槽 slot</title>
    <url>/vue.js/Vue-015-slot/</url>
    <content><![CDATA[<div style="display:flex;justify-content:center;">
  <img style="object-fit:cover;" alt="vue-logo" src='/images/vue-logo.png' width='200px' height='200px' />
</div>

<h2 id="渲染範圍"><a href="#渲染範圍" class="headerlink" title="渲染範圍"></a>渲染範圍</h2><p>使用樣本語法時，我們可以在 HTML 中使用<strong>兩對花括號</strong>來表示要顯示的資料，並且透過 Vue.js 實體中的 <code>el</code> 來指定 Vue.js 渲染的範圍，並且在子元件的 <code>template</code> 中同樣也可以使用，然而如果是在 HTML 中的子元件標籤裡<strong>直接使用則會導致失效</strong>，如下面範例：</p>
<a id="more"></a>

<p>HTML部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span>&#123;&#123; childMessage &#125;&#125;<span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:<span class="string">`&lt;div&gt;&lt;/div&gt;`</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    message : <span class="string">'parent component'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後樣板語法將不會顯示任何資料。（這並非是什麼 BUG，而是 Vue.js 預設的渲染。）</p>
<h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><p>假使想要在子元件標籤中放些自定義的文字或內容，可以透過 <code>&lt;slot&gt;</code> 標籤來達成，我們試著將上面的元件稍微改寫一下：</p>
<p>JavaScript 部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:</span><br><span class="line">  <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;slot&gt;&lt;/slot&gt; // 加入 slot 標籤</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>HTML 部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span><br><span class="line">        &#123;&#123; message &#125;&#125; //這裡的message 將會傳入父元件的資料物件</span><br><span class="line">    <span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>這樣將會使得在 <code>&lt;child-element&gt;&lt;/child-element&gt;</code> 標籤中的資料，傳入到子元件裡的<code>&lt;slot&gt;&lt;/slot&gt;</code>的位置，將其替換掉。並且我們可以也可以傳入 HTML 元素、甚至是其他的元件以及父元件的資料物件：</p>
<p><strong>注意</strong>當使用這樣的方法在子元件內使用樣板語法傳入資料，此時傳入的資料將會是<strong>父元件的資料物件</strong>，若要使用子元件的資料物件，仍然只能在子元件的<code>template</code>中去呼叫。</p>
<p>而當我們使用 <code>&lt;slot&gt;</code> 後，若沒有 HTML 部分中所綁定的元件中傳入資訊，則預設將會顯示<code>&lt;slot&gt;&lt;/slot&gt;</code>所包含的資料：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:</span><br><span class="line">  <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;slot&gt;Hello Vue!&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    message : <span class="string">'parent component'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後顯示的結果會是 <code>&lt;div&gt;Hello Vue!&lt;/div&gt;</code>。</p>
<h2 id="指定slot"><a href="#指定slot" class="headerlink" title="指定slot"></a>指定slot</h2><p>當今天 <code>slot</code> 所要傳入的對象越來越多時，可以透過指定插入的方式去分配 <code>slot</code> 要怎麼對應資料，方法是在子元件中使用 <code>template</code> 標籤並加上<code>v-slot</code>屬性，<code>v-slot</code>的值會對應到的是 <code>slot</code> 標籤的 <code>name</code> 屬性，這樣一來當我們有需要放多個 <code>slot</code> 時就不必擔心對應位置的問題，範例如下：</p>
<p>HTML部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">child-element</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:first</span>&gt;</span>First<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:second</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:third</span>&gt;</span>Third<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child-element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-element'</span>, &#123;</span><br><span class="line">  template:</span><br><span class="line">  <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;slot name="first"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;slot name="second"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;slot name="third"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      childMessage : <span class="string">'child component'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    message : <span class="string">'parent component'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最後 HTML 部分子元件的內容將會對應的傳入子元件中，並顯示出來。而這個 API 好用的地方在於今天有個元件我們純粹只是想要更換部分的顯示內容，就可以在父元件引入該子元件，並且透過 <code>v-slot</code> 直接傳入子元件中，而不用資料整筆 props 進去再接出來。</p>
<p>以上是目前 Vue.js 的最後一章節，而實作的部分將會等到我們以 Vue-cli 創建環境時，再搭配 D3.js 一起介紹！</p>
<blockquote>
<p>隨文附上今日的黑黑，據家人說他今天在同個地方躺了連續八小時 ( XD???<br><img src="https://ithelp.ithome.com.tw/upload/images/20190917/20119062Gz4i7Zt1Ic.jpg" alt="https://ithelp.ithome.com.tw/upload/images/20190917/20119062Gz4i7Zt1Ic.jpg"></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
</search>
